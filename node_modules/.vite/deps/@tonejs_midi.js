import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS
} from "./chunk-ROME4SDB.js";

// node_modules/midi-file/lib/midi-parser.js
var require_midi_parser = __commonJS({
  "node_modules/midi-file/lib/midi-parser.js"(exports, module) {
    function parseMidi(data) {
      var p = new Parser(data);
      var headerChunk = p.readChunk();
      if (headerChunk.id != "MThd")
        throw "Bad MIDI file.  Expected 'MHdr', got: '" + headerChunk.id + "'";
      var header = parseHeader(headerChunk.data);
      var tracks = [];
      for (var i = 0; !p.eof() && i < header.numTracks; i++) {
        var trackChunk = p.readChunk();
        if (trackChunk.id != "MTrk")
          throw "Bad MIDI file.  Expected 'MTrk', got: '" + trackChunk.id + "'";
        var track = parseTrack(trackChunk.data);
        tracks.push(track);
      }
      return {
        header,
        tracks
      };
    }
    function parseHeader(data) {
      var p = new Parser(data);
      var format = p.readUInt16();
      var numTracks = p.readUInt16();
      var result = {
        format,
        numTracks
      };
      var timeDivision = p.readUInt16();
      if (timeDivision & 32768) {
        result.framesPerSecond = 256 - (timeDivision >> 8);
        result.ticksPerFrame = timeDivision & 255;
      } else {
        result.ticksPerBeat = timeDivision;
      }
      return result;
    }
    function parseTrack(data) {
      var p = new Parser(data);
      var events = [];
      while (!p.eof()) {
        var event = readEvent();
        events.push(event);
      }
      return events;
      var lastEventTypeByte = null;
      function readEvent() {
        var event2 = {};
        event2.deltaTime = p.readVarInt();
        var eventTypeByte = p.readUInt8();
        if ((eventTypeByte & 240) === 240) {
          if (eventTypeByte === 255) {
            event2.meta = true;
            var metatypeByte = p.readUInt8();
            var length = p.readVarInt();
            switch (metatypeByte) {
              case 0:
                event2.type = "sequenceNumber";
                if (length !== 2)
                  throw "Expected length for sequenceNumber event is 2, got " + length;
                event2.number = p.readUInt16();
                return event2;
              case 1:
                event2.type = "text";
                event2.text = p.readString(length);
                return event2;
              case 2:
                event2.type = "copyrightNotice";
                event2.text = p.readString(length);
                return event2;
              case 3:
                event2.type = "trackName";
                event2.text = p.readString(length);
                return event2;
              case 4:
                event2.type = "instrumentName";
                event2.text = p.readString(length);
                return event2;
              case 5:
                event2.type = "lyrics";
                event2.text = p.readString(length);
                return event2;
              case 6:
                event2.type = "marker";
                event2.text = p.readString(length);
                return event2;
              case 7:
                event2.type = "cuePoint";
                event2.text = p.readString(length);
                return event2;
              case 32:
                event2.type = "channelPrefix";
                if (length != 1)
                  throw "Expected length for channelPrefix event is 1, got " + length;
                event2.channel = p.readUInt8();
                return event2;
              case 33:
                event2.type = "portPrefix";
                if (length != 1)
                  throw "Expected length for portPrefix event is 1, got " + length;
                event2.port = p.readUInt8();
                return event2;
              case 47:
                event2.type = "endOfTrack";
                if (length != 0)
                  throw "Expected length for endOfTrack event is 0, got " + length;
                return event2;
              case 81:
                event2.type = "setTempo";
                if (length != 3)
                  throw "Expected length for setTempo event is 3, got " + length;
                event2.microsecondsPerBeat = p.readUInt24();
                return event2;
              case 84:
                event2.type = "smpteOffset";
                if (length != 5)
                  throw "Expected length for smpteOffset event is 5, got " + length;
                var hourByte = p.readUInt8();
                var FRAME_RATES = { 0: 24, 32: 25, 64: 29, 96: 30 };
                event2.frameRate = FRAME_RATES[hourByte & 96];
                event2.hour = hourByte & 31;
                event2.min = p.readUInt8();
                event2.sec = p.readUInt8();
                event2.frame = p.readUInt8();
                event2.subFrame = p.readUInt8();
                return event2;
              case 88:
                event2.type = "timeSignature";
                if (length != 2 && length != 4)
                  throw "Expected length for timeSignature event is 4 or 2, got " + length;
                event2.numerator = p.readUInt8();
                event2.denominator = 1 << p.readUInt8();
                if (length === 4) {
                  event2.metronome = p.readUInt8();
                  event2.thirtyseconds = p.readUInt8();
                } else {
                  event2.metronome = 36;
                  event2.thirtyseconds = 8;
                }
                return event2;
              case 89:
                event2.type = "keySignature";
                if (length != 2)
                  throw "Expected length for keySignature event is 2, got " + length;
                event2.key = p.readInt8();
                event2.scale = p.readUInt8();
                return event2;
              case 127:
                event2.type = "sequencerSpecific";
                event2.data = p.readBytes(length);
                return event2;
              default:
                event2.type = "unknownMeta";
                event2.data = p.readBytes(length);
                event2.metatypeByte = metatypeByte;
                return event2;
            }
          } else if (eventTypeByte == 240) {
            event2.type = "sysEx";
            var length = p.readVarInt();
            event2.data = p.readBytes(length);
            return event2;
          } else if (eventTypeByte == 247) {
            event2.type = "endSysEx";
            var length = p.readVarInt();
            event2.data = p.readBytes(length);
            return event2;
          } else {
            throw "Unrecognised MIDI event type byte: " + eventTypeByte;
          }
        } else {
          var param1;
          if ((eventTypeByte & 128) === 0) {
            if (lastEventTypeByte === null)
              throw "Running status byte encountered before status byte";
            param1 = eventTypeByte;
            eventTypeByte = lastEventTypeByte;
            event2.running = true;
          } else {
            param1 = p.readUInt8();
            lastEventTypeByte = eventTypeByte;
          }
          var eventType = eventTypeByte >> 4;
          event2.channel = eventTypeByte & 15;
          switch (eventType) {
            case 8:
              event2.type = "noteOff";
              event2.noteNumber = param1;
              event2.velocity = p.readUInt8();
              return event2;
            case 9:
              var velocity = p.readUInt8();
              event2.type = velocity === 0 ? "noteOff" : "noteOn";
              event2.noteNumber = param1;
              event2.velocity = velocity;
              if (velocity === 0)
                event2.byte9 = true;
              return event2;
            case 10:
              event2.type = "noteAftertouch";
              event2.noteNumber = param1;
              event2.amount = p.readUInt8();
              return event2;
            case 11:
              event2.type = "controller";
              event2.controllerType = param1;
              event2.value = p.readUInt8();
              return event2;
            case 12:
              event2.type = "programChange";
              event2.programNumber = param1;
              return event2;
            case 13:
              event2.type = "channelAftertouch";
              event2.amount = param1;
              return event2;
            case 14:
              event2.type = "pitchBend";
              event2.value = param1 + (p.readUInt8() << 7) - 8192;
              return event2;
            default:
              throw "Unrecognised MIDI event type: " + eventType;
          }
        }
      }
    }
    function Parser(data) {
      this.buffer = data;
      this.bufferLen = this.buffer.length;
      this.pos = 0;
    }
    Parser.prototype.eof = function() {
      return this.pos >= this.bufferLen;
    };
    Parser.prototype.readUInt8 = function() {
      var result = this.buffer[this.pos];
      this.pos += 1;
      return result;
    };
    Parser.prototype.readInt8 = function() {
      var u = this.readUInt8();
      if (u & 128)
        return u - 256;
      else
        return u;
    };
    Parser.prototype.readUInt16 = function() {
      var b0 = this.readUInt8(), b1 = this.readUInt8();
      return (b0 << 8) + b1;
    };
    Parser.prototype.readInt16 = function() {
      var u = this.readUInt16();
      if (u & 32768)
        return u - 65536;
      else
        return u;
    };
    Parser.prototype.readUInt24 = function() {
      var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8();
      return (b0 << 16) + (b1 << 8) + b2;
    };
    Parser.prototype.readInt24 = function() {
      var u = this.readUInt24();
      if (u & 8388608)
        return u - 16777216;
      else
        return u;
    };
    Parser.prototype.readUInt32 = function() {
      var b0 = this.readUInt8(), b1 = this.readUInt8(), b2 = this.readUInt8(), b3 = this.readUInt8();
      return (b0 << 24) + (b1 << 16) + (b2 << 8) + b3;
    };
    Parser.prototype.readBytes = function(len) {
      var bytes = this.buffer.slice(this.pos, this.pos + len);
      this.pos += len;
      return bytes;
    };
    Parser.prototype.readString = function(len) {
      var bytes = this.readBytes(len);
      return String.fromCharCode.apply(null, bytes);
    };
    Parser.prototype.readVarInt = function() {
      var result = 0;
      while (!this.eof()) {
        var b = this.readUInt8();
        if (b & 128) {
          result += b & 127;
          result <<= 7;
        } else {
          return result + b;
        }
      }
      return result;
    };
    Parser.prototype.readChunk = function() {
      var id = this.readString(4);
      var length = this.readUInt32();
      var data = this.readBytes(length);
      return {
        id,
        length,
        data
      };
    };
    module.exports = parseMidi;
  }
});

// node_modules/midi-file/lib/midi-writer.js
var require_midi_writer = __commonJS({
  "node_modules/midi-file/lib/midi-writer.js"(exports, module) {
    function writeMidi(data, opts) {
      if (typeof data !== "object")
        throw "Invalid MIDI data";
      opts = opts || {};
      var header = data.header || {};
      var tracks = data.tracks || [];
      var i, len = tracks.length;
      var w = new Writer();
      writeHeader(w, header, len);
      for (i = 0; i < len; i++) {
        writeTrack(w, tracks[i], opts);
      }
      return w.buffer;
    }
    function writeHeader(w, header, numTracks) {
      var format = header.format == null ? 1 : header.format;
      var timeDivision = 128;
      if (header.timeDivision) {
        timeDivision = header.timeDivision;
      } else if (header.ticksPerFrame && header.framesPerSecond) {
        timeDivision = -(header.framesPerSecond & 255) << 8 | header.ticksPerFrame & 255;
      } else if (header.ticksPerBeat) {
        timeDivision = header.ticksPerBeat & 32767;
      }
      var h = new Writer();
      h.writeUInt16(format);
      h.writeUInt16(numTracks);
      h.writeUInt16(timeDivision);
      w.writeChunk("MThd", h.buffer);
    }
    function writeTrack(w, track, opts) {
      var t = new Writer();
      var i, len = track.length;
      var eventTypeByte = null;
      for (i = 0; i < len; i++) {
        if (opts.running === false || !opts.running && !track[i].running)
          eventTypeByte = null;
        eventTypeByte = writeEvent(t, track[i], eventTypeByte, opts.useByte9ForNoteOff);
      }
      w.writeChunk("MTrk", t.buffer);
    }
    function writeEvent(w, event, lastEventTypeByte, useByte9ForNoteOff) {
      var type = event.type;
      var deltaTime = event.deltaTime;
      var text = event.text || "";
      var data = event.data || [];
      var eventTypeByte = null;
      w.writeVarInt(deltaTime);
      switch (type) {
        case "sequenceNumber":
          w.writeUInt8(255);
          w.writeUInt8(0);
          w.writeVarInt(2);
          w.writeUInt16(event.number);
          break;
        case "text":
          w.writeUInt8(255);
          w.writeUInt8(1);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "copyrightNotice":
          w.writeUInt8(255);
          w.writeUInt8(2);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "trackName":
          w.writeUInt8(255);
          w.writeUInt8(3);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "instrumentName":
          w.writeUInt8(255);
          w.writeUInt8(4);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "lyrics":
          w.writeUInt8(255);
          w.writeUInt8(5);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "marker":
          w.writeUInt8(255);
          w.writeUInt8(6);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "cuePoint":
          w.writeUInt8(255);
          w.writeUInt8(7);
          w.writeVarInt(text.length);
          w.writeString(text);
          break;
        case "channelPrefix":
          w.writeUInt8(255);
          w.writeUInt8(32);
          w.writeVarInt(1);
          w.writeUInt8(event.channel);
          break;
        case "portPrefix":
          w.writeUInt8(255);
          w.writeUInt8(33);
          w.writeVarInt(1);
          w.writeUInt8(event.port);
          break;
        case "endOfTrack":
          w.writeUInt8(255);
          w.writeUInt8(47);
          w.writeVarInt(0);
          break;
        case "setTempo":
          w.writeUInt8(255);
          w.writeUInt8(81);
          w.writeVarInt(3);
          w.writeUInt24(event.microsecondsPerBeat);
          break;
        case "smpteOffset":
          w.writeUInt8(255);
          w.writeUInt8(84);
          w.writeVarInt(5);
          var FRAME_RATES = { 24: 0, 25: 32, 29: 64, 30: 96 };
          var hourByte = event.hour & 31 | FRAME_RATES[event.frameRate];
          w.writeUInt8(hourByte);
          w.writeUInt8(event.min);
          w.writeUInt8(event.sec);
          w.writeUInt8(event.frame);
          w.writeUInt8(event.subFrame);
          break;
        case "timeSignature":
          w.writeUInt8(255);
          w.writeUInt8(88);
          w.writeVarInt(4);
          w.writeUInt8(event.numerator);
          var denominator = Math.floor(Math.log(event.denominator) / Math.LN2) & 255;
          w.writeUInt8(denominator);
          w.writeUInt8(event.metronome);
          w.writeUInt8(event.thirtyseconds || 8);
          break;
        case "keySignature":
          w.writeUInt8(255);
          w.writeUInt8(89);
          w.writeVarInt(2);
          w.writeInt8(event.key);
          w.writeUInt8(event.scale);
          break;
        case "sequencerSpecific":
          w.writeUInt8(255);
          w.writeUInt8(127);
          w.writeVarInt(data.length);
          w.writeBytes(data);
          break;
        case "unknownMeta":
          if (event.metatypeByte != null) {
            w.writeUInt8(255);
            w.writeUInt8(event.metatypeByte);
            w.writeVarInt(data.length);
            w.writeBytes(data);
          }
          break;
        case "sysEx":
          w.writeUInt8(240);
          w.writeVarInt(data.length);
          w.writeBytes(data);
          break;
        case "endSysEx":
          w.writeUInt8(247);
          w.writeVarInt(data.length);
          w.writeBytes(data);
          break;
        case "noteOff":
          var noteByte = useByte9ForNoteOff !== false && event.byte9 || useByte9ForNoteOff && event.velocity == 0 ? 144 : 128;
          eventTypeByte = noteByte | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.noteNumber);
          w.writeUInt8(event.velocity);
          break;
        case "noteOn":
          eventTypeByte = 144 | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.noteNumber);
          w.writeUInt8(event.velocity);
          break;
        case "noteAftertouch":
          eventTypeByte = 160 | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.noteNumber);
          w.writeUInt8(event.amount);
          break;
        case "controller":
          eventTypeByte = 176 | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.controllerType);
          w.writeUInt8(event.value);
          break;
        case "programChange":
          eventTypeByte = 192 | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.programNumber);
          break;
        case "channelAftertouch":
          eventTypeByte = 208 | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          w.writeUInt8(event.amount);
          break;
        case "pitchBend":
          eventTypeByte = 224 | event.channel;
          if (eventTypeByte !== lastEventTypeByte)
            w.writeUInt8(eventTypeByte);
          var value14 = 8192 + event.value;
          var lsb14 = value14 & 127;
          var msb14 = value14 >> 7 & 127;
          w.writeUInt8(lsb14);
          w.writeUInt8(msb14);
          break;
        default:
          throw "Unrecognized event type: " + type;
      }
      return eventTypeByte;
    }
    function Writer() {
      this.buffer = [];
    }
    Writer.prototype.writeUInt8 = function(v) {
      this.buffer.push(v & 255);
    };
    Writer.prototype.writeInt8 = Writer.prototype.writeUInt8;
    Writer.prototype.writeUInt16 = function(v) {
      var b0 = v >> 8 & 255, b1 = v & 255;
      this.writeUInt8(b0);
      this.writeUInt8(b1);
    };
    Writer.prototype.writeInt16 = Writer.prototype.writeUInt16;
    Writer.prototype.writeUInt24 = function(v) {
      var b0 = v >> 16 & 255, b1 = v >> 8 & 255, b2 = v & 255;
      this.writeUInt8(b0);
      this.writeUInt8(b1);
      this.writeUInt8(b2);
    };
    Writer.prototype.writeInt24 = Writer.prototype.writeUInt24;
    Writer.prototype.writeUInt32 = function(v) {
      var b0 = v >> 24 & 255, b1 = v >> 16 & 255, b2 = v >> 8 & 255, b3 = v & 255;
      this.writeUInt8(b0);
      this.writeUInt8(b1);
      this.writeUInt8(b2);
      this.writeUInt8(b3);
    };
    Writer.prototype.writeInt32 = Writer.prototype.writeUInt32;
    Writer.prototype.writeBytes = function(arr) {
      this.buffer = this.buffer.concat(Array.prototype.slice.call(arr, 0));
    };
    Writer.prototype.writeString = function(str) {
      var i, len = str.length, arr = [];
      for (i = 0; i < len; i++) {
        arr.push(str.codePointAt(i));
      }
      this.writeBytes(arr);
    };
    Writer.prototype.writeVarInt = function(v) {
      if (v < 0)
        throw "Cannot write negative variable-length integer";
      if (v <= 127) {
        this.writeUInt8(v);
      } else {
        var i = v;
        var bytes = [];
        bytes.push(i & 127);
        i >>= 7;
        while (i) {
          var b = i & 127 | 128;
          bytes.push(b);
          i >>= 7;
        }
        this.writeBytes(bytes.reverse());
      }
    };
    Writer.prototype.writeChunk = function(id, data) {
      this.writeString(id);
      this.writeUInt32(data.length);
      this.writeBytes(data);
    };
    module.exports = writeMidi;
  }
});

// node_modules/midi-file/index.js
var require_midi_file = __commonJS({
  "node_modules/midi-file/index.js"(exports) {
    exports.parseMidi = require_midi_parser();
    exports.writeMidi = require_midi_writer();
  }
});

// node_modules/@tonejs/midi/dist/BinarySearch.js
var require_BinarySearch = __commonJS({
  "node_modules/@tonejs/midi/dist/BinarySearch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.insert = exports.search = void 0;
    function search(array, value, prop) {
      if (prop === void 0) {
        prop = "ticks";
      }
      var beginning = 0;
      var len = array.length;
      var end = len;
      if (len > 0 && array[len - 1][prop] <= value) {
        return len - 1;
      }
      while (beginning < end) {
        var midPoint = Math.floor(beginning + (end - beginning) / 2);
        var event_1 = array[midPoint];
        var nextEvent = array[midPoint + 1];
        if (event_1[prop] === value) {
          for (var i = midPoint; i < array.length; i++) {
            var testEvent = array[i];
            if (testEvent[prop] === value) {
              midPoint = i;
            }
          }
          return midPoint;
        } else if (event_1[prop] < value && nextEvent[prop] > value) {
          return midPoint;
        } else if (event_1[prop] > value) {
          end = midPoint;
        } else if (event_1[prop] < value) {
          beginning = midPoint + 1;
        }
      }
      return -1;
    }
    exports.search = search;
    function insert(array, event, prop) {
      if (prop === void 0) {
        prop = "ticks";
      }
      if (array.length) {
        var index = search(array, event[prop], prop);
        array.splice(index + 1, 0, event);
      } else {
        array.push(event);
      }
    }
    exports.insert = insert;
  }
});

// node_modules/@tonejs/midi/dist/Header.js
var require_Header = __commonJS({
  "node_modules/@tonejs/midi/dist/Header.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Header = exports.keySignatureKeys = void 0;
    var BinarySearch_1 = require_BinarySearch();
    var privatePPQMap = /* @__PURE__ */ new WeakMap();
    exports.keySignatureKeys = [
      "Cb",
      "Gb",
      "Db",
      "Ab",
      "Eb",
      "Bb",
      "F",
      "C",
      "G",
      "D",
      "A",
      "E",
      "B",
      "F#",
      "C#"
    ];
    var Header = (
      /** @class */
      function() {
        function Header2(midiData) {
          var _this = this;
          this.tempos = [];
          this.timeSignatures = [];
          this.keySignatures = [];
          this.meta = [];
          this.name = "";
          privatePPQMap.set(this, 480);
          if (midiData) {
            privatePPQMap.set(this, midiData.header.ticksPerBeat);
            midiData.tracks.forEach(function(track) {
              track.forEach(function(event) {
                if (event.meta) {
                  if (event.type === "timeSignature") {
                    _this.timeSignatures.push({
                      ticks: event.absoluteTime,
                      timeSignature: [
                        event.numerator,
                        event.denominator
                      ]
                    });
                  } else if (event.type === "setTempo") {
                    _this.tempos.push({
                      bpm: 6e7 / event.microsecondsPerBeat,
                      ticks: event.absoluteTime
                    });
                  } else if (event.type === "keySignature") {
                    _this.keySignatures.push({
                      key: exports.keySignatureKeys[event.key + 7],
                      scale: event.scale === 0 ? "major" : "minor",
                      ticks: event.absoluteTime
                    });
                  }
                }
              });
            });
            var firstTrackCurrentTicks_1 = 0;
            midiData.tracks[0].forEach(function(event) {
              firstTrackCurrentTicks_1 += event.deltaTime;
              if (event.meta) {
                if (event.type === "trackName") {
                  _this.name = event.text;
                } else if (event.type === "text" || event.type === "cuePoint" || event.type === "marker" || event.type === "lyrics") {
                  _this.meta.push({
                    text: event.text,
                    ticks: firstTrackCurrentTicks_1,
                    type: event.type
                  });
                }
              }
            });
            this.update();
          }
        }
        Header2.prototype.update = function() {
          var _this = this;
          var currentTime = 0;
          var lastEventBeats = 0;
          this.tempos.sort(function(a, b) {
            return a.ticks - b.ticks;
          });
          this.tempos.forEach(function(event, index) {
            var lastBPM = index > 0 ? _this.tempos[index - 1].bpm : _this.tempos[0].bpm;
            var beats = event.ticks / _this.ppq - lastEventBeats;
            var elapsedSeconds = 60 / lastBPM * beats;
            event.time = elapsedSeconds + currentTime;
            currentTime = event.time;
            lastEventBeats += beats;
          });
          this.timeSignatures.sort(function(a, b) {
            return a.ticks - b.ticks;
          });
          this.timeSignatures.forEach(function(event, index) {
            var lastEvent = index > 0 ? _this.timeSignatures[index - 1] : _this.timeSignatures[0];
            var elapsedBeats = (event.ticks - lastEvent.ticks) / _this.ppq;
            var elapsedMeasures = elapsedBeats / lastEvent.timeSignature[0] / (lastEvent.timeSignature[1] / 4);
            lastEvent.measures = lastEvent.measures || 0;
            event.measures = elapsedMeasures + lastEvent.measures;
          });
        };
        Header2.prototype.ticksToSeconds = function(ticks) {
          var index = (0, BinarySearch_1.search)(this.tempos, ticks);
          if (index !== -1) {
            var tempo = this.tempos[index];
            var tempoTime = tempo.time;
            var elapsedBeats = (ticks - tempo.ticks) / this.ppq;
            return tempoTime + 60 / tempo.bpm * elapsedBeats;
          } else {
            var beats = ticks / this.ppq;
            return 60 / 120 * beats;
          }
        };
        Header2.prototype.ticksToMeasures = function(ticks) {
          var index = (0, BinarySearch_1.search)(this.timeSignatures, ticks);
          if (index !== -1) {
            var timeSigEvent = this.timeSignatures[index];
            var elapsedBeats = (ticks - timeSigEvent.ticks) / this.ppq;
            return timeSigEvent.measures + elapsedBeats / (timeSigEvent.timeSignature[0] / timeSigEvent.timeSignature[1]) / 4;
          } else {
            return ticks / this.ppq / 4;
          }
        };
        Object.defineProperty(Header2.prototype, "ppq", {
          /**
           * The number of ticks per quarter note.
           */
          get: function() {
            return privatePPQMap.get(this);
          },
          enumerable: false,
          configurable: true
        });
        Header2.prototype.secondsToTicks = function(seconds) {
          var index = (0, BinarySearch_1.search)(this.tempos, seconds, "time");
          if (index !== -1) {
            var tempo = this.tempos[index];
            var tempoTime = tempo.time;
            var elapsedTime = seconds - tempoTime;
            var elapsedBeats = elapsedTime / (60 / tempo.bpm);
            return Math.round(tempo.ticks + elapsedBeats * this.ppq);
          } else {
            var beats = seconds / (60 / 120);
            return Math.round(beats * this.ppq);
          }
        };
        Header2.prototype.toJSON = function() {
          return {
            keySignatures: this.keySignatures,
            meta: this.meta,
            name: this.name,
            ppq: this.ppq,
            tempos: this.tempos.map(function(t) {
              return {
                bpm: t.bpm,
                ticks: t.ticks
              };
            }),
            timeSignatures: this.timeSignatures
          };
        };
        Header2.prototype.fromJSON = function(json) {
          this.name = json.name;
          this.tempos = json.tempos.map(function(t) {
            return Object.assign({}, t);
          });
          this.timeSignatures = json.timeSignatures.map(function(t) {
            return Object.assign({}, t);
          });
          this.keySignatures = json.keySignatures.map(function(t) {
            return Object.assign({}, t);
          });
          this.meta = json.meta.map(function(t) {
            return Object.assign({}, t);
          });
          privatePPQMap.set(this, json.ppq);
          this.update();
        };
        Header2.prototype.setTempo = function(bpm) {
          this.tempos = [
            {
              bpm,
              ticks: 0
            }
          ];
          this.update();
        };
        return Header2;
      }()
    );
    exports.Header = Header;
  }
});

// node_modules/@tonejs/midi/dist/ControlChange.js
var require_ControlChange = __commonJS({
  "node_modules/@tonejs/midi/dist/ControlChange.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ControlChange = exports.controlChangeIds = exports.controlChangeNames = void 0;
    exports.controlChangeNames = {
      1: "modulationWheel",
      2: "breath",
      4: "footController",
      5: "portamentoTime",
      7: "volume",
      8: "balance",
      10: "pan",
      64: "sustain",
      65: "portamentoTime",
      66: "sostenuto",
      67: "softPedal",
      68: "legatoFootswitch",
      84: "portamentoControl"
    };
    exports.controlChangeIds = Object.keys(exports.controlChangeNames).reduce(function(obj, key) {
      obj[exports.controlChangeNames[key]] = key;
      return obj;
    }, {});
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var privateCCNumberMap = /* @__PURE__ */ new WeakMap();
    var ControlChange = (
      /** @class */
      function() {
        function ControlChange2(event, header) {
          privateHeaderMap.set(this, header);
          privateCCNumberMap.set(this, event.controllerType);
          this.ticks = event.absoluteTime;
          this.value = event.value;
        }
        Object.defineProperty(ControlChange2.prototype, "number", {
          /**
           * The controller number
           */
          get: function() {
            return privateCCNumberMap.get(this);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ControlChange2.prototype, "name", {
          /**
           * return the common name of the control number if it exists
           */
          get: function() {
            if (exports.controlChangeNames[this.number]) {
              return exports.controlChangeNames[this.number];
            } else {
              return null;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(ControlChange2.prototype, "time", {
          /**
           * The time of the event in seconds
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
          },
          enumerable: false,
          configurable: true
        });
        ControlChange2.prototype.toJSON = function() {
          return {
            number: this.number,
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        };
        return ControlChange2;
      }()
    );
    exports.ControlChange = ControlChange;
  }
});

// node_modules/@tonejs/midi/dist/ControlChanges.js
var require_ControlChanges = __commonJS({
  "node_modules/@tonejs/midi/dist/ControlChanges.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createControlChanges = void 0;
    var ControlChange_1 = require_ControlChange();
    function createControlChanges() {
      return new Proxy({}, {
        // tslint:disable-next-line: typedef
        get: function(target, handler) {
          if (target[handler]) {
            return target[handler];
          } else if (ControlChange_1.controlChangeIds.hasOwnProperty(handler)) {
            return target[ControlChange_1.controlChangeIds[handler]];
          }
        },
        // tslint:disable-next-line: typedef
        set: function(target, handler, value) {
          if (ControlChange_1.controlChangeIds.hasOwnProperty(handler)) {
            target[ControlChange_1.controlChangeIds[handler]] = value;
          } else {
            target[handler] = value;
          }
          return true;
        }
      });
    }
    exports.createControlChanges = createControlChanges;
  }
});

// node_modules/@tonejs/midi/dist/PitchBend.js
var require_PitchBend = __commonJS({
  "node_modules/@tonejs/midi/dist/PitchBend.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PitchBend = void 0;
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var PitchBend = (
      /** @class */
      function() {
        function PitchBend2(event, header) {
          privateHeaderMap.set(this, header);
          this.ticks = event.absoluteTime;
          this.value = event.value;
        }
        Object.defineProperty(PitchBend2.prototype, "time", {
          /**
           * The time of the event in seconds
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
          },
          enumerable: false,
          configurable: true
        });
        PitchBend2.prototype.toJSON = function() {
          return {
            ticks: this.ticks,
            time: this.time,
            value: this.value
          };
        };
        return PitchBend2;
      }()
    );
    exports.PitchBend = PitchBend;
  }
});

// node_modules/@tonejs/midi/dist/InstrumentMaps.js
var require_InstrumentMaps = __commonJS({
  "node_modules/@tonejs/midi/dist/InstrumentMaps.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DrumKitByPatchID = exports.InstrumentFamilyByID = exports.instrumentByPatchID = void 0;
    exports.instrumentByPatchID = [
      "acoustic grand piano",
      "bright acoustic piano",
      "electric grand piano",
      "honky-tonk piano",
      "electric piano 1",
      "electric piano 2",
      "harpsichord",
      "clavi",
      "celesta",
      "glockenspiel",
      "music box",
      "vibraphone",
      "marimba",
      "xylophone",
      "tubular bells",
      "dulcimer",
      "drawbar organ",
      "percussive organ",
      "rock organ",
      "church organ",
      "reed organ",
      "accordion",
      "harmonica",
      "tango accordion",
      "acoustic guitar (nylon)",
      "acoustic guitar (steel)",
      "electric guitar (jazz)",
      "electric guitar (clean)",
      "electric guitar (muted)",
      "overdriven guitar",
      "distortion guitar",
      "guitar harmonics",
      "acoustic bass",
      "electric bass (finger)",
      "electric bass (pick)",
      "fretless bass",
      "slap bass 1",
      "slap bass 2",
      "synth bass 1",
      "synth bass 2",
      "violin",
      "viola",
      "cello",
      "contrabass",
      "tremolo strings",
      "pizzicato strings",
      "orchestral harp",
      "timpani",
      "string ensemble 1",
      "string ensemble 2",
      "synthstrings 1",
      "synthstrings 2",
      "choir aahs",
      "voice oohs",
      "synth voice",
      "orchestra hit",
      "trumpet",
      "trombone",
      "tuba",
      "muted trumpet",
      "french horn",
      "brass section",
      "synthbrass 1",
      "synthbrass 2",
      "soprano sax",
      "alto sax",
      "tenor sax",
      "baritone sax",
      "oboe",
      "english horn",
      "bassoon",
      "clarinet",
      "piccolo",
      "flute",
      "recorder",
      "pan flute",
      "blown bottle",
      "shakuhachi",
      "whistle",
      "ocarina",
      "lead 1 (square)",
      "lead 2 (sawtooth)",
      "lead 3 (calliope)",
      "lead 4 (chiff)",
      "lead 5 (charang)",
      "lead 6 (voice)",
      "lead 7 (fifths)",
      "lead 8 (bass + lead)",
      "pad 1 (new age)",
      "pad 2 (warm)",
      "pad 3 (polysynth)",
      "pad 4 (choir)",
      "pad 5 (bowed)",
      "pad 6 (metallic)",
      "pad 7 (halo)",
      "pad 8 (sweep)",
      "fx 1 (rain)",
      "fx 2 (soundtrack)",
      "fx 3 (crystal)",
      "fx 4 (atmosphere)",
      "fx 5 (brightness)",
      "fx 6 (goblins)",
      "fx 7 (echoes)",
      "fx 8 (sci-fi)",
      "sitar",
      "banjo",
      "shamisen",
      "koto",
      "kalimba",
      "bag pipe",
      "fiddle",
      "shanai",
      "tinkle bell",
      "agogo",
      "steel drums",
      "woodblock",
      "taiko drum",
      "melodic tom",
      "synth drum",
      "reverse cymbal",
      "guitar fret noise",
      "breath noise",
      "seashore",
      "bird tweet",
      "telephone ring",
      "helicopter",
      "applause",
      "gunshot"
    ];
    exports.InstrumentFamilyByID = [
      "piano",
      "chromatic percussion",
      "organ",
      "guitar",
      "bass",
      "strings",
      "ensemble",
      "brass",
      "reed",
      "pipe",
      "synth lead",
      "synth pad",
      "synth effects",
      "world",
      "percussive",
      "sound effects"
    ];
    exports.DrumKitByPatchID = {
      0: "standard kit",
      8: "room kit",
      16: "power kit",
      24: "electronic kit",
      25: "tr-808 kit",
      32: "jazz kit",
      40: "brush kit",
      48: "orchestra kit",
      56: "sound fx kit"
    };
  }
});

// node_modules/@tonejs/midi/dist/Instrument.js
var require_Instrument = __commonJS({
  "node_modules/@tonejs/midi/dist/Instrument.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Instrument = void 0;
    var InstrumentMaps_1 = require_InstrumentMaps();
    var privateTrackMap = /* @__PURE__ */ new WeakMap();
    var Instrument = (
      /** @class */
      function() {
        function Instrument2(trackData, track) {
          this.number = 0;
          privateTrackMap.set(this, track);
          this.number = 0;
          if (trackData) {
            var programChange = trackData.find(function(e) {
              return e.type === "programChange";
            });
            if (programChange) {
              this.number = programChange.programNumber;
            }
          }
        }
        Object.defineProperty(Instrument2.prototype, "name", {
          /**
           * The common name of the instrument.
           */
          get: function() {
            if (this.percussion) {
              return InstrumentMaps_1.DrumKitByPatchID[this.number];
            } else {
              return InstrumentMaps_1.instrumentByPatchID[this.number];
            }
          },
          set: function(n) {
            var patchNumber = InstrumentMaps_1.instrumentByPatchID.indexOf(n);
            if (patchNumber !== -1) {
              this.number = patchNumber;
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Instrument2.prototype, "family", {
          /**
           * The instrument family, e.g. "piano".
           */
          get: function() {
            if (this.percussion) {
              return "drums";
            } else {
              return InstrumentMaps_1.InstrumentFamilyByID[Math.floor(this.number / 8)];
            }
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Instrument2.prototype, "percussion", {
          /**
           * If the instrument is a percussion instrument.
           */
          get: function() {
            var track = privateTrackMap.get(this);
            return track.channel === 9;
          },
          enumerable: false,
          configurable: true
        });
        Instrument2.prototype.toJSON = function() {
          return {
            family: this.family,
            number: this.number,
            name: this.name
          };
        };
        Instrument2.prototype.fromJSON = function(json) {
          this.number = json.number;
        };
        return Instrument2;
      }()
    );
    exports.Instrument = Instrument;
  }
});

// node_modules/@tonejs/midi/dist/Note.js
var require_Note = __commonJS({
  "node_modules/@tonejs/midi/dist/Note.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Note = void 0;
    function midiToPitch(midi) {
      var octave = Math.floor(midi / 12) - 1;
      return midiToPitchClass(midi) + octave.toString();
    }
    function midiToPitchClass(midi) {
      var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      var note = midi % 12;
      return scaleIndexToNote[note];
    }
    function pitchClassToMidi(pitch) {
      var scaleIndexToNote = ["C", "C#", "D", "D#", "E", "F", "F#", "G", "G#", "A", "A#", "B"];
      return scaleIndexToNote.indexOf(pitch);
    }
    var pitchToMidi = function() {
      var regexp = /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i;
      var noteToScaleIndex = {
        // tslint:disable-next-line: object-literal-sort-keys
        cbb: -2,
        cb: -1,
        c: 0,
        "c#": 1,
        cx: 2,
        dbb: 0,
        db: 1,
        d: 2,
        "d#": 3,
        dx: 4,
        ebb: 2,
        eb: 3,
        e: 4,
        "e#": 5,
        ex: 6,
        fbb: 3,
        fb: 4,
        f: 5,
        "f#": 6,
        fx: 7,
        gbb: 5,
        gb: 6,
        g: 7,
        "g#": 8,
        gx: 9,
        abb: 7,
        ab: 8,
        a: 9,
        "a#": 10,
        ax: 11,
        bbb: 9,
        bb: 10,
        b: 11,
        "b#": 12,
        bx: 13
      };
      return function(note) {
        var split = regexp.exec(note);
        var pitch = split[1];
        var octave = split[2];
        var index = noteToScaleIndex[pitch.toLowerCase()];
        return index + (parseInt(octave, 10) + 1) * 12;
      };
    }();
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var Note = (
      /** @class */
      function() {
        function Note2(noteOn, noteOff, header) {
          privateHeaderMap.set(this, header);
          this.midi = noteOn.midi;
          this.velocity = noteOn.velocity;
          this.noteOffVelocity = noteOff.velocity;
          this.ticks = noteOn.ticks;
          this.durationTicks = noteOff.ticks - noteOn.ticks;
        }
        Object.defineProperty(Note2.prototype, "name", {
          /**
           * The note name and octave in scientific pitch notation, e.g. "C4".
           */
          get: function() {
            return midiToPitch(this.midi);
          },
          set: function(n) {
            this.midi = pitchToMidi(n);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "octave", {
          /**
           * The notes octave number.
           */
          get: function() {
            return Math.floor(this.midi / 12) - 1;
          },
          set: function(o) {
            var diff = o - this.octave;
            this.midi += diff * 12;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "pitch", {
          /**
           * The pitch class name. e.g. "A".
           */
          get: function() {
            return midiToPitchClass(this.midi);
          },
          set: function(p) {
            this.midi = 12 * (this.octave + 1) + pitchClassToMidi(p);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "duration", {
          /**
           * The duration of the segment in seconds.
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks + this.durationTicks) - header.ticksToSeconds(this.ticks);
          },
          set: function(d) {
            var header = privateHeaderMap.get(this);
            var noteEndTicks = header.secondsToTicks(this.time + d);
            this.durationTicks = noteEndTicks - this.ticks;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "time", {
          /**
           * The time of the event in seconds.
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToSeconds(this.ticks);
          },
          set: function(t) {
            var header = privateHeaderMap.get(this);
            this.ticks = header.secondsToTicks(t);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Note2.prototype, "bars", {
          /**
           * The number of measures (and partial measures) to this beat.
           * Takes into account time signature changes.
           * @readonly
           */
          get: function() {
            var header = privateHeaderMap.get(this);
            return header.ticksToMeasures(this.ticks);
          },
          enumerable: false,
          configurable: true
        });
        Note2.prototype.toJSON = function() {
          return {
            duration: this.duration,
            durationTicks: this.durationTicks,
            midi: this.midi,
            name: this.name,
            ticks: this.ticks,
            time: this.time,
            velocity: this.velocity
          };
        };
        return Note2;
      }()
    );
    exports.Note = Note;
  }
});

// node_modules/@tonejs/midi/dist/Track.js
var require_Track = __commonJS({
  "node_modules/@tonejs/midi/dist/Track.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Track = void 0;
    var BinarySearch_1 = require_BinarySearch();
    var ControlChange_1 = require_ControlChange();
    var ControlChanges_1 = require_ControlChanges();
    var PitchBend_1 = require_PitchBend();
    var Instrument_1 = require_Instrument();
    var Note_1 = require_Note();
    var privateHeaderMap = /* @__PURE__ */ new WeakMap();
    var Track = (
      /** @class */
      function() {
        function Track2(trackData, header) {
          var _this = this;
          this.name = "";
          this.notes = [];
          this.controlChanges = (0, ControlChanges_1.createControlChanges)();
          this.pitchBends = [];
          privateHeaderMap.set(this, header);
          if (trackData) {
            var nameEvent = trackData.find(function(e) {
              return e.type === "trackName";
            });
            this.name = nameEvent ? nameEvent.text : "";
          }
          this.instrument = new Instrument_1.Instrument(trackData, this);
          this.channel = 0;
          if (trackData) {
            var noteOns = trackData.filter(function(event) {
              return event.type === "noteOn";
            });
            var noteOffs = trackData.filter(function(event) {
              return event.type === "noteOff";
            });
            var _loop_1 = function() {
              var currentNote = noteOns.shift();
              this_1.channel = currentNote.channel;
              var offIndex = noteOffs.findIndex(function(note) {
                return note.noteNumber === currentNote.noteNumber && note.absoluteTime >= currentNote.absoluteTime;
              });
              if (offIndex !== -1) {
                var noteOff = noteOffs.splice(offIndex, 1)[0];
                this_1.addNote({
                  durationTicks: noteOff.absoluteTime - currentNote.absoluteTime,
                  midi: currentNote.noteNumber,
                  noteOffVelocity: noteOff.velocity / 127,
                  ticks: currentNote.absoluteTime,
                  velocity: currentNote.velocity / 127
                });
              }
            };
            var this_1 = this;
            while (noteOns.length) {
              _loop_1();
            }
            var controlChanges = trackData.filter(function(event) {
              return event.type === "controller";
            });
            controlChanges.forEach(function(event) {
              _this.addCC({
                number: event.controllerType,
                ticks: event.absoluteTime,
                value: event.value / 127
              });
            });
            var pitchBends = trackData.filter(function(event) {
              return event.type === "pitchBend";
            });
            pitchBends.forEach(function(event) {
              _this.addPitchBend({
                ticks: event.absoluteTime,
                // Scale the value between -2^13 to 2^13 to -2 to 2.
                value: event.value / Math.pow(2, 13)
              });
            });
            var endOfTrackEvent = trackData.find(function(event) {
              return event.type === "endOfTrack";
            });
            this.endOfTrackTicks = endOfTrackEvent !== void 0 ? endOfTrackEvent.absoluteTime : void 0;
          }
        }
        Track2.prototype.addNote = function(props) {
          var header = privateHeaderMap.get(this);
          var note = new Note_1.Note({
            midi: 0,
            ticks: 0,
            velocity: 1
          }, {
            ticks: 0,
            velocity: 0
          }, header);
          Object.assign(note, props);
          (0, BinarySearch_1.insert)(this.notes, note, "ticks");
          return this;
        };
        Track2.prototype.addCC = function(props) {
          var header = privateHeaderMap.get(this);
          var cc = new ControlChange_1.ControlChange({
            controllerType: props.number
          }, header);
          delete props.number;
          Object.assign(cc, props);
          if (!Array.isArray(this.controlChanges[cc.number])) {
            this.controlChanges[cc.number] = [];
          }
          (0, BinarySearch_1.insert)(this.controlChanges[cc.number], cc, "ticks");
          return this;
        };
        Track2.prototype.addPitchBend = function(props) {
          var header = privateHeaderMap.get(this);
          var pb = new PitchBend_1.PitchBend({}, header);
          Object.assign(pb, props);
          (0, BinarySearch_1.insert)(this.pitchBends, pb, "ticks");
          return this;
        };
        Object.defineProperty(Track2.prototype, "duration", {
          /**
           * The end time of the last event in the track.
           */
          get: function() {
            if (!this.notes.length) {
              return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].time + this.notes[this.notes.length - 1].duration;
            for (var i = 0; i < this.notes.length - 1; i++) {
              var duration = this.notes[i].time + this.notes[i].duration;
              if (maxDuration < duration) {
                maxDuration = duration;
              }
            }
            return maxDuration;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Track2.prototype, "durationTicks", {
          /**
           * The end time of the last event in the track in ticks.
           */
          get: function() {
            if (!this.notes.length) {
              return 0;
            }
            var maxDuration = this.notes[this.notes.length - 1].ticks + this.notes[this.notes.length - 1].durationTicks;
            for (var i = 0; i < this.notes.length - 1; i++) {
              var duration = this.notes[i].ticks + this.notes[i].durationTicks;
              if (maxDuration < duration) {
                maxDuration = duration;
              }
            }
            return maxDuration;
          },
          enumerable: false,
          configurable: true
        });
        Track2.prototype.fromJSON = function(json) {
          var _this = this;
          this.name = json.name;
          this.channel = json.channel;
          this.instrument = new Instrument_1.Instrument(void 0, this);
          this.instrument.fromJSON(json.instrument);
          if (json.endOfTrackTicks !== void 0) {
            this.endOfTrackTicks = json.endOfTrackTicks;
          }
          for (var number in json.controlChanges) {
            if (json.controlChanges[number]) {
              json.controlChanges[number].forEach(function(cc) {
                _this.addCC({
                  number: cc.number,
                  ticks: cc.ticks,
                  value: cc.value
                });
              });
            }
          }
          json.notes.forEach(function(n) {
            _this.addNote({
              durationTicks: n.durationTicks,
              midi: n.midi,
              ticks: n.ticks,
              velocity: n.velocity
            });
          });
        };
        Track2.prototype.toJSON = function() {
          var controlChanges = {};
          for (var i = 0; i < 127; i++) {
            if (this.controlChanges.hasOwnProperty(i)) {
              controlChanges[i] = this.controlChanges[i].map(function(c) {
                return c.toJSON();
              });
            }
          }
          var json = {
            channel: this.channel,
            controlChanges,
            pitchBends: this.pitchBends.map(function(pb) {
              return pb.toJSON();
            }),
            instrument: this.instrument.toJSON(),
            name: this.name,
            notes: this.notes.map(function(n) {
              return n.toJSON();
            })
          };
          if (this.endOfTrackTicks !== void 0) {
            json.endOfTrackTicks = this.endOfTrackTicks;
          }
          return json;
        };
        return Track2;
      }()
    );
    exports.Track = Track;
  }
});

// node_modules/array-flatten/dist.es2015/index.js
var dist_exports = {};
__export(dist_exports, {
  flatten: () => flatten
});
function flatten(array) {
  var result = [];
  $flatten(array, result);
  return result;
}
function $flatten(array, result) {
  for (var i = 0; i < array.length; i++) {
    var value = array[i];
    if (Array.isArray(value)) {
      $flatten(value, result);
    } else {
      result.push(value);
    }
  }
}
var init_dist = __esm({
  "node_modules/array-flatten/dist.es2015/index.js"() {
  }
});

// node_modules/@tonejs/midi/dist/Encode.js
var require_Encode = __commonJS({
  "node_modules/@tonejs/midi/dist/Encode.js"(exports) {
    "use strict";
    var __spreadArray = exports && exports.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2)
        for (var i = 0, l = from.length, ar; i < l; i++) {
          if (ar || !(i in from)) {
            if (!ar)
              ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
          }
        }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encode = void 0;
    var midi_file_1 = require_midi_file();
    var Header_1 = require_Header();
    var array_flatten_1 = (init_dist(), __toCommonJS(dist_exports));
    function encodeNote(note, channel) {
      return [
        {
          absoluteTime: note.ticks,
          channel,
          deltaTime: 0,
          noteNumber: note.midi,
          type: "noteOn",
          velocity: Math.floor(note.velocity * 127)
        },
        {
          absoluteTime: note.ticks + note.durationTicks,
          channel,
          deltaTime: 0,
          noteNumber: note.midi,
          type: "noteOff",
          velocity: Math.floor(note.noteOffVelocity * 127)
        }
      ];
    }
    function encodeNotes(track) {
      return (0, array_flatten_1.flatten)(track.notes.map(function(note) {
        return encodeNote(note, track.channel);
      }));
    }
    function encodeControlChange(cc, channel) {
      return {
        absoluteTime: cc.ticks,
        channel,
        controllerType: cc.number,
        deltaTime: 0,
        type: "controller",
        value: Math.floor(cc.value * 127)
      };
    }
    function encodeControlChanges(track) {
      var controlChanges = [];
      for (var i = 0; i < 127; i++) {
        if (track.controlChanges.hasOwnProperty(i)) {
          track.controlChanges[i].forEach(function(cc) {
            controlChanges.push(encodeControlChange(cc, track.channel));
          });
        }
      }
      return controlChanges;
    }
    function encodePitchBend(pb, channel) {
      return {
        absoluteTime: pb.ticks,
        channel,
        deltaTime: 0,
        type: "pitchBend",
        value: pb.value
      };
    }
    function encodePitchBends(track) {
      var pitchBends = [];
      track.pitchBends.forEach(function(pb) {
        pitchBends.push(encodePitchBend(pb, track.channel));
      });
      return pitchBends;
    }
    function encodeInstrument(track) {
      return {
        absoluteTime: 0,
        channel: track.channel,
        deltaTime: 0,
        programNumber: track.instrument.number,
        type: "programChange"
      };
    }
    function encodeTrackName(name) {
      return {
        absoluteTime: 0,
        deltaTime: 0,
        meta: true,
        text: name,
        type: "trackName"
      };
    }
    function encodeTempo(tempo) {
      return {
        absoluteTime: tempo.ticks,
        deltaTime: 0,
        meta: true,
        microsecondsPerBeat: Math.floor(6e7 / tempo.bpm),
        type: "setTempo"
      };
    }
    function encodeTimeSignature(timeSig) {
      return {
        absoluteTime: timeSig.ticks,
        deltaTime: 0,
        denominator: timeSig.timeSignature[1],
        meta: true,
        metronome: 24,
        numerator: timeSig.timeSignature[0],
        thirtyseconds: 8,
        type: "timeSignature"
      };
    }
    function encodeKeySignature(keySig) {
      var keyIndex = Header_1.keySignatureKeys.indexOf(keySig.key);
      return {
        absoluteTime: keySig.ticks,
        deltaTime: 0,
        key: keyIndex + 7,
        meta: true,
        scale: keySig.scale === "major" ? 0 : 1,
        type: "keySignature"
      };
    }
    function encodeText(textEvent) {
      return {
        absoluteTime: textEvent.ticks,
        deltaTime: 0,
        meta: true,
        text: textEvent.text,
        type: textEvent.type
      };
    }
    function encode(midi) {
      var midiData = {
        header: {
          format: 1,
          numTracks: midi.tracks.length + 1,
          ticksPerBeat: midi.header.ppq
        },
        tracks: __spreadArray([
          __spreadArray(__spreadArray(__spreadArray(__spreadArray([
            // The name data.
            {
              absoluteTime: 0,
              deltaTime: 0,
              meta: true,
              text: midi.header.name,
              type: "trackName"
            }
          ], midi.header.keySignatures.map(function(keySig) {
            return encodeKeySignature(keySig);
          }), true), midi.header.meta.map(function(e) {
            return encodeText(e);
          }), true), midi.header.tempos.map(function(tempo) {
            return encodeTempo(tempo);
          }), true), midi.header.timeSignatures.map(function(timeSig) {
            return encodeTimeSignature(timeSig);
          }), true)
        ], midi.tracks.map(function(track) {
          return __spreadArray(__spreadArray(__spreadArray([
            // Add the name
            encodeTrackName(track.name),
            // the instrument
            encodeInstrument(track)
          ], encodeNotes(track), true), encodeControlChanges(track), true), encodePitchBends(track), true);
        }), true)
      };
      midiData.tracks = midiData.tracks.map(function(track) {
        track = track.sort(function(a, b) {
          return a.absoluteTime - b.absoluteTime;
        });
        var lastTime = 0;
        track.forEach(function(note) {
          note.deltaTime = note.absoluteTime - lastTime;
          lastTime = note.absoluteTime;
          delete note.absoluteTime;
        });
        track.push({
          deltaTime: 0,
          meta: true,
          type: "endOfTrack"
        });
        return track;
      });
      return new Uint8Array((0, midi_file_1.writeMidi)(midiData));
    }
    exports.encode = encode;
  }
});

// node_modules/@tonejs/midi/dist/Midi.js
var require_Midi = __commonJS({
  "node_modules/@tonejs/midi/dist/Midi.js"(exports) {
    var __awaiter = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step(generator.next(value));
          } catch (e) {
            reject(e);
          }
        }
        function rejected(value) {
          try {
            step(generator["throw"](value));
          } catch (e) {
            reject(e);
          }
        }
        function step(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    var __generator = exports && exports.__generator || function(thisArg, body) {
      var _ = { label: 0, sent: function() {
        if (t[0] & 1)
          throw t[1];
        return t[1];
      }, trys: [], ops: [] }, f, y, t, g;
      return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
        return this;
      }), g;
      function verb(n) {
        return function(v) {
          return step([n, v]);
        };
      }
      function step(op) {
        if (f)
          throw new TypeError("Generator is already executing.");
        while (_)
          try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
              return t;
            if (y = 0, t)
              op = [op[0] & 2, t.value];
            switch (op[0]) {
              case 0:
              case 1:
                t = op;
                break;
              case 4:
                _.label++;
                return { value: op[1], done: false };
              case 5:
                _.label++;
                y = op[1];
                op = [0];
                continue;
              case 7:
                op = _.ops.pop();
                _.trys.pop();
                continue;
              default:
                if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                  _ = 0;
                  continue;
                }
                if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                  _.label = op[1];
                  break;
                }
                if (op[0] === 6 && _.label < t[1]) {
                  _.label = t[1];
                  t = op;
                  break;
                }
                if (t && _.label < t[2]) {
                  _.label = t[2];
                  _.ops.push(op);
                  break;
                }
                if (t[2])
                  _.ops.pop();
                _.trys.pop();
                continue;
            }
            op = body.call(thisArg, _);
          } catch (e) {
            op = [6, e];
            y = 0;
          } finally {
            f = t = 0;
          }
        if (op[0] & 5)
          throw op[1];
        return { value: op[0] ? op[1] : void 0, done: true };
      }
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Header = exports.Track = exports.Midi = void 0;
    var midi_file_1 = require_midi_file();
    var Header_1 = require_Header();
    var Track_1 = require_Track();
    var Encode_1 = require_Encode();
    var Midi = (
      /** @class */
      function() {
        function Midi2(midiArray) {
          var _this = this;
          var midiData = null;
          if (midiArray) {
            var midiArrayLike = midiArray instanceof ArrayBuffer ? new Uint8Array(midiArray) : midiArray;
            midiData = (0, midi_file_1.parseMidi)(midiArrayLike);
            midiData.tracks.forEach(function(track) {
              var currentTicks = 0;
              track.forEach(function(event) {
                currentTicks += event.deltaTime;
                event.absoluteTime = currentTicks;
              });
            });
            midiData.tracks = splitTracks(midiData.tracks);
          }
          this.header = new Header_1.Header(midiData);
          this.tracks = [];
          if (midiArray) {
            this.tracks = midiData.tracks.map(function(trackData) {
              return new Track_1.Track(trackData, _this.header);
            });
            if (midiData.header.format === 1 && this.tracks[0].duration === 0) {
              this.tracks.shift();
            }
          }
        }
        Midi2.fromUrl = function(url) {
          return __awaiter(this, void 0, void 0, function() {
            var response, arrayBuffer;
            return __generator(this, function(_a) {
              switch (_a.label) {
                case 0:
                  return [4, fetch(url)];
                case 1:
                  response = _a.sent();
                  if (!response.ok)
                    return [3, 3];
                  return [4, response.arrayBuffer()];
                case 2:
                  arrayBuffer = _a.sent();
                  return [2, new Midi2(arrayBuffer)];
                case 3:
                  throw new Error("Could not load '".concat(url, "'"));
              }
            });
          });
        };
        Object.defineProperty(Midi2.prototype, "name", {
          /**
           * The name of the midi file, taken from the first track.
           */
          get: function() {
            return this.header.name;
          },
          set: function(n) {
            this.header.name = n;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Midi2.prototype, "duration", {
          /**
           * The total length of the file in seconds.
           */
          get: function() {
            var durations = this.tracks.map(function(t) {
              return t.duration;
            });
            return Math.max.apply(Math, durations);
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Midi2.prototype, "durationTicks", {
          /**
           * The total length of the file in ticks.
           */
          get: function() {
            var durationTicks = this.tracks.map(function(t) {
              return t.durationTicks;
            });
            return Math.max.apply(Math, durationTicks);
          },
          enumerable: false,
          configurable: true
        });
        Midi2.prototype.addTrack = function() {
          var track = new Track_1.Track(void 0, this.header);
          this.tracks.push(track);
          return track;
        };
        Midi2.prototype.toArray = function() {
          return (0, Encode_1.encode)(this);
        };
        Midi2.prototype.toJSON = function() {
          return {
            header: this.header.toJSON(),
            tracks: this.tracks.map(function(track) {
              return track.toJSON();
            })
          };
        };
        Midi2.prototype.fromJSON = function(json) {
          var _this = this;
          this.header = new Header_1.Header();
          this.header.fromJSON(json.header);
          this.tracks = json.tracks.map(function(trackJSON) {
            var track = new Track_1.Track(void 0, _this.header);
            track.fromJSON(trackJSON);
            return track;
          });
        };
        Midi2.prototype.clone = function() {
          var midi = new Midi2();
          midi.fromJSON(this.toJSON());
          return midi;
        };
        return Midi2;
      }()
    );
    exports.Midi = Midi;
    var Track_2 = require_Track();
    Object.defineProperty(exports, "Track", { enumerable: true, get: function() {
      return Track_2.Track;
    } });
    var Header_2 = require_Header();
    Object.defineProperty(exports, "Header", { enumerable: true, get: function() {
      return Header_2.Header;
    } });
    function splitTracks(tracks) {
      var newTracks = [];
      for (var i = 0; i < tracks.length; i++) {
        var defaultTrack = newTracks.length;
        var trackMap = /* @__PURE__ */ new Map();
        var currentProgram = Array(16).fill(0);
        for (var _i = 0, _a = tracks[i]; _i < _a.length; _i++) {
          var event_1 = _a[_i];
          var targetTrack = defaultTrack;
          var channel = event_1.channel;
          if (channel !== void 0) {
            if (event_1.type === "programChange") {
              currentProgram[channel] = event_1.programNumber;
            }
            var program = currentProgram[channel];
            var trackKey = "".concat(program, " ").concat(channel);
            if (trackMap.has(trackKey)) {
              targetTrack = trackMap.get(trackKey);
            } else {
              targetTrack = defaultTrack + trackMap.size;
              trackMap.set(trackKey, targetTrack);
            }
          }
          if (!newTracks[targetTrack]) {
            newTracks.push([]);
          }
          newTracks[targetTrack].push(event_1);
        }
      }
      return newTracks;
    }
  }
});
export default require_Midi();
//# sourceMappingURL=@tonejs_midi.js.map
