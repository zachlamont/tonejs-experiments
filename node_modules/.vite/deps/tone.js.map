{
  "version": 3,
  "sources": ["../../tone/Tone/version.ts", "../../automation-events/src/functions/create-extended-exponential-ramp-to-value-automation-event.ts", "../../automation-events/src/functions/create-extended-linear-ramp-to-value-automation-event.ts", "../../automation-events/src/functions/create-set-value-automation-event.ts", "../../automation-events/src/functions/create-set-value-curve-automation-event.ts", "../../automation-events/src/functions/get-target-value-at-time.ts", "../../automation-events/src/guards/exponential-ramp-to-value-automation-event.ts", "../../automation-events/src/guards/linear-ramp-to-value-automation-event.ts", "../../automation-events/src/guards/any-ramp-to-value-automation-event.ts", "../../automation-events/src/guards/set-value-automation-event.ts", "../../automation-events/src/guards/set-value-curve-automation-event.ts", "../../automation-events/src/functions/get-value-of-automation-event-at-index-at-time.ts", "../../automation-events/src/functions/get-end-time-and-value-of-previous-automation-event.ts", "../../automation-events/src/guards/cancel-and-hold-automation-event.ts", "../../automation-events/src/guards/cancel-scheduled-values-automation-event.ts", "../../automation-events/src/functions/get-event-time.ts", "../../automation-events/src/functions/get-exponential-ramp-value-at-time.ts", "../../automation-events/src/functions/get-linear-ramp-value-at-time.ts", "../../automation-events/src/functions/interpolate-value.ts", "../../automation-events/src/functions/get-value-curve-value-at-time.ts", "../../automation-events/src/guards/set-target-automation-event.ts", "../../automation-events/src/classes/automation-event-list.ts", "../../automation-events/src/functions/create-cancel-and-hold-automation-event.ts", "../../automation-events/src/functions/create-cancel-scheduled-values-automation-event.ts", "../../automation-events/src/functions/create-exponential-ramp-to-value-automation-event.ts", "../../automation-events/src/functions/create-linear-ramp-to-value-automation-event.ts", "../../automation-events/src/functions/create-set-target-automation-event.ts", "../../standardized-audio-context/src/factories/abort-error.ts", "../../standardized-audio-context/src/factories/add-active-input-connection-to-audio-node.ts", "../../standardized-audio-context/src/factories/add-audio-node-connections.ts", "../../standardized-audio-context/src/factories/add-audio-param-connections.ts", "../../standardized-audio-context/src/globals.ts", "../../standardized-audio-context/src/helpers/is-constructible.ts", "../../standardized-audio-context/src/helpers/split-import-statements.ts", "../../standardized-audio-context/src/factories/add-audio-worklet-module.ts", "../../standardized-audio-context/src/helpers/get-value-for-key.ts", "../../standardized-audio-context/src/helpers/pick-element-from-set.ts", "../../standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-node.ts", "../../standardized-audio-context/src/helpers/get-event-listeners-of-audio-node.ts", "../../standardized-audio-context/src/helpers/set-internal-state-to-active.ts", "../../standardized-audio-context/src/guards/audio-worklet-node.ts", "../../standardized-audio-context/src/helpers/set-internal-state-to-passive.ts", "../../standardized-audio-context/src/helpers/set-internal-state-to-passive-when-necessary.ts", "../../standardized-audio-context/src/factories/add-connection-to-audio-node.ts", "../../standardized-audio-context/src/factories/add-passive-input-connection-to-audio-node.ts", "../../standardized-audio-context/src/factories/add-silent-connection.ts", "../../standardized-audio-context/src/factories/add-unrendered-audio-worklet-node.ts", "../../standardized-audio-context/src/factories/analyser-node-constructor.ts", "../../standardized-audio-context/src/helpers/is-owned-by-context.ts", "../../standardized-audio-context/src/factories/analyser-node-renderer-factory.ts", "../../standardized-audio-context/src/helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support.ts", "../../standardized-audio-context/src/factories/index-size-error.ts", "../../standardized-audio-context/src/helpers/wrap-audio-buffer-get-channel-data-method.ts", "../../standardized-audio-context/src/factories/audio-buffer-constructor.ts", "../../standardized-audio-context/src/constants.ts", "../../standardized-audio-context/src/helpers/is-active-audio-node.ts", "../../standardized-audio-context/src/factories/audio-buffer-source-node-constructor.ts", "../../standardized-audio-context/src/factories/audio-buffer-source-node-renderer-factory.ts", "../../standardized-audio-context/src/guards/audio-buffer-source-node.ts", "../../standardized-audio-context/src/guards/biquad-filter-node.ts", "../../standardized-audio-context/src/guards/constant-source-node.ts", "../../standardized-audio-context/src/guards/gain-node.ts", "../../standardized-audio-context/src/guards/oscillator-node.ts", "../../standardized-audio-context/src/guards/stereo-panner-node.ts", "../../standardized-audio-context/src/helpers/get-audio-node-connections.ts", "../../standardized-audio-context/src/helpers/get-audio-param-connections.ts", "../../standardized-audio-context/src/helpers/deactivate-active-audio-node-input-connections.ts", "../../standardized-audio-context/src/helpers/deactivate-audio-graph.ts", "../../standardized-audio-context/src/helpers/is-valid-latency-hint.ts", "../../standardized-audio-context/src/factories/audio-context-constructor.ts", "../../standardized-audio-context/src/factories/audio-destination-node-constructor.ts", "../../standardized-audio-context/src/factories/audio-destination-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/audio-listener-factory.ts", "../../standardized-audio-context/src/guards/audio-node.ts", "../../standardized-audio-context/src/guards/audio-node-output-connection.ts", "../../standardized-audio-context/src/helpers/insert-element-in-set.ts", "../../standardized-audio-context/src/helpers/add-active-input-connection-to-audio-param.ts", "../../standardized-audio-context/src/helpers/add-passive-input-connection-to-audio-param.ts", "../../standardized-audio-context/src/guards/native-audio-node-faker.ts", "../../standardized-audio-context/src/helpers/connect-native-audio-node-to-native-audio-node.ts", "../../standardized-audio-context/src/helpers/delete-active-input-connection.ts", "../../standardized-audio-context/src/helpers/delete-active-input-connection-to-audio-param.ts", "../../standardized-audio-context/src/helpers/delete-event-listeners-of-audio-node.ts", "../../standardized-audio-context/src/helpers/delete-passive-input-connection-to-audio-param.ts", "../../standardized-audio-context/src/helpers/disconnect-native-audio-node-from-native-audio-node.ts", "../../standardized-audio-context/src/helpers/get-native-audio-node.ts", "../../standardized-audio-context/src/helpers/get-native-audio-param.ts", "../../standardized-audio-context/src/helpers/is-part-of-a-cycle.ts", "../../standardized-audio-context/src/helpers/is-passive-audio-node.ts", "../../standardized-audio-context/src/helpers/test-audio-node-disconnect-method-support.ts", "../../standardized-audio-context/src/helpers/visit-each-audio-node-once.ts", "../../standardized-audio-context/src/guards/native-audio-node.ts", "../../standardized-audio-context/src/helpers/wrap-audio-node-disconnect-method.ts", "../../standardized-audio-context/src/factories/audio-node-constructor.ts", "../../standardized-audio-context/src/factories/audio-param-factory.ts", "../../standardized-audio-context/src/factories/audio-param-renderer.ts", "../../standardized-audio-context/src/read-only-map.ts", "../../standardized-audio-context/src/factories/audio-worklet-node-constructor.ts", "../../standardized-audio-context/src/helpers/copy-from-channel.ts", "../../standardized-audio-context/src/helpers/copy-to-channel.ts", "../../standardized-audio-context/src/helpers/create-nested-arrays.ts", "../../standardized-audio-context/src/helpers/get-audio-worklet-processor.ts", "../../standardized-audio-context/src/factories/audio-worklet-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/base-audio-context-constructor.ts", "../../standardized-audio-context/src/factories/biquad-filter-node-constructor.ts", "../../standardized-audio-context/src/factories/biquad-filter-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/cache-test-result.ts", "../../standardized-audio-context/src/factories/channel-merger-node-constructor.ts", "../../standardized-audio-context/src/factories/channel-merger-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/channel-splitter-node-constructor.ts", "../../standardized-audio-context/src/factories/channel-splitter-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/connect-audio-param.ts", "../../standardized-audio-context/src/factories/connect-multiple-outputs.ts", "../../standardized-audio-context/src/factories/connected-native-audio-buffer-source-node-factory.ts", "../../standardized-audio-context/src/factories/constant-source-node-constructor.ts", "../../standardized-audio-context/src/factories/constant-source-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/convert-number-to-unsigned-long.ts", "../../standardized-audio-context/src/factories/convolver-node-constructor.ts", "../../standardized-audio-context/src/factories/convolver-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/create-native-offline-audio-context.ts", "../../standardized-audio-context/src/factories/data-clone-error.ts", "../../standardized-audio-context/src/helpers/detach-array-buffer.ts", "../../standardized-audio-context/src/factories/decode-audio-data.ts", "../../standardized-audio-context/src/factories/decrement-cycle-counter.ts", "../../standardized-audio-context/src/factories/delay-node-constructor.ts", "../../standardized-audio-context/src/factories/delay-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/delete-active-input-connection-to-audio-node.ts", "../../standardized-audio-context/src/factories/delete-unrendered-audio-worklet-node.ts", "../../standardized-audio-context/src/guards/delay-node.ts", "../../standardized-audio-context/src/factories/detect-cycles.ts", "../../standardized-audio-context/src/factories/disconnect-multiple-outputs.ts", "../../standardized-audio-context/src/factories/dynamics-compressor-node-constructor.ts", "../../standardized-audio-context/src/factories/dynamics-compressor-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/encoding-error.ts", "../../standardized-audio-context/src/factories/evaluate-source.ts", "../../standardized-audio-context/src/factories/event-target-constructor.ts", "../../standardized-audio-context/src/factories/expose-current-frame-and-current-time.ts", "../../standardized-audio-context/src/factories/fetch-source.ts", "../../standardized-audio-context/src/factories/gain-node-constructor.ts", "../../standardized-audio-context/src/factories/gain-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/get-active-audio-worklet-node-inputs.ts", "../../standardized-audio-context/src/factories/get-audio-node-renderer.ts", "../../standardized-audio-context/src/factories/get-audio-node-tail-time.ts", "../../standardized-audio-context/src/factories/get-audio-param-renderer.ts", "../../standardized-audio-context/src/factories/get-backup-offline-audio-context.ts", "../../standardized-audio-context/src/factories/invalid-state-error.ts", "../../standardized-audio-context/src/factories/get-native-context.ts", "../../standardized-audio-context/src/factories/get-or-create-backup-offline-audio-context.ts", "../../standardized-audio-context/src/factories/get-unrendered-audio-worklet-nodes.ts", "../../standardized-audio-context/src/factories/invalid-access-error.ts", "../../standardized-audio-context/src/helpers/wrap-iir-filter-node-get-frequency-response-method.ts", "../../standardized-audio-context/src/factories/iir-filter-node-constructor.ts", "../../standardized-audio-context/src/helpers/filter-buffer.ts", "../../standardized-audio-context/src/factories/iir-filter-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/increment-cycle-counter-factory.ts", "../../standardized-audio-context/src/factories/is-any-audio-context.ts", "../../standardized-audio-context/src/factories/is-any-audio-node.ts", "../../standardized-audio-context/src/factories/is-any-audio-param.ts", "../../standardized-audio-context/src/factories/is-any-offline-audio-context.ts", "../../standardized-audio-context/src/factories/is-native-audio-context.ts", "../../standardized-audio-context/src/factories/is-native-audio-node.ts", "../../standardized-audio-context/src/factories/is-native-audio-param.ts", "../../standardized-audio-context/src/factories/is-native-context.ts", "../../standardized-audio-context/src/factories/is-native-offline-audio-context.ts", "../../standardized-audio-context/src/factories/is-secure-context.ts", "../../standardized-audio-context/src/factories/is-supported-promise.ts", "../../standardized-audio-context/src/factories/media-element-audio-source-node-constructor.ts", "../../standardized-audio-context/src/factories/media-stream-audio-destination-node-constructor.ts", "../../standardized-audio-context/src/factories/media-stream-audio-source-node-constructor.ts", "../../standardized-audio-context/src/factories/media-stream-track-audio-source-node-constructor.ts", "../../standardized-audio-context/src/factories/minimal-audio-context-constructor.ts", "../../standardized-audio-context/src/factories/minimal-base-audio-context-constructor.ts", "../../standardized-audio-context/src/helpers/test-promise-support.ts", "../../standardized-audio-context/src/factories/minimal-offline-audio-context-constructor.ts", "../../standardized-audio-context/src/factories/monitor-connections.ts", "../../standardized-audio-context/src/helpers/assign-native-audio-node-option.ts", "../../standardized-audio-context/src/helpers/assign-native-audio-node-options.ts", "../../standardized-audio-context/src/helpers/test-analyser-node-get-float-time-domain-data-method-support.ts", "../../standardized-audio-context/src/helpers/wrap-analyser-node-get-float-time-domain-data-method.ts", "../../standardized-audio-context/src/factories/native-analyser-node-factory.ts", "../../standardized-audio-context/src/factories/native-audio-buffer-constructor.ts", "../../standardized-audio-context/src/helpers/assign-native-audio-node-audio-param-value.ts", "../../standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls.ts", "../../standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters.ts", "../../standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters.ts", "../../standardized-audio-context/src/factories/native-audio-buffer-source-node-factory.ts", "../../standardized-audio-context/src/factories/native-audio-context-constructor.ts", "../../standardized-audio-context/src/factories/native-audio-destination-node.ts", "../../standardized-audio-context/src/factories/native-audio-worklet-node-constructor.ts", "../../standardized-audio-context/src/helpers/test-clonability-of-audio-worklet-node-options.ts", "../../standardized-audio-context/src/factories/native-audio-worklet-node-factory.ts", "../../standardized-audio-context/src/helpers/compute-buffer-size.ts", "../../standardized-audio-context/src/helpers/clone-audio-worklet-node-options.ts", "../../standardized-audio-context/src/helpers/create-audio-worklet-processor-promise.ts", "../../standardized-audio-context/src/helpers/create-audio-worklet-processor.ts", "../../standardized-audio-context/src/factories/native-audio-worklet-node-faker-factory.ts", "../../standardized-audio-context/src/factories/native-biquad-filter-node.ts", "../../standardized-audio-context/src/factories/native-channel-merger-node-factory.ts", "../../standardized-audio-context/src/helpers/wrap-channel-splitter-node.ts", "../../standardized-audio-context/src/factories/native-channel-splitter-node.ts", "../../standardized-audio-context/src/factories/native-constant-source-node-factory.ts", "../../standardized-audio-context/src/helpers/intercept-connections.ts", "../../standardized-audio-context/src/factories/native-constant-source-node-faker-factory.ts", "../../standardized-audio-context/src/factories/native-convolver-node-factory.ts", "../../standardized-audio-context/src/factories/native-delay-node.ts", "../../standardized-audio-context/src/factories/native-dynamics-compressor-node-factory.ts", "../../standardized-audio-context/src/factories/native-gain-node.ts", "../../standardized-audio-context/src/factories/native-iir-filter-node-factory.ts", "../../standardized-audio-context/src/factories/native-iir-filter-node-faker-factory.ts", "../../standardized-audio-context/src/factories/native-media-element-audio-source-node.ts", "../../standardized-audio-context/src/factories/native-media-stream-audio-destination-node.ts", "../../standardized-audio-context/src/factories/native-media-stream-audio-source-node.ts", "../../standardized-audio-context/src/factories/native-media-stream-track-audio-source-node-factory.ts", "../../standardized-audio-context/src/factories/native-offline-audio-context-constructor.ts", "../../standardized-audio-context/src/factories/native-oscillator-node-factory.ts", "../../standardized-audio-context/src/factories/native-panner-node-factory.ts", "../../standardized-audio-context/src/factories/native-panner-node-faker-factory.ts", "../../standardized-audio-context/src/factories/native-periodic-wave-factory.ts", "../../standardized-audio-context/src/factories/native-script-processor-node.ts", "../../standardized-audio-context/src/factories/native-stereo-panner-node-factory.ts", "../../standardized-audio-context/src/factories/native-stereo-panner-node-faker-factory.ts", "../../standardized-audio-context/src/factories/native-wave-shaper-node-factory.ts", "../../standardized-audio-context/src/factories/native-wave-shaper-node-faker-factory.ts", "../../standardized-audio-context/src/factories/not-supported-error.ts", "../../standardized-audio-context/src/factories/offline-audio-context-constructor.ts", "../../standardized-audio-context/src/factories/oscillator-node-constructor.ts", "../../standardized-audio-context/src/factories/oscillator-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/panner-node-constructor.ts", "../../standardized-audio-context/src/factories/panner-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/periodic-wave-constructor.ts", "../../standardized-audio-context/src/factories/render-automation.ts", "../../standardized-audio-context/src/factories/render-inputs-of-audio-node.ts", "../../standardized-audio-context/src/factories/render-inputs-of-audio-param.ts", "../../standardized-audio-context/src/factories/render-native-offline-audio-context.ts", "../../standardized-audio-context/src/factories/set-active-audio-worklet-node-inputs.ts", "../../standardized-audio-context/src/factories/set-audio-node-tail-time.ts", "../../standardized-audio-context/src/factories/start-rendering.ts", "../../standardized-audio-context/src/factories/stereo-panner-node-constructor.ts", "../../standardized-audio-context/src/factories/stereo-panner-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/test-audio-buffer-constructor-support.ts", "../../standardized-audio-context/src/factories/test-audio-buffer-copy-channel-methods-subarray-support.ts", "../../standardized-audio-context/src/factories/test-audio-context-close-method-support.ts", "../../standardized-audio-context/src/factories/test-audio-context-decode-audio-data-method-type-error-support.ts", "../../standardized-audio-context/src/factories/test-audio-context-options-support.ts", "../../standardized-audio-context/src/factories/test-audio-node-connect-method-support.ts", "../../standardized-audio-context/src/factories/test-audio-worklet-processor-no-outputs-support.ts", "../../standardized-audio-context/src/factories/test-audio-worklet-processor-post-message-support.ts", "../../standardized-audio-context/src/factories/test-channel-merger-node-channel-count-support.ts", "../../standardized-audio-context/src/factories/test-constant-source-node-accurate-scheduling-support.ts", "../../standardized-audio-context/src/factories/test-convolver-node-buffer-reassignability-support.ts", "../../standardized-audio-context/src/factories/test-convolver-node-channel-count-support.ts", "../../standardized-audio-context/src/factories/test-is-secure-context-support.ts", "../../standardized-audio-context/src/factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support.ts", "../../standardized-audio-context/src/factories/test-offline-audio-context-current-time-support.ts", "../../standardized-audio-context/src/factories/test-stereo-panner-node-default-value-support.ts", "../../standardized-audio-context/src/factories/unknown-error.ts", "../../standardized-audio-context/src/factories/wave-shaper-node-constructor.ts", "../../standardized-audio-context/src/factories/wave-shaper-node-renderer-factory.ts", "../../standardized-audio-context/src/factories/window.ts", "../../standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods.ts", "../../standardized-audio-context/src/factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds.ts", "../../standardized-audio-context/src/factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer.ts", "../../standardized-audio-context/src/factories/wrap-channel-merger-node.ts", "../../standardized-audio-context/src/helpers/get-first-sample.ts", "../../standardized-audio-context/src/helpers/is-dc-curve.ts", "../../standardized-audio-context/src/helpers/overwrite-accessors.ts", "../../standardized-audio-context/src/helpers/sanitize-audio-worklet-node-options.ts", "../../standardized-audio-context/src/helpers/sanitize-channel-splitter-options.ts", "../../standardized-audio-context/src/helpers/sanitize-periodic-wave-options.ts", "../../standardized-audio-context/src/helpers/set-value-at-time-until-possible.ts", "../../standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support.ts", "../../standardized-audio-context/src/helpers/test-audio-buffer-source-node-start-method-offset-clamping-support.ts", "../../standardized-audio-context/src/helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support.ts", "../../standardized-audio-context/src/helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support.ts", "../../standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support.ts", "../../standardized-audio-context/src/helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support.ts", "../../standardized-audio-context/src/helpers/test-audio-worklet-node-options-clonability.ts", "../../standardized-audio-context/src/helpers/test-dom-exception-constructor-support.ts", "../../standardized-audio-context/src/helpers/test-transferables-support.ts", "../../standardized-audio-context/src/helpers/wrap-audio-buffer-source-node-start-method-offset-clamping.ts", "../../standardized-audio-context/src/helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts", "../../standardized-audio-context/src/helpers/wrap-event-listener.ts", "../../standardized-audio-context/src/module.ts", "../../tone/Tone/core/util/Debug.ts", "../../tone/Tone/core/util/TypeCheck.ts", "../../tone/Tone/core/context/AudioContext.ts", "../../tone/Tone/core/clock/Ticker.ts", "../../tone/Tone/core/util/AdvancedTypeCheck.ts", "../../tone/Tone/core/util/Defaults.ts", "../../tone/Tone/core/Tone.ts", "../../tone/Tone/core/util/Math.ts", "../../tone/Tone/core/util/Timeline.ts", "../../tone/Tone/core/context/ContextInitialization.ts", "../../tone/Tone/core/util/Emitter.ts", "../../tone/Tone/core/context/BaseContext.ts", "../../tone/Tone/core/context/Context.ts", "../../tone/Tone/core/context/DummyContext.ts", "../../tone/Tone/core/util/Interface.ts", "../../tone/Tone/core/context/ToneAudioBuffer.ts", "../../tone/Tone/core/context/OfflineContext.ts", "../../tone/Tone/core/Global.ts", "../../tone/Tone/core/type/Conversions.ts", "../../tone/Tone/core/type/TimeBase.ts", "../../tone/Tone/core/type/Time.ts", "../../tone/Tone/core/type/Frequency.ts", "../../tone/Tone/core/type/TransportTime.ts", "../../tone/Tone/core/context/ToneWithContext.ts", "../../tone/Tone/core/util/StateTimeline.ts", "../../tone/Tone/core/context/Param.ts", "../../tone/Tone/core/context/ToneAudioNode.ts", "../../tone/Tone/core/context/Gain.ts", "../../tone/Tone/source/OneShotSource.ts", "../../tone/Tone/signal/ToneConstantSource.ts", "../../tone/Tone/signal/Signal.ts", "../../tone/Tone/core/clock/TickParam.ts", "../../tone/Tone/core/clock/TickSignal.ts", "../../tone/Tone/core/clock/TickSource.ts", "../../tone/Tone/core/clock/Clock.ts", "../../tone/Tone/core/context/Delay.ts", "../../tone/Tone/core/context/Offline.ts", "../../tone/Tone/core/context/ToneAudioBuffers.ts", "../../tone/Tone/core/type/Midi.ts", "../../tone/Tone/core/type/Ticks.ts", "../../tone/Tone/core/util/Draw.ts", "../../tone/Tone/core/util/IntervalTimeline.ts", "../../tone/Tone/core/type/Units.ts", "../../tone/Tone/component/channel/Volume.ts", "../../tone/Tone/core/context/Destination.ts", "../../tone/Tone/core/util/TimelineValue.ts", "../../tone/Tone/core/clock/TransportEvent.ts", "../../tone/Tone/core/clock/TransportRepeatEvent.ts", "../../tone/Tone/core/clock/Transport.ts", "../../tone/Tone/source/Source.ts", "../../tone/Tone/source/buffer/ToneBufferSource.ts", "../../tone/Tone/source/Noise.ts", "../../tone/Tone/source/UserMedia.ts", "../../tone/Tone/source/oscillator/OscillatorInterface.ts", "../../tone/Tone/source/oscillator/ToneOscillatorNode.ts", "../../tone/Tone/source/oscillator/Oscillator.ts", "../../tone/Tone/signal/SignalOperator.ts", "../../tone/Tone/signal/WaveShaper.ts", "../../tone/Tone/signal/AudioToGain.ts", "../../tone/Tone/signal/Multiply.ts", "../../tone/Tone/source/oscillator/AMOscillator.ts", "../../tone/Tone/source/oscillator/FMOscillator.ts", "../../tone/Tone/source/oscillator/PulseOscillator.ts", "../../tone/Tone/source/oscillator/FatOscillator.ts", "../../tone/Tone/source/oscillator/PWMOscillator.ts", "../../tone/Tone/source/oscillator/OmniOscillator.ts", "../../tone/Tone/signal/Add.ts", "../../tone/Tone/signal/Scale.ts", "../../tone/Tone/signal/Zero.ts", "../../tone/Tone/source/oscillator/LFO.ts", "../../tone/Tone/core/util/Decorator.ts", "../../tone/Tone/source/buffer/Player.ts", "../../tone/Tone/source/buffer/Players.ts", "../../tone/Tone/source/buffer/GrainPlayer.ts", "../../tone/Tone/signal/Abs.ts", "../../tone/Tone/signal/GainToAudio.ts", "../../tone/Tone/signal/Negate.ts", "../../tone/Tone/signal/Subtract.ts", "../../tone/Tone/signal/GreaterThanZero.ts", "../../tone/Tone/signal/GreaterThan.ts", "../../tone/Tone/signal/Pow.ts", "../../tone/Tone/signal/ScaleExp.ts", "../../tone/Tone/signal/SyncedSignal.ts", "../../tone/Tone/component/envelope/Envelope.ts", "../../tone/Tone/instrument/Instrument.ts", "../../tone/Tone/instrument/Monophonic.ts", "../../tone/Tone/component/envelope/AmplitudeEnvelope.ts", "../../tone/Tone/instrument/Synth.ts", "../../tone/Tone/instrument/ModulationSynth.ts", "../../tone/Tone/instrument/AMSynth.ts", "../../tone/Tone/component/filter/BiquadFilter.ts", "../../tone/Tone/component/filter/Filter.ts", "../../tone/Tone/component/envelope/FrequencyEnvelope.ts", "../../tone/Tone/instrument/MonoSynth.ts", "../../tone/Tone/instrument/DuoSynth.ts", "../../tone/Tone/instrument/FMSynth.ts", "../../tone/Tone/instrument/MetalSynth.ts", "../../tone/Tone/instrument/MembraneSynth.ts", "../../tone/Tone/instrument/NoiseSynth.ts", "../../tone/Tone/core/worklet/WorkletGlobalScope.ts", "../../tone/Tone/core/worklet/ToneAudioWorklet.ts", "../../tone/Tone/core/worklet/ToneAudioWorkletProcessor.worklet.ts", "../../tone/Tone/core/worklet/SingleIOProcessor.worklet.ts", "../../tone/Tone/core/worklet/DelayLine.worklet.ts", "../../tone/Tone/component/filter/FeedbackCombFilter.worklet.ts", "../../tone/Tone/component/filter/FeedbackCombFilter.ts", "../../tone/Tone/component/filter/OnePoleFilter.ts", "../../tone/Tone/component/filter/LowpassCombFilter.ts", "../../tone/Tone/instrument/PluckSynth.ts", "../../tone/Tone/instrument/PolySynth.ts", "../../tone/Tone/instrument/Sampler.ts", "../../tone/Tone/event/ToneEvent.ts", "../../tone/Tone/event/Loop.ts", "../../tone/Tone/event/Part.ts", "../../tone/Tone/event/PatternGenerator.ts", "../../tone/Tone/event/Pattern.ts", "../../tone/Tone/event/Sequence.ts", "../../tone/Tone/component/channel/CrossFade.ts", "../../tone/Tone/effect/Effect.ts", "../../tone/Tone/effect/LFOEffect.ts", "../../tone/Tone/effect/AutoFilter.ts", "../../tone/Tone/component/channel/Panner.ts", "../../tone/Tone/effect/AutoPanner.ts", "../../tone/Tone/component/analysis/Follower.ts", "../../tone/Tone/effect/AutoWah.ts", "../../tone/Tone/effect/BitCrusher.worklet.ts", "../../tone/Tone/effect/BitCrusher.ts", "../../tone/Tone/effect/Chebyshev.ts", "../../tone/Tone/component/channel/Split.ts", "../../tone/Tone/component/channel/Merge.ts", "../../tone/Tone/effect/StereoEffect.ts", "../../tone/Tone/effect/StereoFeedbackEffect.ts", "../../tone/Tone/effect/Chorus.ts", "../../tone/Tone/effect/Distortion.ts", "../../tone/Tone/effect/FeedbackEffect.ts", "../../tone/Tone/effect/FeedbackDelay.ts", "../../tone/Tone/component/filter/PhaseShiftAllpass.ts", "../../tone/Tone/effect/FrequencyShifter.ts", "../../tone/Tone/effect/Freeverb.ts", "../../tone/Tone/effect/JCReverb.ts", "../../tone/Tone/effect/StereoXFeedbackEffect.ts", "../../tone/Tone/effect/PingPongDelay.ts", "../../tone/Tone/effect/PitchShift.ts", "../../tone/Tone/effect/Phaser.ts", "../../tone/Tone/effect/Reverb.ts", "../../tone/Tone/component/channel/MidSideSplit.ts", "../../tone/Tone/component/channel/MidSideMerge.ts", "../../tone/Tone/effect/MidSideEffect.ts", "../../tone/Tone/effect/StereoWidener.ts", "../../tone/Tone/effect/Tremolo.ts", "../../tone/Tone/effect/Vibrato.ts", "../../tone/Tone/component/analysis/Analyser.ts", "../../tone/Tone/component/analysis/MeterBase.ts", "../../tone/Tone/component/analysis/Meter.ts", "../../tone/Tone/component/analysis/FFT.ts", "../../tone/Tone/component/analysis/DCMeter.ts", "../../tone/Tone/component/analysis/Waveform.ts", "../../tone/Tone/component/channel/Solo.ts", "../../tone/Tone/component/channel/PanVol.ts", "../../tone/Tone/component/channel/Channel.ts", "../../tone/Tone/component/channel/Mono.ts", "../../tone/Tone/component/channel/MultibandSplit.ts", "../../tone/Tone/core/context/Listener.ts", "../../tone/Tone/component/channel/Panner3D.ts", "../../tone/Tone/component/channel/Recorder.ts", "../../tone/Tone/component/dynamics/Compressor.ts", "../../tone/Tone/component/dynamics/Gate.ts", "../../tone/Tone/component/dynamics/Limiter.ts", "../../tone/Tone/component/dynamics/MidSideCompressor.ts", "../../tone/Tone/component/dynamics/MultibandCompressor.ts", "../../tone/Tone/component/filter/EQ3.ts", "../../tone/Tone/component/filter/Convolver.ts", "../../tone/Tone/index.ts"],
  "sourcesContent": ["export const version: string = \"14.7.77\";\n", "import { IExtendedExponentialRampToValueAutomationEvent } from '../interfaces';\n\nexport const createExtendedExponentialRampToValueAutomationEvent = (\n    value: number,\n    endTime: number,\n    insertTime: number\n): IExtendedExponentialRampToValueAutomationEvent => {\n    return { endTime, insertTime, type: 'exponentialRampToValue', value };\n};\n", "import { IExtendedLinearRampToValueAutomationEvent } from '../interfaces';\n\nexport const createExtendedLinearRampToValueAutomationEvent = (\n    value: number,\n    endTime: number,\n    insertTime: number\n): IExtendedLinearRampToValueAutomationEvent => {\n    return { endTime, insertTime, type: 'linearRampToValue', value };\n};\n", "import { ISetValueAutomationEvent } from '../interfaces';\n\nexport const createSetValueAutomationEvent = (value: number, startTime: number): ISetValueAutomationEvent => {\n    return { startTime, type: 'setValue', value };\n};\n", "import { ISetValueCurveAutomationEvent } from '../interfaces';\n\nexport const createSetValueCurveAutomationEvent = (\n    values: Float32Array,\n    startTime: number,\n    duration: number\n): ISetValueCurveAutomationEvent => {\n    return { duration, startTime, type: 'setValueCurve', values };\n};\n", "import { ISetTargetAutomationEvent } from '../interfaces';\n\nexport const getTargetValueAtTime = (\n    time: number,\n    valueAtStartTime: number,\n    { startTime, target, timeConstant }: ISetTargetAutomationEvent\n): number => {\n    return target + (valueAtStartTime - target) * Math.exp((startTime - time) / timeConstant);\n};\n", "import { IExponentialRampToValueAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isExponentialRampToValueAutomationEvent = (\n    automationEvent: TAutomationEvent\n): automationEvent is IExponentialRampToValueAutomationEvent => {\n    return automationEvent.type === 'exponentialRampToValue';\n};\n", "import { ILinearRampToValueAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isLinearRampToValueAutomationEvent = (\n    automationEvent: TAutomationEvent\n): automationEvent is ILinearRampToValueAutomationEvent => {\n    return automationEvent.type === 'linearRampToValue';\n};\n", "import { IExponentialRampToValueAutomationEvent, ILinearRampToValueAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\nimport { isExponentialRampToValueAutomationEvent } from './exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from './linear-ramp-to-value-automation-event';\n\nexport const isAnyRampToValueAutomationEvent = (\n    automationEvent: TAutomationEvent\n): automationEvent is IExponentialRampToValueAutomationEvent | ILinearRampToValueAutomationEvent => {\n    return isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent);\n};\n", "import { ISetValueAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isSetValueAutomationEvent = (automationEvent: TAutomationEvent): automationEvent is ISetValueAutomationEvent => {\n    return automationEvent.type === 'setValue';\n};\n", "import { ISetValueCurveAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isSetValueCurveAutomationEvent = (automationEvent: TAutomationEvent): automationEvent is ISetValueCurveAutomationEvent => {\n    return automationEvent.type === 'setValueCurve';\n};\n", "import { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nimport { TPersistentAutomationEvent } from '../types';\n\nexport const getValueOfAutomationEventAtIndexAtTime = (\n    automationEvents: TPersistentAutomationEvent[],\n    index: number,\n    time: number,\n    defaultValue: number\n): number => {\n    const automationEvent = automationEvents[index];\n\n    return automationEvent === undefined\n        ? defaultValue\n        : isAnyRampToValueAutomationEvent(automationEvent) || isSetValueAutomationEvent(automationEvent)\n        ? automationEvent.value\n        : isSetValueCurveAutomationEvent(automationEvent)\n        ? automationEvent.values[automationEvent.values.length - 1]\n        : getTargetValueAtTime(\n              time,\n              getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, automationEvent.startTime, defaultValue),\n              automationEvent\n          );\n};\n", "import { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nimport { IExtendedExponentialRampToValueAutomationEvent, IExtendedLinearRampToValueAutomationEvent } from '../interfaces';\nimport { TPersistentAutomationEvent } from '../types';\n\nexport const getEndTimeAndValueOfPreviousAutomationEvent = (\n    automationEvents: TPersistentAutomationEvent[],\n    index: number,\n    currentAutomationEvent: TPersistentAutomationEvent,\n    nextAutomationEvent: IExtendedExponentialRampToValueAutomationEvent | IExtendedLinearRampToValueAutomationEvent,\n    defaultValue: number\n): [number, number] => {\n    return currentAutomationEvent === undefined\n        ? [nextAutomationEvent.insertTime, defaultValue]\n        : isAnyRampToValueAutomationEvent(currentAutomationEvent)\n        ? [currentAutomationEvent.endTime, currentAutomationEvent.value]\n        : isSetValueAutomationEvent(currentAutomationEvent)\n        ? [currentAutomationEvent.startTime, currentAutomationEvent.value]\n        : isSetValueCurveAutomationEvent(currentAutomationEvent)\n        ? [\n              currentAutomationEvent.startTime + currentAutomationEvent.duration,\n              currentAutomationEvent.values[currentAutomationEvent.values.length - 1]\n          ]\n        : [\n              currentAutomationEvent.startTime,\n              getValueOfAutomationEventAtIndexAtTime(automationEvents, index - 1, currentAutomationEvent.startTime, defaultValue)\n          ];\n};\n", "import { ICancelAndHoldAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isCancelAndHoldAutomationEvent = (automationEvent: TAutomationEvent): automationEvent is ICancelAndHoldAutomationEvent => {\n    return automationEvent.type === 'cancelAndHold';\n};\n", "import { ICancelScheduledValuesAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isCancelScheduledValuesAutomationEvent = (\n    automationEvent: TAutomationEvent\n): automationEvent is ICancelScheduledValuesAutomationEvent => {\n    return automationEvent.type === 'cancelScheduledValues';\n};\n", "import { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nimport { TAutomationEvent } from '../types';\n\nexport const getEventTime = (automationEvent: TAutomationEvent): number => {\n    if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n        return automationEvent.cancelTime;\n    }\n\n    if (isExponentialRampToValueAutomationEvent(automationEvent) || isLinearRampToValueAutomationEvent(automationEvent)) {\n        return automationEvent.endTime;\n    }\n\n    return automationEvent.startTime;\n};\n", "import { IExponentialRampToValueAutomationEvent } from '../interfaces';\n\nexport const getExponentialRampValueAtTime = (\n    time: number,\n    startTime: number,\n    valueAtStartTime: number,\n    { endTime, value }: IExponentialRampToValueAutomationEvent\n) => {\n    if (valueAtStartTime === value) {\n        return value;\n    }\n\n    if ((0 < valueAtStartTime && 0 < value) || (valueAtStartTime < 0 && value < 0)) {\n        return valueAtStartTime * (value / valueAtStartTime) ** ((time - startTime) / (endTime - startTime));\n    }\n\n    return 0;\n};\n", "import { ILinearRampToValueAutomationEvent } from '../interfaces';\n\nexport const getLinearRampValueAtTime = (\n    time: number,\n    startTime: number,\n    valueAtStartTime: number,\n    { endTime, value }: ILinearRampToValueAutomationEvent\n) => {\n    return valueAtStartTime + ((time - startTime) / (endTime - startTime)) * (value - valueAtStartTime);\n};\n", "export const interpolateValue = (values: Float32Array, theoreticIndex: number) => {\n    const lowerIndex = Math.floor(theoreticIndex);\n    const upperIndex = Math.ceil(theoreticIndex);\n\n    if (lowerIndex === upperIndex) {\n        return values[lowerIndex];\n    }\n\n    return (1 - (theoreticIndex - lowerIndex)) * values[lowerIndex] + (1 - (upperIndex - theoreticIndex)) * values[upperIndex];\n};\n", "import { ISetValueCurveAutomationEvent } from '../interfaces';\nimport { interpolateValue } from './interpolate-value';\n\nexport const getValueCurveValueAtTime = (time: number, { duration, startTime, values }: ISetValueCurveAutomationEvent): number => {\n    const theoreticIndex = ((time - startTime) / duration) * (values.length - 1);\n\n    return interpolateValue(values, theoreticIndex);\n};\n", "import { ISetTargetAutomationEvent } from '../interfaces';\nimport { TAutomationEvent } from '../types';\n\nexport const isSetTargetAutomationEvent = (automationEvent: TAutomationEvent): automationEvent is ISetTargetAutomationEvent => {\n    return automationEvent.type === 'setTarget';\n};\n", "import { createExtendedExponentialRampToValueAutomationEvent } from '../functions/create-extended-exponential-ramp-to-value-automation-event';\nimport { createExtendedLinearRampToValueAutomationEvent } from '../functions/create-extended-linear-ramp-to-value-automation-event';\nimport { createSetValueAutomationEvent } from '../functions/create-set-value-automation-event';\nimport { createSetValueCurveAutomationEvent } from '../functions/create-set-value-curve-automation-event';\nimport { getEndTimeAndValueOfPreviousAutomationEvent } from '../functions/get-end-time-and-value-of-previous-automation-event';\nimport { getEventTime } from '../functions/get-event-time';\nimport { getExponentialRampValueAtTime } from '../functions/get-exponential-ramp-value-at-time';\nimport { getLinearRampValueAtTime } from '../functions/get-linear-ramp-value-at-time';\nimport { getTargetValueAtTime } from '../functions/get-target-value-at-time';\nimport { getValueCurveValueAtTime } from '../functions/get-value-curve-value-at-time';\nimport { getValueOfAutomationEventAtIndexAtTime } from '../functions/get-value-of-automation-event-at-index-at-time';\nimport { isAnyRampToValueAutomationEvent } from '../guards/any-ramp-to-value-automation-event';\nimport { isCancelAndHoldAutomationEvent } from '../guards/cancel-and-hold-automation-event';\nimport { isCancelScheduledValuesAutomationEvent } from '../guards/cancel-scheduled-values-automation-event';\nimport { isExponentialRampToValueAutomationEvent } from '../guards/exponential-ramp-to-value-automation-event';\nimport { isLinearRampToValueAutomationEvent } from '../guards/linear-ramp-to-value-automation-event';\nimport { isSetTargetAutomationEvent } from '../guards/set-target-automation-event';\nimport { isSetValueAutomationEvent } from '../guards/set-value-automation-event';\nimport { isSetValueCurveAutomationEvent } from '../guards/set-value-curve-automation-event';\nimport { TAutomationEvent, TPersistentAutomationEvent } from '../types';\n\nexport class AutomationEventList {\n    private _automationEvents: TPersistentAutomationEvent[];\n\n    private _currenTime: number;\n\n    private _defaultValue: number;\n\n    constructor(defaultValue: number) {\n        this._automationEvents = [];\n        this._currenTime = 0;\n        this._defaultValue = defaultValue;\n    }\n\n    public [Symbol.iterator](): Iterator<TPersistentAutomationEvent> {\n        return this._automationEvents[Symbol.iterator]();\n    }\n\n    public add(automationEvent: TAutomationEvent): boolean {\n        const eventTime = getEventTime(automationEvent);\n\n        if (isCancelAndHoldAutomationEvent(automationEvent) || isCancelScheduledValuesAutomationEvent(automationEvent)) {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => {\n                if (isCancelScheduledValuesAutomationEvent(automationEvent) && isSetValueCurveAutomationEvent(currentAutomationEvent)) {\n                    return currentAutomationEvent.startTime + currentAutomationEvent.duration >= eventTime;\n                }\n\n                return getEventTime(currentAutomationEvent) >= eventTime;\n            });\n            const removedAutomationEvent = this._automationEvents[index];\n\n            if (index !== -1) {\n                this._automationEvents = this._automationEvents.slice(0, index);\n            }\n\n            if (isCancelAndHoldAutomationEvent(automationEvent)) {\n                const lastAutomationEvent = this._automationEvents[this._automationEvents.length - 1];\n\n                if (removedAutomationEvent !== undefined && isAnyRampToValueAutomationEvent(removedAutomationEvent)) {\n                    if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                        throw new Error('The internal list is malformed.');\n                    }\n\n                    const startTime =\n                        lastAutomationEvent === undefined\n                            ? removedAutomationEvent.insertTime\n                            : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.startTime + lastAutomationEvent.duration\n                            : getEventTime(lastAutomationEvent);\n                    const startValue =\n                        lastAutomationEvent === undefined\n                            ? this._defaultValue\n                            : isSetValueCurveAutomationEvent(lastAutomationEvent)\n                            ? lastAutomationEvent.values[lastAutomationEvent.values.length - 1]\n                            : lastAutomationEvent.value;\n                    const value = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? getExponentialRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent)\n                        : getLinearRampValueAtTime(eventTime, startTime, startValue, removedAutomationEvent);\n                    const truncatedAutomationEvent = isExponentialRampToValueAutomationEvent(removedAutomationEvent)\n                        ? createExtendedExponentialRampToValueAutomationEvent(value, eventTime, this._currenTime)\n                        : createExtendedLinearRampToValueAutomationEvent(value, eventTime, this._currenTime);\n\n                    this._automationEvents.push(truncatedAutomationEvent);\n                }\n\n                if (lastAutomationEvent !== undefined && isSetTargetAutomationEvent(lastAutomationEvent)) {\n                    this._automationEvents.push(createSetValueAutomationEvent(this.getValue(eventTime), eventTime));\n                }\n\n                if (\n                    lastAutomationEvent !== undefined &&\n                    isSetValueCurveAutomationEvent(lastAutomationEvent) &&\n                    lastAutomationEvent.startTime + lastAutomationEvent.duration > eventTime\n                ) {\n                    const duration = eventTime - lastAutomationEvent.startTime;\n                    const ratio = (lastAutomationEvent.values.length - 1) / lastAutomationEvent.duration;\n                    const length = Math.max(2, 1 + Math.ceil(duration * ratio));\n                    const fraction = (duration / (length - 1)) * ratio;\n                    const values = lastAutomationEvent.values.slice(0, length);\n\n                    if (fraction < 1) {\n                        for (let i = 1; i < length; i += 1) {\n                            const factor = (fraction * i) % 1;\n\n                            values[i] = lastAutomationEvent.values[i - 1] * (1 - factor) + lastAutomationEvent.values[i] * factor;\n                        }\n                    }\n\n                    this._automationEvents[this._automationEvents.length - 1] = createSetValueCurveAutomationEvent(\n                        values,\n                        lastAutomationEvent.startTime,\n                        duration\n                    );\n                }\n            }\n        } else {\n            const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > eventTime);\n\n            const previousAutomationEvent =\n                index === -1 ? this._automationEvents[this._automationEvents.length - 1] : this._automationEvents[index - 1];\n\n            if (\n                previousAutomationEvent !== undefined &&\n                isSetValueCurveAutomationEvent(previousAutomationEvent) &&\n                getEventTime(previousAutomationEvent) + previousAutomationEvent.duration > eventTime\n            ) {\n                return false;\n            }\n\n            const persistentAutomationEvent = isExponentialRampToValueAutomationEvent(automationEvent)\n                ? createExtendedExponentialRampToValueAutomationEvent(automationEvent.value, automationEvent.endTime, this._currenTime)\n                : isLinearRampToValueAutomationEvent(automationEvent)\n                ? createExtendedLinearRampToValueAutomationEvent(automationEvent.value, eventTime, this._currenTime)\n                : automationEvent;\n\n            if (index === -1) {\n                this._automationEvents.push(persistentAutomationEvent);\n            } else {\n                if (\n                    isSetValueCurveAutomationEvent(automationEvent) &&\n                    eventTime + automationEvent.duration > getEventTime(this._automationEvents[index])\n                ) {\n                    return false;\n                }\n\n                this._automationEvents.splice(index, 0, persistentAutomationEvent);\n            }\n        }\n\n        return true;\n    }\n\n    public flush(time: number): void {\n        const index = this._automationEvents.findIndex((currentAutomationEvent) => getEventTime(currentAutomationEvent) > time);\n\n        if (index > 1) {\n            const remainingAutomationEvents = this._automationEvents.slice(index - 1);\n            const firstRemainingAutomationEvent = remainingAutomationEvents[0];\n\n            if (isSetTargetAutomationEvent(firstRemainingAutomationEvent)) {\n                remainingAutomationEvents.unshift(\n                    createSetValueAutomationEvent(\n                        getValueOfAutomationEventAtIndexAtTime(\n                            this._automationEvents,\n                            index - 2,\n                            firstRemainingAutomationEvent.startTime,\n                            this._defaultValue\n                        ),\n                        firstRemainingAutomationEvent.startTime\n                    )\n                );\n            }\n\n            this._automationEvents = remainingAutomationEvents;\n        }\n    }\n\n    public getValue(time: number): number {\n        if (this._automationEvents.length === 0) {\n            return this._defaultValue;\n        }\n\n        const indexOfNextEvent = this._automationEvents.findIndex((automationEvent) => getEventTime(automationEvent) > time);\n        const nextAutomationEvent = this._automationEvents[indexOfNextEvent];\n        const indexOfCurrentEvent = (indexOfNextEvent === -1 ? this._automationEvents.length : indexOfNextEvent) - 1;\n        const currentAutomationEvent = this._automationEvents[indexOfCurrentEvent];\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isSetTargetAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                nextAutomationEvent.insertTime > time)\n        ) {\n            return getTargetValueAtTime(\n                time,\n                getValueOfAutomationEventAtIndexAtTime(\n                    this._automationEvents,\n                    indexOfCurrentEvent - 1,\n                    currentAutomationEvent.startTime,\n                    this._defaultValue\n                ),\n                currentAutomationEvent\n            );\n        }\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isSetValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))\n        ) {\n            return currentAutomationEvent.value;\n        }\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isSetValueCurveAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined ||\n                !isAnyRampToValueAutomationEvent(nextAutomationEvent) ||\n                currentAutomationEvent.startTime + currentAutomationEvent.duration > time)\n        ) {\n            if (time < currentAutomationEvent.startTime + currentAutomationEvent.duration) {\n                return getValueCurveValueAtTime(time, currentAutomationEvent);\n            }\n\n            return currentAutomationEvent.values[currentAutomationEvent.values.length - 1];\n        }\n\n        if (\n            currentAutomationEvent !== undefined &&\n            isAnyRampToValueAutomationEvent(currentAutomationEvent) &&\n            (nextAutomationEvent === undefined || !isAnyRampToValueAutomationEvent(nextAutomationEvent))\n        ) {\n            return currentAutomationEvent.value;\n        }\n\n        if (nextAutomationEvent !== undefined && isExponentialRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(\n                this._automationEvents,\n                indexOfCurrentEvent,\n                currentAutomationEvent,\n                nextAutomationEvent,\n                this._defaultValue\n            );\n\n            return getExponentialRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n\n        if (nextAutomationEvent !== undefined && isLinearRampToValueAutomationEvent(nextAutomationEvent)) {\n            const [startTime, value] = getEndTimeAndValueOfPreviousAutomationEvent(\n                this._automationEvents,\n                indexOfCurrentEvent,\n                currentAutomationEvent,\n                nextAutomationEvent,\n                this._defaultValue\n            );\n\n            return getLinearRampValueAtTime(time, startTime, value, nextAutomationEvent);\n        }\n\n        return this._defaultValue;\n    }\n}\n", "import { ICancelAndHoldAutomationEvent } from '../interfaces';\n\nexport const createCancelAndHoldAutomationEvent = (cancelTime: number): ICancelAndHoldAutomationEvent => {\n    return { cancelTime, type: 'cancelAndHold' };\n};\n", "import { ICancelScheduledValuesAutomationEvent } from '../interfaces';\n\nexport const createCancelScheduledValuesAutomationEvent = (cancelTime: number): ICancelScheduledValuesAutomationEvent => {\n    return { cancelTime, type: 'cancelScheduledValues' };\n};\n", "import { IExponentialRampToValueAutomationEvent } from '../interfaces';\n\nexport const createExponentialRampToValueAutomationEvent = (value: number, endTime: number): IExponentialRampToValueAutomationEvent => {\n    return { endTime, type: 'exponentialRampToValue', value };\n};\n", "import { ILinearRampToValueAutomationEvent } from '../interfaces';\n\nexport const createLinearRampToValueAutomationEvent = (value: number, endTime: number): ILinearRampToValueAutomationEvent => {\n    return { endTime, type: 'linearRampToValue', value };\n};\n", "import { ISetTargetAutomationEvent } from '../interfaces';\n\nexport const createSetTargetAutomationEvent = (target: number, startTime: number, timeConstant: number): ISetTargetAutomationEvent => {\n    return { startTime, target, timeConstant, type: 'setTarget' };\n};\n", "import { TAbortErrorFactory } from '../types';\n\nexport const createAbortError: TAbortErrorFactory = () => new DOMException('', 'AbortError');\n", "import { TAddActiveInputConnectionToAudioNodeFactory } from '../types/add-active-input-connection-to-audio-node-factory';\n\nexport const createAddActiveInputConnectionToAudioNode: TAddActiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (activeInputs, source, [output, input, eventListener], ignoreDuplicates) => {\n        insertElementInSet(\n            activeInputs[input],\n            [source, output, eventListener],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n            ignoreDuplicates\n        );\n    };\n};\n", "import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TActiveInputConnection, TAddAudioNodeConnectionsFactory, TContext, TNativeAudioNode } from '../types';\n\nexport const createAddAudioNodeConnections: TAddAudioNodeConnectionsFactory = (audioNodeConnectionsStore) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null,\n        nativeAudioNode: TNativeAudioNode\n    ) => {\n        const activeInputs = [];\n\n        for (let i = 0; i < nativeAudioNode.numberOfInputs; i += 1) {\n            activeInputs.push(new Set<TActiveInputConnection<T>>());\n        }\n\n        audioNodeConnectionsStore.set(audioNode, {\n            activeInputs,\n            outputs: new Set(),\n            passiveInputs: new WeakMap(),\n            renderer: audioNodeRenderer\n        });\n    };\n};\n", "import { IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAddAudioParamConnectionsFactory, TContext } from '../types';\n\nexport const createAddAudioParamConnections: TAddAudioParamConnectionsFactory = (audioParamConnectionsStore) => {\n    return <T extends TContext>(\n        audioParam: IAudioParam,\n        audioParamRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null\n    ) => {\n        audioParamConnectionsStore.set(audioParam, { activeInputs: new Set(), passiveInputs: new WeakMap(), renderer: audioParamRenderer });\n    };\n};\n", "import { IAudioNode, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from './interfaces';\nimport {\n    TAudioNodeConnectionsStore,\n    TAudioNodeStore,\n    TAudioParamConnectionsStore,\n    TAudioParamStore,\n    TContext,\n    TContextStore,\n    TCycleCounters,\n    TInternalStateEventListener,\n    TNativeAudioWorkletNode,\n    TNativeContext\n} from './types';\n\nexport const ACTIVE_AUDIO_NODE_STORE: WeakSet<IAudioNode<TContext>> = new WeakSet();\n\nexport const AUDIO_NODE_CONNECTIONS_STORE: TAudioNodeConnectionsStore = new WeakMap();\n\nexport const AUDIO_NODE_STORE: TAudioNodeStore = new WeakMap();\n\nexport const AUDIO_PARAM_CONNECTIONS_STORE: TAudioParamConnectionsStore = new WeakMap();\n\nexport const AUDIO_PARAM_STORE: TAudioParamStore = new WeakMap();\n\nexport const CONTEXT_STORE: TContextStore = new WeakMap();\n\nexport const EVENT_LISTENERS: WeakMap<IAudioNode<TContext>, Set<TInternalStateEventListener>> = new WeakMap();\n\nexport const CYCLE_COUNTERS: TCycleCounters = new WeakMap();\n\n// This clunky name is borrowed from the spec. :-)\nexport const NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS: WeakMap<\n    TNativeContext,\n    Map<string, IAudioWorkletProcessorConstructor>\n> = new WeakMap();\n\nexport const NODE_TO_PROCESSOR_MAPS: WeakMap<\n    TNativeContext,\n    WeakMap<TNativeAudioWorkletNode, Promise<IAudioWorkletProcessor>>\n> = new WeakMap();\n", "import { TConstructor } from '../types';\n\nconst handler = {\n    construct(): any {\n        return handler;\n    }\n};\n\nexport const isConstructible = (constructible: TConstructor): boolean => {\n    try {\n        const proxy = new Proxy(constructible, handler);\n\n        new proxy(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "/*\n * This massive regex tries to cover all the following cases.\n *\n * import './path';\n * import defaultImport from './path';\n * import { namedImport } from './path';\n * import { namedImport as renamendImport } from './path';\n * import * as namespaceImport from './path';\n * import defaultImport, { namedImport } from './path';\n * import defaultImport, { namedImport as renamendImport } from './path';\n * import defaultImport, * as namespaceImport from './path';\n */\nconst IMPORT_STATEMENT_REGEX = /^import(?:(?:[\\s]+[\\w]+|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\{[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?(?:[\\s]*,[\\s]*[\\w]+(?:[\\s]+as[\\s]+[\\w]+)?)*[\\s]*}|(?:[\\s]+[\\w]+[\\s]*,)?[\\s]*\\*[\\s]+as[\\s]+[\\w]+)[\\s]+from)?(?:[\\s]*)(\"([^\"\\\\]|\\\\.)+\"|'([^'\\\\]|\\\\.)+')(?:[\\s]*);?/; // tslint:disable-line:max-line-length\n\nexport const splitImportStatements = (source: string, url: string): [string, string] => {\n    const importStatements = [];\n\n    let sourceWithoutImportStatements = source.replace(/^[\\s]+/, '');\n    let result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n\n    while (result !== null) {\n        const unresolvedUrl = result[1].slice(1, -1);\n\n        const importStatementWithResolvedUrl = result[0]\n            .replace(/([\\s]+)?;?$/, '')\n            .replace(unresolvedUrl, new URL(unresolvedUrl, url).toString());\n        importStatements.push(importStatementWithResolvedUrl);\n\n        sourceWithoutImportStatements = sourceWithoutImportStatements.slice(result[0].length).replace(/^[\\s]+/, '');\n        result = sourceWithoutImportStatements.match(IMPORT_STATEMENT_REGEX);\n    }\n\n    return [importStatements.join(';'), sourceWithoutImportStatements];\n};\n", "import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { isConstructible } from '../helpers/is-constructible';\nimport { splitImportStatements } from '../helpers/split-import-statements';\nimport { IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TAddAudioWorkletModuleFactory, TEvaluateAudioWorkletGlobalScopeFunction } from '../types';\n\nconst verifyParameterDescriptors = (parameterDescriptors: IAudioWorkletProcessorConstructor['parameterDescriptors']) => {\n    if (parameterDescriptors !== undefined && !Array.isArray(parameterDescriptors)) {\n        throw new TypeError('The parameterDescriptors property of given value for processorCtor is not an array.');\n    }\n};\n\nconst verifyProcessorCtor = <T extends IAudioWorkletProcessorConstructor>(processorCtor: T) => {\n    if (!isConstructible(processorCtor)) {\n        throw new TypeError('The given value for processorCtor should be a constructor.');\n    }\n\n    if (processorCtor.prototype === null || typeof processorCtor.prototype !== 'object') {\n        throw new TypeError('The given value for processorCtor should have a prototype.');\n    }\n};\n\nexport const createAddAudioWorkletModule: TAddAudioWorkletModuleFactory = (\n    cacheTestResult,\n    createNotSupportedError,\n    evaluateSource,\n    exposeCurrentFrameAndCurrentTime,\n    fetchSource,\n    getNativeContext,\n    getOrCreateBackupOfflineAudioContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    ongoingRequests,\n    resolvedRequests,\n    testAudioWorkletProcessorPostMessageSupport,\n    window\n) => {\n    let index = 0;\n\n    return (context, moduleURL, options = { credentials: 'omit' }) => {\n        const resolvedRequestsOfContext = resolvedRequests.get(context);\n\n        if (resolvedRequestsOfContext !== undefined && resolvedRequestsOfContext.has(moduleURL)) {\n            return Promise.resolve();\n        }\n\n        const ongoingRequestsOfContext = ongoingRequests.get(context);\n\n        if (ongoingRequestsOfContext !== undefined) {\n            const promiseOfOngoingRequest = ongoingRequestsOfContext.get(moduleURL);\n\n            if (promiseOfOngoingRequest !== undefined) {\n                return promiseOfOngoingRequest;\n            }\n        }\n\n        const nativeContext = getNativeContext(context);\n\n        // Bug #59: Safari does not implement the audioWorklet property.\n        const promise =\n            nativeContext.audioWorklet === undefined\n                ? fetchSource(moduleURL)\n                      .then(([source, absoluteUrl]) => {\n                          const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n\n                          /*\n                           * This is the unminified version of the code used below:\n                           *\n                           * ```js\n                           * ${ importStatements };\n                           * ((a, b) => {\n                           *     (a[b] = a[b] || [ ]).push(\n                           *         (AudioWorkletProcessor, global, registerProcessor, sampleRate, self, window) => {\n                           *             ${ sourceWithoutImportStatements }\n                           *         }\n                           *     );\n                           * })(window, '_AWGS');\n                           * ```\n                           */\n                          // tslint:disable-next-line:max-line-length\n                          const wrappedSource = `${importStatements};((a,b)=>{(a[b]=a[b]||[]).push((AudioWorkletProcessor,global,registerProcessor,sampleRate,self,window)=>{${sourceWithoutImportStatements}\n})})(window,'_AWGS')`;\n\n                          // @todo Evaluating the given source code is a possible security problem.\n                          return evaluateSource(wrappedSource);\n                      })\n                      .then(() => {\n                          const evaluateAudioWorkletGlobalScope = (<TEvaluateAudioWorkletGlobalScopeFunction[]>(<any>window)._AWGS).pop();\n\n                          if (evaluateAudioWorkletGlobalScope === undefined) {\n                              // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                              throw new SyntaxError();\n                          }\n\n                          exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                              evaluateAudioWorkletGlobalScope(\n                                  class AudioWorkletProcessor {},\n                                  undefined,\n                                  (name, processorCtor) => {\n                                      if (name.trim() === '') {\n                                          throw createNotSupportedError();\n                                      }\n\n                                      const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n\n                                      if (nodeNameToProcessorConstructorMap !== undefined) {\n                                          if (nodeNameToProcessorConstructorMap.has(name)) {\n                                              throw createNotSupportedError();\n                                          }\n\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          nodeNameToProcessorConstructorMap.set(name, processorCtor);\n                                      } else {\n                                          verifyProcessorCtor(processorCtor);\n                                          verifyParameterDescriptors(processorCtor.parameterDescriptors);\n\n                                          NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.set(nativeContext, new Map([[name, processorCtor]]));\n                                      }\n                                  },\n                                  nativeContext.sampleRate,\n                                  undefined,\n                                  undefined\n                              )\n                          );\n                      })\n                : Promise.all([\n                      fetchSource(moduleURL),\n                      Promise.resolve(\n                          cacheTestResult(testAudioWorkletProcessorPostMessageSupport, testAudioWorkletProcessorPostMessageSupport)\n                      )\n                  ]).then(([[source, absoluteUrl], isSupportingPostMessage]) => {\n                      const currentIndex = index + 1;\n\n                      index = currentIndex;\n\n                      const [importStatements, sourceWithoutImportStatements] = splitImportStatements(source, absoluteUrl);\n                      /*\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * This is the unminified version of the code used below.\n                       *\n                       * ```js\n                       * class extends AudioWorkletProcessor {\n                       *\n                       *     __buffers = new WeakSet();\n                       *\n                       *     constructor () {\n                       *         super();\n                       *\n                       *         this.port.postMessage = ((postMessage) => {\n                       *             return (message, transferables) => {\n                       *                 const filteredTransferables = (transferables)\n                       *                     ? transferables.filter((transferable) => !this.__buffers.has(transferable))\n                       *                     : transferables;\n                       *\n                       *                 return postMessage.call(this.port, message, filteredTransferables);\n                       *              };\n                       *         })(this.port.postMessage);\n                       *     }\n                       * }\n                       * ```\n                       */\n                      const patchedAudioWorkletProcessor = isSupportingPostMessage\n                          ? 'AudioWorkletProcessor'\n                          : 'class extends AudioWorkletProcessor {__b=new WeakSet();constructor(){super();(p=>p.postMessage=(q=>(m,t)=>q.call(p,m,t?t.filter(u=>!this.__b.has(u)):t))(p.postMessage))(this.port)}}';\n                      /*\n                       * Bug #170: Chrome and Edge do call process() with an array with empty channelData for each input if no input is connected.\n                       *\n                       * Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\n                       *\n                       * Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                       *\n                       * This is the unminified version of the code used below:\n                       *\n                       * ```js\n                       * `${ importStatements };\n                       * ((AudioWorkletProcessor, registerProcessor) => {${ sourceWithoutImportStatements }\n                       * })(\n                       *     ${ patchedAudioWorkletProcessor },\n                       *     (name, processorCtor) => registerProcessor(name, class extends processorCtor {\n                       *\n                       *         __collectBuffers = (array) => {\n                       *             array.forEach((element) => this.__buffers.add(element.buffer));\n                       *         };\n                       *\n                       *         process (inputs, outputs, parameters) {\n                       *             inputs.forEach(this.__collectBuffers);\n                       *             outputs.forEach(this.__collectBuffers);\n                       *             this.__collectBuffers(Object.values(parameters));\n                       *\n                       *             return super.process(\n                       *                 (inputs.map((input) => input.some((channelData) => channelData.length === 0)) ? [ ] : input),\n                       *                 outputs,\n                       *                 parameters\n                       *             );\n                       *         }\n                       *\n                       *     })\n                       * );\n                       *\n                       * registerProcessor(`__sac${currentIndex}`, class extends AudioWorkletProcessor{\n                       *\n                       *     process () {\n                       *         return false;\n                       *     }\n                       *\n                       * })`\n                       * ```\n                       */\n                      const memberDefinition = isSupportingPostMessage ? '' : '__c = (a) => a.forEach(e=>this.__b.add(e.buffer));';\n                      const bufferRegistration = isSupportingPostMessage\n                          ? ''\n                          : 'i.forEach(this.__c);o.forEach(this.__c);this.__c(Object.values(p));';\n                      const wrappedSource = `${importStatements};((AudioWorkletProcessor,registerProcessor)=>{${sourceWithoutImportStatements}\n})(${patchedAudioWorkletProcessor},(n,p)=>registerProcessor(n,class extends p{${memberDefinition}process(i,o,p){${bufferRegistration}return super.process(i.map(j=>j.some(k=>k.length===0)?[]:j),o,p)}}));registerProcessor('__sac${currentIndex}',class extends AudioWorkletProcessor{process(){return !1}})`;\n                      const blob = new Blob([wrappedSource], { type: 'application/javascript; charset=utf-8' });\n                      const url = URL.createObjectURL(blob);\n\n                      return nativeContext.audioWorklet\n                          .addModule(url, options)\n                          .then(() => {\n                              if (isNativeOfflineAudioContext(nativeContext)) {\n                                  return nativeContext;\n                              }\n\n                              // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n                              const backupOfflineAudioContext = getOrCreateBackupOfflineAudioContext(nativeContext);\n\n                              return backupOfflineAudioContext.audioWorklet.addModule(url, options).then(() => backupOfflineAudioContext);\n                          })\n                          .then((nativeContextOrBackupOfflineAudioContext) => {\n                              if (nativeAudioWorkletNodeConstructor === null) {\n                                  throw new SyntaxError();\n                              }\n\n                              try {\n                                  // Bug #190: Safari doesn't throw an error when loading an unparsable module.\n                                  new nativeAudioWorkletNodeConstructor(nativeContextOrBackupOfflineAudioContext, `__sac${currentIndex}`); // tslint:disable-line:no-unused-expression\n                              } catch {\n                                  throw new SyntaxError();\n                              }\n                          })\n                          .finally(() => URL.revokeObjectURL(url));\n                  });\n\n        if (ongoingRequestsOfContext === undefined) {\n            ongoingRequests.set(context, new Map([[moduleURL, promise]]));\n        } else {\n            ongoingRequestsOfContext.set(moduleURL, promise);\n        }\n\n        promise\n            .then(() => {\n                const updatedResolvedRequestsOfContext = resolvedRequests.get(context);\n\n                if (updatedResolvedRequestsOfContext === undefined) {\n                    resolvedRequests.set(context, new Set([moduleURL]));\n                } else {\n                    updatedResolvedRequestsOfContext.add(moduleURL);\n                }\n            })\n            .finally(() => {\n                const updatedOngoingRequestsOfContext = ongoingRequests.get(context);\n\n                if (updatedOngoingRequestsOfContext !== undefined) {\n                    updatedOngoingRequestsOfContext.delete(moduleURL);\n                }\n            });\n\n        return promise;\n    };\n};\n", "import { TGetValueForKeyFunction } from '../types';\n\nexport const getValueForKey: TGetValueForKeyFunction = (map, key) => {\n    const value = map.get(key);\n\n    if (value === undefined) {\n        throw new Error('A value with the given key could not be found.');\n    }\n\n    return value;\n};\n", "import { TPickElementFromSetFunction } from '../types';\n\nexport const pickElementFromSet: TPickElementFromSetFunction = (set, predicate) => {\n    const matchingElements = Array.from(set).filter(predicate);\n\n    if (matchingElements.length > 1) {\n        throw Error('More than one element was found.');\n    }\n\n    if (matchingElements.length === 0) {\n        throw Error('No element was found.');\n    }\n\n    const [matchingElement] = matchingElements;\n\n    set.delete(matchingElement);\n\n    return matchingElement;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioNodeInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioNode = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioNodeInputConnection>>,\n    source: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n", "import { EVENT_LISTENERS } from '../globals';\nimport { TGetEventListenersOfAudioNodeFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getEventListenersOfAudioNode: TGetEventListenersOfAudioNodeFunction = (audioNode) => {\n    return getValueForKey(EVENT_LISTENERS, audioNode);\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToActive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is already stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.add(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(true));\n};\n", "import { IAudioNode, IAudioWorkletNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioWorkletNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioWorkletNode<T> => {\n    return 'port' in audioNode;\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const setInternalStateToPassive = <T extends TContext>(audioNode: IAudioNode<T>) => {\n    if (!ACTIVE_AUDIO_NODE_STORE.has(audioNode)) {\n        throw new Error('The AudioNode is not stored.');\n    }\n\n    ACTIVE_AUDIO_NODE_STORE.delete(audioNode);\n\n    getEventListenersOfAudioNode(audioNode).forEach((eventListener) => eventListener(false));\n};\n", "import { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\n// Set the internalState of the audioNode to 'passive' if it is not an AudioWorkletNode and if it has no 'active' input connections.\nexport const setInternalStateToPassiveWhenNecessary = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    activeInputs: Set<TActiveInputConnection<T>>[]\n) => {\n    if (!isAudioWorkletNode(audioNode) && activeInputs.every((connections) => connections.size === 0)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n", "import { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { IAudioNode } from '../interfaces';\nimport { TAddConnectionToAudioNodeFactory, TContext, TInternalStateEventListener } from '../types';\n\nexport const createAddConnectionToAudioNode: TAddConnectionToAudioNodeFactory = (\n    addActiveInputConnectionToAudioNode,\n    addPassiveInputConnectionToAudioNode,\n    connectNativeAudioNodeToNativeAudioNode,\n    deleteActiveInputConnectionToAudioNode,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getAudioNodeTailTime,\n    getEventListenersOfAudioNode,\n    getNativeAudioNode,\n    insertElementInSet,\n    isActiveAudioNode,\n    isPartOfACycle,\n    isPassiveAudioNode\n) => {\n    const tailTimeTimeoutIds = new WeakMap<IAudioNode<TContext>, number>();\n\n    return (source, destination, output, input, isOffline) => {\n        const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n        const { outputs } = getAudioNodeConnections(source);\n        const eventListeners = getEventListenersOfAudioNode(source);\n\n        const eventListener: TInternalStateEventListener = (isActive) => {\n            const nativeDestinationAudioNode = getNativeAudioNode(destination);\n            const nativeSourceAudioNode = getNativeAudioNode(source);\n\n            if (isActive) {\n                const partialConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n                addActiveInputConnectionToAudioNode(activeInputs, source, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                if (isPassiveAudioNode(destination)) {\n                    setInternalStateToActive(destination);\n                }\n            } else {\n                const partialConnection = deleteActiveInputConnectionToAudioNode(activeInputs, source, output, input);\n\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, partialConnection, false);\n\n                if (!isOffline && !isPartOfACycle(source)) {\n                    disconnectNativeAudioNodeFromNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output, input);\n                }\n\n                const tailTime = getAudioNodeTailTime(destination);\n\n                if (tailTime === 0) {\n                    if (isActiveAudioNode(destination)) {\n                        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                    }\n                } else {\n                    const tailTimeTimeoutId = tailTimeTimeoutIds.get(destination);\n\n                    if (tailTimeTimeoutId !== undefined) {\n                        clearTimeout(tailTimeTimeoutId);\n                    }\n\n                    tailTimeTimeoutIds.set(\n                        destination,\n                        setTimeout(() => {\n                            if (isActiveAudioNode(destination)) {\n                                setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n                            }\n                        }, tailTime * 1000)\n                    );\n                }\n            }\n        };\n\n        if (\n            insertElementInSet(\n                outputs,\n                [destination, output, input],\n                (outputConnection) =>\n                    outputConnection[0] === destination && outputConnection[1] === output && outputConnection[2] === input,\n                true\n            )\n        ) {\n            eventListeners.add(eventListener);\n\n            if (isActiveAudioNode(source)) {\n                addActiveInputConnectionToAudioNode(activeInputs, source, [output, input, eventListener], true);\n            } else {\n                addPassiveInputConnectionToAudioNode(passiveInputs, input, [source, output, eventListener], true);\n            }\n\n            return true;\n        }\n\n        return false;\n    };\n};\n", "import { TAddPassiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createAddPassiveInputConnectionToAudioNode: TAddPassiveInputConnectionToAudioNodeFactory = (insertElementInSet) => {\n    return (passiveInputs, input, [source, output, eventListener], ignoreDuplicates) => {\n        const passiveInputConnections = passiveInputs.get(source);\n\n        if (passiveInputConnections === undefined) {\n            passiveInputs.set(source, new Set([[output, input, eventListener]]));\n        } else {\n            insertElementInSet(\n                passiveInputConnections,\n                [output, input, eventListener],\n                (passiveInputConnection) => passiveInputConnection[0] === output && passiveInputConnection[1] === input,\n                ignoreDuplicates\n            );\n        }\n    };\n};\n", "import { TAddSilentConnectionFactory } from '../types';\n\nexport const createAddSilentConnection: TAddSilentConnectionFactory = (createNativeGainNode) => {\n    return (nativeContext, nativeAudioScheduledSourceNode) => {\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        nativeAudioScheduledSourceNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n        const disconnect = () => {\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnect);\n            nativeAudioScheduledSourceNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n\n        nativeAudioScheduledSourceNode.addEventListener('ended', disconnect);\n    };\n};\n", "import { TAddUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createAddUnrenderedAudioWorkletNode: TAddUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).add(audioWorkletNode);\n    };\n};\n", "import { IAnalyserNode, IAnalyserOptions } from '../interfaces';\nimport { TAnalyserNodeConstructorFactory, TAudioNodeRenderer, TContext, TNativeAnalyserNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    fftSize: 2048,\n    maxDecibels: -30,\n    minDecibels: -100,\n    smoothingTimeConstant: 0.8\n} as const;\n\nexport const createAnalyserNodeConstructor: TAnalyserNodeConstructorFactory = (\n    audionNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class AnalyserNode<T extends TContext> extends audionNodeConstructor<T> implements IAnalyserNode<T> {\n        private _nativeAnalyserNode: TNativeAnalyserNode;\n\n        constructor(context: T, options?: Partial<IAnalyserOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAnalyserNode = createNativeAnalyserNode(nativeContext, mergedOptions);\n            const analyserNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createAnalyserNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAnalyserNode, analyserNodeRenderer);\n\n            this._nativeAnalyserNode = nativeAnalyserNode;\n        }\n\n        get fftSize(): number {\n            return this._nativeAnalyserNode.fftSize;\n        }\n\n        set fftSize(value) {\n            this._nativeAnalyserNode.fftSize = value;\n        }\n\n        get frequencyBinCount(): number {\n            return this._nativeAnalyserNode.frequencyBinCount;\n        }\n\n        get maxDecibels(): number {\n            return this._nativeAnalyserNode.maxDecibels;\n        }\n\n        set maxDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const maxDecibels = this._nativeAnalyserNode.maxDecibels;\n\n            this._nativeAnalyserNode.maxDecibels = value;\n\n            if (!(value > this._nativeAnalyserNode.minDecibels)) {\n                this._nativeAnalyserNode.maxDecibels = maxDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get minDecibels(): number {\n            return this._nativeAnalyserNode.minDecibels;\n        }\n\n        set minDecibels(value) {\n            // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n            const minDecibels = this._nativeAnalyserNode.minDecibels;\n\n            this._nativeAnalyserNode.minDecibels = value;\n\n            if (!(this._nativeAnalyserNode.maxDecibels > value)) {\n                this._nativeAnalyserNode.minDecibels = minDecibels;\n\n                throw createIndexSizeError();\n            }\n        }\n\n        get smoothingTimeConstant(): number {\n            return this._nativeAnalyserNode.smoothingTimeConstant;\n        }\n\n        set smoothingTimeConstant(value) {\n            this._nativeAnalyserNode.smoothingTimeConstant = value;\n        }\n\n        public getByteFrequencyData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteFrequencyData(array);\n        }\n\n        public getByteTimeDomainData(array: Uint8Array): void {\n            this._nativeAnalyserNode.getByteTimeDomainData(array);\n        }\n\n        public getFloatFrequencyData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatFrequencyData(array);\n        }\n\n        public getFloatTimeDomainData(array: Float32Array): void {\n            this._nativeAnalyserNode.getFloatTimeDomainData(array);\n        }\n    };\n};\n", "import { TNativeAudioNode, TNativeContext } from '../types';\n\nexport const isOwnedByContext = (nativeAudioNode: TNativeAudioNode, nativeContext: TNativeContext): boolean => {\n    return nativeAudioNode.context === nativeContext;\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAnalyserNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAnalyserNodeRendererFactoryFactory, TNativeAnalyserNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAnalyserNodeRendererFactory: TAnalyserNodeRendererFactoryFactory = (\n    createNativeAnalyserNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAnalyserNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAnalyserNode>();\n\n        const createAnalyserNode = async (proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAnalyserNode = getNativeAudioNode<T, TNativeAnalyserNode>(proxy);\n\n            // If the initially used nativeAnalyserNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAnalyserNodeIsOwnedByContext = isOwnedByContext(nativeAnalyserNode, nativeOfflineAudioContext);\n\n            if (!nativeAnalyserNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAnalyserNode.channelCount,\n                    channelCountMode: nativeAnalyserNode.channelCountMode,\n                    channelInterpretation: nativeAnalyserNode.channelInterpretation,\n                    fftSize: nativeAnalyserNode.fftSize,\n                    maxDecibels: nativeAnalyserNode.maxDecibels,\n                    minDecibels: nativeAnalyserNode.minDecibels,\n                    smoothingTimeConstant: nativeAnalyserNode.smoothingTimeConstant\n                };\n\n                nativeAnalyserNode = createNativeAnalyserNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAnalyserNodes.set(nativeOfflineAudioContext, nativeAnalyserNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAnalyserNode);\n\n            return nativeAnalyserNode;\n        };\n\n        return {\n            render(proxy: IAnalyserNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAnalyserNode> {\n                const renderedNativeAnalyserNode = renderedNativeAnalyserNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAnalyserNode !== undefined) {\n                    return Promise.resolve(renderedNativeAnalyserNode);\n                }\n\n                return createAnalyserNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TNativeAudioBuffer } from '../types';\n\nexport const testAudioBufferCopyChannelMethodsOutOfBoundsSupport = (nativeAudioBuffer: TNativeAudioBuffer): boolean => {\n    try {\n        nativeAudioBuffer.copyToChannel(new Float32Array(1), 0, -1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TIndexSizeErrorFactory } from '../types';\n\nexport const createIndexSizeError: TIndexSizeErrorFactory = () => new DOMException('', 'IndexSizeError');\n", "import { createIndexSizeError } from '../factories/index-size-error';\nimport { TNativeAudioBuffer } from '../types';\n\nexport const wrapAudioBufferGetChannelDataMethod = (audioBuffer: TNativeAudioBuffer): void => {\n    audioBuffer.getChannelData = ((getChannelData) => {\n        return (channel: number) => {\n            try {\n                return getChannelData.call(audioBuffer, channel);\n            } catch (err) {\n                if (err.code === 12) {\n                    throw createIndexSizeError();\n                }\n\n                throw err;\n            }\n        };\n    })(audioBuffer.getChannelData);\n};\n", "import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n", "export const MOST_NEGATIVE_SINGLE_FLOAT = -3.4028234663852886e38;\n\nexport const MOST_POSITIVE_SINGLE_FLOAT = -MOST_NEGATIVE_SINGLE_FLOAT;\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsActiveAudioNodeFunction } from '../types';\n\nexport const isActiveAudioNode: TIsActiveAudioNodeFunction = (audioNode) => ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioBufferSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioBufferSourceNodeRendererFactoryFactory, TNativeAudioBufferSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createAudioBufferSourceNodeRendererFactory: TAudioBufferSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioBufferSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode>();\n\n        let start: null | [number, number] | [number, number, number] = null;\n        let stop: null | number = null;\n\n        const createAudioBufferSourceNode = async (\n            proxy: IAudioBufferSourceNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeAudioBufferSourceNode = getNativeAudioNode<T, TNativeAudioBufferSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeAudioBufferSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeAudioBufferSourceNodeIsOwnedByContext = isOwnedByContext(nativeAudioBufferSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeAudioBufferSourceNode.buffer,\n                    channelCount: nativeAudioBufferSourceNode.channelCount,\n                    channelCountMode: nativeAudioBufferSourceNode.channelCountMode,\n                    channelInterpretation: nativeAudioBufferSourceNode.channelInterpretation,\n                    // Bug #149: Safari does not yet support the detune AudioParam.\n                    loop: nativeAudioBufferSourceNode.loop,\n                    loopEnd: nativeAudioBufferSourceNode.loopEnd,\n                    loopStart: nativeAudioBufferSourceNode.loopStart,\n                    playbackRate: nativeAudioBufferSourceNode.playbackRate.value\n                };\n\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeAudioBufferSourceNode.start(...start);\n                }\n\n                if (stop !== null) {\n                    nativeAudioBufferSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeAudioBufferSourceNodes.set(nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            if (!nativeAudioBufferSourceNodeIsOwnedByContext) {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await renderAutomation(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            } else {\n                // Bug #149: Safari does not yet support the detune AudioParam.\n                await connectAudioParam(nativeOfflineAudioContext, proxy.playbackRate, nativeAudioBufferSourceNode.playbackRate);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioBufferSourceNode);\n\n            return nativeAudioBufferSourceNode;\n        };\n\n        return {\n            set start(value: [number, number] | [number, number, number]) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IAudioBufferSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode> {\n                const renderedNativeAudioBufferSourceNode = renderedNativeAudioBufferSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioBufferSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioBufferSourceNode);\n                }\n\n                return createAudioBufferSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IAudioBufferSourceNode, IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioBufferSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IAudioBufferSourceNode<T> => {\n    return 'playbackRate' in audioNode;\n};\n", "import { IAudioNode, IBiquadFilterNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isBiquadFilterNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IBiquadFilterNode<T> => {\n    return 'frequency' in audioNode && 'gain' in audioNode;\n};\n", "import { IAudioNode, IConstantSourceNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isConstantSourceNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IConstantSourceNode<T> => {\n    return 'offset' in audioNode;\n};\n", "import { IAudioNode, IGainNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isGainNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IGainNode<T> => {\n    return !('frequency' in audioNode) && 'gain' in audioNode;\n};\n", "import { IAudioNode, IOscillatorNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isOscillatorNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IOscillatorNode<T> => {\n    return 'detune' in audioNode && 'frequency' in audioNode;\n};\n", "import { IAudioNode, IStereoPannerNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isStereoPannerNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IStereoPannerNode<T> => {\n    return 'pan' in audioNode;\n};\n", "import { AUDIO_NODE_CONNECTIONS_STORE } from '../globals';\nimport { IAudioNode } from '../interfaces';\nimport { TAudioNodeConnections, TContext, TGetAudioNodeConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioNodeConnections: TGetAudioNodeConnectionsFunction = <T extends TContext>(\n    audioNode: IAudioNode<T>\n): TAudioNodeConnections<T> => {\n    return <TAudioNodeConnections<T>>getValueForKey(AUDIO_NODE_CONNECTIONS_STORE, audioNode);\n};\n", "import { AUDIO_PARAM_CONNECTIONS_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioParamConnections, TContext, TGetAudioParamConnectionsFunction } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioParamConnections: TGetAudioParamConnectionsFunction = <T extends TContext>(\n    audioParam: IAudioParam\n): TAudioParamConnections<T> => {\n    return <TAudioParamConnections<T>>getValueForKey(AUDIO_PARAM_CONNECTIONS_STORE, audioParam);\n};\n", "import { isAudioBufferSourceNode } from '../guards/audio-buffer-source-node';\nimport { isAudioWorkletNode } from '../guards/audio-worklet-node';\nimport { isBiquadFilterNode } from '../guards/biquad-filter-node';\nimport { isConstantSourceNode } from '../guards/constant-source-node';\nimport { isGainNode } from '../guards/gain-node';\nimport { isOscillatorNode } from '../guards/oscillator-node';\nimport { isStereoPannerNode } from '../guards/stereo-panner-node';\nimport { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { getAudioNodeConnections } from './get-audio-node-connections';\nimport { getAudioParamConnections } from './get-audio-param-connections';\nimport { isActiveAudioNode } from './is-active-audio-node';\nimport { setInternalStateToPassive } from './set-internal-state-to-passive';\n\nexport const deactivateActiveAudioNodeInputConnections = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    trace: readonly IAudioNode<T>[]\n) => {\n    const { activeInputs } = getAudioNodeConnections(audioNode);\n\n    activeInputs.forEach((connections) =>\n        connections.forEach(([source]) => {\n            if (!trace.includes(audioNode)) {\n                deactivateActiveAudioNodeInputConnections(source, [...trace, audioNode]);\n            }\n        })\n    );\n\n    const audioParams = isAudioBufferSourceNode(audioNode)\n        ? [\n              // Bug #149: Safari does not yet support the detune AudioParam.\n              audioNode.playbackRate\n          ]\n        : isAudioWorkletNode(audioNode)\n        ? Array.from(audioNode.parameters.values())\n        : isBiquadFilterNode(audioNode)\n        ? [audioNode.Q, audioNode.detune, audioNode.frequency, audioNode.gain]\n        : isConstantSourceNode(audioNode)\n        ? [audioNode.offset]\n        : isGainNode(audioNode)\n        ? [audioNode.gain]\n        : isOscillatorNode(audioNode)\n        ? [audioNode.detune, audioNode.frequency]\n        : isStereoPannerNode(audioNode)\n        ? [audioNode.pan]\n        : [];\n\n    for (const audioParam of audioParams) {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        if (audioParamConnections !== undefined) {\n            audioParamConnections.activeInputs.forEach(([source]) => deactivateActiveAudioNodeInputConnections(source, trace));\n        }\n    }\n\n    if (isActiveAudioNode(audioNode)) {\n        setInternalStateToPassive(audioNode);\n    }\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport { TContext } from '../types';\nimport { deactivateActiveAudioNodeInputConnections } from './deactivate-active-audio-node-input-connections';\n\nexport const deactivateAudioGraph = <T extends TContext>(context: T): void => {\n    deactivateActiveAudioNodeInputConnections(<IAudioDestinationNode<T>>context.destination, []);\n};\n", "import { IAudioContextOptions } from '../interfaces';\n\nexport const isValidLatencyHint = (latencyHint: IAudioContextOptions['latencyHint']) => {\n    return (\n        latencyHint === undefined ||\n        typeof latencyHint === 'number' ||\n        (typeof latencyHint === 'string' && (latencyHint === 'balanced' || latencyHint === 'interactive' || latencyHint === 'playback'))\n    );\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport {\n    IAudioContext,\n    IAudioContextOptions,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode\n} from '../interfaces';\nimport { TAudioContextConstructorFactory, TAudioContextState, TNativeAudioContext, TNativeGainNode, TNativeOscillatorNode } from '../types';\n\nexport const createAudioContextConstructor: TAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class AudioContext extends baseAudioContextConstructor<IAudioContext> implements IAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public createMediaElementSource(mediaElement: HTMLMediaElement): IMediaElementAudioSourceNode<this> {\n            return new mediaElementAudioSourceNodeConstructor(this, { mediaElement });\n        }\n\n        public createMediaStreamDestination(): IMediaStreamAudioDestinationNode<this> {\n            return new mediaStreamAudioDestinationNodeConstructor(this);\n        }\n\n        public createMediaStreamSource(mediaStream: MediaStream): IMediaStreamAudioSourceNode<this> {\n            return new mediaStreamAudioSourceNodeConstructor(this, { mediaStream });\n        }\n\n        public createMediaStreamTrackSource(mediaStreamTrack: MediaStreamTrack): IMediaStreamTrackAudioSourceNode<this> {\n            return new mediaStreamTrackAudioSourceNodeConstructor(this, { mediaStreamTrack });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport {\n    TAudioDestinationNodeConstructorFactory,\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TNativeAudioDestinationNode\n} from '../types';\n\nexport const createAudioDestinationNodeConstructor: TAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n) => {\n    return class AudioDestinationNode<T extends TContext> extends audioNodeConstructor<T> implements IAudioDestinationNode<T> {\n        private _isNodeOfNativeOfflineAudioContext: boolean;\n\n        private _nativeAudioDestinationNode: TNativeAudioDestinationNode;\n\n        constructor(context: T, channelCount: number) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const nativeAudioDestinationNode = createNativeAudioDestinationNode(nativeContext, channelCount, isOffline);\n            const audioDestinationNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioDestinationNodeRenderer(renderInputsOfAudioNode) : null)\n            );\n\n            super(context, false, nativeAudioDestinationNode, audioDestinationNodeRenderer);\n\n            this._isNodeOfNativeOfflineAudioContext = isOffline;\n            this._nativeAudioDestinationNode = nativeAudioDestinationNode;\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioDestinationNode.channelCount;\n        }\n\n        set channelCount(value) {\n            // Bug #52: Chrome, Edge & Safari do not throw an exception at all.\n            // Bug #54: Firefox does throw an IndexSizeError.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n            if (value > this._nativeAudioDestinationNode.maxChannelCount) {\n                throw createIndexSizeError();\n            }\n\n            this._nativeAudioDestinationNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioDestinationNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            // Bug #53: No browser does throw an exception yet.\n            if (this._isNodeOfNativeOfflineAudioContext) {\n                throw createInvalidStateError();\n            }\n\n            this._nativeAudioDestinationNode.channelCountMode = value;\n        }\n\n        get maxChannelCount(): number {\n            return this._nativeAudioDestinationNode.maxChannelCount;\n        }\n    };\n};\n", "import { IAudioDestinationNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TAudioDestinationNodeRendererFactory,\n    TNativeAudioDestinationNode,\n    TNativeOfflineAudioContext,\n    TRenderInputsOfAudioNodeFunction\n} from '../types';\n\nexport const createAudioDestinationNodeRenderer: TAudioDestinationNodeRendererFactory = <\n    T extends IMinimalOfflineAudioContext | IOfflineAudioContext\n>(\n    renderInputsOfAudioNode: TRenderInputsOfAudioNodeFunction\n) => {\n    const renderedNativeAudioDestinationNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioDestinationNode>();\n\n    const createAudioDestinationNode = async (proxy: IAudioDestinationNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeOfflineAudioContext.destination;\n\n        renderedNativeAudioDestinationNodes.set(nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioDestinationNode);\n\n        return nativeAudioDestinationNode;\n    };\n\n    return {\n        render(\n            proxy: IAudioDestinationNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ): Promise<TNativeAudioDestinationNode> {\n            const renderedNativeAudioDestinationNode = renderedNativeAudioDestinationNodes.get(nativeOfflineAudioContext);\n\n            if (renderedNativeAudioDestinationNode !== undefined) {\n                return Promise.resolve(renderedNativeAudioDestinationNode);\n            }\n\n            return createAudioDestinationNode(proxy, nativeOfflineAudioContext);\n        }\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam } from '../interfaces';\nimport { TAudioListenerFactoryFactory } from '../types';\n\nexport const createAudioListenerFactory: TAudioListenerFactoryFactory = (\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n) => {\n    return (context, nativeContext) => {\n        const nativeListener = nativeContext.listener;\n\n        // Bug #117: Only Chrome & Edge support the new interface already.\n        const createFakeAudioParams = () => {\n            const buffer = new Float32Array(1);\n            const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'speakers',\n                numberOfInputs: 9\n            });\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            let isScriptProcessorNodeCreated = false;\n            let lastOrientation: [number, number, number, number, number, number] = [0, 0, -1, 0, 1, 0];\n            let lastPosition: [number, number, number] = [0, 0, 0];\n\n            const createScriptProcessorNode = () => {\n                if (isScriptProcessorNodeCreated) {\n                    return;\n                }\n\n                isScriptProcessorNodeCreated = true;\n\n                const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 9, 0);\n\n                // tslint:disable-next-line:deprecation\n                scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n                    const orientation: [number, number, number, number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 0),\n                        getFirstSample(inputBuffer, buffer, 1),\n                        getFirstSample(inputBuffer, buffer, 2),\n                        getFirstSample(inputBuffer, buffer, 3),\n                        getFirstSample(inputBuffer, buffer, 4),\n                        getFirstSample(inputBuffer, buffer, 5)\n                    ];\n\n                    if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                        nativeListener.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                        lastOrientation = orientation;\n                    }\n\n                    const positon: [number, number, number] = [\n                        getFirstSample(inputBuffer, buffer, 6),\n                        getFirstSample(inputBuffer, buffer, 7),\n                        getFirstSample(inputBuffer, buffer, 8)\n                    ];\n\n                    if (positon.some((value, index) => value !== lastPosition[index])) {\n                        nativeListener.setPosition(...positon); // tslint:disable-line:deprecation\n\n                        lastPosition = positon;\n                    }\n                };\n\n                channelMergerNode.connect(scriptProcessorNode);\n            };\n            const createSetOrientation = (index: number) => (value: number) => {\n                if (value !== lastOrientation[index]) {\n                    lastOrientation[index] = value;\n\n                    nativeListener.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n                }\n            };\n            const createSetPosition = (index: number) => (value: number) => {\n                if (value !== lastPosition[index]) {\n                    lastPosition[index] = value;\n\n                    nativeListener.setPosition(...lastPosition); // tslint:disable-line:deprecation\n                }\n            };\n            const createFakeAudioParam = (input: number, initialValue: number, setValue: (value: number) => void) => {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset: initialValue\n                });\n\n                constantSourceNode.connect(channelMergerNode, 0, input);\n\n                // @todo This should be stopped when the context is closed.\n                constantSourceNode.start();\n\n                Object.defineProperty(constantSourceNode.offset, 'defaultValue', {\n                    get(): number {\n                        return initialValue;\n                    }\n                });\n\n                /*\n                 * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and\n                 * minValue for GainNodes.\n                 */\n                const audioParam = createAudioParam(\n                    <any>{ context },\n                    isOffline,\n                    constantSourceNode.offset,\n                    MOST_POSITIVE_SINGLE_FLOAT,\n                    MOST_NEGATIVE_SINGLE_FLOAT\n                );\n\n                overwriteAccessors(\n                    audioParam,\n                    'value',\n                    (get) => () => get.call(audioParam),\n                    (set) => (value) => {\n                        try {\n                            set.call(audioParam, value);\n                        } catch (err) {\n                            if (err.code !== 9) {\n                                throw err;\n                            }\n                        }\n\n                        createScriptProcessorNode();\n\n                        if (isOffline) {\n                            // Bug #117: Using setOrientation() and setPosition() doesn't work with an OfflineAudioContext.\n                            setValue(value);\n                        }\n                    }\n                );\n\n                audioParam.cancelAndHoldAtTime = ((cancelAndHoldAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelAndHoldAtTime']>) => {\n                        const value = cancelAndHoldAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelAndHoldAtTime);\n                audioParam.cancelScheduledValues = ((cancelScheduledValues) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['cancelScheduledValues']>) => {\n                        const value = cancelScheduledValues.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.cancelScheduledValues);\n                audioParam.exponentialRampToValueAtTime = ((exponentialRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['exponentialRampToValueAtTime']>) => {\n                        const value = exponentialRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.exponentialRampToValueAtTime);\n                audioParam.linearRampToValueAtTime = ((linearRampToValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['linearRampToValueAtTime']>) => {\n                        const value = linearRampToValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.linearRampToValueAtTime);\n                audioParam.setTargetAtTime = ((setTargetAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setTargetAtTime']>) => {\n                        const value = setTargetAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setTargetAtTime);\n                audioParam.setValueAtTime = ((setValueAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueAtTime']>) => {\n                        const value = setValueAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueAtTime);\n                audioParam.setValueCurveAtTime = ((setValueCurveAtTime) => {\n                    if (isOffline) {\n                        return () => {\n                            throw createNotSupportedError();\n                        };\n                    }\n\n                    return (...args: Parameters<IAudioParam['setValueCurveAtTime']>) => {\n                        const value = setValueCurveAtTime.apply(audioParam, args);\n\n                        createScriptProcessorNode();\n\n                        return value;\n                    };\n                })(audioParam.setValueCurveAtTime);\n\n                return audioParam;\n            };\n\n            return {\n                forwardX: createFakeAudioParam(0, 0, createSetOrientation(0)),\n                forwardY: createFakeAudioParam(1, 0, createSetOrientation(1)),\n                forwardZ: createFakeAudioParam(2, -1, createSetOrientation(2)),\n                positionX: createFakeAudioParam(6, 0, createSetPosition(0)),\n                positionY: createFakeAudioParam(7, 0, createSetPosition(1)),\n                positionZ: createFakeAudioParam(8, 0, createSetPosition(2)),\n                upX: createFakeAudioParam(3, 0, createSetOrientation(3)),\n                upY: createFakeAudioParam(4, 1, createSetOrientation(4)),\n                upZ: createFakeAudioParam(5, 0, createSetOrientation(5))\n            };\n        };\n\n        const { forwardX, forwardY, forwardZ, positionX, positionY, positionZ, upX, upY, upZ } =\n            nativeListener.forwardX === undefined ? createFakeAudioParams() : nativeListener;\n\n        return {\n            get forwardX(): IAudioParam {\n                return forwardX;\n            },\n            get forwardY(): IAudioParam {\n                return forwardY;\n            },\n            get forwardZ(): IAudioParam {\n                return forwardZ;\n            },\n            get positionX(): IAudioParam {\n                return positionX;\n            },\n            get positionY(): IAudioParam {\n                return positionY;\n            },\n            get positionZ(): IAudioParam {\n                return positionZ;\n            },\n            get upX(): IAudioParam {\n                return upX;\n            },\n            get upY(): IAudioParam {\n                return upY;\n            },\n            get upZ(): IAudioParam {\n                return upZ;\n            }\n        };\n    };\n};\n", "import { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isAudioNode = <T extends TContext>(\n    audioNodeOrAudioParam: IAudioNode<T> | IAudioParam\n): audioNodeOrAudioParam is IAudioNode<T> => {\n    return 'context' in audioNodeOrAudioParam;\n};\n", "import { TAudioNodeOutputConnection, TContext, TOutputConnection } from '../types';\nimport { isAudioNode } from './audio-node';\n\nexport const isAudioNodeOutputConnection = <T extends TContext>(\n    outputConnection: TOutputConnection<T>\n): outputConnection is TAudioNodeOutputConnection<T> => {\n    return isAudioNode(outputConnection[0]);\n};\n", "import { TInsertElementInSetFunction } from '../types';\n\nexport const insertElementInSet: TInsertElementInSetFunction = (set, element, predicate, ignoreDuplicates) => {\n    for (const lmnt of set) {\n        if (predicate(lmnt)) {\n            if (ignoreDuplicates) {\n                return false;\n            }\n\n            throw Error('The set contains at least one similar element.');\n        }\n    }\n\n    set.add(element);\n\n    return true;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    [output, eventListener]: TPassiveAudioParamInputConnection,\n    ignoreDuplicates: boolean\n) => {\n    insertElementInSet(\n        activeInputs,\n        [source, output, eventListener],\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output,\n        ignoreDuplicates\n    );\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { insertElementInSet } from './insert-element-in-set';\n\nexport const addPassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    [source, output, eventListener]: TActiveInputConnection<T>,\n    ignoreDuplicates: boolean\n) => {\n    const passiveInputConnections = passiveInputs.get(source);\n\n    if (passiveInputConnections === undefined) {\n        passiveInputs.set(source, new Set([[output, eventListener]]));\n    } else {\n        insertElementInSet(\n            passiveInputConnections,\n            [output, eventListener],\n            (passiveInputConnection) => passiveInputConnection[0] === output,\n            ignoreDuplicates\n        );\n    }\n};\n", "import { INativeAudioNodeFaker } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\n\nexport const isNativeAudioNodeFaker = (\n    nativeAudioNodeOrNativeAudioNodeFaker: TNativeAudioNode | INativeAudioNodeFaker\n): nativeAudioNodeOrNativeAudioNodeFaker is INativeAudioNodeFaker => {\n    return 'inputs' in nativeAudioNodeOrNativeAudioNodeFaker;\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { INativeAudioNodeFaker } from '../interfaces';\nimport { TConnectNativeAudioNodeToNativeAudioNodeFunction, TNativeAudioNode } from '../types';\n\nexport const connectNativeAudioNodeToNativeAudioNode: TConnectNativeAudioNodeToNativeAudioNodeFunction = (\n    nativeSourceAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    nativeDestinationAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n    output: number,\n    input: number\n): [TNativeAudioNode, number, number] => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        const fakeNativeDestinationAudioNode = nativeDestinationAudioNode.inputs[input];\n\n        nativeSourceAudioNode.connect(fakeNativeDestinationAudioNode, output, 0);\n\n        return [fakeNativeDestinationAudioNode, output, 0];\n    }\n\n    nativeSourceAudioNode.connect(nativeDestinationAudioNode, output, input);\n\n    return [nativeDestinationAudioNode, output, input];\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\n\nexport const deleteActiveInputConnection = <T extends TContext>(\n    activeInputConnections: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n): null | TActiveInputConnection<T> => {\n    for (const activeInputConnection of activeInputConnections) {\n        if (activeInputConnection[0] === source && activeInputConnection[1] === output) {\n            activeInputConnections.delete(activeInputConnection);\n\n            return activeInputConnection;\n        }\n    }\n\n    return null;\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TActiveInputConnection, TContext } from '../types';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deleteActiveInputConnectionToAudioParam = <T extends TContext>(\n    activeInputs: Set<TActiveInputConnection<T>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    return pickElementFromSet(\n        activeInputs,\n        (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n    );\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TInternalStateEventListener } from '../types';\nimport { getEventListenersOfAudioNode } from './get-event-listeners-of-audio-node';\n\nexport const deleteEventListenerOfAudioNode = <T extends TContext>(\n    audioNode: IAudioNode<T>,\n    eventListener: TInternalStateEventListener\n) => {\n    const eventListeners = getEventListenersOfAudioNode(audioNode);\n\n    if (!eventListeners.delete(eventListener)) {\n        throw new Error('Missing the expected event listener.');\n    }\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext, TPassiveAudioParamInputConnection } from '../types';\nimport { getValueForKey } from './get-value-for-key';\nimport { pickElementFromSet } from './pick-element-from-set';\n\nexport const deletePassiveInputConnectionToAudioParam = <T extends TContext>(\n    passiveInputs: WeakMap<IAudioNode<T>, Set<TPassiveAudioParamInputConnection>>,\n    source: IAudioNode<T>,\n    output: number\n) => {\n    const passiveInputConnections = getValueForKey(passiveInputs, source);\n    const matchingConnection = pickElementFromSet(\n        passiveInputConnections,\n        (passiveInputConnection) => passiveInputConnection[0] === output\n    );\n\n    if (passiveInputConnections.size === 0) {\n        passiveInputs.delete(source);\n    }\n\n    return matchingConnection;\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { TDisconnectNativeAudioNodeFromNativeAudioNodeFunction } from '../types';\n\nexport const disconnectNativeAudioNodeFromNativeAudioNode: TDisconnectNativeAudioNodeFromNativeAudioNodeFunction = (\n    nativeSourceAudioNode,\n    nativeDestinationAudioNode,\n    output,\n    input\n) => {\n    if (isNativeAudioNodeFaker(nativeDestinationAudioNode)) {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode.inputs[input], output, 0);\n    } else {\n        nativeSourceAudioNode.disconnect(nativeDestinationAudioNode, output, input);\n    }\n};\n", "import { AUDIO_NODE_STORE } from '../globals';\nimport { IAudioNode, INativeAudioNodeFaker } from '../interfaces';\nimport { TContext, TGetNativeAudioNodeFunction, TNativeAudioNode } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioNode: TGetNativeAudioNodeFunction = <T extends TContext, U extends TNativeAudioNode | INativeAudioNodeFaker>(\n    audioNode: IAudioNode<T>\n): U => {\n    return <U>getValueForKey(AUDIO_NODE_STORE, audioNode);\n};\n", "import { AUDIO_PARAM_STORE } from '../globals';\nimport { IAudioParam } from '../interfaces';\nimport { TNativeAudioParam } from '../types';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getNativeAudioParam = (audioParam: IAudioParam): TNativeAudioParam => {\n    return getValueForKey(AUDIO_PARAM_STORE, audioParam);\n};\n", "import { CYCLE_COUNTERS } from '../globals';\nimport { TIsPartOfACycleFunction } from '../types';\n\nexport const isPartOfACycle: TIsPartOfACycleFunction = (audioNode) => {\n    return CYCLE_COUNTERS.has(audioNode);\n};\n", "import { ACTIVE_AUDIO_NODE_STORE } from '../globals';\nimport { TIsPassiveAudioNodeFunction } from '../types';\n\nexport const isPassiveAudioNode: TIsPassiveAudioNodeFunction = (audioNode) => {\n    return !ACTIVE_AUDIO_NODE_STORE.has(audioNode);\n};\n", "import { TNativeAudioContext, TNativeAudioWorkletNodeConstructor } from '../types';\n\nexport const testAudioNodeDisconnectMethodSupport = (\n    nativeAudioContext: TNativeAudioContext,\n    nativeAudioWorkletNodeConstructor: null | TNativeAudioWorkletNodeConstructor\n): Promise<boolean> => {\n    return new Promise((resolve) => {\n        /*\n         * This bug existed in Safari up until v14.0.2. Since AudioWorklets were not supported in Safari until v14.1 the presence of the\n         * constructor for an AudioWorkletNode can be used here to skip the test.\n         */\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            resolve(true);\n        } else {\n            const analyzer = nativeAudioContext.createScriptProcessor(256, 1, 1); // tslint:disable-line deprecation\n            const dummy = nativeAudioContext.createGain();\n            // Bug #95: Safari does not play one sample buffers.\n            const ones = nativeAudioContext.createBuffer(1, 2, 44100);\n            const channelData = ones.getChannelData(0);\n\n            channelData[0] = 1;\n            channelData[1] = 1;\n\n            const source = nativeAudioContext.createBufferSource();\n\n            source.buffer = ones;\n            source.loop = true;\n\n            source.connect(analyzer).connect(nativeAudioContext.destination);\n            source.connect(dummy);\n            source.disconnect(dummy);\n\n            // tslint:disable-next-line:deprecation\n            analyzer.onaudioprocess = (event) => {\n                const chnnlDt = event.inputBuffer.getChannelData(0); // tslint:disable-line deprecation\n\n                if (Array.prototype.some.call(chnnlDt, (sample: number) => sample === 1)) {\n                    resolve(true);\n                } else {\n                    resolve(false);\n                }\n\n                source.stop();\n\n                analyzer.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                source.disconnect(analyzer);\n                analyzer.disconnect(nativeAudioContext.destination);\n            };\n\n            source.start();\n        }\n    });\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const visitEachAudioNodeOnce = <T extends TContext>(\n    cycles: IAudioNode<T>[][],\n    visitor: (audioNode: IAudioNode<T>, count: number) => void\n): void => {\n    const counts = new Map<IAudioNode<T>, number>();\n\n    for (const cycle of cycles) {\n        for (const audioNode of cycle) {\n            const count = counts.get(audioNode);\n\n            counts.set(audioNode, count === undefined ? 1 : count + 1);\n        }\n    }\n\n    counts.forEach((count, audioNode) => visitor(audioNode, count));\n};\n", "import { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const isNativeAudioNode = (\n    nativeAudioNodeOrAudioParam: TNativeAudioNode | TNativeAudioParam\n): nativeAudioNodeOrAudioParam is TNativeAudioNode => {\n    return 'context' in nativeAudioNodeOrAudioParam;\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const wrapAudioNodeDisconnectMethod = (nativeAudioNode: TNativeAudioNode): void => {\n    const connections = new Map<TNativeAudioNode | TNativeAudioParam, { input: number; output: number }[]>();\n\n    nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n        // tslint:disable-next-line:invalid-void no-inferrable-types\n        return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n            const returnValue = isNativeAudioNode(destination) ? connect(destination, output, input) : connect(destination, output);\n\n            // Save the new connection only if the calls to connect above didn't throw an error.\n            const connectionsToDestination = connections.get(destination);\n\n            if (connectionsToDestination === undefined) {\n                connections.set(destination, [{ input, output }]);\n            } else {\n                if (connectionsToDestination.every((connection) => connection.input !== input || connection.output !== output)) {\n                    connectionsToDestination.push({ input, output });\n                }\n            }\n\n            return returnValue;\n        };\n    })(nativeAudioNode.connect.bind(nativeAudioNode));\n\n    nativeAudioNode.disconnect = ((disconnect) => {\n        return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n            disconnect.apply(nativeAudioNode);\n\n            if (destinationOrOutput === undefined) {\n                connections.clear();\n            } else if (typeof destinationOrOutput === 'number') {\n                for (const [destination, connectionsToDestination] of connections) {\n                    const filteredConnections = connectionsToDestination.filter((connection) => connection.output !== destinationOrOutput);\n\n                    if (filteredConnections.length === 0) {\n                        connections.delete(destination);\n                    } else {\n                        connections.set(destination, filteredConnections);\n                    }\n                }\n            } else if (connections.has(destinationOrOutput)) {\n                if (output === undefined) {\n                    connections.delete(destinationOrOutput);\n                } else {\n                    const connectionsToDestination = connections.get(destinationOrOutput);\n\n                    if (connectionsToDestination !== undefined) {\n                        const filteredConnections = connectionsToDestination.filter(\n                            (connection) => connection.output !== output && (connection.input !== input || input === undefined)\n                        );\n\n                        if (filteredConnections.length === 0) {\n                            connections.delete(destinationOrOutput);\n                        } else {\n                            connections.set(destinationOrOutput, filteredConnections);\n                        }\n                    }\n                }\n            }\n\n            for (const [destination, connectionsToDestination] of connections) {\n                connectionsToDestination.forEach((connection) => {\n                    if (isNativeAudioNode(destination)) {\n                        nativeAudioNode.connect(destination, connection.output, connection.input);\n                    } else {\n                        nativeAudioNode.connect(destination, connection.output);\n                    }\n                });\n            }\n        };\n    })(nativeAudioNode.disconnect);\n};\n", "import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n", "import { AutomationEventList } from 'automation-events';\nimport { IAudioNode, IAudioParam, IAudioParamRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TAudioParamFactoryFactory, TContext, TNativeAudioParam } from '../types';\n\nexport const createAudioParamFactory: TAudioParamFactoryFactory = (\n    addAudioParamConnections,\n    audioParamAudioNodeStore,\n    audioParamStore,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n) => {\n    return <T extends TContext>(\n        audioNode: IAudioNode<T>,\n        isAudioParamOfOfflineAudioContext: boolean,\n        nativeAudioParam: TNativeAudioParam,\n        maxValue: null | number = null,\n        minValue: null | number = null\n    ): IAudioParam => {\n        // Bug #196 Only Safari sets the defaultValue to the initial value.\n        const defaultValue = nativeAudioParam.value;\n        const automationEventList = new AutomationEventList(defaultValue);\n        const audioParamRenderer = isAudioParamOfOfflineAudioContext ? createAudioParamRenderer(automationEventList) : null;\n        const audioParam = {\n            get defaultValue(): number {\n                return defaultValue;\n            },\n            get maxValue(): number {\n                return maxValue === null ? nativeAudioParam.maxValue : maxValue;\n            },\n            get minValue(): number {\n                return minValue === null ? nativeAudioParam.minValue : minValue;\n            },\n            get value(): number {\n                return nativeAudioParam.value;\n            },\n            set value(value) {\n                nativeAudioParam.value = value;\n\n                // Bug #98: Firefox & Safari do not yet treat the value setter like a call to setValueAtTime().\n                audioParam.setValueAtTime(value, audioNode.context.currentTime);\n            },\n            cancelAndHoldAtTime(cancelTime: number): IAudioParam {\n                // Bug #28: Firefox & Safari do not yet implement cancelAndHoldAtTime().\n                if (typeof nativeAudioParam.cancelAndHoldAtTime === 'function') {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n                    nativeAudioParam.cancelAndHoldAtTime(cancelTime);\n                } else {\n                    const previousLastEvent = Array.from(automationEventList).pop();\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createCancelAndHoldAutomationEvent(cancelTime));\n\n                    const currentLastEvent = Array.from(automationEventList).pop();\n\n                    nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                    if (previousLastEvent !== currentLastEvent && currentLastEvent !== undefined) {\n                        if (currentLastEvent.type === 'exponentialRampToValue') {\n                            nativeAudioParam.exponentialRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'linearRampToValue') {\n                            nativeAudioParam.linearRampToValueAtTime(currentLastEvent.value, currentLastEvent.endTime);\n                        } else if (currentLastEvent.type === 'setValue') {\n                            nativeAudioParam.setValueAtTime(currentLastEvent.value, currentLastEvent.startTime);\n                        } else if (currentLastEvent.type === 'setValueCurve') {\n                            nativeAudioParam.setValueCurveAtTime(\n                                currentLastEvent.values,\n                                currentLastEvent.startTime,\n                                currentLastEvent.duration\n                            );\n                        }\n                    }\n                }\n\n                return audioParam;\n            },\n            cancelScheduledValues(cancelTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createCancelScheduledValuesAutomationEvent(cancelTime));\n                nativeAudioParam.cancelScheduledValues(cancelTime);\n\n                return audioParam;\n            },\n            exponentialRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                // Bug #45: Safari does not throw an error yet.\n                if (value === 0) {\n                    throw new RangeError();\n                }\n\n                // Bug #187: Safari does not throw an error yet.\n                if (!Number.isFinite(endTime) || endTime < 0) {\n                    throw new RangeError();\n                }\n\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #194: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createExponentialRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.exponentialRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            linearRampToValueAtTime(value: number, endTime: number): IAudioParam {\n                const currentTime = audioNode.context.currentTime;\n\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(currentTime);\n                }\n\n                // Bug #195: Firefox does not implicitly call setValueAtTime() if there is no previous event.\n                if (Array.from(automationEventList).length === 0) {\n                    automationEventList.add(createSetValueAutomationEvent(defaultValue, currentTime));\n                    nativeAudioParam.setValueAtTime(defaultValue, currentTime);\n                }\n\n                automationEventList.add(createLinearRampToValueAutomationEvent(value, endTime));\n                nativeAudioParam.linearRampToValueAtTime(value, endTime);\n\n                return audioParam;\n            },\n            setTargetAtTime(target: number, startTime: number, timeConstant: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetTargetAutomationEvent(target, startTime, timeConstant));\n                nativeAudioParam.setTargetAtTime(target, startTime, timeConstant);\n\n                return audioParam;\n            },\n            setValueAtTime(value: number, startTime: number): IAudioParam {\n                if (audioParamRenderer === null) {\n                    automationEventList.flush(audioNode.context.currentTime);\n                }\n\n                automationEventList.add(createSetValueAutomationEvent(value, startTime));\n                nativeAudioParam.setValueAtTime(value, startTime);\n\n                return audioParam;\n            },\n            setValueCurveAtTime(values: Iterable<number>, startTime: number, duration: number): IAudioParam {\n                // Bug 183: Safari only accepts a Float32Array.\n                const convertedValues = values instanceof Float32Array ? values : new Float32Array(values);\n                /*\n                 * Bug #152: Safari does not correctly interpolate the values of the curve.\n                 * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the\n                 * existence of the webkitAudioContext is used as a workaround here.\n                 */\n                if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                    const endTime = startTime + duration;\n                    const sampleRate = audioNode.context.sampleRate;\n                    const firstSample = Math.ceil(startTime * sampleRate);\n                    const lastSample = Math.floor(endTime * sampleRate);\n                    const numberOfInterpolatedValues = lastSample - firstSample;\n                    const interpolatedValues = new Float32Array(numberOfInterpolatedValues);\n\n                    for (let i = 0; i < numberOfInterpolatedValues; i += 1) {\n                        const theoreticIndex = ((convertedValues.length - 1) / duration) * ((firstSample + i) / sampleRate - startTime);\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        interpolatedValues[i] =\n                            lowerIndex === upperIndex\n                                ? convertedValues[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * convertedValues[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * convertedValues[upperIndex];\n                    }\n\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(interpolatedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(interpolatedValues, startTime, duration);\n\n                    const timeOfLastSample = lastSample / sampleRate;\n\n                    if (timeOfLastSample < endTime) {\n                        setValueAtTimeUntilPossible(audioParam, interpolatedValues[interpolatedValues.length - 1], timeOfLastSample);\n                    }\n\n                    setValueAtTimeUntilPossible(audioParam, convertedValues[convertedValues.length - 1], endTime);\n                } else {\n                    if (audioParamRenderer === null) {\n                        automationEventList.flush(audioNode.context.currentTime);\n                    }\n\n                    automationEventList.add(createSetValueCurveAutomationEvent(convertedValues, startTime, duration));\n                    nativeAudioParam.setValueCurveAtTime(convertedValues, startTime, duration);\n                }\n\n                return audioParam;\n            }\n        };\n\n        audioParamStore.set(audioParam, nativeAudioParam);\n        audioParamAudioNodeStore.set(audioParam, audioNode);\n\n        addAudioParamConnections(\n            audioParam,\n            <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioParamRenderer : null>audioParamRenderer\n        );\n\n        return audioParam;\n    };\n};\n", "import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n", "import { IReadOnlyMap } from './interfaces';\n\nexport class ReadOnlyMap<T, U> implements IReadOnlyMap<T, U> {\n    private _map: Map<T, U>;\n\n    constructor(parameters: [T, U][]) {\n        this._map = new Map(parameters);\n    }\n\n    get size(): number {\n        return this._map.size;\n    }\n\n    public entries(): IterableIterator<[T, U]> {\n        return this._map.entries();\n    }\n\n    public forEach(callback: (audioParam: U, name: T, map: ReadOnlyMap<T, U>) => void, thisArg: any = null): void {\n        return this._map.forEach((value: U, key: T) => callback.call(thisArg, value, key, this));\n    }\n\n    public get(name: T): undefined | U {\n        return this._map.get(name);\n    }\n\n    public has(name: T): boolean {\n        return this._map.has(name);\n    }\n\n    public keys(): IterableIterator<T> {\n        return this._map.keys();\n    }\n\n    public values(): IterableIterator<U> {\n        return this._map.values();\n    }\n}\n", "import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n", "import { TNativeAudioBuffer } from '../types';\n\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: string]: Float32Array },\n    key: string,\n    channelNumber: number,\n    bufferOffset: number\n): void;\nexport function copyFromChannel(\n    audioBuffer: TNativeAudioBuffer,\n    // @todo There is currently no way to define something like { [ key: number | string ]: Float32Array }\n    parent: any,\n    key: number | string,\n    channelNumber: number,\n    bufferOffset: number\n): void {\n    if (typeof audioBuffer.copyFromChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = new Float32Array(128);\n        }\n\n        audioBuffer.copyFromChannel(parent[key], channelNumber, bufferOffset);\n\n        // Bug #5: Safari does not support copyFromChannel().\n    } else {\n        const channelData = audioBuffer.getChannelData(channelNumber);\n\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength === 0) {\n            parent[key] = channelData.slice(bufferOffset, bufferOffset + 128);\n        } else {\n            const slicedInput = new Float32Array(channelData.buffer, bufferOffset * Float32Array.BYTES_PER_ELEMENT, 128);\n\n            parent[key].set(slicedInput);\n        }\n    }\n}\n", "import { TNativeAudioBuffer } from '../types';\n\nexport const copyToChannel = (\n    audioBuffer: TNativeAudioBuffer,\n    parent: { [key: number]: Float32Array },\n    key: number,\n    channelNumber: number,\n    bufferOffset: number\n): void => {\n    if (typeof audioBuffer.copyToChannel === 'function') {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.copyToChannel(parent[key], channelNumber, bufferOffset);\n        }\n\n        // Bug #5: Safari does not support copyToChannel().\n    } else {\n        // The byteLength will be 0 when the ArrayBuffer was transferred.\n        if (parent[key].byteLength !== 0) {\n            audioBuffer.getChannelData(channelNumber).set(parent[key], bufferOffset);\n        }\n    }\n};\n", "export const createNestedArrays = (x: number, y: number | number[]): Float32Array[][] => {\n    const arrays: Float32Array[][] = [];\n\n    for (let i = 0; i < x; i += 1) {\n        const array = [];\n\n        const length = typeof y === 'number' ? y : y[i];\n\n        for (let j = 0; j < length; j += 1) {\n            array.push(new Float32Array(128));\n        }\n\n        arrays.push(array);\n    }\n\n    return arrays;\n};\n", "import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioNode, IAudioWorkletProcessor } from '../interfaces';\nimport { TContext, TNativeAudioWorkletNode, TNativeOfflineAudioContext } from '../types';\nimport { getNativeAudioNode } from './get-native-audio-node';\nimport { getValueForKey } from './get-value-for-key';\n\nexport const getAudioWorkletProcessor = <T extends TContext>(\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    proxy: IAudioNode<T>\n): Promise<IAudioWorkletProcessor> => {\n    const nodeToProcessorMap = getValueForKey(NODE_TO_PROCESSOR_MAPS, nativeOfflineAudioContext);\n    const nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n\n    return getValueForKey(nodeToProcessorMap, nativeAudioWorkletNode);\n};\n", "import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioNode,\n    IAudioWorklet,\n    IBaseAudioContext,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IPeriodicWaveConstraints,\n    IStereoPannerNode,\n    IWaveShaperNode,\n    IWorkletOptions\n} from '../interfaces';\nimport { TBaseAudioContextConstructorFactory, TContext, TDecodeErrorCallback, TDecodeSuccessCallback, TNativeContext } from '../types';\n\nexport const createBaseAudioContextConstructor: TBaseAudioContextConstructorFactory = (\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n) => {\n    return class BaseAudioContext<T extends TContext> extends minimalBaseAudioContextConstructor<T> implements IBaseAudioContext<T> {\n        private _audioWorklet: undefined | IAudioWorklet;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext, numberOfChannels);\n\n            this._audioWorklet =\n                addAudioWorkletModule === undefined\n                    ? undefined\n                    : {\n                          addModule: (moduleURL: string, options?: IWorkletOptions) => {\n                              return addAudioWorkletModule(<T>(<unknown>this), moduleURL, options);\n                          }\n                      };\n        }\n\n        get audioWorklet(): undefined | IAudioWorklet {\n            return this._audioWorklet;\n        }\n\n        public createAnalyser(): IAnalyserNode<T> {\n            return new analyserNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBiquadFilter(): IBiquadFilterNode<T> {\n            return new biquadFilterNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createBuffer(numberOfChannels: number, length: number, sampleRate: number): IAudioBuffer {\n            return new audioBufferConstructor({ length, numberOfChannels, sampleRate });\n        }\n\n        public createBufferSource(): IAudioBufferSourceNode<T> {\n            return new audioBufferSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createChannelMerger(numberOfInputs = 6): IAudioNode<T> {\n            return new channelMergerNodeConstructor(<T>(<unknown>this), { numberOfInputs });\n        }\n\n        public createChannelSplitter(numberOfOutputs = 6): IAudioNode<T> {\n            return new channelSplitterNodeConstructor(<T>(<unknown>this), { numberOfOutputs });\n        }\n\n        public createConstantSource(): IConstantSourceNode<T> {\n            return new constantSourceNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createConvolver(): IConvolverNode<T> {\n            return new convolverNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createDelay(maxDelayTime = 1): IDelayNode<T> {\n            return new delayNodeConstructor(<T>(<unknown>this), { maxDelayTime });\n        }\n\n        public createDynamicsCompressor(): IDynamicsCompressorNode<T> {\n            return new dynamicsCompressorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createGain(): IGainNode<T> {\n            return new gainNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createIIRFilter(feedforward: Iterable<number>, feedback: Iterable<number>): IIIRFilterNode<T> {\n            return new iIRFilterNodeConstructor(<T>(<unknown>this), { feedback, feedforward });\n        }\n\n        public createOscillator(): IOscillatorNode<T> {\n            return new oscillatorNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPanner(): IPannerNode<T> {\n            return new pannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createPeriodicWave(\n            real: Iterable<number>,\n            imag: Iterable<number>,\n            constraints: Partial<IPeriodicWaveConstraints> = { disableNormalization: false }\n        ): IPeriodicWave {\n            return new periodicWaveConstructor(<T>(<unknown>this), { ...constraints, imag, real });\n        }\n\n        public createStereoPanner(): IStereoPannerNode<T> {\n            return new stereoPannerNodeConstructor(<T>(<unknown>this));\n        }\n\n        public createWaveShaper(): IWaveShaperNode<T> {\n            return new waveShaperNodeConstructor(<T>(<unknown>this));\n        }\n\n        public decodeAudioData(\n            audioData: ArrayBuffer,\n            successCallback?: TDecodeSuccessCallback,\n            errorCallback?: TDecodeErrorCallback\n        ): Promise<IAudioBuffer> {\n            return decodeAudioData(this._nativeContext, audioData).then(\n                (audioBuffer) => {\n                    if (typeof successCallback === 'function') {\n                        successCallback(audioBuffer);\n                    }\n\n                    return audioBuffer;\n                },\n                (err) => {\n                    if (typeof errorCallback === 'function') {\n                        errorCallback(err);\n                    }\n\n                    throw err;\n                }\n            );\n        }\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IBiquadFilterNode, IBiquadFilterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TBiquadFilterNodeConstructorFactory, TBiquadFilterType, TContext, TNativeBiquadFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    Q: 1,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    detune: 0,\n    frequency: 350,\n    gain: 0,\n    type: 'lowpass'\n} as const;\n\nexport const createBiquadFilterNodeConstructor: TBiquadFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class BiquadFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IBiquadFilterNode<T> {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _gain: IAudioParam;\n\n        private _nativeBiquadFilterNode: TNativeBiquadFilterNode;\n\n        private _Q: IAudioParam;\n\n        constructor(context: T, options?: Partial<IBiquadFilterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const biquadFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createBiquadFilterNodeRenderer() : null);\n\n            super(context, false, nativeBiquadFilterNode, biquadFilterNodeRenderer);\n\n            // Bug #80: Safari does not export the correct values for maxValue and minValue.\n            this._Q = createAudioParam(this, isOffline, nativeBiquadFilterNode.Q, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n            // Bug #78: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.detune,\n                1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT),\n                -1200 * Math.log2(MOST_POSITIVE_SINGLE_FLOAT)\n            );\n            // Bug #77: Firefox & Safari do not export the correct value for minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeBiquadFilterNode.frequency, context.sampleRate / 2, 0);\n            // Bug #79: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(\n                this,\n                isOffline,\n                nativeBiquadFilterNode.gain,\n                40 * Math.log10(MOST_POSITIVE_SINGLE_FLOAT),\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._nativeBiquadFilterNode = nativeBiquadFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n\n        get Q(): IAudioParam {\n            return this._Q;\n        }\n\n        get type(): TBiquadFilterType {\n            return this._nativeBiquadFilterNode.type;\n        }\n\n        set type(value) {\n            this._nativeBiquadFilterNode.type = value;\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            // Bug #189: Safari does throw an InvalidStateError.\n            try {\n                this._nativeBiquadFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n            } catch (err) {\n                if (err.code === 11) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            // Bug #68: Safari does not throw an error if the parameters differ in their length.\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IBiquadFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TBiquadFilterNodeRendererFactoryFactory, TNativeBiquadFilterNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createBiquadFilterNodeRendererFactory: TBiquadFilterNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeBiquadFilterNodes = new WeakMap<TNativeOfflineAudioContext, TNativeBiquadFilterNode>();\n\n        const createBiquadFilterNode = async (proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeBiquadFilterNode = getNativeAudioNode<T, TNativeBiquadFilterNode>(proxy);\n\n            /*\n             * If the initially used nativeBiquadFilterNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeBiquadFilterNodeIsOwnedByContext = isOwnedByContext(nativeBiquadFilterNode, nativeOfflineAudioContext);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                const options = {\n                    Q: nativeBiquadFilterNode.Q.value,\n                    channelCount: nativeBiquadFilterNode.channelCount,\n                    channelCountMode: nativeBiquadFilterNode.channelCountMode,\n                    channelInterpretation: nativeBiquadFilterNode.channelInterpretation,\n                    detune: nativeBiquadFilterNode.detune.value,\n                    frequency: nativeBiquadFilterNode.frequency.value,\n                    gain: nativeBiquadFilterNode.gain.value,\n                    type: nativeBiquadFilterNode.type\n                };\n\n                nativeBiquadFilterNode = createNativeBiquadFilterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeBiquadFilterNodes.set(nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            if (!nativeBiquadFilterNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.Q, nativeBiquadFilterNode.Q);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeBiquadFilterNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeBiquadFilterNode.frequency);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeBiquadFilterNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeBiquadFilterNode);\n\n            return nativeBiquadFilterNode;\n        };\n\n        return {\n            render(proxy: IBiquadFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeBiquadFilterNode> {\n                const renderedNativeBiquadFilterNode = renderedNativeBiquadFilterNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeBiquadFilterNode !== undefined) {\n                    return Promise.resolve(renderedNativeBiquadFilterNode);\n                }\n\n                return createBiquadFilterNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TCacheTestResultFactory } from '../types';\n\nexport const createCacheTestResult: TCacheTestResultFactory = (ongoingTests, testResults) => {\n    return (tester, test) => {\n        const cachedTestResult = testResults.get(tester);\n\n        if (cachedTestResult !== undefined) {\n            return cachedTestResult;\n        }\n\n        const ongoingTest = ongoingTests.get(tester);\n\n        if (ongoingTest !== undefined) {\n            return ongoingTest;\n        }\n\n        try {\n            const synchronousTestResult = test();\n\n            if (synchronousTestResult instanceof Promise) {\n                ongoingTests.set(tester, synchronousTestResult);\n\n                return synchronousTestResult\n                    .catch(() => false)\n                    .then((finalTestResult) => {\n                        ongoingTests.delete(tester);\n                        testResults.set(tester, finalTestResult);\n\n                        return finalTestResult;\n                    });\n            }\n\n            testResults.set(tester, synchronousTestResult);\n\n            return synchronousTestResult;\n        } catch {\n            testResults.set(tester, false);\n\n            return false;\n        }\n    };\n};\n", "import { IChannelMergerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelMergerNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 6\n} as const;\n\nexport const createChannelMergerNodeConstructor: TChannelMergerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class ChannelMergerNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelMergerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeChannelMergerNode = createNativeChannelMergerNode(nativeContext, mergedOptions);\n            const channelMergerNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelMergerNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelMergerNode, channelMergerNodeRenderer);\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelMergerNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelMergerNodeRendererFactory: TChannelMergerNodeRendererFactoryFactory = (\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfInputs: nativeAudioNode.numberOfInputs\n                };\n\n                nativeAudioNode = createNativeChannelMergerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IChannelSplitterOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TChannelSplitterNodeConstructorFactory, TContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 6,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete',\n    numberOfOutputs: 6\n} as const;\n\nexport const createChannelSplitterNodeConstructor: TChannelSplitterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n) => {\n    return class ChannelSplitterNode<T extends TContext> extends audioNodeConstructor<T> {\n        constructor(context: T, options?: Partial<IChannelSplitterOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizeChannelSplitterOptions({ ...DEFAULT_OPTIONS, ...options });\n            const nativeChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, mergedOptions);\n            const channelSplitterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isNativeOfflineAudioContext(nativeContext) ? createChannelSplitterNodeRenderer() : null)\n            );\n\n            super(context, false, nativeChannelSplitterNode, channelSplitterNodeRenderer);\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IAudioNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TChannelSplitterNodeRendererFactoryFactory, TNativeAudioNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createChannelSplitterNodeRendererFactory: TChannelSplitterNodeRendererFactoryFactory = (\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioNode>();\n\n        const createAudioNode = async (proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioNode = getNativeAudioNode<T, TNativeAudioNode>(proxy);\n\n            // If the initially used nativeAudioNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeAudioNodeIsOwnedByContext = isOwnedByContext(nativeAudioNode, nativeOfflineAudioContext);\n\n            if (!nativeAudioNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeAudioNode.channelCount,\n                    channelCountMode: nativeAudioNode.channelCountMode,\n                    channelInterpretation: nativeAudioNode.channelInterpretation,\n                    numberOfOutputs: nativeAudioNode.numberOfOutputs\n                };\n\n                nativeAudioNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeAudioNode);\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioNode);\n\n            return nativeAudioNode;\n        };\n\n        return {\n            render(proxy: IAudioNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeAudioNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TConnectAudioParamFactory } from '../types';\n\nexport const createConnectAudioParam: TConnectAudioParamFactory = (renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TConnectMultipleOutputsFactory } from '../types';\n\nexport const createConnectMultipleOutputs: TConnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destination, output = 0, input = 0) => {\n        const outputAudioNode = outputAudioNodes[output];\n\n        if (outputAudioNode === undefined) {\n            throw createIndexSizeError();\n        }\n\n        if (isNativeAudioNode(destination)) {\n            return outputAudioNode.connect(destination, 0, input);\n        }\n\n        return outputAudioNode.connect(destination, 0);\n    };\n};\n", "import { TConnectedNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createConnectedNativeAudioBufferSourceNodeFactory: TConnectedNativeAudioBufferSourceNodeFactoryFactory = (\n    createNativeAudioBufferSourceNode\n) => {\n    return (nativeContext, nativeAudioNode) => {\n        const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const nativeAudioBuffer = nativeContext.createBuffer(1, 2, 44100);\n\n        nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n        nativeAudioBufferSourceNode.loop = true;\n\n        nativeAudioBufferSourceNode.connect(nativeAudioNode);\n        nativeAudioBufferSourceNode.start();\n\n        return () => {\n            nativeAudioBufferSourceNode.stop();\n            nativeAudioBufferSourceNode.disconnect(nativeAudioNode);\n        };\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioParam, IAudioScheduledSourceNodeEventMap, IConstantSourceNode, IConstantSourceOptions } from '../interfaces';\nimport {\n    TConstantSourceNodeConstructorFactory,\n    TConstantSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeConstantSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    offset: 1\n} as const;\n\nexport const createConstantSourceNodeConstructor: TConstantSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRendererFactory,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class ConstantSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IConstantSourceNode<T>\n    {\n        private _constantSourceNodeRenderer: TConstantSourceNodeRenderer<T>;\n\n        private _nativeConstantSourceNode: TNativeConstantSourceNode;\n\n        private _offset: IAudioParam;\n\n        private _onended: null | TEventHandler<this>;\n\n        constructor(context: T, options?: Partial<IConstantSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConstantSourceNode = createNativeConstantSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const constantSourceNodeRenderer = <TConstantSourceNodeRenderer<T>>(\n                (isOffline ? createConstantSourceNodeRendererFactory() : null)\n            );\n\n            super(context, false, nativeConstantSourceNode, constantSourceNodeRenderer);\n\n            this._constantSourceNodeRenderer = constantSourceNodeRenderer;\n            this._nativeConstantSourceNode = nativeConstantSourceNode;\n            /*\n             * Bug #62 & #74: Safari does not support ConstantSourceNodes and does not export the correct values for maxValue and minValue\n             * for GainNodes.\n             */\n            this._offset = createAudioParam(\n                this,\n                isOffline,\n                nativeConstantSourceNode.offset,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._onended = null;\n        }\n\n        get offset(): IAudioParam {\n            return this._offset;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeConstantSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeConstantSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        public start(when = 0): void {\n            this._nativeConstantSourceNode.start(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeConstantSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeConstantSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeConstantSourceNode.stop(when);\n\n            if (this._constantSourceNodeRenderer !== null) {\n                this._constantSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConstantSourceNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConstantSourceNodeRendererFactoryFactory, TNativeConstantSourceNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConstantSourceNodeRendererFactory: TConstantSourceNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConstantSourceNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConstantSourceNode>();\n\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createConstantSourceNode = async (proxy: IConstantSourceNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConstantSourceNode = getNativeAudioNode<T, TNativeConstantSourceNode>(proxy);\n\n            /*\n             * If the initially used nativeConstantSourceNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeConstantSourceNodeIsOwnedByContext = isOwnedByContext(nativeConstantSourceNode, nativeOfflineAudioContext);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeConstantSourceNode.channelCount,\n                    channelCountMode: nativeConstantSourceNode.channelCountMode,\n                    channelInterpretation: nativeConstantSourceNode.channelInterpretation,\n                    offset: nativeConstantSourceNode.offset.value\n                };\n\n                nativeConstantSourceNode = createNativeConstantSourceNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeConstantSourceNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeConstantSourceNode.stop(stop);\n                }\n            }\n\n            renderedNativeConstantSourceNodes.set(nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            if (!nativeConstantSourceNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.offset, nativeConstantSourceNode.offset);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConstantSourceNode);\n\n            return nativeConstantSourceNode;\n        };\n\n        return {\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(\n                proxy: IConstantSourceNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeConstantSourceNode> {\n                const renderedNativeConstantSourceNode = renderedNativeConstantSourceNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConstantSourceNode !== undefined) {\n                    return Promise.resolve(renderedNativeConstantSourceNode);\n                }\n\n                return createConstantSourceNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TConvertNumberToUnsignedLongFactory } from '../types';\n\nexport const createConvertNumberToUnsignedLong: TConvertNumberToUnsignedLongFactory = (unit32Array) => {\n    return (value) => {\n        unit32Array[0] = value;\n\n        return unit32Array[0];\n    };\n};\n", "import { IConvolverNode, IConvolverOptions } from '../interfaces';\nimport { TAnyAudioBuffer, TAudioNodeRenderer, TContext, TConvolverNodeConstructorFactory, TNativeConvolverNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    disableNormalization: false\n} as const;\n\nexport const createConvolverNodeConstructor: TConvolverNodeConstructorFactory = (\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class ConvolverNode<T extends TContext> extends audioNodeConstructor<T> implements IConvolverNode<T> {\n        private _isBufferNullified: boolean;\n\n        private _nativeConvolverNode: TNativeConvolverNode;\n\n        constructor(context: T, options?: Partial<IConvolverOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeConvolverNode = createNativeConvolverNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const convolverNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createConvolverNodeRenderer() : null);\n\n            super(context, false, nativeConvolverNode, convolverNodeRenderer);\n\n            this._isBufferNullified = false;\n            this._nativeConvolverNode = nativeConvolverNode;\n\n            if (mergedOptions.buffer !== null) {\n                setAudioNodeTailTime(this, mergedOptions.buffer.duration);\n            }\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeConvolverNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeConvolverNode.buffer = value;\n\n            // Bug #115: Safari does not allow to set the buffer to null.\n            if (value === null && this._nativeConvolverNode.buffer !== null) {\n                const nativeContext = this._nativeConvolverNode.context;\n\n                this._nativeConvolverNode.buffer = nativeContext.createBuffer(1, 1, nativeContext.sampleRate);\n                this._isBufferNullified = true;\n\n                setAudioNodeTailTime(this, 0);\n            } else {\n                this._isBufferNullified = false;\n\n                setAudioNodeTailTime(this, this._nativeConvolverNode.buffer === null ? 0 : this._nativeConvolverNode.buffer.duration);\n            }\n        }\n\n        get normalize(): boolean {\n            return this._nativeConvolverNode.normalize;\n        }\n\n        set normalize(value) {\n            this._nativeConvolverNode.normalize = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IConvolverNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TConvolverNodeRendererFactoryFactory, TNativeConvolverNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createConvolverNodeRendererFactory: TConvolverNodeRendererFactoryFactory = (\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeConvolverNodes = new WeakMap<TNativeOfflineAudioContext, TNativeConvolverNode>();\n\n        const createConvolverNode = async (proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeConvolverNode = getNativeAudioNode<T, TNativeConvolverNode>(proxy);\n\n            // If the initially used nativeConvolverNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeConvolverNodeIsOwnedByContext = isOwnedByContext(nativeConvolverNode, nativeOfflineAudioContext);\n\n            if (!nativeConvolverNodeIsOwnedByContext) {\n                const options = {\n                    buffer: nativeConvolverNode.buffer,\n                    channelCount: nativeConvolverNode.channelCount,\n                    channelCountMode: nativeConvolverNode.channelCountMode,\n                    channelInterpretation: nativeConvolverNode.channelInterpretation,\n                    disableNormalization: !nativeConvolverNode.normalize\n                };\n\n                nativeConvolverNode = createNativeConvolverNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeConvolverNodes.set(nativeOfflineAudioContext, nativeConvolverNode);\n\n            if (isNativeAudioNodeFaker(nativeConvolverNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeConvolverNode);\n            }\n\n            return nativeConvolverNode;\n        };\n\n        return {\n            render(proxy: IConvolverNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeConvolverNode> {\n                const renderedNativeConvolverNode = renderedNativeConvolverNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeConvolverNode !== undefined) {\n                    return Promise.resolve(renderedNativeConvolverNode);\n                }\n\n                return createConvolverNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TCreateNativeOfflineAudioContextFactory } from '../types';\n\nexport const createCreateNativeOfflineAudioContext: TCreateNativeOfflineAudioContextFactory = (\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (numberOfChannels, length, sampleRate) => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        try {\n            return new nativeOfflineAudioContextConstructor(numberOfChannels, length, sampleRate);\n        } catch (err) {\n            // Bug #143, #144 & #146: Safari throws a SyntaxError when numberOfChannels, length or sampleRate are invalid.\n            if (err.name === 'SyntaxError') {\n                throw createNotSupportedError();\n            }\n\n            throw err;\n        }\n    };\n};\n", "import { TDataCloneErrorFactory } from '../types';\n\nexport const createDataCloneError: TDataCloneErrorFactory = () => new DOMException('', 'DataCloneError');\n", "export const detachArrayBuffer = (arrayBuffer: ArrayBuffer): Promise<void> => {\n    const { port1, port2 } = new MessageChannel();\n\n    return new Promise((resolve) => {\n        const closeAndResolve = () => {\n            port2.onmessage = null;\n\n            port1.close();\n            port2.close();\n\n            resolve();\n        };\n\n        port2.onmessage = () => closeAndResolve();\n\n        try {\n            port1.postMessage(arrayBuffer, [arrayBuffer]);\n        } catch {\n            // Ignore errors.\n        } finally {\n            closeAndResolve();\n        }\n    });\n};\n", "import { detachArrayBuffer } from '../helpers/detach-array-buffer';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TDecodeAudioDataFactory } from '../types';\n\nexport const createDecodeAudioData: TDecodeAudioDataFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    detachedArrayBuffers,\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (anyContext, audioData) => {\n        const nativeContext = isNativeContext(anyContext) ? anyContext : getNativeContext(anyContext);\n\n        // Bug #43: Only Chrome and Edge do throw a DataCloneError.\n        if (detachedArrayBuffers.has(audioData)) {\n            const err = createDataCloneError();\n\n            return Promise.reject(err);\n        }\n\n        // The audioData parameter maybe of a type which can't be added to a WeakSet.\n        try {\n            detachedArrayBuffers.add(audioData);\n        } catch {\n            // Ignore errors.\n        }\n\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeContext))) {\n            return nativeContext.decodeAudioData(audioData).then((audioBuffer) => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                detachArrayBuffer(audioData).catch(() => {\n                    // Ignore errors.\n                });\n\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n        }\n\n        // Bug #21: Safari does not return a Promise yet.\n        return new Promise((resolve, reject) => {\n            const complete = async () => {\n                // Bug #133: Safari does neuter the ArrayBuffer.\n                try {\n                    await detachArrayBuffer(audioData);\n                } catch {\n                    // Ignore errors.\n                }\n            };\n\n            const fail = (err: DOMException | Error) => {\n                reject(err);\n                complete();\n            };\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                // Bug #1: Safari requires a successCallback.\n                nativeContext.decodeAudioData(\n                    audioData,\n                    (audioBuffer) => {\n                        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                        // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                        if (typeof audioBuffer.copyFromChannel !== 'function') {\n                            wrapAudioBufferCopyChannelMethods(audioBuffer);\n                            wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                        }\n\n                        audioBufferStore.add(audioBuffer);\n\n                        complete().then(() => resolve(audioBuffer));\n                    },\n                    (err: DOMException | Error) => {\n                        // Bug #4: Safari returns null instead of an error.\n                        if (err === null) {\n                            fail(createEncodingError());\n                        } else {\n                            fail(err);\n                        }\n                    }\n                );\n            } catch (err) {\n                fail(err);\n            }\n        });\n    };\n};\n", "import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TDecrementCycleCounterFactory } from '../types';\n\nexport const createDecrementCycleCounter: TDecrementCycleCounterFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    cycleCounters,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    getNativeContext,\n    isActiveAudioNode,\n    isNativeOfflineAudioContext\n) => {\n    return (audioNode, count) => {\n        const cycleCounter = cycleCounters.get(audioNode);\n\n        if (cycleCounter === undefined) {\n            throw new Error('Missing the expected cycle count.');\n        }\n\n        const nativeContext = getNativeContext(audioNode.context);\n        const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n        if (cycleCounter === count) {\n            cycleCounters.delete(audioNode);\n\n            if (!isOffline && isActiveAudioNode(audioNode)) {\n                const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                const { outputs } = getAudioNodeConnections(audioNode);\n\n                for (const output of outputs) {\n                    if (isAudioNodeOutputConnection(output)) {\n                        const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                        connectNativeAudioNodeToNativeAudioNode(nativeSourceAudioNode, nativeDestinationAudioNode, output[1], output[2]);\n                    } else {\n                        const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                        nativeSourceAudioNode.connect(nativeDestinationAudioParam, output[1]);\n                    }\n                }\n            }\n        } else {\n            cycleCounters.set(audioNode, cycleCounter - count);\n        }\n    };\n};\n", "import { IAudioParam, IDelayNode, IDelayOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TDelayNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    delayTime: 0,\n    maxDelayTime: 1\n} as const;\n\nexport const createDelayNodeConstructor: TDelayNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DelayNode<T extends TContext> extends audioNodeConstructor<T> implements IDelayNode<T> {\n        private _delayTime: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDelayOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDelayNode = createNativeDelayNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const delayNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDelayNodeRenderer(mergedOptions.maxDelayTime) : null);\n\n            super(context, false, nativeDelayNode, delayNodeRenderer);\n\n            this._delayTime = createAudioParam(this, isOffline, nativeDelayNode.delayTime);\n\n            setAudioNodeTailTime(this, mergedOptions.maxDelayTime);\n        }\n\n        get delayTime(): IAudioParam {\n            return this._delayTime;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDelayNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDelayNodeRendererFactoryFactory, TNativeDelayNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDelayNodeRendererFactory: TDelayNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(maxDelayTime: number) => {\n        const renderedNativeDelayNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDelayNode>();\n\n        const createDelayNode = async (proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeDelayNode = getNativeAudioNode<T, TNativeDelayNode>(proxy);\n\n            // If the initially used nativeDelayNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeDelayNodeIsOwnedByContext = isOwnedByContext(nativeDelayNode, nativeOfflineAudioContext);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeDelayNode.channelCount,\n                    channelCountMode: nativeDelayNode.channelCountMode,\n                    channelInterpretation: nativeDelayNode.channelInterpretation,\n                    delayTime: nativeDelayNode.delayTime.value,\n                    maxDelayTime\n                };\n\n                nativeDelayNode = createNativeDelayNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDelayNodes.set(nativeOfflineAudioContext, nativeDelayNode);\n\n            if (!nativeDelayNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.delayTime, nativeDelayNode.delayTime);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDelayNode);\n\n            return nativeDelayNode;\n        };\n\n        return {\n            render(proxy: IDelayNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeDelayNode> {\n                const renderedNativeDelayNode = renderedNativeDelayNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDelayNode !== undefined) {\n                    return Promise.resolve(renderedNativeDelayNode);\n                }\n\n                return createDelayNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TDeleteActiveInputConnectionToAudioNodeFactory } from '../types';\n\nexport const createDeleteActiveInputConnectionToAudioNode: TDeleteActiveInputConnectionToAudioNodeFactory = (pickElementFromSet) => {\n    return (activeInputs, source, output, input) => {\n        return pickElementFromSet(\n            activeInputs[input],\n            (activeInputConnection) => activeInputConnection[0] === source && activeInputConnection[1] === output\n        );\n    };\n};\n", "import { TDeleteUnrenderedAudioWorkletNodeFactory } from '../types';\n\nexport const createDeleteUnrenderedAudioWorkletNode: TDeleteUnrenderedAudioWorkletNodeFactory = (getUnrenderedAudioWorkletNodes) => {\n    return (nativeContext, audioWorkletNode) => {\n        getUnrenderedAudioWorkletNodes(nativeContext).delete(audioWorkletNode);\n    };\n};\n", "import { IAudioNode, IDelayNode } from '../interfaces';\nimport { TContext } from '../types';\n\nexport const isDelayNode = <T extends TContext>(audioNode: IAudioNode<T>): audioNode is IDelayNode<T> => {\n    return 'delayTime' in audioNode;\n};\n", "import { isAudioNode } from '../guards/audio-node';\nimport { isDelayNode } from '../guards/delay-node';\nimport { IAudioNode, IAudioParam } from '../interfaces';\nimport { TContext, TDetectCyclesFactory } from '../types';\n\nexport const createDetectCycles: TDetectCyclesFactory = (audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey) => {\n    return function detectCycles<T extends TContext>(chain: IAudioNode<T>[], nextLink: IAudioNode<T> | IAudioParam): IAudioNode<T>[][] {\n        const audioNode = isAudioNode(nextLink) ? nextLink : <IAudioNode<T>>getValueForKey(audioParamAudioNodeStore, nextLink);\n\n        if (isDelayNode(audioNode)) {\n            return [];\n        }\n\n        if (chain[0] === audioNode) {\n            return [chain];\n        }\n\n        if (chain.includes(audioNode)) {\n            return [];\n        }\n\n        const { outputs } = getAudioNodeConnections(audioNode);\n\n        return Array.from(outputs)\n            .map((outputConnection) => detectCycles([...chain, audioNode], outputConnection[0]))\n            .reduce((mergedCycles, nestedCycles) => mergedCycles.concat(nestedCycles), []);\n    };\n};\n", "import { isNativeAudioNode } from '../guards/native-audio-node';\nimport { TDisconnectMultipleOutputsFactory, TIndexSizeErrorFactory, TNativeAudioNode } from '../types';\n\nconst getOutputAudioNodeAtIndex = (\n    createIndexSizeError: TIndexSizeErrorFactory,\n    outputAudioNodes: TNativeAudioNode[],\n    output: number\n): TNativeAudioNode => {\n    const outputAudioNode = outputAudioNodes[output];\n\n    if (outputAudioNode === undefined) {\n        throw createIndexSizeError();\n    }\n\n    return outputAudioNode;\n};\n\nexport const createDisconnectMultipleOutputs: TDisconnectMultipleOutputsFactory = (createIndexSizeError) => {\n    return (outputAudioNodes, destinationOrOutput = undefined, output = undefined, input = 0) => {\n        if (destinationOrOutput === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect());\n        }\n\n        if (typeof destinationOrOutput === 'number') {\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, destinationOrOutput).disconnect();\n        }\n\n        if (isNativeAudioNode(destinationOrOutput)) {\n            if (output === undefined) {\n                return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n            }\n\n            if (input === undefined) {\n                return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n            }\n\n            return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0, input);\n        }\n\n        if (output === undefined) {\n            return outputAudioNodes.forEach((outputAudioNode) => outputAudioNode.disconnect(destinationOrOutput));\n        }\n\n        return getOutputAudioNodeAtIndex(createIndexSizeError, outputAudioNodes, output).disconnect(destinationOrOutput, 0);\n    };\n};\n", "import { IAudioParam, IDynamicsCompressorNode, IDynamicsCompressorOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TChannelCountMode,\n    TContext,\n    TDynamicsCompressorNodeConstructorFactory,\n    TNativeAudioParam,\n    TNativeDynamicsCompressorNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    attack: 0.003,\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    knee: 30,\n    ratio: 12,\n    release: 0.25,\n    threshold: -24\n} as const;\n\nexport const createDynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class DynamicsCompressorNode<T extends TContext> extends audioNodeConstructor<T> implements IDynamicsCompressorNode<T> {\n        private _attack: IAudioParam;\n\n        private _knee: IAudioParam;\n\n        private _nativeDynamicsCompressorNode: TNativeDynamicsCompressorNode;\n\n        private _ratio: IAudioParam;\n\n        private _release: IAudioParam;\n\n        private _threshold: IAudioParam;\n\n        constructor(context: T, options?: Partial<IDynamicsCompressorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const dynamicsCompressorNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createDynamicsCompressorNodeRenderer() : null);\n\n            super(context, false, nativeDynamicsCompressorNode, dynamicsCompressorNodeRenderer);\n\n            this._attack = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.attack);\n            this._knee = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.knee);\n            this._nativeDynamicsCompressorNode = nativeDynamicsCompressorNode;\n            this._ratio = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.ratio);\n            this._release = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.release);\n            this._threshold = createAudioParam(this, isOffline, nativeDynamicsCompressorNode.threshold);\n\n            setAudioNodeTailTime(this, 0.006);\n        }\n\n        get attack(): IAudioParam {\n            return this._attack;\n        }\n\n        // Bug #108: Safari allows a channelCount of three and above which is why the getter and setter needs to be overwritten here.\n        get channelCount(): number {\n            return this._nativeDynamicsCompressorNode.channelCount;\n        }\n\n        set channelCount(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCount;\n\n            this._nativeDynamicsCompressorNode.channelCount = value;\n\n            if (value > 2) {\n                this._nativeDynamicsCompressorNode.channelCount = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        /*\n         * Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max' yet which is why the getter and setter needs to be\n         * overwritten here.\n         */\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeDynamicsCompressorNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            const previousChannelCount = this._nativeDynamicsCompressorNode.channelCountMode;\n\n            this._nativeDynamicsCompressorNode.channelCountMode = value;\n\n            if (value === 'max') {\n                this._nativeDynamicsCompressorNode.channelCountMode = previousChannelCount;\n\n                throw createNotSupportedError();\n            }\n        }\n\n        get knee(): IAudioParam {\n            return this._knee;\n        }\n\n        get ratio(): IAudioParam {\n            return this._ratio;\n        }\n\n        get reduction(): number {\n            // Bug #111: Safari returns an AudioParam instead of a number.\n            if (typeof (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value === 'number') {\n                return (<TNativeAudioParam>(<any>this._nativeDynamicsCompressorNode.reduction)).value;\n            }\n\n            return this._nativeDynamicsCompressorNode.reduction;\n        }\n\n        get release(): IAudioParam {\n            return this._release;\n        }\n\n        get threshold(): IAudioParam {\n            return this._threshold;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IDynamicsCompressorNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TDynamicsCompressorNodeRendererFactoryFactory, TNativeDynamicsCompressorNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createDynamicsCompressorNodeRendererFactory: TDynamicsCompressorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeDynamicsCompressorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeDynamicsCompressorNode>();\n\n        const createDynamicsCompressorNode = async (\n            proxy: IDynamicsCompressorNode<T>,\n            nativeOfflineAudioContext: TNativeOfflineAudioContext\n        ) => {\n            let nativeDynamicsCompressorNode = getNativeAudioNode<T, TNativeDynamicsCompressorNode>(proxy);\n\n            /*\n             * If the initially used nativeDynamicsCompressorNode was not constructed on the same OfflineAudioContext it needs to be\n             * created again.\n             */\n            const nativeDynamicsCompressorNodeIsOwnedByContext = isOwnedByContext(nativeDynamicsCompressorNode, nativeOfflineAudioContext);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                const options = {\n                    attack: nativeDynamicsCompressorNode.attack.value,\n                    channelCount: nativeDynamicsCompressorNode.channelCount,\n                    channelCountMode: nativeDynamicsCompressorNode.channelCountMode,\n                    channelInterpretation: nativeDynamicsCompressorNode.channelInterpretation,\n                    knee: nativeDynamicsCompressorNode.knee.value,\n                    ratio: nativeDynamicsCompressorNode.ratio.value,\n                    release: nativeDynamicsCompressorNode.release.value,\n                    threshold: nativeDynamicsCompressorNode.threshold.value\n                };\n\n                nativeDynamicsCompressorNode = createNativeDynamicsCompressorNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeDynamicsCompressorNodes.set(nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            if (!nativeDynamicsCompressorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await renderAutomation(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await renderAutomation(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await renderAutomation(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await renderAutomation(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.attack, nativeDynamicsCompressorNode.attack);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.knee, nativeDynamicsCompressorNode.knee);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.ratio, nativeDynamicsCompressorNode.ratio);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.release, nativeDynamicsCompressorNode.release);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.threshold, nativeDynamicsCompressorNode.threshold);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeDynamicsCompressorNode);\n\n            return nativeDynamicsCompressorNode;\n        };\n\n        return {\n            render(\n                proxy: IDynamicsCompressorNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeDynamicsCompressorNode> {\n                const renderedNativeDynamicsCompressorNode = renderedNativeDynamicsCompressorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeDynamicsCompressorNode !== undefined) {\n                    return Promise.resolve(renderedNativeDynamicsCompressorNode);\n                }\n\n                return createDynamicsCompressorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TEncodingErrorFactory } from '../types';\n\nexport const createEncodingError: TEncodingErrorFactory = () => new DOMException('', 'EncodingError');\n", "import { TEvaluateSourceFactory } from '../types';\n\nexport const createEvaluateSource: TEvaluateSourceFactory = (window) => {\n    return (source) =>\n        new Promise((resolve, reject) => {\n            if (window === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n\n                return;\n            }\n\n            const head = window.document.head;\n\n            if (head === null) {\n                // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                reject(new SyntaxError());\n            } else {\n                const script = window.document.createElement('script');\n                // @todo Safari doesn't like URLs with a type of 'application/javascript; charset=utf-8'.\n                const blob = new Blob([source], { type: 'application/javascript' });\n                const url = URL.createObjectURL(blob);\n\n                const originalOnErrorHandler = window.onerror;\n\n                const removeErrorEventListenerAndRevokeUrl = () => {\n                    window.onerror = originalOnErrorHandler;\n\n                    URL.revokeObjectURL(url);\n                };\n\n                window.onerror = (message, src, lineno, colno, error) => {\n                    // @todo Edge thinks the source is the one of the html document.\n                    if (src === url || (src === window.location.href && lineno === 1 && colno === 1)) {\n                        removeErrorEventListenerAndRevokeUrl();\n                        reject(error);\n\n                        return false;\n                    }\n\n                    if (originalOnErrorHandler !== null) {\n                        return originalOnErrorHandler(message, src, lineno, colno, error);\n                    }\n                };\n\n                script.onerror = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    // Bug #182 Chrome and Edge do throw an instance of a SyntaxError instead of a DOMException.\n                    reject(new SyntaxError());\n                };\n                script.onload = () => {\n                    removeErrorEventListenerAndRevokeUrl();\n                    resolve();\n                };\n                script.src = url;\n                script.type = 'module';\n\n                head.appendChild(script);\n            }\n        });\n};\n", "import { IEventTarget } from '../interfaces';\nimport { TEventHandler, TEventTargetConstructorFactory, TNativeEventTarget } from '../types';\n\nexport const createEventTargetConstructor: TEventTargetConstructorFactory = (wrapEventListener) => {\n    return class EventTarget<EventMap extends Record<string, Event>> implements IEventTarget<EventMap> {\n        private _listeners: WeakMap<EventListenerOrEventListenerObject, EventListenerOrEventListenerObject>;\n\n        constructor(private _nativeEventTarget: TNativeEventTarget) {\n            this._listeners = new WeakMap();\n        }\n\n        public addEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | AddEventListenerOptions\n        ): void {\n            if (listener !== null) {\n                let wrappedEventListener = this._listeners.get(listener);\n\n                if (wrappedEventListener === undefined) {\n                    wrappedEventListener = wrapEventListener(this, listener);\n\n                    if (typeof listener === 'function') {\n                        this._listeners.set(listener, wrappedEventListener);\n                    }\n                }\n\n                this._nativeEventTarget.addEventListener(type, wrappedEventListener, options);\n            }\n        }\n\n        public dispatchEvent(event: Event): boolean {\n            return this._nativeEventTarget.dispatchEvent(event);\n        }\n\n        public removeEventListener(\n            type: string,\n            listener: null | TEventHandler<this> | EventListenerOrEventListenerObject,\n            options?: boolean | EventListenerOptions\n        ): void {\n            const wrappedEventListener = listener === null ? undefined : this._listeners.get(listener);\n\n            this._nativeEventTarget.removeEventListener(type, wrappedEventListener === undefined ? null : wrappedEventListener, options);\n        }\n    };\n};\n", "import { TExposeCurrentFrameAndCurrentTimeFactory } from '../types';\n\nexport const createExposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFactory = (window) => {\n    return (currentTime, sampleRate, fn) => {\n        Object.defineProperties(window, {\n            currentFrame: {\n                configurable: true,\n                get(): number {\n                    return Math.round(currentTime * sampleRate);\n                }\n            },\n            currentTime: {\n                configurable: true,\n                get(): number {\n                    return currentTime;\n                }\n            }\n        });\n\n        try {\n            return fn();\n        } finally {\n            if (window !== null) {\n                delete (<any>window).currentFrame;\n                delete (<any>window).currentTime;\n            }\n        }\n    };\n};\n", "import { TFetchSourceFactory } from '../types';\n\nexport const createFetchSource: TFetchSourceFactory = (createAbortError) => {\n    return async (url) => {\n        try {\n            const response = await fetch(url);\n\n            if (response.ok) {\n                return [await response.text(), response.url];\n            }\n        } catch {\n            // Ignore errors.\n        } // tslint:disable-line:no-empty\n\n        throw createAbortError();\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IGainNode, IGainOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TGainNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    gain: 1\n} as const;\n\nexport const createGainNodeConstructor: TGainNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class GainNode<T extends TContext> extends audioNodeConstructor<T> implements IGainNode<T> {\n        private _gain: IAudioParam;\n\n        constructor(context: T, options?: Partial<IGainOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeGainNode = createNativeGainNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const gainNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createGainNodeRenderer() : null);\n\n            super(context, false, nativeGainNode, gainNodeRenderer);\n\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._gain = createAudioParam(this, isOffline, nativeGainNode.gain, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n        }\n\n        get gain(): IAudioParam {\n            return this._gain;\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IGainNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGainNodeRendererFactoryFactory, TNativeGainNode, TNativeOfflineAudioContext } from '../types';\n\nexport const createGainNodeRendererFactory: TGainNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeGainNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode>();\n\n        const createGainNode = async (proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode = getNativeAudioNode<T, TNativeGainNode>(proxy);\n\n            // If the initially used nativeGainNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeGainNodeIsOwnedByContext = isOwnedByContext(nativeGainNode, nativeOfflineAudioContext);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeGainNode.channelCount,\n                    channelCountMode: nativeGainNode.channelCountMode,\n                    channelInterpretation: nativeGainNode.channelInterpretation,\n                    gain: nativeGainNode.gain.value\n                };\n\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeGainNodes.set(nativeOfflineAudioContext, nativeGainNode);\n\n            if (!nativeGainNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.gain, nativeGainNode.gain);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeGainNode);\n\n            return nativeGainNode;\n        };\n\n        return {\n            render(proxy: IGainNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeGainNode> {\n                const renderedNativeGainNode = renderedNativeGainNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNode);\n                }\n\n                return createGainNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TActiveInputConnection, TContext, TGetActiveAudioWorkletNodeInputsFactory, TNativeAudioWorkletNode } from '../types';\n\nexport const createGetActiveAudioWorkletNodeInputs: TGetActiveAudioWorkletNodeInputsFactory = (\n    activeAudioWorkletNodeInputsStore,\n    getValueForKey\n) => {\n    return <T extends TContext>(nativeAudioWorkletNode: TNativeAudioWorkletNode) =>\n        <Set<TActiveInputConnection<T>>[]>getValueForKey(activeAudioWorkletNodeInputsStore, nativeAudioWorkletNode);\n};\n", "import { IAudioNode, IAudioNodeRenderer, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TGetAudioNodeRendererFactory } from '../types';\n\nexport const createGetAudioNodeRenderer: TGetAudioNodeRendererFactory = (getAudioNodeConnections) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioNode: IAudioNode<T>\n    ): IAudioNodeRenderer<T, IAudioNode<T>> => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        if (audioNodeConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioNode in the audio graph.');\n        }\n\n        return <IAudioNodeRenderer<T, IAudioNode<T>>>audioNodeConnections.renderer;\n    };\n};\n", "import { TGetAudioNodeTailTimeFactory } from '../types';\n\nexport const createGetAudioNodeTailTime: TGetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode) => audioNodeTailTimeStore.get(audioNode) ?? 0;\n};\n", "import { IMinimalOfflineAudioContext } from '../interfaces';\nimport { TGetAudioParamRendererFactory } from '../types';\n\nexport const createGetAudioParamRenderer: TGetAudioParamRendererFactory = (getAudioParamConnections) => {\n    return (audioParam) => {\n        const audioParamConnections = getAudioParamConnections<IMinimalOfflineAudioContext>(audioParam);\n\n        if (audioParamConnections.renderer === null) {\n            throw new Error('Missing the renderer of the given AudioParam in the audio graph.');\n        }\n\n        return audioParamConnections.renderer;\n    };\n};\n", "import { TGetBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetBackupOfflineAudioContext: TGetBackupOfflineAudioContextFactory = (backupOfflineAudioContextStore) => {\n    return (nativeContext) => {\n        return backupOfflineAudioContextStore.get(nativeContext);\n    };\n};\n", "import { TInvalidStateErrorFactory } from '../types';\n\nexport const createInvalidStateError: TInvalidStateErrorFactory = () => new DOMException('', 'InvalidStateError');\n", "import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TContext, TGetNativeContextFactory, TNativeAudioContext, TNativeOfflineAudioContext } from '../types';\nimport { createInvalidStateError } from './invalid-state-error';\n\nexport const createGetNativeContext: TGetNativeContextFactory = (contextStore) => {\n    return <T extends TContext>(\n        context: T\n    ): T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext => {\n        const nativeContext = contextStore.get(context);\n\n        if (nativeContext === undefined) {\n            throw createInvalidStateError();\n        }\n\n        return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? TNativeOfflineAudioContext : TNativeAudioContext>(\n            nativeContext\n        );\n    };\n};\n", "import { TGetOrCreateBackupOfflineAudioContextFactory } from '../types';\n\nexport const createGetOrCreateBackupOfflineAudioContext: TGetOrCreateBackupOfflineAudioContextFactory = (\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n) => {\n    return (nativeContext) => {\n        let backupOfflineAudioContext = backupOfflineAudioContextStore.get(nativeContext);\n\n        if (backupOfflineAudioContext !== undefined) {\n            return backupOfflineAudioContext;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            throw new Error('Missing the native OfflineAudioContext constructor.');\n        }\n\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        backupOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        backupOfflineAudioContextStore.set(nativeContext, backupOfflineAudioContext);\n\n        return backupOfflineAudioContext;\n    };\n};\n", "import { TGetUnrenderedAudioWorkletNodesFactory } from '../types';\n\nexport const createGetUnrenderedAudioWorkletNodes: TGetUnrenderedAudioWorkletNodesFactory = (unrenderedAudioWorkletNodeStore) => {\n    return (nativeContext) => {\n        const unrenderedAudioWorkletNodes = unrenderedAudioWorkletNodeStore.get(nativeContext);\n\n        if (unrenderedAudioWorkletNodes === undefined) {\n            throw new Error('The context has no set of AudioWorkletNodes.');\n        }\n\n        return unrenderedAudioWorkletNodes;\n    };\n};\n", "import { TInvalidAccessErrorFactory } from '../types';\n\nexport const createInvalidAccessError: TInvalidAccessErrorFactory = () => new DOMException('', 'InvalidAccessError');\n", "import { createInvalidAccessError } from '../factories/invalid-access-error';\nimport { TNativeIIRFilterNode } from '../types';\n\nexport const wrapIIRFilterNodeGetFrequencyResponseMethod = (nativeIIRFilterNode: TNativeIIRFilterNode): void => {\n    nativeIIRFilterNode.getFrequencyResponse = ((getFrequencyResponse) => {\n        return (frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array) => {\n            if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                throw createInvalidAccessError();\n            }\n\n            return getFrequencyResponse.call(nativeIIRFilterNode, frequencyHz, magResponse, phaseResponse);\n        };\n    })(nativeIIRFilterNode.getFrequencyResponse);\n};\n", "import { wrapIIRFilterNodeGetFrequencyResponseMethod } from '../helpers/wrap-iir-filter-node-get-frequency-response-method';\nimport { IIIRFilterNode, IIIRFilterOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TIIRFilterNodeConstructorFactory, TNativeIIRFilterNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createIIRFilterNodeConstructor: TIIRFilterNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class IIRFilterNode<T extends TContext> extends audioNodeConstructor<T> implements IIIRFilterNode<T> {\n        private _nativeIIRFilterNode: TNativeIIRFilterNode;\n\n        constructor(\n            context: T,\n            options: { feedback: IIIRFilterOptions['feedback']; feedforward: IIIRFilterOptions['feedforward'] } & Partial<IIIRFilterOptions>\n        ) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeIIRFilterNode = createNativeIIRFilterNode(\n                nativeContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                mergedOptions\n            );\n            const iirFilterNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createIIRFilterNodeRenderer(mergedOptions.feedback, mergedOptions.feedforward) : null)\n            );\n\n            super(context, false, nativeIIRFilterNode, iirFilterNodeRenderer);\n\n            // Bug #23 & #24: FirefoxDeveloper does not throw an InvalidAccessError.\n            // @todo Write a test which allows other browsers to remain unpatched.\n            wrapIIRFilterNodeGetFrequencyResponseMethod(nativeIIRFilterNode);\n\n            this._nativeIIRFilterNode = nativeIIRFilterNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        public getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n            return this._nativeIIRFilterNode.getFrequencyResponse(frequencyHz, magResponse, phaseResponse);\n        }\n    };\n};\n", "// This implementation as shamelessly inspired by source code of\n// tslint:disable-next-line:max-line-length\n// {@link https://chromium.googlesource.com/chromium/src.git/+/master/third_party/WebKit/Source/platform/audio/IIRFilter.cpp|Chromium's IIRFilter}.\nexport const filterBuffer = (\n    feedback: Float64Array,\n    feedbackLength: number,\n    feedforward: Float64Array,\n    feedforwardLength: number,\n    minLength: number,\n    xBuffer: Float32Array,\n    yBuffer: Float32Array,\n    bufferIndex: number,\n    bufferLength: number,\n    input: Float32Array,\n    output: Float32Array\n) => {\n    const inputLength = input.length;\n\n    let i = bufferIndex;\n\n    for (let j = 0; j < inputLength; j += 1) {\n        let y = feedforward[0] * input[j];\n\n        for (let k = 1; k < minLength; k += 1) {\n            const x = (i - k) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n            y += feedforward[k] * xBuffer[x];\n            y -= feedback[k] * yBuffer[x];\n        }\n\n        for (let k = minLength; k < feedforwardLength; k += 1) {\n            y += feedforward[k] * xBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        for (let k = minLength; k < feedbackLength; k += 1) {\n            y -= feedback[k] * yBuffer[(i - k) & (bufferLength - 1)]; // tslint:disable-line:no-bitwise\n        }\n\n        xBuffer[i] = input[j];\n        yBuffer[i] = y;\n\n        i = (i + 1) & (bufferLength - 1); // tslint:disable-line:no-bitwise\n\n        output[j] = y;\n    }\n\n    return i;\n};\n", "import { filterBuffer } from '../helpers/filter-buffer';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IIIRFilterNode, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport {\n    TIIRFilterNodeRendererFactoryFactory,\n    TNativeAudioBuffer,\n    TNativeAudioBufferSourceNode,\n    TNativeIIRFilterNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst filterFullBuffer = (\n    renderedBuffer: TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    feedback: Iterable<number>,\n    feedforward: Iterable<number>\n) => {\n    const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n    const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n    const feedbackLength = convertedFeedback.length;\n    const feedforwardLength = convertedFeedforward.length;\n    const minLength = Math.min(feedbackLength, feedforwardLength);\n\n    if (convertedFeedback[0] !== 1) {\n        for (let i = 0; i < feedbackLength; i += 1) {\n            convertedFeedforward[i] /= convertedFeedback[0];\n        }\n\n        for (let i = 1; i < feedforwardLength; i += 1) {\n            convertedFeedback[i] /= convertedFeedback[0];\n        }\n    }\n\n    const bufferLength = 32;\n    const xBuffer = new Float32Array(bufferLength);\n    const yBuffer = new Float32Array(bufferLength);\n\n    const filteredBuffer = nativeOfflineAudioContext.createBuffer(\n        renderedBuffer.numberOfChannels,\n        renderedBuffer.length,\n        renderedBuffer.sampleRate\n    );\n\n    const numberOfChannels = renderedBuffer.numberOfChannels;\n\n    for (let i = 0; i < numberOfChannels; i += 1) {\n        const input = renderedBuffer.getChannelData(i);\n        const output = filteredBuffer.getChannelData(i);\n\n        xBuffer.fill(0);\n        yBuffer.fill(0);\n\n        filterBuffer(\n            convertedFeedback,\n            feedbackLength,\n            convertedFeedforward,\n            feedforwardLength,\n            minLength,\n            xBuffer,\n            yBuffer,\n            0,\n            bufferLength,\n            input,\n            output\n        );\n    }\n\n    return filteredBuffer;\n};\n\nexport const createIIRFilterNodeRendererFactory: TIIRFilterNodeRendererFactoryFactory = (\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(feedback: Iterable<number>, feedforward: Iterable<number>) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioBufferSourceNode | TNativeIIRFilterNode>();\n\n        let filteredBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IIIRFilterNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioBufferSourceNode: null | TNativeAudioBufferSourceNode = null;\n            let nativeIIRFilterNode = getNativeAudioNode<T, TNativeIIRFilterNode>(proxy);\n\n            // If the initially used nativeIIRFilterNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeIIRFilterNodeIsOwnedByContext = isOwnedByContext(nativeIIRFilterNode, nativeOfflineAudioContext);\n\n            // Bug #9: Safari does not support IIRFilterNodes.\n            if (nativeOfflineAudioContext.createIIRFilter === undefined) {\n                nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n            } else if (!nativeIIRFilterNodeIsOwnedByContext) {\n                // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n                nativeIIRFilterNode = nativeOfflineAudioContext.createIIRFilter(<number[]>feedforward, <number[]>feedback);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeAudioBufferSourceNode === null ? nativeIIRFilterNode : nativeAudioBufferSourceNode\n            );\n\n            if (nativeAudioBufferSourceNode !== null) {\n                if (filteredBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                        proxy.context.destination.channelCount,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n\n                    filteredBufferPromise = (async () => {\n                        await renderInputsOfAudioNode(proxy, partialOfflineAudioContext, partialOfflineAudioContext.destination);\n\n                        const renderedBuffer = await renderNativeOfflineAudioContext(partialOfflineAudioContext);\n\n                        return filterFullBuffer(renderedBuffer, nativeOfflineAudioContext, feedback, feedforward);\n                    })();\n                }\n\n                const filteredBuffer = await filteredBufferPromise;\n\n                nativeAudioBufferSourceNode.buffer = filteredBuffer;\n                nativeAudioBufferSourceNode.start(0);\n\n                return nativeAudioBufferSourceNode;\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeIIRFilterNode);\n\n            return nativeIIRFilterNode;\n        };\n\n        return {\n            render(\n                proxy: IIIRFilterNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioBufferSourceNode | TNativeIIRFilterNode> {\n                const renderedNativeAudioNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { TIncrementCycleCounterFactoryFactory } from '../types';\n\nexport const createIncrementCycleCounterFactory: TIncrementCycleCounterFactoryFactory = (\n    cycleCounters,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getAudioNodeConnections,\n    getNativeAudioNode,\n    getNativeAudioParam,\n    isActiveAudioNode\n) => {\n    return (isOffline) => {\n        return (audioNode, count) => {\n            const cycleCounter = cycleCounters.get(audioNode);\n\n            if (cycleCounter === undefined) {\n                if (!isOffline && isActiveAudioNode(audioNode)) {\n                    const nativeSourceAudioNode = getNativeAudioNode(audioNode);\n                    const { outputs } = getAudioNodeConnections(audioNode);\n\n                    for (const output of outputs) {\n                        if (isAudioNodeOutputConnection(output)) {\n                            const nativeDestinationAudioNode = getNativeAudioNode(output[0]);\n\n                            disconnectNativeAudioNodeFromNativeAudioNode(\n                                nativeSourceAudioNode,\n                                nativeDestinationAudioNode,\n                                output[1],\n                                output[2]\n                            );\n                        } else {\n                            const nativeDestinationAudioParam = getNativeAudioParam(output[0]);\n\n                            nativeSourceAudioNode.disconnect(nativeDestinationAudioParam, output[1]);\n                        }\n                    }\n                }\n\n                cycleCounters.set(audioNode, count);\n            } else {\n                cycleCounters.set(audioNode, cycleCounter + count);\n            }\n        };\n    };\n};\n", "import { IAudioContext, IMinimalAudioContext } from '../interfaces';\nimport { TIsAnyAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsAnyAudioContext: TIsAnyAudioContextFactory = (contextStore, isNativeAudioContext) => {\n    return (anything): anything is IAudioContext | IMinimalAudioContext | TNativeAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeAudioContext(nativeContext) || isNativeAudioContext(anything);\n    };\n};\n", "import { IAudioNode } from '../interfaces';\nimport { TIsAnyAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsAnyAudioNode: TIsAnyAudioNodeFactory = (audioNodeStore, isNativeAudioNode) => {\n    return (anything): anything is IAudioNode<any> | TNativeAudioNode => audioNodeStore.has(<any>anything) || isNativeAudioNode(anything);\n};\n", "import { IAudioParam } from '../interfaces';\nimport { TIsAnyAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsAnyAudioParam: TIsAnyAudioParamFactory = (audioParamStore, isNativeAudioParam) => {\n    return (anything): anything is IAudioParam | TNativeAudioParam => audioParamStore.has(<any>anything) || isNativeAudioParam(anything);\n};\n", "import { IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TIsAnyOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsAnyOfflineAudioContext: TIsAnyOfflineAudioContextFactory = (contextStore, isNativeOfflineAudioContext) => {\n    return (anything): anything is IMinimalOfflineAudioContext | IOfflineAudioContext | TNativeOfflineAudioContext => {\n        const nativeContext = contextStore.get(<any>anything);\n\n        return isNativeOfflineAudioContext(nativeContext) || isNativeOfflineAudioContext(anything);\n    };\n};\n", "import { TIsNativeAudioContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeAudioContext: TIsNativeAudioContextFactory = (nativeAudioContextConstructor) => {\n    return (anything): anything is TNativeAudioContext => {\n        return nativeAudioContextConstructor !== null && anything instanceof nativeAudioContextConstructor;\n    };\n};\n", "import { TIsNativeAudioNodeFactory, TNativeAudioNode } from '../types';\n\nexport const createIsNativeAudioNode: TIsNativeAudioNodeFactory = (window) => {\n    return (anything): anything is TNativeAudioNode => {\n        return window !== null && typeof window.AudioNode === 'function' && anything instanceof window.AudioNode;\n    };\n};\n", "import { TIsNativeAudioParamFactory, TNativeAudioParam } from '../types';\n\nexport const createIsNativeAudioParam: TIsNativeAudioParamFactory = (window) => {\n    return (anything): anything is TNativeAudioParam => {\n        return window !== null && typeof window.AudioParam === 'function' && anything instanceof window.AudioParam;\n    };\n};\n", "import { TIsNativeContextFactory, TNativeAudioContext } from '../types';\n\nexport const createIsNativeContext: TIsNativeContextFactory = (isNativeAudioContext, isNativeOfflineAudioContext) => {\n    return (anything): anything is TNativeAudioContext => {\n        return isNativeAudioContext(anything) || isNativeOfflineAudioContext(anything);\n    };\n};\n", "import { TIsNativeOfflineAudioContextFactory, TNativeOfflineAudioContext } from '../types';\n\nexport const createIsNativeOfflineAudioContext: TIsNativeOfflineAudioContextFactory = (nativeOfflineAudioContextConstructor) => {\n    return (anything): anything is TNativeOfflineAudioContext => {\n        return nativeOfflineAudioContextConstructor !== null && anything instanceof nativeOfflineAudioContextConstructor;\n    };\n};\n", "import { TIsSecureContextFactory } from '../types';\n\nexport const createIsSecureContext: TIsSecureContextFactory = (window) => window !== null && window.isSecureContext;\n", "import { TIsSupportedPromiseFactory } from '../types';\n\nexport const createIsSupportedPromise: TIsSupportedPromiseFactory = async (\n    cacheTestResult,\n    testAudioBufferCopyChannelMethodsSubarraySupport,\n    testAudioContextCloseMethodSupport,\n    testAudioContextDecodeAudioDataMethodTypeErrorSupport,\n    testAudioContextOptionsSupport,\n    testAudioNodeConnectMethodSupport,\n    testAudioWorkletProcessorNoOutputsSupport,\n    testChannelMergerNodeChannelCountSupport,\n    testConstantSourceNodeAccurateSchedulingSupport,\n    testConvolverNodeBufferReassignabilitySupport,\n    testConvolverNodeChannelCountSupport,\n    testDomExceptionContrucorSupport,\n    testIsSecureContextSupport,\n    testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport,\n    testStereoPannerNodeDefaultValueSupport,\n    testTransferablesSupport\n) => {\n    if (\n        cacheTestResult(testAudioBufferCopyChannelMethodsSubarraySupport, testAudioBufferCopyChannelMethodsSubarraySupport) &&\n        cacheTestResult(testAudioContextCloseMethodSupport, testAudioContextCloseMethodSupport) &&\n        cacheTestResult(testAudioContextOptionsSupport, testAudioContextOptionsSupport) &&\n        cacheTestResult(testAudioNodeConnectMethodSupport, testAudioNodeConnectMethodSupport) &&\n        cacheTestResult(testChannelMergerNodeChannelCountSupport, testChannelMergerNodeChannelCountSupport) &&\n        cacheTestResult(testConstantSourceNodeAccurateSchedulingSupport, testConstantSourceNodeAccurateSchedulingSupport) &&\n        cacheTestResult(testConvolverNodeBufferReassignabilitySupport, testConvolverNodeBufferReassignabilitySupport) &&\n        cacheTestResult(testConvolverNodeChannelCountSupport, testConvolverNodeChannelCountSupport) &&\n        cacheTestResult(testDomExceptionContrucorSupport, testDomExceptionContrucorSupport) &&\n        cacheTestResult(testIsSecureContextSupport, testIsSecureContextSupport) &&\n        cacheTestResult(\n            testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport,\n            testMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport\n        )\n    ) {\n        const results = await Promise.all([\n            cacheTestResult(testAudioContextDecodeAudioDataMethodTypeErrorSupport, testAudioContextDecodeAudioDataMethodTypeErrorSupport),\n            cacheTestResult(testAudioWorkletProcessorNoOutputsSupport, testAudioWorkletProcessorNoOutputsSupport),\n            cacheTestResult(testStereoPannerNodeDefaultValueSupport, testStereoPannerNodeDefaultValueSupport),\n            cacheTestResult(testTransferablesSupport, testTransferablesSupport)\n        ]);\n\n        return results.every((result) => result);\n    }\n\n    return false;\n};\n", "import { IAudioContext, IMediaElementAudioSourceNode, IMediaElementAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaElementAudioSourceNodeConstructorFactory, TNativeMediaElementAudioSourceNode } from '../types';\n\nexport const createMediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaElementAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaElementAudioSourceNode<T> {\n        private _nativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNode;\n\n        constructor(context: T, options: IMediaElementAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaElementAudioSourceNode = createNativeMediaElementAudioSourceNode(nativeContext, options);\n\n            // Bug #171: Safari allows to create a MediaElementAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw TypeError();\n            }\n\n            super(context, true, nativeMediaElementAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaElementAudioSourceNode = nativeMediaElementAudioSourceNode;\n        }\n\n        get mediaElement(): HTMLMediaElement {\n            return this._nativeMediaElementAudioSourceNode.mediaElement;\n        }\n    };\n};\n", "import { IAudioContext, IAudioNodeOptions, IMediaStreamAudioDestinationNode, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioDestinationNodeConstructorFactory, TNativeMediaStreamAudioDestinationNode } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers'\n} as const;\n\nexport const createMediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioDestinationNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioDestinationNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioDestinationNode<T> {\n        private _nativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNode;\n\n        constructor(context: T, options?: Partial<IAudioNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n\n            // Bug #173: Safari allows to create a MediaStreamAudioDestinationNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeMediaStreamAudioDestinationNode = createNativeMediaStreamAudioDestinationNode(nativeContext, mergedOptions);\n\n            super(context, false, nativeMediaStreamAudioDestinationNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioDestinationNode = nativeMediaStreamAudioDestinationNode;\n        }\n\n        get stream(): MediaStream {\n            return this._nativeMediaStreamAudioDestinationNode.stream;\n        }\n    };\n};\n", "import { IAudioContext, IMediaStreamAudioSourceNode, IMediaStreamAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamAudioSourceNodeConstructorFactory, TNativeMediaStreamAudioSourceNode } from '../types';\n\nexport const createMediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class MediaStreamAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamAudioSourceNode<T> {\n        private _nativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNode;\n\n        constructor(context: T, options: IMediaStreamAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamAudioSourceNode = createNativeMediaStreamAudioSourceNode(nativeContext, options);\n\n            // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n            if (isNativeOfflineAudioContext(nativeContext)) {\n                throw new TypeError();\n            }\n\n            super(context, true, nativeMediaStreamAudioSourceNode, <TAudioNodeRenderer<T>>null);\n\n            this._nativeMediaStreamAudioSourceNode = nativeMediaStreamAudioSourceNode;\n        }\n\n        get mediaStream(): MediaStream {\n            return this._nativeMediaStreamAudioSourceNode.mediaStream;\n        }\n    };\n};\n", "import { IAudioContext, IMediaStreamTrackAudioSourceNode, IMediaStreamTrackAudioSourceOptions, IMinimalAudioContext } from '../interfaces';\nimport { TAudioNodeRenderer, TMediaStreamTrackAudioSourceNodeConstructorFactory } from '../types';\n\nexport const createMediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createNativeMediaStreamTrackAudioSourceNode,\n    getNativeContext\n) => {\n    return class MediaStreamTrackAudioSourceNode<T extends IAudioContext | IMinimalAudioContext> extends audioNodeConstructor<T>\n        implements IMediaStreamTrackAudioSourceNode<T> {\n        constructor(context: T, options: IMediaStreamTrackAudioSourceOptions) {\n            const nativeContext = getNativeContext(context);\n            const nativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNode(nativeContext, options);\n\n            super(context, true, nativeMediaStreamTrackAudioSourceNode, <TAudioNodeRenderer<T>>null);\n        }\n    };\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { isValidLatencyHint } from '../helpers/is-valid-latency-hint';\nimport { IAudioContextOptions, IMinimalAudioContext } from '../interfaces';\nimport {\n    TAudioContextState,\n    TMinimalAudioContextConstructorFactory,\n    TNativeAudioContext,\n    TNativeGainNode,\n    TNativeOscillatorNode\n} from '../types';\n\nexport const createMinimalAudioContextConstructor: TMinimalAudioContextConstructorFactory = (\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n) => {\n    return class MinimalAudioContext extends minimalBaseAudioContextConstructor<IMinimalAudioContext> implements IMinimalAudioContext {\n        private _baseLatency: number;\n\n        private _nativeAudioContext: TNativeAudioContext;\n\n        private _nativeGainNode: null | TNativeGainNode;\n\n        private _nativeOscillatorNode: null | TNativeOscillatorNode;\n\n        private _state: null | 'suspended';\n\n        constructor(options: IAudioContextOptions = {}) {\n            if (nativeAudioContextConstructor === null) {\n                throw new Error('Missing the native AudioContext constructor.');\n            }\n\n            let nativeAudioContext: TNativeAudioContext;\n\n            try {\n                nativeAudioContext = new nativeAudioContextConstructor(options);\n            } catch (err) {\n                // Bug #192 Safari does throw a SyntaxError if the sampleRate is not supported.\n                if (err.code === 12 && err.message === 'sampleRate is not in range') {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n\n            // Bug #131 Safari returns null when there are four other AudioContexts running already.\n            if (nativeAudioContext === null) {\n                throw createUnknownError();\n            }\n\n            // Bug #51 Only Chrome and Edge throw an error if the given latencyHint is invalid.\n            if (!isValidLatencyHint(options.latencyHint)) {\n                throw new TypeError(\n                    `The provided value '${options.latencyHint}' is not a valid enum value of type AudioContextLatencyCategory.`\n                );\n            }\n\n            // Bug #150 Safari does not support setting the sampleRate.\n            if (options.sampleRate !== undefined && nativeAudioContext.sampleRate !== options.sampleRate) {\n                throw createNotSupportedError();\n            }\n\n            super(nativeAudioContext, 2);\n\n            const { latencyHint } = options;\n            const { sampleRate } = nativeAudioContext;\n\n            // @todo The values for 'balanced', 'interactive' and 'playback' are just copied from Chrome's implementation.\n            this._baseLatency =\n                typeof nativeAudioContext.baseLatency === 'number'\n                    ? nativeAudioContext.baseLatency\n                    : latencyHint === 'balanced'\n                    ? 512 / sampleRate\n                    : latencyHint === 'interactive' || latencyHint === undefined\n                    ? 256 / sampleRate\n                    : latencyHint === 'playback'\n                    ? 1024 / sampleRate\n                    : /*\n                       * @todo The min (256) and max (16384) values are taken from the allowed bufferSize values of a\n                       * ScriptProcessorNode.\n                       */\n                      (Math.max(2, Math.min(128, Math.round((latencyHint * sampleRate) / 128))) * 128) / sampleRate;\n            this._nativeAudioContext = nativeAudioContext;\n\n            // Bug #188: Safari will set the context's state to 'interrupted' in case the user switches tabs.\n            if (nativeAudioContextConstructor.name === 'webkitAudioContext') {\n                this._nativeGainNode = nativeAudioContext.createGain();\n                this._nativeOscillatorNode = nativeAudioContext.createOscillator();\n\n                this._nativeGainNode.gain.value = 1e-37;\n\n                this._nativeOscillatorNode.connect(this._nativeGainNode).connect(nativeAudioContext.destination);\n                this._nativeOscillatorNode.start();\n            } else {\n                this._nativeGainNode = null;\n                this._nativeOscillatorNode = null;\n            }\n\n            this._state = null;\n\n            /*\n             * Bug #34: Chrome and Edge pretend to be running right away, but fire an onstatechange event when the state actually changes\n             * to 'running'.\n             */\n            if (nativeAudioContext.state === 'running') {\n                this._state = 'suspended';\n\n                const revokeState = () => {\n                    if (this._state === 'suspended') {\n                        this._state = null;\n                    }\n\n                    nativeAudioContext.removeEventListener('statechange', revokeState);\n                };\n\n                nativeAudioContext.addEventListener('statechange', revokeState);\n            }\n        }\n\n        get baseLatency(): number {\n            return this._baseLatency;\n        }\n\n        get state(): TAudioContextState {\n            return this._state !== null ? this._state : this._nativeAudioContext.state;\n        }\n\n        public close(): Promise<void> {\n            // Bug #35: Firefox does not throw an error if the AudioContext was closed before.\n            if (this.state === 'closed') {\n                return this._nativeAudioContext.close().then(() => {\n                    throw createInvalidStateError();\n                });\n            }\n\n            // Bug #34: If the state was set to suspended before it should be revoked now.\n            if (this._state === 'suspended') {\n                this._state = null;\n            }\n\n            return this._nativeAudioContext.close().then(() => {\n                if (this._nativeGainNode !== null && this._nativeOscillatorNode !== null) {\n                    this._nativeOscillatorNode.stop();\n\n                    this._nativeGainNode.disconnect();\n                    this._nativeOscillatorNode.disconnect();\n                }\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        public resume(): Promise<void> {\n            if (this._state === 'suspended') {\n                return new Promise((resolve, reject) => {\n                    const resolvePromise = () => {\n                        this._nativeAudioContext.removeEventListener('statechange', resolvePromise);\n\n                        if (this._nativeAudioContext.state === 'running') {\n                            resolve();\n                        } else {\n                            this.resume().then(resolve, reject);\n                        }\n                    };\n\n                    this._nativeAudioContext.addEventListener('statechange', resolvePromise);\n                });\n            }\n\n            return this._nativeAudioContext.resume().catch((err) => {\n                // Bug #55: Chrome and Edge do throw an InvalidAccessError instead of an InvalidStateError.\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined || err.code === 15) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n\n        public suspend(): Promise<void> {\n            return this._nativeAudioContext.suspend().catch((err) => {\n                // Bug #56: Safari invokes the catch handler but without an error.\n                if (err === undefined) {\n                    throw createInvalidStateError();\n                }\n\n                throw err;\n            });\n        }\n    };\n};\n", "import { CONTEXT_STORE } from '../globals';\nimport { IAudioDestinationNode, IAudioListener, IMinimalBaseAudioContext, IMinimalBaseAudioContextEventMap } from '../interfaces';\nimport { TAudioContextState, TContext, TEventHandler, TMinimalBaseAudioContextConstructorFactory, TNativeContext } from '../types';\n\nexport const createMinimalBaseAudioContextConstructor: TMinimalBaseAudioContextConstructorFactory = (\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n) => {\n    return class MinimalBaseAudioContext<T extends TContext>\n        extends eventTargetConstructor<IMinimalBaseAudioContextEventMap>\n        implements IMinimalBaseAudioContext<T>\n    {\n        private _destination: IAudioDestinationNode<T>;\n\n        private _listener: IAudioListener;\n\n        private _onstatechange: null | TEventHandler<T>;\n\n        constructor(private _nativeContext: TNativeContext, numberOfChannels: number) {\n            super(_nativeContext);\n\n            CONTEXT_STORE.set(<T>(<unknown>this), _nativeContext);\n\n            if (isNativeOfflineAudioContext(_nativeContext)) {\n                unrenderedAudioWorkletNodeStore.set(_nativeContext, new Set());\n            }\n\n            this._destination = new audioDestinationNodeConstructor(<T>(<unknown>this), numberOfChannels);\n            this._listener = createAudioListener(<T>(<unknown>this), _nativeContext);\n            this._onstatechange = null;\n        }\n\n        get currentTime(): number {\n            return this._nativeContext.currentTime;\n        }\n\n        get destination(): IAudioDestinationNode<T> {\n            return this._destination;\n        }\n\n        get listener(): IAudioListener {\n            return this._listener;\n        }\n\n        get onstatechange(): null | TEventHandler<T> {\n            return this._onstatechange;\n        }\n\n        set onstatechange(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeContext.onstatechange = wrappedListener;\n\n            const nativeOnStateChange = this._nativeContext.onstatechange;\n\n            this._onstatechange = nativeOnStateChange !== null && nativeOnStateChange === wrappedListener ? value : nativeOnStateChange;\n        }\n\n        get sampleRate(): number {\n            return this._nativeContext.sampleRate;\n        }\n\n        get state(): TAudioContextState {\n            return this._nativeContext.state;\n        }\n    };\n};\n", "import { TNativeContext } from '../types';\n\nexport const testPromiseSupport = (nativeContext: TNativeContext): boolean => {\n    // This 12 numbers represent the 48 bytes of an empty WAVE file with a single sample.\n    const uint32Array = new Uint32Array([1179011410, 40, 1163280727, 544501094, 16, 131073, 44100, 176400, 1048580, 1635017060, 4, 0]);\n\n    try {\n        // Bug #1: Safari requires a successCallback.\n        const promise = nativeContext.decodeAudioData(<ArrayBuffer>uint32Array.buffer, () => {\n            // Ignore the success callback.\n        });\n\n        if (promise === undefined) {\n            return false;\n        }\n\n        promise.catch(() => {\n            // Ignore rejected errors.\n        });\n\n        return true;\n    } catch {\n        // Ignore errors.\n    }\n\n    return false;\n};\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IMinimalOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TMinimalOfflineAudioContextConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createMinimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructorFactory = (\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n) => {\n    return class MinimalOfflineAudioContext extends minimalBaseAudioContextConstructor<IMinimalOfflineAudioContext>\n        implements IMinimalOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions) {\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n", "import { TMonitorConnectionsFactory, TNativeAudioNode, TNativeAudioParam } from '../types';\n\nexport const createMonitorConnections: TMonitorConnectionsFactory = (insertElementInSet, isNativeAudioNode) => {\n    return (nativeAudioNode, whenConnected, whenDisconnected) => {\n        const connections = new Set<[TNativeAudioNode, number, number] | [TNativeAudioParam, number]>();\n\n        nativeAudioNode.connect = <TNativeAudioNode['connect']>((connect) => {\n            // tslint:disable-next-line:invalid-void no-inferrable-types\n            return (destination: TNativeAudioNode | TNativeAudioParam, output = 0, input: number = 0): void | TNativeAudioNode => {\n                const wasDisconnected = connections.size === 0;\n\n                if (isNativeAudioNode(destination)) {\n                    // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                    (<(destination: TNativeAudioNode, output?: number, input?: number) => TNativeAudioNode>connect).call(\n                        nativeAudioNode,\n                        destination,\n                        output,\n                        input\n                    );\n\n                    insertElementInSet(\n                        connections,\n                        [destination, output, input],\n                        (connection) => connection[0] === destination && connection[1] === output && connection[2] === input,\n                        true\n                    );\n\n                    if (wasDisconnected) {\n                        whenConnected();\n                    }\n\n                    return destination;\n                }\n\n                connect.call(nativeAudioNode, destination, output);\n\n                insertElementInSet(\n                    connections,\n                    [destination, output],\n                    (connection) => connection[0] === destination && connection[1] === output,\n                    true\n                );\n\n                if (wasDisconnected) {\n                    whenConnected();\n                }\n\n                return;\n            };\n        })(nativeAudioNode.connect);\n\n        nativeAudioNode.disconnect = ((disconnect) => {\n            return (destinationOrOutput?: number | TNativeAudioNode | TNativeAudioParam, output?: number, input?: number): void => {\n                const wasConnected = connections.size > 0;\n\n                if (destinationOrOutput === undefined) {\n                    disconnect.apply(nativeAudioNode);\n\n                    connections.clear();\n                } else if (typeof destinationOrOutput === 'number') {\n                    // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n                    (<(output: number) => void>disconnect).call(nativeAudioNode, destinationOrOutput);\n\n                    for (const connection of connections) {\n                        if (connection[1] === destinationOrOutput) {\n                            connections.delete(connection);\n                        }\n                    }\n                } else {\n                    if (isNativeAudioNode(destinationOrOutput)) {\n                        // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n                        (<(destination: TNativeAudioNode, output?: number, input?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output,\n                            input\n                        );\n                    } else {\n                        // @todo TypeScript cannot infer the overloaded signature with 2 arguments yet.\n                        (<(destination: TNativeAudioParam, output?: number) => void>disconnect).call(\n                            nativeAudioNode,\n                            destinationOrOutput,\n                            output\n                        );\n                    }\n\n                    for (const connection of connections) {\n                        if (\n                            connection[0] === destinationOrOutput &&\n                            (output === undefined || connection[1] === output) &&\n                            (input === undefined || connection[2] === input)\n                        ) {\n                            connections.delete(connection);\n                        }\n                    }\n                }\n\n                const isDisconnected = connections.size === 0;\n\n                if (wasConnected && isDisconnected) {\n                    whenDisconnected();\n                }\n            };\n        })(nativeAudioNode.disconnect);\n\n        return nativeAudioNode;\n    };\n};\n", "export const assignNativeAudioNodeOption = <T extends keyof any, U extends any>(\n    nativeAudioNode: Record<T, U>,\n    options: Record<T, U>,\n    option: T\n) => {\n    const value = options[option];\n\n    if (value !== undefined && value !== nativeAudioNode[option]) {\n        nativeAudioNode[option] = value;\n    }\n};\n", "import { IAudioNodeOptions } from '../interfaces';\nimport { TNativeAudioNode } from '../types';\nimport { assignNativeAudioNodeOption } from './assign-native-audio-node-option';\n\nexport const assignNativeAudioNodeOptions = (nativeAudioNode: TNativeAudioNode, options: IAudioNodeOptions): void => {\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCount');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelCountMode');\n    assignNativeAudioNodeOption(nativeAudioNode, options, 'channelInterpretation');\n};\n", "import { TNativeAnalyserNode } from '../types';\n\nexport const testAnalyserNodeGetFloatTimeDomainDataMethodSupport = (nativeAnalyserNode: TNativeAnalyserNode): boolean => {\n    return typeof nativeAnalyserNode.getFloatTimeDomainData === 'function';\n};\n", "import { TNativeAnalyserNode } from '../types';\n\nexport const wrapAnalyserNodeGetFloatTimeDomainDataMethod = (nativeAnalyserNode: TNativeAnalyserNode): void => {\n    nativeAnalyserNode.getFloatTimeDomainData = (array: Float32Array) => {\n        const byteTimeDomainData = new Uint8Array(array.length);\n\n        nativeAnalyserNode.getByteTimeDomainData(byteTimeDomainData);\n\n        const length = Math.max(byteTimeDomainData.length, nativeAnalyserNode.fftSize);\n\n        for (let i = 0; i < length; i += 1) {\n            array[i] = (byteTimeDomainData[i] - 128) * 0.0078125;\n        }\n\n        return array;\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { testAnalyserNodeGetFloatTimeDomainDataMethodSupport } from '../helpers/test-analyser-node-get-float-time-domain-data-method-support';\nimport { wrapAnalyserNodeGetFloatTimeDomainDataMethod } from '../helpers/wrap-analyser-node-get-float-time-domain-data-method';\nimport { TNativeAnalyserNodeFactoryFactory } from '../types';\n\nexport const createNativeAnalyserNodeFactory: TNativeAnalyserNodeFactoryFactory = (cacheTestResult, createIndexSizeError) => {\n    return (nativeContext, options) => {\n        const nativeAnalyserNode = nativeContext.createAnalyser();\n\n        // Bug #37: Firefox does not create an AnalyserNode with the default properties.\n        assignNativeAudioNodeOptions(nativeAnalyserNode, options);\n\n        // Bug #118: Safari does not throw an error if maxDecibels is not more than minDecibels.\n        if (!(options.maxDecibels > options.minDecibels)) {\n            throw createIndexSizeError();\n        }\n\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'fftSize');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'maxDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'minDecibels');\n        assignNativeAudioNodeOption(nativeAnalyserNode, options, 'smoothingTimeConstant');\n\n        // Bug #36: Safari does not support getFloatTimeDomainData() yet.\n        if (\n            !cacheTestResult(testAnalyserNodeGetFloatTimeDomainDataMethodSupport, () =>\n                testAnalyserNodeGetFloatTimeDomainDataMethodSupport(nativeAnalyserNode)\n            )\n        ) {\n            wrapAnalyserNodeGetFloatTimeDomainDataMethod(nativeAnalyserNode);\n        }\n\n        return nativeAnalyserNode;\n    };\n};\n", "import { TNativeAudioBufferConstructorFactory } from '../types';\n\nexport const createNativeAudioBufferConstructor: TNativeAudioBufferConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioBuffer')) {\n        return window.AudioBuffer;\n    }\n\n    return null;\n};\n", "export const assignNativeAudioNodeAudioParamValue = <T extends { [key: string]: any }, U extends { [key: string]: any }>(\n    nativeAudioNode: T,\n    options: U,\n    audioParam: keyof T & keyof U\n) => {\n    const value = options[audioParam];\n\n    if (value !== undefined && value !== nativeAudioNode[audioParam].value) {\n        nativeAudioNode[audioParam].value = value;\n    }\n};\n", "import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodConsecutiveCalls = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        let isScheduled = false;\n\n        return (when = 0, offset = 0, duration?: number) => {\n            if (isScheduled) {\n                throw createInvalidStateError();\n            }\n\n            start.call(nativeAudioBufferSourceNode, when, offset, duration);\n\n            isScheduled = true;\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n", "import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStartMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            if ((typeof duration === 'number' && duration < 0) || offset < 0 || when < 0) {\n                throw new RangeError(\"The parameters can't be negative.\");\n            }\n\n            // @todo TypeScript cannot infer the overloaded signature with 3 arguments yet.\n            (<(when: number, offset: number, duration?: number) => void>start).call(nativeAudioScheduledSourceNode, when, offset, duration);\n        };\n    })(nativeAudioScheduledSourceNode.start);\n};\n", "import { TNativeAudioBufferSourceNode, TNativeConstantSourceNode, TNativeOscillatorNode } from '../types';\n\nexport const wrapAudioScheduledSourceNodeStopMethodNegativeParameters = (\n    nativeAudioScheduledSourceNode: TNativeAudioBufferSourceNode | TNativeConstantSourceNode | TNativeOscillatorNode\n): void => {\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        return (when = 0) => {\n            if (when < 0) {\n                throw new RangeError(\"The parameter can't be negative.\");\n            }\n\n            stop.call(nativeAudioScheduledSourceNode, when);\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioBufferSourceNodeStartMethodConsecutiveCalls } from '../helpers/wrap-audio-buffer-source-node-start-method-consecutive-calls';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeAudioBufferSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeAudioBufferSourceNodeFactory: TNativeAudioBufferSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClampling,\n    wrapAudioBufferSourceNodeStopMethodNullifiedBuffer,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n        assignNativeAudioNodeOptions(nativeAudioBufferSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeAudioBufferSourceNode, options, 'playbackRate');\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'buffer');\n\n        // Bug #149: Safari does not yet support the detune AudioParam.\n\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loop');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopEnd');\n        assignNativeAudioNodeOption(nativeAudioBufferSourceNode, options, 'loopStart');\n\n        // Bug #69: Safari does allow calls to start() of an already scheduled AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport, () =>\n                testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodConsecutiveCalls(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #154 & #155: Safari does not handle offsets which are equal to or greater than the duration of the buffer.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStartMethodOffsetClampingSupport, () =>\n                testAudioBufferSourceNodeStartMethodOffsetClampingSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStartMethodOffsetClampling(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #162: Safari does throw an error when stop() is called on an AudioBufferSourceNode which has no buffer assigned to it.\n        if (\n            !cacheTestResult(testAudioBufferSourceNodeStopMethodNullifiedBufferSupport, () =>\n                testAudioBufferSourceNodeStopMethodNullifiedBufferSupport(nativeContext)\n            )\n        ) {\n            wrapAudioBufferSourceNodeStopMethodNullifiedBuffer(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioBufferSourceNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeAudioBufferSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeAudioBufferSourceNode);\n\n        return nativeAudioBufferSourceNode;\n    };\n};\n", "import { TNativeAudioContextConstructorFactory } from '../types';\n\nexport const createNativeAudioContextConstructor: TNativeAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('AudioContext')) {\n        return window.AudioContext;\n    }\n\n    return window.hasOwnProperty('webkitAudioContext') ? (<any>window).webkitAudioContext : null;\n};\n", "import { TNativeAudioDestinationNode, TNativeAudioDestinationNodeFactoryFactory, TNativeGainNode } from '../types';\n\nexport const createNativeAudioDestinationNodeFactory: TNativeAudioDestinationNodeFactoryFactory = (\n    createNativeGainNode,\n    overwriteAccessors\n) => {\n    return (nativeContext, channelCount, isNodeOfNativeOfflineAudioContext) => {\n        const nativeAudioDestinationNode = nativeContext.destination;\n\n        // Bug #132: Safari does not have the correct channelCount.\n        if (nativeAudioDestinationNode.channelCount !== channelCount) {\n            try {\n                nativeAudioDestinationNode.channelCount = channelCount;\n            } catch {\n                // Bug #169: Safari throws an error on each attempt to change the channelCount.\n            }\n        }\n\n        // Bug #83: Safari does not have the correct channelCountMode.\n        if (isNodeOfNativeOfflineAudioContext && nativeAudioDestinationNode.channelCountMode !== 'explicit') {\n            nativeAudioDestinationNode.channelCountMode = 'explicit';\n        }\n\n        // Bug #47: The AudioDestinationNode in Safari does not initialize the maxChannelCount property correctly.\n        if (nativeAudioDestinationNode.maxChannelCount === 0) {\n            Object.defineProperty(nativeAudioDestinationNode, 'maxChannelCount', {\n                value: channelCount\n            });\n        }\n\n        // Bug #168: No browser does yet have an AudioDestinationNode with an output.\n        const gainNode = createNativeGainNode(nativeContext, {\n            channelCount,\n            channelCountMode: nativeAudioDestinationNode.channelCountMode,\n            channelInterpretation: nativeAudioDestinationNode.channelInterpretation,\n            gain: 1\n        });\n\n        overwriteAccessors(\n            gainNode,\n            'channelCount',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n\n                try {\n                    nativeAudioDestinationNode.channelCount = value;\n                } catch (err) {\n                    // Bug #169: Safari throws an error on each attempt to change the channelCount.\n                    if (value > nativeAudioDestinationNode.maxChannelCount) {\n                        throw err;\n                    }\n                }\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelCountMode',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelCountMode = value;\n            }\n        );\n\n        overwriteAccessors(\n            gainNode,\n            'channelInterpretation',\n            (get) => () => get.call(gainNode),\n            (set) => (value) => {\n                set.call(gainNode, value);\n                nativeAudioDestinationNode.channelInterpretation = value;\n            }\n        );\n\n        Object.defineProperty(gainNode, 'maxChannelCount', {\n            get: () => nativeAudioDestinationNode.maxChannelCount\n        });\n\n        // @todo This should be disconnected when the context is closed.\n        gainNode.connect(nativeAudioDestinationNode);\n\n        return <{ maxChannelCount: TNativeAudioDestinationNode['maxChannelCount'] } & TNativeGainNode>gainNode;\n    };\n};\n", "import { TNativeAudioWorkletNodeConstructorFactory } from '../types';\n\nexport const createNativeAudioWorkletNodeConstructor: TNativeAudioWorkletNodeConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    return window.hasOwnProperty('AudioWorkletNode') ? window.AudioWorkletNode : null;\n};\n", "import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const testClonabilityOfAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): void => {\n    const { port1 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n    }\n};\n", "import { testClonabilityOfAudioWorkletNodeOptions } from '../helpers/test-clonability-of-audio-worklet-node-options';\nimport { TNativeAudioWorkletNode, TNativeAudioWorkletNodeFactoryFactory, TNativeAudioWorkletNodeOptions } from '../types';\n\nexport const createNativeAudioWorkletNodeFactory: TNativeAudioWorkletNodeFactoryFactory = (\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, options) => {\n        if (nativeAudioWorkletNodeConstructor !== null) {\n            try {\n                const nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(\n                    nativeContext,\n                    name,\n                    <TNativeAudioWorkletNodeOptions>options\n                );\n                const patchedEventListeners: Map<\n                    EventListenerOrEventListenerObject,\n                    NonNullable<TNativeAudioWorkletNode['onprocessorerror']>\n                > = new Map();\n\n                let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n                Object.defineProperties(nativeAudioWorkletNode, {\n                    /*\n                     * Bug #61: Overwriting the property accessors for channelCount and channelCountMode is necessary as long as some\n                     * browsers have no native implementation to achieve a consistent behavior.\n                     */\n                    channelCount: {\n                        get: () => options.channelCount,\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    channelCountMode: {\n                        get: () => 'explicit',\n                        set: () => {\n                            throw createInvalidStateError();\n                        }\n                    },\n                    // Bug #156: Chrome and Edge do not yet fire an ErrorEvent.\n                    onprocessorerror: {\n                        get: () => onprocessorerror,\n                        set: (value) => {\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.removeEventListener('processorerror', onprocessorerror);\n                            }\n\n                            onprocessorerror = typeof value === 'function' ? value : null;\n\n                            if (typeof onprocessorerror === 'function') {\n                                nativeAudioWorkletNode.addEventListener('processorerror', onprocessorerror);\n                            }\n                        }\n                    }\n                });\n\n                nativeAudioWorkletNode.addEventListener = ((addEventListener) => {\n                    return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                        if (args[0] === 'processorerror') {\n                            const unpatchedEventListener =\n                                typeof args[1] === 'function'\n                                    ? args[1]\n                                    : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                                    ? args[1].handleEvent\n                                    : null;\n\n                            if (unpatchedEventListener !== null) {\n                                const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                                if (patchedEventListener !== undefined) {\n                                    args[1] = patchedEventListener;\n                                } else {\n                                    args[1] = (event: Event) => {\n                                        // Bug #178: Chrome and Edge do fire an event of type error.\n                                        if (event.type === 'error') {\n                                            Object.defineProperties(event, {\n                                                type: { value: 'processorerror' }\n                                            });\n\n                                            unpatchedEventListener(event);\n                                        } else {\n                                            unpatchedEventListener(new ErrorEvent(args[0], { ...event }));\n                                        }\n                                    };\n\n                                    patchedEventListeners.set(unpatchedEventListener, args[1]);\n                                }\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        addEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return addEventListener.call(nativeAudioWorkletNode, ...args);\n                    };\n                })(nativeAudioWorkletNode.addEventListener);\n\n                nativeAudioWorkletNode.removeEventListener = ((removeEventListener) => {\n                    return (...args: any[]): void => {\n                        if (args[0] === 'processorerror') {\n                            const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                            if (patchedEventListener !== undefined) {\n                                patchedEventListeners.delete(args[1]);\n\n                                args[1] = patchedEventListener;\n                            }\n                        }\n\n                        // Bug #178: Chrome and Edge do fire an event of type error.\n                        removeEventListener.call(nativeAudioWorkletNode, 'error', args[1], args[2]);\n\n                        return removeEventListener.call(nativeAudioWorkletNode, args[0], args[1], args[2]);\n                    };\n                })(nativeAudioWorkletNode.removeEventListener);\n\n                /*\n                 * Bug #86: Chrome and Edge do not invoke the process() function if the corresponding AudioWorkletNode is unconnected but\n                 * has an output.\n                 */\n                if (options.numberOfOutputs !== 0) {\n                    const nativeGainNode = createNativeGainNode(nativeContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'discrete',\n                        gain: 0\n                    });\n\n                    nativeAudioWorkletNode.connect(nativeGainNode).connect(nativeContext.destination);\n\n                    const whenConnected = () => nativeGainNode.disconnect();\n                    const whenDisconnected = () => nativeGainNode.connect(nativeContext.destination);\n\n                    // @todo Disconnect the connection when the process() function of the AudioWorkletNode returns false.\n                    return monitorConnections(nativeAudioWorkletNode, whenConnected, whenDisconnected);\n                }\n\n                return nativeAudioWorkletNode;\n            } catch (err) {\n                // Bug #60: Chrome & Edge throw an InvalidStateError instead of a NotSupportedError.\n                if (err.code === 11) {\n                    throw createNotSupportedError();\n                }\n\n                throw err;\n            }\n        }\n\n        // Bug #61: Only Chrome & Edge have an implementation of the AudioWorkletNode yet.\n        if (processorConstructor === undefined) {\n            throw createNotSupportedError();\n        }\n\n        testClonabilityOfAudioWorkletNodeOptions(options);\n\n        return createNativeAudioWorkletNodeFaker(nativeContext, baseLatency, processorConstructor, options);\n    };\n};\n", "export const computeBufferSize = (baseLatency: null | number, sampleRate: number) => {\n    if (baseLatency === null) {\n        return 512;\n    }\n\n    return Math.max(512, Math.min(16384, Math.pow(2, Math.round(Math.log2(baseLatency * sampleRate)))));\n};\n", "import { IAudioWorkletNodeOptions } from '../interfaces';\n\nexport const cloneAudioWorkletNodeOptions = (audioWorkletNodeOptions: IAudioWorkletNodeOptions): Promise<IAudioWorkletNodeOptions> => {\n    return new Promise((resolve, reject) => {\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            resolve(data);\n        };\n        port1.onmessageerror = ({ data }) => {\n            port1.close();\n            port2.close();\n\n            reject(data);\n        };\n\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port2.postMessage(audioWorkletNodeOptions);\n    });\n};\n", "import { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { cloneAudioWorkletNodeOptions } from './clone-audio-worklet-node-options';\n\nexport const createAudioWorkletProcessorPromise = async (\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    const clonedAudioWorkletNodeOptions = await cloneAudioWorkletNodeOptions(audioWorkletNodeOptions);\n\n    return new processorConstructor(clonedAudioWorkletNodeOptions);\n};\n", "import { NODE_TO_PROCESSOR_MAPS } from '../globals';\nimport { IAudioWorkletNodeOptions, IAudioWorkletProcessor, IAudioWorkletProcessorConstructor } from '../interfaces';\nimport { TNativeAudioWorkletNode, TNativeContext } from '../types';\nimport { createAudioWorkletProcessorPromise } from './create-audio-worklet-processor-promise';\n\nexport const createAudioWorkletProcessor = (\n    nativeContext: TNativeContext,\n    nativeAudioWorkletNode: TNativeAudioWorkletNode,\n    processorConstructor: IAudioWorkletProcessorConstructor,\n    audioWorkletNodeOptions: IAudioWorkletNodeOptions\n): Promise<IAudioWorkletProcessor> => {\n    let nodeToProcessorMap = NODE_TO_PROCESSOR_MAPS.get(nativeContext);\n\n    if (nodeToProcessorMap === undefined) {\n        nodeToProcessorMap = new WeakMap();\n\n        NODE_TO_PROCESSOR_MAPS.set(nativeContext, nodeToProcessorMap);\n    }\n\n    const audioWorkletProcessorPromise = createAudioWorkletProcessorPromise(processorConstructor, audioWorkletNodeOptions);\n\n    nodeToProcessorMap.set(nativeAudioWorkletNode, audioWorkletProcessorPromise);\n\n    return audioWorkletProcessorPromise;\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createAudioWorkletProcessor } from '../helpers/create-audio-worklet-processor';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { IAudioWorkletProcessor } from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeAudioWorkletNodeFakerFactoryFactory,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeConstantSourceNode,\n    TNativeGainNode\n} from '../types';\n\nexport const createNativeAudioWorkletNodeFakerFactory: TNativeAudioWorkletNodeFakerFactoryFactory = (\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n) => {\n    return (nativeContext, baseLatency, processorConstructor, options) => {\n        if (options.numberOfInputs === 0 && options.numberOfOutputs === 0) {\n            throw createNotSupportedError();\n        }\n\n        const outputChannelCount = Array.isArray(options.outputChannelCount)\n            ? options.outputChannelCount\n            : Array.from(options.outputChannelCount);\n\n        // @todo Check if any of the channelCount values is greater than the implementation's maximum number of channels.\n        if (outputChannelCount.some((channelCount) => channelCount < 1)) {\n            throw createNotSupportedError();\n        }\n\n        if (outputChannelCount.length !== options.numberOfOutputs) {\n            throw createIndexSizeError();\n        }\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (options.channelCountMode !== 'explicit') {\n            throw createNotSupportedError();\n        }\n\n        const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n        const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n        const numberOfParameters =\n            processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n\n        // Bug #61: This is not part of the standard but required for the faker to work.\n        if (numberOfInputChannels + numberOfParameters > 6 || numberOfOutputChannels > 6) {\n            throw createNotSupportedError();\n        }\n\n        const messageChannel = new MessageChannel();\n        const gainNodes: TNativeGainNode[] = [];\n        const inputChannelSplitterNodes: TNativeChannelSplitterNode[] = [];\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes.push(\n                createNativeGainNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                })\n            );\n            inputChannelSplitterNodes.push(\n                createNativeChannelSplitterNode(nativeContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: options.channelCount\n                })\n            );\n        }\n\n        const constantSourceNodes: TNativeConstantSourceNode[] = [];\n\n        if (processorConstructor.parameterDescriptors !== undefined) {\n            for (const { defaultValue, maxValue, minValue, name } of processorConstructor.parameterDescriptors) {\n                const constantSourceNode = createNativeConstantSourceNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    offset:\n                        options.parameterData[name] !== undefined\n                            ? options.parameterData[name]\n                            : defaultValue === undefined\n                            ? 0\n                            : defaultValue\n                });\n\n                Object.defineProperties(constantSourceNode.offset, {\n                    defaultValue: {\n                        get: () => (defaultValue === undefined ? 0 : defaultValue)\n                    },\n                    maxValue: {\n                        get: () => (maxValue === undefined ? MOST_POSITIVE_SINGLE_FLOAT : maxValue)\n                    },\n                    minValue: {\n                        get: () => (minValue === undefined ? MOST_NEGATIVE_SINGLE_FLOAT : minValue)\n                    }\n                });\n\n                constantSourceNodes.push(constantSourceNode);\n            }\n        }\n\n        const inputChannelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'speakers',\n            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n        });\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const scriptProcessorNode = createNativeScriptProcessorNode(\n            nativeContext,\n            bufferSize,\n            numberOfInputChannels + numberOfParameters,\n            // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n            Math.max(1, numberOfOutputChannels)\n        );\n        const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: Math.max(1, numberOfOutputChannels),\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: Math.max(1, numberOfOutputChannels)\n        });\n        const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n        for (let i = 0; i < options.numberOfOutputs; i += 1) {\n            outputChannelMergerNodes.push(\n                createNativeChannelMergerNode(nativeContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                })\n            );\n        }\n\n        for (let i = 0; i < options.numberOfInputs; i += 1) {\n            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n            for (let j = 0; j < options.channelCount; j += 1) {\n                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n            }\n        }\n\n        const parameterMap = new ReadOnlyMap(\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.map(({ name }, index) => {\n                      const constantSourceNode = constantSourceNodes[index];\n\n                      constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                      constantSourceNode.start(0);\n\n                      return <[string, TNativeAudioParam]>[name, constantSourceNode.offset];\n                  })\n        );\n\n        inputChannelMergerNode.connect(scriptProcessorNode);\n\n        let channelInterpretation = options.channelInterpretation;\n        let onprocessorerror: TNativeAudioWorkletNode['onprocessorerror'] = null;\n\n        // Bug #87: Expose at least one output to make this node connectable.\n        const outputAudioNodes = options.numberOfOutputs === 0 ? [scriptProcessorNode] : outputChannelMergerNodes;\n        const nativeAudioWorkletNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return options.channelCount;\n            },\n            set channelCount(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelCountMode(): TNativeAudioWorkletNode['channelCountMode'] {\n                return options.channelCountMode;\n            },\n            set channelCountMode(_) {\n                // Bug #61: This is not part of the standard but required for the faker to work.\n                throw createInvalidStateError();\n            },\n            get channelInterpretation(): TNativeAudioWorkletNode['channelInterpretation'] {\n                return channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                for (const gainNode of gainNodes) {\n                    gainNode.channelInterpretation = value;\n                }\n\n                channelInterpretation = value;\n            },\n            get context(): TNativeAudioWorkletNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return gainNodes;\n            },\n            get numberOfInputs(): number {\n                return options.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return options.numberOfOutputs;\n            },\n            get onprocessorerror(): TNativeAudioWorkletNode['onprocessorerror'] {\n                return onprocessorerror;\n            },\n            set onprocessorerror(value) {\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.removeEventListener('processorerror', onprocessorerror);\n                }\n\n                onprocessorerror = typeof value === 'function' ? value : null;\n\n                if (typeof onprocessorerror === 'function') {\n                    nativeAudioWorkletNodeFaker.addEventListener('processorerror', onprocessorerror);\n                }\n            },\n            get parameters(): TNativeAudioWorkletNode['parameters'] {\n                return parameterMap;\n            },\n            get port(): TNativeAudioWorkletNode['port'] {\n                return messageChannel.port2;\n            },\n            addEventListener(...args: any[]): void {\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            connect: <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputAudioNodes),\n            disconnect: <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputAudioNodes),\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        const patchedEventListeners: Map<EventListenerOrEventListenerObject, NonNullable<MessagePort['onmessage']>> = new Map();\n\n        messageChannel.port1.addEventListener = ((addEventListener) => {\n            return (...args: [string, EventListenerOrEventListenerObject, (boolean | AddEventListenerOptions)?]): void => {\n                if (args[0] === 'message') {\n                    const unpatchedEventListener =\n                        typeof args[1] === 'function'\n                            ? args[1]\n                            : typeof args[1] === 'object' && args[1] !== null && typeof args[1].handleEvent === 'function'\n                            ? args[1].handleEvent\n                            : null;\n\n                    if (unpatchedEventListener !== null) {\n                        const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                        if (patchedEventListener !== undefined) {\n                            args[1] = <EventListenerOrEventListenerObject>patchedEventListener;\n                        } else {\n                            args[1] = (event: Event) => {\n                                exposeCurrentFrameAndCurrentTime(nativeContext.currentTime, nativeContext.sampleRate, () =>\n                                    unpatchedEventListener(event)\n                                );\n                            };\n\n                            patchedEventListeners.set(unpatchedEventListener, args[1]);\n                        }\n                    }\n                }\n\n                return addEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.addEventListener);\n\n        messageChannel.port1.removeEventListener = ((removeEventListener) => {\n            return (...args: any[]): void => {\n                if (args[0] === 'message') {\n                    const patchedEventListener = patchedEventListeners.get(args[1]);\n\n                    if (patchedEventListener !== undefined) {\n                        patchedEventListeners.delete(args[1]);\n\n                        args[1] = patchedEventListener;\n                    }\n                }\n\n                return removeEventListener.call(messageChannel.port1, args[0], args[1], args[2]);\n            };\n        })(messageChannel.port1.removeEventListener);\n\n        let onmessage: MessagePort['onmessage'] = null;\n\n        Object.defineProperty(messageChannel.port1, 'onmessage', {\n            get: () => onmessage,\n            set: (value) => {\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.removeEventListener('message', onmessage);\n                }\n\n                onmessage = typeof value === 'function' ? value : null;\n\n                if (typeof onmessage === 'function') {\n                    messageChannel.port1.addEventListener('message', onmessage);\n                    messageChannel.port1.start();\n                }\n            }\n        });\n\n        processorConstructor.prototype.port = messageChannel.port1;\n\n        let audioWorkletProcessor: null | IAudioWorkletProcessor = null;\n\n        const audioWorkletProcessorPromise = createAudioWorkletProcessor(\n            nativeContext,\n            nativeAudioWorkletNodeFaker,\n            processorConstructor,\n            options\n        );\n\n        audioWorkletProcessorPromise.then((dWrkltPrcssr) => (audioWorkletProcessor = dWrkltPrcssr));\n\n        const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n        const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n        const parameters: { [name: string]: Float32Array } =\n            processorConstructor.parameterDescriptors === undefined\n                ? []\n                : processorConstructor.parameterDescriptors.reduce(\n                      (prmtrs, { name }) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n                      {}\n                  );\n\n        let isActive = true;\n\n        const disconnectOutputsGraph = () => {\n            if (options.numberOfOutputs > 0) {\n                scriptProcessorNode.disconnect(outputChannelSplitterNode);\n            }\n\n            for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                    outputChannelSplitterNode.disconnect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n\n                outputChannelSplitterNodeOutput += outputChannelCount[i];\n            }\n        };\n\n        const activeInputIndexes = new Map<number, number>();\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer, outputBuffer }: AudioProcessingEvent) => {\n            if (audioWorkletProcessor !== null) {\n                const activeInputs = getActiveAudioWorkletNodeInputs(nativeAudioWorkletNodeFaker);\n\n                for (let i = 0; i < bufferSize; i += 128) {\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < options.channelCount; k += 1) {\n                            copyFromChannel(inputBuffer, inputs[j], k, k, i);\n                        }\n                    }\n\n                    if (processorConstructor.parameterDescriptors !== undefined) {\n                        processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                            copyFromChannel(inputBuffer, parameters, name, numberOfInputChannels + index, i);\n                        });\n                    }\n\n                    for (let j = 0; j < options.numberOfInputs; j += 1) {\n                        for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                            // The byteLength will be 0 when the ArrayBuffer was transferred.\n                            if (outputs[j][k].byteLength === 0) {\n                                outputs[j][k] = new Float32Array(128);\n                            }\n                        }\n                    }\n\n                    try {\n                        const potentiallyEmptyInputs = inputs.map((input, index) => {\n                            const activeInput = activeInputs[index];\n\n                            if (activeInput.size > 0) {\n                                activeInputIndexes.set(index, bufferSize / 128);\n\n                                return input;\n                            }\n\n                            const count = activeInputIndexes.get(index);\n\n                            if (count === undefined) {\n                                return [];\n                            }\n\n                            if (input.every((channelData) => channelData.every((sample) => sample === 0))) {\n                                if (count === 1) {\n                                    activeInputIndexes.delete(index);\n                                } else {\n                                    activeInputIndexes.set(index, count - 1);\n                                }\n                            }\n\n                            return input;\n                        });\n\n                        const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                            nativeContext.currentTime + i / nativeContext.sampleRate,\n                            nativeContext.sampleRate,\n                            () => (<IAudioWorkletProcessor>audioWorkletProcessor).process(potentiallyEmptyInputs, outputs, parameters)\n                        );\n\n                        isActive = activeSourceFlag;\n\n                        for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                                copyToChannel(outputBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                            }\n\n                            outputChannelSplitterNodeOutput += outputChannelCount[j];\n                        }\n                    } catch (error) {\n                        isActive = false;\n\n                        nativeAudioWorkletNodeFaker.dispatchEvent(\n                            new ErrorEvent('processorerror', {\n                                colno: error.colno,\n                                filename: error.filename,\n                                lineno: error.lineno,\n                                message: error.message\n                            })\n                        );\n                    }\n\n                    if (!isActive) {\n                        for (let j = 0; j < options.numberOfInputs; j += 1) {\n                            gainNodes[j].disconnect(inputChannelSplitterNodes[j]);\n\n                            for (let k = 0; k < options.channelCount; k += 1) {\n                                inputChannelSplitterNodes[i].disconnect(inputChannelMergerNode, k, j * options.channelCount + k);\n                            }\n                        }\n\n                        if (processorConstructor.parameterDescriptors !== undefined) {\n                            const length = processorConstructor.parameterDescriptors.length;\n\n                            for (let j = 0; j < length; j += 1) {\n                                const constantSourceNode = constantSourceNodes[j];\n\n                                constantSourceNode.disconnect(inputChannelMergerNode, 0, numberOfInputChannels + j);\n                                constantSourceNode.stop();\n                            }\n                        }\n\n                        inputChannelMergerNode.disconnect(scriptProcessorNode);\n\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n\n                        if (isConnected) {\n                            disconnectOutputsGraph();\n                        } else {\n                            disconnectFakeGraph();\n                        }\n\n                        break;\n                    }\n                }\n            }\n        };\n\n        let isConnected = false;\n\n        // Bug #87: Only Firefox will fire an AudioProcessingEvent if there is no connected output.\n        const nativeGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        const connectFakeGraph = () => scriptProcessorNode.connect(nativeGainNode).connect(nativeContext.destination);\n        const disconnectFakeGraph = () => {\n            scriptProcessorNode.disconnect(nativeGainNode);\n            nativeGainNode.disconnect();\n        };\n        const whenConnected = () => {\n            if (isActive) {\n                disconnectFakeGraph();\n\n                if (options.numberOfOutputs > 0) {\n                    scriptProcessorNode.connect(outputChannelSplitterNode);\n                }\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < options.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n            }\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            if (isActive) {\n                connectFakeGraph();\n                disconnectOutputsGraph();\n            }\n\n            isConnected = false;\n        };\n\n        connectFakeGraph();\n\n        return monitorConnections(nativeAudioWorkletNodeFaker, whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeBiquadFilterNodeFactory } from '../types';\n\nexport const createNativeBiquadFilterNode: TNativeBiquadFilterNodeFactory = (nativeContext, options) => {\n    const nativeBiquadFilterNode = nativeContext.createBiquadFilter();\n\n    assignNativeAudioNodeOptions(nativeBiquadFilterNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'Q');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'detune');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'frequency');\n    assignNativeAudioNodeAudioParamValue(nativeBiquadFilterNode, options, 'gain');\n\n    assignNativeAudioNodeOption(nativeBiquadFilterNode, options, 'type');\n\n    return nativeBiquadFilterNode;\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeChannelMergerNodeFactoryFactory } from '../types';\n\nexport const createNativeChannelMergerNodeFactory: TNativeChannelMergerNodeFactoryFactory = (\n    nativeAudioContextConstructor,\n    wrapChannelMergerNode\n) => {\n    return (nativeContext, options) => {\n        const nativeChannelMergerNode = nativeContext.createChannelMerger(options.numberOfInputs);\n\n        /*\n         * Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here.\n         */\n        if (nativeAudioContextConstructor !== null && nativeAudioContextConstructor.name === 'webkitAudioContext') {\n            wrapChannelMergerNode(nativeContext, nativeChannelMergerNode);\n        }\n\n        assignNativeAudioNodeOptions(nativeChannelMergerNode, options);\n\n        return nativeChannelMergerNode;\n    };\n};\n", "import { createInvalidStateError } from '../factories/invalid-state-error';\nimport { TNativeChannelSplitterNode } from '../types';\n\nexport const wrapChannelSplitterNode = (channelSplitterNode: TNativeChannelSplitterNode): void => {\n    const channelCount = channelSplitterNode.numberOfOutputs;\n\n    // Bug #97: Safari does not throw an error when attempting to change the channelCount to something other than its initial value.\n    Object.defineProperty(channelSplitterNode, 'channelCount', {\n        get: () => channelCount,\n        set: (value) => {\n            if (value !== channelCount) {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #30: Safari does not throw an error when attempting to change the channelCountMode to something other than explicit.\n    Object.defineProperty(channelSplitterNode, 'channelCountMode', {\n        get: () => 'explicit',\n        set: (value) => {\n            if (value !== 'explicit') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n\n    // Bug #32: Safari does not throw an error when attempting to change the channelInterpretation to something other than discrete.\n    Object.defineProperty(channelSplitterNode, 'channelInterpretation', {\n        get: () => 'discrete',\n        set: (value) => {\n            if (value !== 'discrete') {\n                throw createInvalidStateError();\n            }\n        }\n    });\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapChannelSplitterNode } from '../helpers/wrap-channel-splitter-node';\nimport { TNativeChannelSplitterNodeFactory } from '../types';\n\nexport const createNativeChannelSplitterNode: TNativeChannelSplitterNodeFactory = (nativeContext, options) => {\n    const nativeChannelSplitterNode = nativeContext.createChannelSplitter(options.numberOfOutputs);\n\n    // Bug #96: Safari does not have the correct channelCount.\n    // Bug #29: Safari does not have the correct channelCountMode.\n    // Bug #31: Safari does not have the correct channelInterpretation.\n    assignNativeAudioNodeOptions(nativeChannelSplitterNode, options);\n\n    // Bug #29, #30, #31, #32, #96 & #97: Only Chrome, Edge & Firefox partially support the spec yet.\n    wrapChannelSplitterNode(nativeChannelSplitterNode);\n\n    return nativeChannelSplitterNode;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeConstantSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeConstantSourceNodeFactory: TNativeConstantSourceNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n) => {\n    return (nativeContext, options) => {\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeContext.createConstantSource === undefined) {\n            return createNativeConstantSourceNodeFaker(nativeContext, options);\n        }\n\n        const nativeConstantSourceNode = nativeContext.createConstantSource();\n\n        assignNativeAudioNodeOptions(nativeConstantSourceNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeConstantSourceNode, options, 'offset');\n\n        // Bug #44: Safari does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeConstantSourceNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the ConstantSourceNode is unconnected.\n        addSilentConnection(nativeContext, nativeConstantSourceNode);\n\n        return nativeConstantSourceNode;\n    };\n};\n", "import { TNativeAudioNode } from '../types';\n\nexport const interceptConnections = <T extends object>(\n    original: T,\n    interceptor: TNativeAudioNode\n): T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] } => {\n    (<T & { connect: TNativeAudioNode['connect'] }>original).connect = interceptor.connect.bind(interceptor);\n\n    (<T & { disconnect: TNativeAudioNode['disconnect'] }>original).disconnect = interceptor.disconnect.bind(interceptor);\n\n    return <T & { connect: TNativeAudioNode['connect']; disconnect: TNativeAudioNode['disconnect'] }>original;\n};\n", "import { interceptConnections } from '../helpers/intercept-connections';\nimport {\n    TNativeAudioBufferSourceNode,\n    TNativeAudioNode,\n    TNativeConstantSourceNode,\n    TNativeConstantSourceNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeConstantSourceNodeFakerFactory: TNativeConstantSourceNodeFakerFactoryFactory = (\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n) => {\n    return (nativeContext, { offset, ...audioNodeOptions }) => {\n        const audioBuffer = nativeContext.createBuffer(1, 2, 44100);\n        const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, {\n            buffer: null,\n            channelCount: 2,\n            channelCountMode: 'max',\n            channelInterpretation: 'speakers',\n            loop: false,\n            loopEnd: 0,\n            loopStart: 0,\n            playbackRate: 1\n        });\n        const gainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: offset });\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        const channelData = audioBuffer.getChannelData(0);\n\n        // Bug #95: Safari does not play or loop one sample buffers.\n        channelData[0] = 1;\n        channelData[1] = 1;\n\n        audioBufferSourceNode.buffer = audioBuffer;\n        audioBufferSourceNode.loop = true;\n\n        const nativeConstantSourceNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return gainNode.channelCount;\n            },\n            set channelCount(value) {\n                gainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeConstantSourceNode['channelCountMode'] {\n                return gainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                gainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeConstantSourceNode['channelInterpretation'] {\n                return gainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                gainNode.channelInterpretation = value;\n            },\n            get context(): TNativeConstantSourceNode['context'] {\n                return gainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [];\n            },\n            get numberOfInputs(): number {\n                return audioBufferSourceNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return gainNode.numberOfOutputs;\n            },\n            get offset(): TNativeConstantSourceNode['offset'] {\n                return gainNode.gain;\n            },\n            get onended(): TNativeConstantSourceNode['onended'] {\n                return audioBufferSourceNode.onended;\n            },\n            set onended(value) {\n                audioBufferSourceNode.onended = <TNativeAudioBufferSourceNode['onended']>value;\n            },\n            addEventListener(...args: any[]): void {\n                return audioBufferSourceNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return audioBufferSourceNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return audioBufferSourceNode.removeEventListener(args[0], args[1], args[2]);\n            },\n            start(when = 0): void {\n                audioBufferSourceNode.start.call(audioBufferSourceNode, when);\n            },\n            stop(when = 0): void {\n                audioBufferSourceNode.stop.call(audioBufferSourceNode, when);\n            }\n        };\n\n        const whenConnected = () => audioBufferSourceNode.connect(gainNode);\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(gainNode);\n\n        // Bug #175: Safari will not fire an ended event if the AudioBufferSourceNode is unconnected.\n        addSilentConnection(nativeContext, audioBufferSourceNode);\n\n        return monitorConnections(interceptConnections(nativeConstantSourceNodeFaker, gainNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeConvolverNodeFactoryFactory } from '../types';\n\nexport const createNativeConvolverNodeFactory: TNativeConvolverNodeFactoryFactory = (createNotSupportedError, overwriteAccessors) => {\n    return (nativeContext, options) => {\n        const nativeConvolverNode = nativeContext.createConvolver();\n\n        assignNativeAudioNodeOptions(nativeConvolverNode, options);\n\n        // The normalize property needs to be set before setting the buffer.\n        if (options.disableNormalization === nativeConvolverNode.normalize) {\n            nativeConvolverNode.normalize = !options.disableNormalization;\n        }\n\n        assignNativeAudioNodeOption(nativeConvolverNode, options, 'buffer');\n\n        // Bug #113: Safari does allow to set the channelCount to a value larger than 2.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCount',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        // Bug #114: Safari allows to set the channelCountMode to 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        overwriteAccessors(\n            nativeConvolverNode,\n            'channelCountMode',\n            (get) => () => get.call(nativeConvolverNode),\n            (set) => (value) => {\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                return set.call(nativeConvolverNode, value);\n            }\n        );\n\n        return nativeConvolverNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDelayNodeFactory } from '../types';\n\nexport const createNativeDelayNode: TNativeDelayNodeFactory = (nativeContext, options) => {\n    const nativeDelayNode = nativeContext.createDelay(options.maxDelayTime);\n\n    assignNativeAudioNodeOptions(nativeDelayNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeDelayNode, options, 'delayTime');\n\n    return nativeDelayNode;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeDynamicsCompressorNodeFactoryFactory } from '../types';\n\nexport const createNativeDynamicsCompressorNodeFactory: TNativeDynamicsCompressorNodeFactoryFactory = (createNotSupportedError) => {\n    return (nativeContext, options) => {\n        const nativeDynamicsCompressorNode = nativeContext.createDynamicsCompressor();\n\n        assignNativeAudioNodeOptions(nativeDynamicsCompressorNode, options);\n\n        // Bug #108: Safari allows a channelCount of three and above.\n        if (options.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #109: Only Chrome and Firefox disallow a channelCountMode of 'max'.\n        if (options.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'attack');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'knee');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'ratio');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'release');\n        assignNativeAudioNodeAudioParamValue(nativeDynamicsCompressorNode, options, 'threshold');\n\n        return nativeDynamicsCompressorNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeGainNodeFactory } from '../types';\n\nexport const createNativeGainNode: TNativeGainNodeFactory = (nativeContext, options) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    assignNativeAudioNodeOptions(nativeGainNode, options);\n\n    assignNativeAudioNodeAudioParamValue(nativeGainNode, options, 'gain');\n\n    return nativeGainNode;\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeIIRFilterNodeFactoryFactory } from '../types';\n\nexport const createNativeIIRFilterNodeFactory: TNativeIIRFilterNodeFactoryFactory = (createNativeIIRFilterNodeFaker) => {\n    return (nativeContext, baseLatency, options) => {\n        // Bug #9: Safari does not support IIRFilterNodes.\n        if (nativeContext.createIIRFilter === undefined) {\n            return createNativeIIRFilterNodeFaker(nativeContext, baseLatency, options);\n        }\n\n        // @todo TypeScript defines the parameters of createIIRFilter() as arrays of numbers.\n        const nativeIIRFilterNode = nativeContext.createIIRFilter(<number[]>options.feedforward, <number[]>options.feedback);\n\n        assignNativeAudioNodeOptions(nativeIIRFilterNode, options);\n\n        return nativeIIRFilterNode;\n    };\n};\n", "import { computeBufferSize } from '../helpers/compute-buffer-size';\nimport { filterBuffer } from '../helpers/filter-buffer';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeIIRFilterNode, TNativeIIRFilterNodeFakerFactoryFactory } from '../types';\n\nfunction divide(a: [number, number], b: [number, number]): [number, number] {\n    const denominator = b[0] * b[0] + b[1] * b[1];\n\n    return [(a[0] * b[0] + a[1] * b[1]) / denominator, (a[1] * b[0] - a[0] * b[1]) / denominator];\n}\n\nfunction multiply(a: [number, number], b: [number, number]): [number, number] {\n    return [a[0] * b[0] - a[1] * b[1], a[0] * b[1] + a[1] * b[0]];\n}\n\nfunction evaluatePolynomial(coefficient: Float64Array, z: [number, number]): [number, number] {\n    let result: [number, number] = [0, 0];\n\n    for (let i = coefficient.length - 1; i >= 0; i -= 1) {\n        result = multiply(result, z);\n\n        result[0] += coefficient[i];\n    }\n\n    return result;\n}\n\nexport const createNativeIIRFilterNodeFakerFactory: TNativeIIRFilterNodeFakerFactoryFactory = (\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n) => {\n    return (nativeContext, baseLatency, { channelCount, channelCountMode, channelInterpretation, feedback, feedforward }) => {\n        const bufferSize = computeBufferSize(baseLatency, nativeContext.sampleRate);\n        const convertedFeedback = feedback instanceof Float64Array ? feedback : new Float64Array(feedback);\n        const convertedFeedforward = feedforward instanceof Float64Array ? feedforward : new Float64Array(feedforward);\n        const feedbackLength = convertedFeedback.length;\n        const feedforwardLength = convertedFeedforward.length;\n        const minLength = Math.min(feedbackLength, feedforwardLength);\n\n        if (feedbackLength === 0 || feedbackLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedback[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (feedforwardLength === 0 || feedforwardLength > 20) {\n            throw createNotSupportedError();\n        }\n\n        if (convertedFeedforward[0] === 0) {\n            throw createInvalidStateError();\n        }\n\n        if (convertedFeedback[0] !== 1) {\n            for (let i = 0; i < feedforwardLength; i += 1) {\n                convertedFeedforward[i] /= convertedFeedback[0];\n            }\n\n            for (let i = 1; i < feedbackLength; i += 1) {\n                convertedFeedback[i] /= convertedFeedback[0];\n            }\n        }\n\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, bufferSize, channelCount, channelCount);\n\n        scriptProcessorNode.channelCount = channelCount;\n        scriptProcessorNode.channelCountMode = channelCountMode;\n        scriptProcessorNode.channelInterpretation = channelInterpretation;\n\n        const bufferLength = 32;\n        const bufferIndexes: number[] = [];\n        const xBuffers: Float32Array[] = [];\n        const yBuffers: Float32Array[] = [];\n\n        for (let i = 0; i < channelCount; i += 1) {\n            bufferIndexes.push(0);\n\n            const xBuffer = new Float32Array(bufferLength);\n            const yBuffer = new Float32Array(bufferLength);\n\n            xBuffer.fill(0);\n            yBuffer.fill(0);\n\n            xBuffers.push(xBuffer);\n            yBuffers.push(yBuffer);\n        }\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = (event: AudioProcessingEvent) => {\n            const inputBuffer = event.inputBuffer;\n            const outputBuffer = event.outputBuffer;\n\n            const numberOfChannels = inputBuffer.numberOfChannels;\n\n            for (let i = 0; i < numberOfChannels; i += 1) {\n                const input = inputBuffer.getChannelData(i);\n                const output = outputBuffer.getChannelData(i);\n\n                bufferIndexes[i] = filterBuffer(\n                    convertedFeedback,\n                    feedbackLength,\n                    convertedFeedforward,\n                    feedforwardLength,\n                    minLength,\n                    xBuffers[i],\n                    yBuffers[i],\n                    bufferIndexes[i],\n                    bufferLength,\n                    input,\n                    output\n                );\n            }\n        };\n\n        const nyquist = nativeContext.sampleRate / 2;\n\n        const nativeIIRFilterNodeFaker = {\n            get bufferSize(): number {\n                return bufferSize;\n            },\n            get channelCount(): number {\n                return scriptProcessorNode.channelCount;\n            },\n            set channelCount(value) {\n                scriptProcessorNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeIIRFilterNode['channelCountMode'] {\n                return scriptProcessorNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                scriptProcessorNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeIIRFilterNode['channelInterpretation'] {\n                return scriptProcessorNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                scriptProcessorNode.channelInterpretation = value;\n            },\n            get context(): TNativeIIRFilterNode['context'] {\n                return scriptProcessorNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [scriptProcessorNode];\n            },\n            get numberOfInputs(): number {\n                return scriptProcessorNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return scriptProcessorNode.numberOfOutputs;\n            },\n            addEventListener(...args: any[]): void {\n                // @todo Dissallow adding an audioprocess listener.\n                return scriptProcessorNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return scriptProcessorNode.dispatchEvent(args[0]);\n            },\n            getFrequencyResponse(frequencyHz: Float32Array, magResponse: Float32Array, phaseResponse: Float32Array): void {\n                if (frequencyHz.length !== magResponse.length || magResponse.length !== phaseResponse.length) {\n                    throw createInvalidAccessError();\n                }\n\n                const length = frequencyHz.length;\n\n                for (let i = 0; i < length; i += 1) {\n                    const omega = -Math.PI * (frequencyHz[i] / nyquist);\n                    const z: [number, number] = [Math.cos(omega), Math.sin(omega)];\n                    const numerator = evaluatePolynomial(convertedFeedforward, z);\n                    const denominator = evaluatePolynomial(convertedFeedback, z);\n                    const response = divide(numerator, denominator);\n\n                    magResponse[i] = Math.sqrt(response[0] * response[0] + response[1] * response[1]);\n                    phaseResponse[i] = Math.atan2(response[1], response[0]);\n                }\n            },\n            removeEventListener(...args: any[]): void {\n                return scriptProcessorNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        return interceptConnections(nativeIIRFilterNodeFaker, scriptProcessorNode);\n    };\n};\n", "import { TNativeMediaElementAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaElementAudioSourceNode: TNativeMediaElementAudioSourceNodeFactory = (nativeAudioContext, options) => {\n    return nativeAudioContext.createMediaElementSource(options.mediaElement);\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeMediaStreamAudioDestinationNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioDestinationNode: TNativeMediaStreamAudioDestinationNodeFactory = (nativeAudioContext, options) => {\n    const nativeMediaStreamAudioDestinationNode = nativeAudioContext.createMediaStreamDestination();\n\n    assignNativeAudioNodeOptions(nativeMediaStreamAudioDestinationNode, options);\n\n    // Bug #174: Safari does expose a wrong numberOfOutputs.\n    if (nativeMediaStreamAudioDestinationNode.numberOfOutputs === 1) {\n        Object.defineProperty(nativeMediaStreamAudioDestinationNode, 'numberOfOutputs', { get: () => 0 });\n    }\n\n    return nativeMediaStreamAudioDestinationNode;\n};\n", "import { TNativeMediaStreamAudioSourceNodeFactory } from '../types';\n\nexport const createNativeMediaStreamAudioSourceNode: TNativeMediaStreamAudioSourceNodeFactory = (nativeAudioContext, { mediaStream }) => {\n    const audioStreamTracks = mediaStream.getAudioTracks();\n    /*\n     * Bug #151: Safari does not use the audio track as input anymore if it gets removed from the mediaStream after construction.\n     * Bug #159: Safari picks the first audio track if the MediaStream has more than one audio track.\n     */\n    audioStreamTracks.sort((a, b) => (a.id < b.id ? -1 : a.id > b.id ? 1 : 0));\n\n    const filteredAudioStreamTracks = audioStreamTracks.slice(0, 1);\n\n    const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(new MediaStream(filteredAudioStreamTracks));\n\n    /*\n     * Bug #151 & #159: The given mediaStream gets reconstructed before it gets passed to the native node which is why the accessor needs\n     * to be overwritten as it would otherwise expose the reconstructed version.\n     */\n    Object.defineProperty(nativeMediaStreamAudioSourceNode, 'mediaStream', { value: mediaStream });\n\n    return nativeMediaStreamAudioSourceNode;\n};\n", "import { TNativeMediaStreamTrackAudioSourceNodeFactoryFactory } from '../types';\n\nexport const createNativeMediaStreamTrackAudioSourceNodeFactory: TNativeMediaStreamTrackAudioSourceNodeFactoryFactory = (\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n) => {\n    return (nativeAudioContext, { mediaStreamTrack }) => {\n        // Bug #121: Only Firefox does yet support the MediaStreamTrackAudioSourceNode.\n        if (typeof nativeAudioContext.createMediaStreamTrackSource === 'function') {\n            return nativeAudioContext.createMediaStreamTrackSource(mediaStreamTrack);\n        }\n\n        const mediaStream = new MediaStream([mediaStreamTrack]);\n        const nativeMediaStreamAudioSourceNode = nativeAudioContext.createMediaStreamSource(mediaStream);\n\n        // Bug #120: Firefox does not throw an error if the mediaStream has no audio track.\n        if (mediaStreamTrack.kind !== 'audio') {\n            throw createInvalidStateError();\n        }\n\n        // Bug #172: Safari allows to create a MediaStreamAudioSourceNode with an OfflineAudioContext.\n        if (isNativeOfflineAudioContext(nativeAudioContext)) {\n            throw new TypeError();\n        }\n\n        return nativeMediaStreamAudioSourceNode;\n    };\n};\n", "import { TNativeOfflineAudioContextConstructorFactory } from '../types';\n\nexport const createNativeOfflineAudioContextConstructor: TNativeOfflineAudioContextConstructorFactory = (window) => {\n    if (window === null) {\n        return null;\n    }\n\n    if (window.hasOwnProperty('OfflineAudioContext')) {\n        return window.OfflineAudioContext;\n    }\n\n    return window.hasOwnProperty('webkitOfflineAudioContext') ? (<any>window).webkitOfflineAudioContext : null;\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { wrapAudioScheduledSourceNodeStartMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-start-method-negative-parameters';\nimport { wrapAudioScheduledSourceNodeStopMethodNegativeParameters } from '../helpers/wrap-audio-scheduled-source-node-stop-method-negative-parameters';\nimport { TNativeOscillatorNodeFactoryFactory } from '../types';\n\nexport const createNativeOscillatorNodeFactory: TNativeOscillatorNodeFactoryFactory = (\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n) => {\n    return (nativeContext, options) => {\n        const nativeOscillatorNode = nativeContext.createOscillator();\n\n        assignNativeAudioNodeOptions(nativeOscillatorNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'detune');\n        assignNativeAudioNodeAudioParamValue(nativeOscillatorNode, options, 'frequency');\n\n        if (options.periodicWave !== undefined) {\n            nativeOscillatorNode.setPeriodicWave(options.periodicWave);\n        } else {\n            assignNativeAudioNodeOption(nativeOscillatorNode, options, 'type');\n        }\n\n        // Bug #44: Only Chrome & Edge throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStartMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStartMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStartMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #19: Safari does not ignore calls to stop() of an already stopped AudioBufferSourceNode.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport, () =>\n                testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeOscillatorNode, nativeContext);\n        }\n\n        // Bug #44: Only Firefox does not throw a RangeError yet.\n        if (\n            !cacheTestResult(testAudioScheduledSourceNodeStopMethodNegativeParametersSupport, () =>\n                testAudioScheduledSourceNodeStopMethodNegativeParametersSupport(nativeContext)\n            )\n        ) {\n            wrapAudioScheduledSourceNodeStopMethodNegativeParameters(nativeOscillatorNode);\n        }\n\n        // Bug #175: Safari will not fire an ended event if the OscillatorNode is unconnected.\n        addSilentConnection(nativeContext, nativeOscillatorNode);\n\n        return nativeOscillatorNode;\n    };\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativePannerNodeFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFactory: TNativePannerNodeFactoryFactory = (createNativePannerNodeFaker) => {\n    return (nativeContext, options) => {\n        const nativePannerNode = nativeContext.createPanner();\n\n        // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n        if (nativePannerNode.orientationX === undefined) {\n            return createNativePannerNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativePannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'orientationZ');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionX');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionY');\n        assignNativeAudioNodeAudioParamValue(nativePannerNode, options, 'positionZ');\n\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneInnerAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterAngle');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'coneOuterGain');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'distanceModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'maxDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'panningModel');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'refDistance');\n        assignNativeAudioNodeOption(nativePannerNode, options, 'rolloffFactor');\n\n        return nativePannerNode;\n    };\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativePannerNode, TNativePannerNodeFakerFactoryFactory } from '../types';\n\nexport const createNativePannerNodeFakerFactory: TNativePannerNodeFakerFactoryFactory = (\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n) => {\n    return (\n        nativeContext,\n        {\n            coneInnerAngle,\n            coneOuterAngle,\n            coneOuterGain,\n            distanceModel,\n            maxDistance,\n            orientationX,\n            orientationY,\n            orientationZ,\n            panningModel,\n            positionX,\n            positionY,\n            positionZ,\n            refDistance,\n            rolloffFactor,\n            ...audioNodeOptions\n        }\n    ) => {\n        const pannerNode = nativeContext.createPanner();\n\n        // Bug #125: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCount > 2) {\n            throw createNotSupportedError();\n        }\n\n        // Bug #126: Safari does not throw an error yet.\n        if (audioNodeOptions.channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        assignNativeAudioNodeOptions(pannerNode, audioNodeOptions);\n\n        const SINGLE_CHANNEL_OPTIONS = {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete'\n        } as const;\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            channelInterpretation: 'speakers',\n            numberOfInputs: 6\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const orientationXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 1 });\n        const orientationYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const orientationZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionXGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionYGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const positionZGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        const scriptProcessorNode = createNativeScriptProcessorNode(nativeContext, 256, 6, 1);\n        const waveShaperNode = createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_OPTIONS,\n            curve: new Float32Array([1, 1]),\n            oversample: 'none'\n        });\n\n        let lastOrientation: [number, number, number] = [orientationX, orientationY, orientationZ];\n        let lastPosition: [number, number, number] = [positionX, positionY, positionZ];\n\n        const buffer = new Float32Array(1);\n\n        // tslint:disable-next-line:deprecation\n        scriptProcessorNode.onaudioprocess = ({ inputBuffer }) => {\n            const orientation: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 0),\n                getFirstSample(inputBuffer, buffer, 1),\n                getFirstSample(inputBuffer, buffer, 2)\n            ];\n\n            if (orientation.some((value, index) => value !== lastOrientation[index])) {\n                pannerNode.setOrientation(...orientation); // tslint:disable-line:deprecation\n\n                lastOrientation = orientation;\n            }\n\n            const positon: [number, number, number] = [\n                getFirstSample(inputBuffer, buffer, 3),\n                getFirstSample(inputBuffer, buffer, 4),\n                getFirstSample(inputBuffer, buffer, 5)\n            ];\n\n            if (positon.some((value, index) => value !== lastPosition[index])) {\n                pannerNode.setPosition(...positon); // tslint:disable-line:deprecation\n\n                lastPosition = positon;\n            }\n        };\n\n        Object.defineProperty(orientationYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(orientationZGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionXGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionYGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(positionZGainNode.gain, 'defaultValue', { get: () => 0 });\n\n        const nativePannerNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return pannerNode.channelCount;\n            },\n            set channelCount(value) {\n                // Bug #125: Safari does not throw an error yet.\n                if (value > 2) {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCount = value;\n                pannerNode.channelCount = value;\n            },\n            get channelCountMode(): TNativePannerNode['channelCountMode'] {\n                return pannerNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                // Bug #126: Safari does not throw an error yet.\n                if (value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n                pannerNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativePannerNode['channelInterpretation'] {\n                return pannerNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                pannerNode.channelInterpretation = value;\n            },\n            get coneInnerAngle(): TNativePannerNode['coneInnerAngle'] {\n                return pannerNode.coneInnerAngle;\n            },\n            set coneInnerAngle(value) {\n                pannerNode.coneInnerAngle = value;\n            },\n            get coneOuterAngle(): TNativePannerNode['coneOuterAngle'] {\n                return pannerNode.coneOuterAngle;\n            },\n            set coneOuterAngle(value) {\n                pannerNode.coneOuterAngle = value;\n            },\n            get coneOuterGain(): TNativePannerNode['coneOuterGain'] {\n                return pannerNode.coneOuterGain;\n            },\n            set coneOuterGain(value) {\n                // Bug #127: Safari does not throw an InvalidStateError yet.\n                if (value < 0 || value > 1) {\n                    throw createInvalidStateError();\n                }\n\n                pannerNode.coneOuterGain = value;\n            },\n            get context(): TNativePannerNode['context'] {\n                return pannerNode.context;\n            },\n            get distanceModel(): TNativePannerNode['distanceModel'] {\n                return pannerNode.distanceModel;\n            },\n            set distanceModel(value) {\n                pannerNode.distanceModel = value;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get maxDistance(): TNativePannerNode['maxDistance'] {\n                return pannerNode.maxDistance;\n            },\n            set maxDistance(value) {\n                // Bug #128: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.maxDistance = value;\n            },\n            get numberOfInputs(): number {\n                return pannerNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return pannerNode.numberOfOutputs;\n            },\n            get orientationX(): TNativePannerNode['orientationX'] {\n                return orientationXGainNode.gain;\n            },\n            get orientationY(): TNativePannerNode['orientationY'] {\n                return orientationYGainNode.gain;\n            },\n            get orientationZ(): TNativePannerNode['orientationZ'] {\n                return orientationZGainNode.gain;\n            },\n            get panningModel(): TNativePannerNode['panningModel'] {\n                return pannerNode.panningModel;\n            },\n            set panningModel(value) {\n                pannerNode.panningModel = value;\n            },\n            get positionX(): TNativePannerNode['positionX'] {\n                return positionXGainNode.gain;\n            },\n            get positionY(): TNativePannerNode['positionY'] {\n                return positionYGainNode.gain;\n            },\n            get positionZ(): TNativePannerNode['positionZ'] {\n                return positionZGainNode.gain;\n            },\n            get refDistance(): TNativePannerNode['refDistance'] {\n                return pannerNode.refDistance;\n            },\n            set refDistance(value) {\n                // Bug #129: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.refDistance = value;\n            },\n            get rolloffFactor(): TNativePannerNode['rolloffFactor'] {\n                return pannerNode.rolloffFactor;\n            },\n            set rolloffFactor(value) {\n                // Bug #130: Safari does not throw an error yet.\n                if (value < 0) {\n                    throw new RangeError();\n                }\n\n                pannerNode.rolloffFactor = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (coneInnerAngle !== nativePannerNodeFaker.coneInnerAngle) {\n            nativePannerNodeFaker.coneInnerAngle = coneInnerAngle;\n        }\n\n        if (coneOuterAngle !== nativePannerNodeFaker.coneOuterAngle) {\n            nativePannerNodeFaker.coneOuterAngle = coneOuterAngle;\n        }\n\n        if (coneOuterGain !== nativePannerNodeFaker.coneOuterGain) {\n            nativePannerNodeFaker.coneOuterGain = coneOuterGain;\n        }\n\n        if (distanceModel !== nativePannerNodeFaker.distanceModel) {\n            nativePannerNodeFaker.distanceModel = distanceModel;\n        }\n\n        if (maxDistance !== nativePannerNodeFaker.maxDistance) {\n            nativePannerNodeFaker.maxDistance = maxDistance;\n        }\n\n        if (orientationX !== nativePannerNodeFaker.orientationX.value) {\n            nativePannerNodeFaker.orientationX.value = orientationX;\n        }\n\n        if (orientationY !== nativePannerNodeFaker.orientationY.value) {\n            nativePannerNodeFaker.orientationY.value = orientationY;\n        }\n\n        if (orientationZ !== nativePannerNodeFaker.orientationZ.value) {\n            nativePannerNodeFaker.orientationZ.value = orientationZ;\n        }\n\n        if (panningModel !== nativePannerNodeFaker.panningModel) {\n            nativePannerNodeFaker.panningModel = panningModel;\n        }\n\n        if (positionX !== nativePannerNodeFaker.positionX.value) {\n            nativePannerNodeFaker.positionX.value = positionX;\n        }\n\n        if (positionY !== nativePannerNodeFaker.positionY.value) {\n            nativePannerNodeFaker.positionY.value = positionY;\n        }\n\n        if (positionZ !== nativePannerNodeFaker.positionZ.value) {\n            nativePannerNodeFaker.positionZ.value = positionZ;\n        }\n\n        if (refDistance !== nativePannerNodeFaker.refDistance) {\n            nativePannerNodeFaker.refDistance = refDistance;\n        }\n\n        if (rolloffFactor !== nativePannerNodeFaker.rolloffFactor) {\n            nativePannerNodeFaker.rolloffFactor = rolloffFactor;\n        }\n\n        if (lastOrientation[0] !== 1 || lastOrientation[1] !== 0 || lastOrientation[2] !== 0) {\n            pannerNode.setOrientation(...lastOrientation); // tslint:disable-line:deprecation\n        }\n\n        if (lastPosition[0] !== 0 || lastPosition[1] !== 0 || lastPosition[2] !== 0) {\n            pannerNode.setPosition(...lastPosition); // tslint:disable-line:deprecation\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            connectNativeAudioNodeToNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.connect(orientationXGainNode).connect(channelMergerNode, 0, 0);\n            waveShaperNode.connect(orientationYGainNode).connect(channelMergerNode, 0, 1);\n            waveShaperNode.connect(orientationZGainNode).connect(channelMergerNode, 0, 2);\n            waveShaperNode.connect(positionXGainNode).connect(channelMergerNode, 0, 3);\n            waveShaperNode.connect(positionYGainNode).connect(channelMergerNode, 0, 4);\n            waveShaperNode.connect(positionZGainNode).connect(channelMergerNode, 0, 5);\n\n            channelMergerNode.connect(scriptProcessorNode).connect(nativeContext.destination);\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(pannerNode);\n\n            // Bug #119: Safari does not fully support the WaveShaperNode.\n            disconnectNativeAudioNodeFromNativeAudioNode(inputGainNode, waveShaperNode, 0, 0);\n\n            waveShaperNode.disconnect(orientationXGainNode);\n            orientationXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationYGainNode);\n            orientationYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(orientationZGainNode);\n            orientationZGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionXGainNode);\n            positionXGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionYGainNode);\n            positionYGainNode.disconnect(channelMergerNode);\n            waveShaperNode.disconnect(positionZGainNode);\n            positionZGainNode.disconnect(channelMergerNode);\n\n            channelMergerNode.disconnect(scriptProcessorNode);\n            scriptProcessorNode.disconnect(nativeContext.destination);\n        };\n\n        return monitorConnections(interceptConnections(nativePannerNodeFaker, pannerNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { TNativePeriodicWaveFactoryFactory } from '../types';\n\nexport const createNativePeriodicWaveFactory: TNativePeriodicWaveFactoryFactory = (createIndexSizeError) => {\n    return (nativeContext, { disableNormalization, imag, real }) => {\n        // Bug #180: Safari does not allow to use ordinary arrays.\n        const convertedImag = imag instanceof Float32Array ? imag : new Float32Array(imag);\n        const convertedReal = real instanceof Float32Array ? real : new Float32Array(real);\n\n        const nativePeriodicWave = nativeContext.createPeriodicWave(convertedReal, convertedImag, { disableNormalization });\n\n        // Bug #181: Safari does not throw an IndexSizeError so far if the given arrays have less than two values.\n        if (Array.from(imag).length < 2) {\n            throw createIndexSizeError();\n        }\n\n        return nativePeriodicWave;\n    };\n};\n", "import { TNativeScriptProcessorNodeFactory } from '../types';\n\nexport const createNativeScriptProcessorNode: TNativeScriptProcessorNodeFactory = (\n    nativeContext,\n    bufferSize,\n    numberOfInputChannels,\n    numberOfOutputChannels\n) => {\n    return nativeContext.createScriptProcessor(bufferSize, numberOfInputChannels, numberOfOutputChannels); // tslint:disable-line deprecation\n};\n", "import { assignNativeAudioNodeAudioParamValue } from '../helpers/assign-native-audio-node-audio-param-value';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeStereoPannerNodeFactoryFactory } from '../types';\n\nexport const createNativeStereoPannerNodeFactory: TNativeStereoPannerNodeFactoryFactory = (\n    createNativeStereoPannerNodeFaker,\n    createNotSupportedError\n) => {\n    return (nativeContext, options) => {\n        const channelCountMode = options.channelCountMode;\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        if (channelCountMode === 'clamped-max') {\n            throw createNotSupportedError();\n        }\n\n        // Bug #105: Safari does not support the StereoPannerNode.\n        if (nativeContext.createStereoPanner === undefined) {\n            return createNativeStereoPannerNodeFaker(nativeContext, options);\n        }\n\n        const nativeStereoPannerNode = nativeContext.createStereoPanner();\n\n        assignNativeAudioNodeOptions(nativeStereoPannerNode, options);\n\n        assignNativeAudioNodeAudioParamValue(nativeStereoPannerNode, options, 'pan');\n\n        /*\n         * Bug #105: The channelCountMode of 'clamped-max' should be supported. However it is not possible to write a polyfill for Safari\n         * which supports it and therefore it can't be supported at all.\n         */\n        Object.defineProperty(nativeStereoPannerNode, 'channelCountMode', {\n            get: () => channelCountMode,\n            set: (value) => {\n                if (value !== channelCountMode) {\n                    throw createNotSupportedError();\n                }\n            }\n        });\n\n        return nativeStereoPannerNode;\n    };\n};\n", "import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n", "import { assignNativeAudioNodeOption } from '../helpers/assign-native-audio-node-option';\nimport { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { TNativeWaveShaperNodeFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFactory: TNativeWaveShaperNodeFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n) => {\n    return (nativeContext, options) => {\n        const nativeWaveShaperNode = nativeContext.createWaveShaper();\n\n        /*\n         * Bug #119: Safari does not correctly map the values.\n         * @todo Unfortunately there is no way to test for this behavior in a synchronous fashion which is why testing for the existence of\n         * the webkitAudioContext is used as a workaround here. Testing for the automationRate property is necessary because this workaround\n         * isn't necessary anymore since v14.0.2 of Safari.\n         */\n        if (\n            nativeAudioContextConstructor !== null &&\n            nativeAudioContextConstructor.name === 'webkitAudioContext' &&\n            nativeContext.createGain().gain.automationRate === undefined\n        ) {\n            return createNativeWaveShaperNodeFaker(nativeContext, options);\n        }\n\n        assignNativeAudioNodeOptions(nativeWaveShaperNode, options);\n\n        const curve = options.curve === null || options.curve instanceof Float32Array ? options.curve : new Float32Array(options.curve);\n\n        // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n        if (curve !== null && curve.length < 2) {\n            throw createInvalidStateError();\n        }\n\n        // Only values of type Float32Array can be assigned to the curve property.\n        assignNativeAudioNodeOption(nativeWaveShaperNode, { curve }, 'curve');\n        assignNativeAudioNodeOption(nativeWaveShaperNode, options, 'oversample');\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n\n        overwriteAccessors(\n            nativeWaveShaperNode,\n            'curve',\n            (get) => () => get.call(nativeWaveShaperNode),\n            (set) => (value) => {\n                set.call(nativeWaveShaperNode, value);\n\n                if (isConnected) {\n                    if (isDCCurve(value) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(\n                            nativeContext,\n                            nativeWaveShaperNode\n                        );\n                    } else if (!isDCCurve(value) && disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n\n                return value;\n            }\n        );\n\n        const whenConnected = () => {\n            isConnected = true;\n\n            if (isDCCurve(nativeWaveShaperNode.curve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, nativeWaveShaperNode);\n            }\n        };\n        const whenDisconnected = () => {\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(nativeWaveShaperNode, whenConnected, whenDisconnected);\n    };\n};\n", "import { assignNativeAudioNodeOptions } from '../helpers/assign-native-audio-node-options';\nimport { interceptConnections } from '../helpers/intercept-connections';\nimport { TNativeAudioNode, TNativeWaveShaperNode, TNativeWaveShaperNodeFakerFactoryFactory } from '../types';\n\nexport const createNativeWaveShaperNodeFakerFactory: TNativeWaveShaperNodeFakerFactoryFactory = (\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n) => {\n    return (nativeContext, { curve, oversample, ...audioNodeOptions }) => {\n        const negativeWaveShaperNode = nativeContext.createWaveShaper();\n        const positiveWaveShaperNode = nativeContext.createWaveShaper();\n\n        assignNativeAudioNodeOptions(negativeWaveShaperNode, audioNodeOptions);\n        assignNativeAudioNodeOptions(positiveWaveShaperNode, audioNodeOptions);\n\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const invertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n        const outputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: 1 });\n        const revertGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, gain: -1 });\n\n        let disconnectNativeAudioBufferSourceNode: null | (() => void) = null;\n        let isConnected = false;\n        let unmodifiedCurve: null | TNativeWaveShaperNode['curve'] = null;\n\n        const nativeWaveShaperNodeFaker = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return negativeWaveShaperNode.channelCount;\n            },\n            set channelCount(value) {\n                inputGainNode.channelCount = value;\n                invertGainNode.channelCount = value;\n                negativeWaveShaperNode.channelCount = value;\n                outputGainNode.channelCount = value;\n                positiveWaveShaperNode.channelCount = value;\n                revertGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeWaveShaperNode['channelCountMode'] {\n                return negativeWaveShaperNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                inputGainNode.channelCountMode = value;\n                invertGainNode.channelCountMode = value;\n                negativeWaveShaperNode.channelCountMode = value;\n                outputGainNode.channelCountMode = value;\n                positiveWaveShaperNode.channelCountMode = value;\n                revertGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeWaveShaperNode['channelInterpretation'] {\n                return negativeWaveShaperNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n                invertGainNode.channelInterpretation = value;\n                negativeWaveShaperNode.channelInterpretation = value;\n                outputGainNode.channelInterpretation = value;\n                positiveWaveShaperNode.channelInterpretation = value;\n                revertGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeWaveShaperNode['context'] {\n                return negativeWaveShaperNode.context;\n            },\n            get curve(): TNativeWaveShaperNode['curve'] {\n                return unmodifiedCurve;\n            },\n            set curve(value) {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                if (value !== null && value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                if (value === null) {\n                    negativeWaveShaperNode.curve = value;\n                    positiveWaveShaperNode.curve = value;\n                } else {\n                    const curveLength = value.length;\n\n                    const negativeCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n                    const positiveCurve = new Float32Array(curveLength + 2 - (curveLength % 2));\n\n                    negativeCurve[0] = value[0];\n                    positiveCurve[0] = -value[curveLength - 1];\n\n                    const length = Math.ceil((curveLength + 1) / 2);\n                    const centerIndex = (curveLength + 1) / 2 - 1;\n\n                    for (let i = 1; i < length; i += 1) {\n                        const theoreticIndex = (i / length) * centerIndex;\n\n                        const lowerIndex = Math.floor(theoreticIndex);\n                        const upperIndex = Math.ceil(theoreticIndex);\n\n                        negativeCurve[i] =\n                            lowerIndex === upperIndex\n                                ? value[lowerIndex]\n                                : (1 - (theoreticIndex - lowerIndex)) * value[lowerIndex] +\n                                  (1 - (upperIndex - theoreticIndex)) * value[upperIndex];\n                        positiveCurve[i] =\n                            lowerIndex === upperIndex\n                                ? -value[curveLength - 1 - lowerIndex]\n                                : -((1 - (theoreticIndex - lowerIndex)) * value[curveLength - 1 - lowerIndex]) -\n                                  (1 - (upperIndex - theoreticIndex)) * value[curveLength - 1 - upperIndex];\n                    }\n\n                    negativeCurve[length] = curveLength % 2 === 1 ? value[length - 1] : (value[length - 2] + value[length - 1]) / 2;\n\n                    negativeWaveShaperNode.curve = negativeCurve;\n                    positiveWaveShaperNode.curve = positiveCurve;\n                }\n\n                unmodifiedCurve = value;\n\n                if (isConnected) {\n                    if (isDCCurve(unmodifiedCurve) && disconnectNativeAudioBufferSourceNode === null) {\n                        disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n                    } else if (disconnectNativeAudioBufferSourceNode !== null) {\n                        disconnectNativeAudioBufferSourceNode();\n                        disconnectNativeAudioBufferSourceNode = null;\n                    }\n                }\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return negativeWaveShaperNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return negativeWaveShaperNode.numberOfOutputs;\n            },\n            get oversample(): TNativeWaveShaperNode['oversample'] {\n                return negativeWaveShaperNode.oversample;\n            },\n            set oversample(value) {\n                negativeWaveShaperNode.oversample = value;\n                positiveWaveShaperNode.oversample = value;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        if (curve !== null) {\n            // Only values of type Float32Array can be assigned to the curve property.\n            nativeWaveShaperNodeFaker.curve = curve instanceof Float32Array ? curve : new Float32Array(curve);\n        }\n\n        if (oversample !== nativeWaveShaperNodeFaker.oversample) {\n            nativeWaveShaperNodeFaker.oversample = oversample;\n        }\n\n        const whenConnected = () => {\n            inputGainNode.connect(negativeWaveShaperNode).connect(outputGainNode);\n\n            inputGainNode.connect(invertGainNode).connect(positiveWaveShaperNode).connect(revertGainNode).connect(outputGainNode);\n\n            isConnected = true;\n\n            if (isDCCurve(unmodifiedCurve)) {\n                disconnectNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNode(nativeContext, inputGainNode);\n            }\n        };\n        const whenDisconnected = () => {\n            inputGainNode.disconnect(negativeWaveShaperNode);\n            negativeWaveShaperNode.disconnect(outputGainNode);\n\n            inputGainNode.disconnect(invertGainNode);\n            invertGainNode.disconnect(positiveWaveShaperNode);\n            positiveWaveShaperNode.disconnect(revertGainNode);\n            revertGainNode.disconnect(outputGainNode);\n\n            isConnected = false;\n\n            if (disconnectNativeAudioBufferSourceNode !== null) {\n                disconnectNativeAudioBufferSourceNode();\n                disconnectNativeAudioBufferSourceNode = null;\n            }\n        };\n\n        return monitorConnections(interceptConnections(nativeWaveShaperNodeFaker, outputGainNode), whenConnected, whenDisconnected);\n    };\n};\n", "import { TNotSupportedErrorFactory } from '../types';\n\nexport const createNotSupportedError: TNotSupportedErrorFactory = () => new DOMException('', 'NotSupportedError');\n", "import { deactivateAudioGraph } from '../helpers/deactivate-audio-graph';\nimport { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IAudioBuffer, IOfflineAudioContext, IOfflineAudioContextOptions } from '../interfaces';\nimport { TAudioContextState, TNativeOfflineAudioContext, TOfflineAudioContextConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createOfflineAudioContextConstructor: TOfflineAudioContextConstructorFactory = (\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n) => {\n    return class OfflineAudioContext extends baseAudioContextConstructor<IOfflineAudioContext> implements IOfflineAudioContext {\n        private _length: number;\n\n        private _nativeOfflineAudioContext: TNativeOfflineAudioContext;\n\n        private _state: null | TAudioContextState;\n\n        constructor(options: IOfflineAudioContextOptions);\n        constructor(numberOfChannels: number, length: number, sampleRate: number);\n        constructor(a: number | IOfflineAudioContextOptions, b?: number, c?: number) {\n            let options: IOfflineAudioContextOptions;\n\n            if (typeof a === 'number' && b !== undefined && c !== undefined) {\n                options = { length: b, numberOfChannels: a, sampleRate: c };\n            } else if (typeof a === 'object') {\n                options = a;\n            } else {\n                throw new Error('The given parameters are not valid.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            const nativeOfflineAudioContext = createNativeOfflineAudioContext(numberOfChannels, length, sampleRate);\n\n            // #21 Safari does not support promises and therefore would fire the statechange event before the promise can be resolved.\n            if (!cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n                nativeOfflineAudioContext.addEventListener(\n                    'statechange',\n                    (() => {\n                        let i = 0;\n\n                        const delayStateChangeEvent = (event: Event) => {\n                            if (this._state === 'running') {\n                                if (i > 0) {\n                                    nativeOfflineAudioContext.removeEventListener('statechange', delayStateChangeEvent);\n                                    event.stopImmediatePropagation();\n\n                                    this._waitForThePromiseToSettle(event);\n                                } else {\n                                    i += 1;\n                                }\n                            }\n                        };\n\n                        return delayStateChangeEvent;\n                    })()\n                );\n            }\n\n            super(nativeOfflineAudioContext, numberOfChannels);\n\n            this._length = length;\n            this._nativeOfflineAudioContext = nativeOfflineAudioContext;\n            this._state = null;\n        }\n\n        get length(): number {\n            // Bug #17: Safari does not yet expose the length.\n            if (this._nativeOfflineAudioContext.length === undefined) {\n                return this._length;\n            }\n\n            return this._nativeOfflineAudioContext.length;\n        }\n\n        get state(): TAudioContextState {\n            return this._state === null ? this._nativeOfflineAudioContext.state : this._state;\n        }\n\n        public startRendering(): Promise<IAudioBuffer> {\n            /*\n             * Bug #9 & #59: It is theoretically possible that startRendering() will first render a partialOfflineAudioContext. Therefore\n             * the state of the nativeOfflineAudioContext might no transition to running immediately.\n             */\n            if (this._state === 'running') {\n                return Promise.reject(createInvalidStateError());\n            }\n\n            this._state = 'running';\n\n            return startRendering(this.destination, this._nativeOfflineAudioContext).finally(() => {\n                this._state = null;\n\n                deactivateAudioGraph(this);\n            });\n        }\n\n        private _waitForThePromiseToSettle(event: Event): void {\n            if (this._state === null) {\n                this._nativeOfflineAudioContext.dispatchEvent(event);\n            } else {\n                setTimeout(() => this._waitForThePromiseToSettle(event));\n            }\n        }\n    };\n};\n", "import { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport {\n    IAudioParam,\n    IAudioScheduledSourceNodeEventMap,\n    IMinimalOfflineAudioContext,\n    IOscillatorNode,\n    IOscillatorNodeRenderer,\n    IOscillatorOptions\n} from '../interfaces';\nimport {\n    TContext,\n    TEventHandler,\n    TNativeOscillatorNode,\n    TOscillatorNodeConstructorFactory,\n    TOscillatorNodeRenderer,\n    TOscillatorType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max', // This attribute has no effect for nodes with no inputs.\n    channelInterpretation: 'speakers', // This attribute has no effect for nodes with no inputs.\n    detune: 0,\n    frequency: 440,\n    periodicWave: undefined,\n    type: 'sine'\n} as const;\n\nexport const createOscillatorNodeConstructor: TOscillatorNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class OscillatorNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IOscillatorNode<T>\n    {\n        private _detune: IAudioParam;\n\n        private _frequency: IAudioParam;\n\n        private _nativeOscillatorNode: TNativeOscillatorNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _oscillatorNodeRenderer: TOscillatorNodeRenderer<T>;\n\n        constructor(context: T, options?: Partial<IOscillatorOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeOscillatorNode = createNativeOscillatorNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const oscillatorNodeRenderer = <TOscillatorNodeRenderer<T>>(isOffline ? createOscillatorNodeRenderer() : null);\n            const nyquist = context.sampleRate / 2;\n\n            super(context, false, nativeOscillatorNode, oscillatorNodeRenderer);\n\n            // Bug #81: Firefox & Safari do not export the correct values for maxValue and minValue.\n            this._detune = createAudioParam(this, isOffline, nativeOscillatorNode.detune, 153600, -153600);\n            // Bug #76: Safari does not export the correct values for maxValue and minValue.\n            this._frequency = createAudioParam(this, isOffline, nativeOscillatorNode.frequency, nyquist, -nyquist);\n            this._nativeOscillatorNode = nativeOscillatorNode;\n            this._onended = null;\n            this._oscillatorNodeRenderer = oscillatorNodeRenderer;\n\n            if (this._oscillatorNodeRenderer !== null && mergedOptions.periodicWave !== undefined) {\n                (<IOscillatorNodeRenderer<IMinimalOfflineAudioContext>>this._oscillatorNodeRenderer).periodicWave =\n                    mergedOptions.periodicWave;\n            }\n        }\n\n        get detune(): IAudioParam {\n            return this._detune;\n        }\n\n        get frequency(): IAudioParam {\n            return this._frequency;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeOscillatorNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeOscillatorNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get type(): TOscillatorType {\n            return this._nativeOscillatorNode.type;\n        }\n\n        set type(value) {\n            this._nativeOscillatorNode.type = value;\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = null;\n            }\n        }\n\n        public setPeriodicWave(periodicWave: PeriodicWave): void {\n            this._nativeOscillatorNode.setPeriodicWave(periodicWave);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.periodicWave = periodicWave;\n            }\n        }\n\n        public start(when = 0): void {\n            this._nativeOscillatorNode.start(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.start = when;\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeOscillatorNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeOscillatorNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeOscillatorNode.stop(when);\n\n            if (this._oscillatorNodeRenderer !== null) {\n                this._oscillatorNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n", "import { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IOscillatorNode, IPeriodicWave } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeOscillatorNode, TOscillatorNodeRendererFactoryFactory } from '../types';\n\nexport const createOscillatorNodeRendererFactory: TOscillatorNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeOscillatorNodes = new WeakMap<TNativeOfflineAudioContext, TNativeOscillatorNode>();\n\n        let periodicWave: null | IPeriodicWave = null;\n        let start: null | number = null;\n        let stop: null | number = null;\n\n        const createOscillatorNode = async (proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeOscillatorNode = getNativeAudioNode<T, TNativeOscillatorNode>(proxy);\n\n            // If the initially used nativeOscillatorNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeOscillatorNodeIsOwnedByContext = isOwnedByContext(nativeOscillatorNode, nativeOfflineAudioContext);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeOscillatorNode.channelCount,\n                    channelCountMode: nativeOscillatorNode.channelCountMode,\n                    channelInterpretation: nativeOscillatorNode.channelInterpretation,\n                    detune: nativeOscillatorNode.detune.value,\n                    frequency: nativeOscillatorNode.frequency.value,\n                    periodicWave: periodicWave === null ? undefined : periodicWave,\n                    type: nativeOscillatorNode.type\n                };\n\n                nativeOscillatorNode = createNativeOscillatorNode(nativeOfflineAudioContext, options);\n\n                if (start !== null) {\n                    nativeOscillatorNode.start(start);\n                }\n\n                if (stop !== null) {\n                    nativeOscillatorNode.stop(stop);\n                }\n            }\n\n            renderedNativeOscillatorNodes.set(nativeOfflineAudioContext, nativeOscillatorNode);\n\n            if (!nativeOscillatorNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await renderAutomation(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.detune, nativeOscillatorNode.detune);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.frequency, nativeOscillatorNode.frequency);\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeOscillatorNode);\n\n            return nativeOscillatorNode;\n        };\n\n        return {\n            set periodicWave(value: null | IPeriodicWave) {\n                periodicWave = value;\n            },\n            set start(value: number) {\n                start = value;\n            },\n            set stop(value: number) {\n                stop = value;\n            },\n            render(proxy: IOscillatorNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeOscillatorNode> {\n                const renderedNativeOscillatorNode = renderedNativeOscillatorNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeOscillatorNode !== undefined) {\n                    return Promise.resolve(renderedNativeOscillatorNode);\n                }\n\n                return createOscillatorNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { IAudioParam, IPannerNode, IPannerOptions } from '../interfaces';\nimport {\n    TAudioNodeRenderer,\n    TContext,\n    TDistanceModelType,\n    TNativePannerNode,\n    TPannerNodeConstructorFactory,\n    TPanningModelType\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'clamped-max',\n    channelInterpretation: 'speakers',\n    coneInnerAngle: 360,\n    coneOuterAngle: 360,\n    coneOuterGain: 0,\n    distanceModel: 'inverse',\n    maxDistance: 10000,\n    orientationX: 1,\n    orientationY: 0,\n    orientationZ: 0,\n    panningModel: 'equalpower',\n    positionX: 0,\n    positionY: 0,\n    positionZ: 0,\n    refDistance: 1,\n    rolloffFactor: 1\n} as const;\n\nexport const createPannerNodeConstructor: TPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class PannerNode<T extends TContext> extends audioNodeConstructor<T> implements IPannerNode<T> {\n        private _nativePannerNode: TNativePannerNode;\n\n        private _orientationX: IAudioParam;\n\n        private _orientationY: IAudioParam;\n\n        private _orientationZ: IAudioParam;\n\n        private _positionX: IAudioParam;\n\n        private _positionY: IAudioParam;\n\n        private _positionZ: IAudioParam;\n\n        constructor(context: T, options?: Partial<IPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativePannerNode = createNativePannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const pannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createPannerNodeRenderer() : null);\n\n            super(context, false, nativePannerNode, pannerNodeRenderer);\n\n            this._nativePannerNode = nativePannerNode;\n            // Bug #74: Safari does not export the correct values for maxValue and minValue.\n            this._orientationX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._orientationZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.orientationZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionX = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionX,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionY = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionY,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n            this._positionZ = createAudioParam(\n                this,\n                isOffline,\n                nativePannerNode.positionZ,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get coneInnerAngle(): number {\n            return this._nativePannerNode.coneInnerAngle;\n        }\n\n        set coneInnerAngle(value) {\n            this._nativePannerNode.coneInnerAngle = value;\n        }\n\n        get coneOuterAngle(): number {\n            return this._nativePannerNode.coneOuterAngle;\n        }\n\n        set coneOuterAngle(value) {\n            this._nativePannerNode.coneOuterAngle = value;\n        }\n\n        get coneOuterGain(): number {\n            return this._nativePannerNode.coneOuterGain;\n        }\n\n        set coneOuterGain(value) {\n            this._nativePannerNode.coneOuterGain = value;\n        }\n\n        get distanceModel(): TDistanceModelType {\n            return this._nativePannerNode.distanceModel;\n        }\n\n        set distanceModel(value) {\n            this._nativePannerNode.distanceModel = value;\n        }\n\n        get maxDistance(): number {\n            return this._nativePannerNode.maxDistance;\n        }\n\n        set maxDistance(value) {\n            this._nativePannerNode.maxDistance = value;\n        }\n\n        get orientationX(): IAudioParam {\n            return this._orientationX;\n        }\n\n        get orientationY(): IAudioParam {\n            return this._orientationY;\n        }\n\n        get orientationZ(): IAudioParam {\n            return this._orientationZ;\n        }\n\n        get panningModel(): TPanningModelType {\n            return this._nativePannerNode.panningModel;\n        }\n\n        set panningModel(value) {\n            this._nativePannerNode.panningModel = value;\n        }\n\n        get positionX(): IAudioParam {\n            return this._positionX;\n        }\n\n        get positionY(): IAudioParam {\n            return this._positionY;\n        }\n\n        get positionZ(): IAudioParam {\n            return this._positionZ;\n        }\n\n        get refDistance(): number {\n            return this._nativePannerNode.refDistance;\n        }\n\n        set refDistance(value) {\n            this._nativePannerNode.refDistance = value;\n        }\n\n        get rolloffFactor(): number {\n            return this._nativePannerNode.rolloffFactor;\n        }\n\n        set rolloffFactor(value) {\n            this._nativePannerNode.rolloffFactor = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, INativePannerNodeFaker, IOfflineAudioContext, IPannerNode } from '../interfaces';\nimport {\n    TNativeAudioBuffer,\n    TNativeGainNode,\n    TNativeOfflineAudioContext,\n    TNativePannerNode,\n    TPannerNodeRendererFactoryFactory\n} from '../types';\n\nexport const createPannerNodeRendererFactory: TPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeGainNode | TNativePannerNode>();\n\n        let renderedBufferPromise: null | Promise<TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeGainNode: null | TNativeGainNode = null;\n            let nativePannerNode = getNativeAudioNode<T, TNativePannerNode>(proxy);\n\n            const commonAudioNodeOptions = {\n                channelCount: nativePannerNode.channelCount,\n                channelCountMode: nativePannerNode.channelCountMode,\n                channelInterpretation: nativePannerNode.channelInterpretation\n            };\n            const commonNativePannerNodeOptions = {\n                ...commonAudioNodeOptions,\n                coneInnerAngle: nativePannerNode.coneInnerAngle,\n                coneOuterAngle: nativePannerNode.coneOuterAngle,\n                coneOuterGain: nativePannerNode.coneOuterGain,\n                distanceModel: nativePannerNode.distanceModel,\n                maxDistance: nativePannerNode.maxDistance,\n                panningModel: nativePannerNode.panningModel,\n                refDistance: nativePannerNode.refDistance,\n                rolloffFactor: nativePannerNode.rolloffFactor\n            };\n\n            // If the initially used nativePannerNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativePannerNodeIsOwnedByContext = isOwnedByContext(nativePannerNode, nativeOfflineAudioContext);\n\n            // Bug #124: Safari does not support modifying the orientation and the position with AudioParams.\n            if ('bufferSize' in nativePannerNode) {\n                nativeGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n            } else if (!nativePannerNodeIsOwnedByContext) {\n                const options = {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: nativePannerNode.orientationX.value,\n                    orientationY: nativePannerNode.orientationY.value,\n                    orientationZ: nativePannerNode.orientationZ.value,\n                    positionX: nativePannerNode.positionX.value,\n                    positionY: nativePannerNode.positionY.value,\n                    positionZ: nativePannerNode.positionZ.value\n                };\n\n                nativePannerNode = createNativePannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeGainNode === null ? nativePannerNode : nativeGainNode);\n\n            if (nativeGainNode !== null) {\n                if (renderedBufferPromise === null) {\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                        6,\n                        // Bug #17: Safari does not yet expose the length.\n                        proxy.context.length,\n                        nativeOfflineAudioContext.sampleRate\n                    );\n                    const nativeChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                        channelCount: 1,\n                        channelCountMode: 'explicit',\n                        channelInterpretation: 'speakers',\n                        numberOfInputs: 6\n                    });\n                    nativeChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                    renderedBufferPromise = (async () => {\n                        const nativeConstantSourceNodes = await Promise.all(\n                            [\n                                proxy.orientationX,\n                                proxy.orientationY,\n                                proxy.orientationZ,\n                                proxy.positionX,\n                                proxy.positionY,\n                                proxy.positionZ\n                            ].map(async (audioParam, index) => {\n                                const nativeConstantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: index === 0 ? 1 : 0\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, nativeConstantSourceNode.offset);\n\n                                return nativeConstantSourceNode;\n                            })\n                        );\n\n                        for (let i = 0; i < 6; i += 1) {\n                            nativeConstantSourceNodes[i].connect(nativeChannelMergerNode, 0, i);\n                            nativeConstantSourceNodes[i].start(0);\n                        }\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    })();\n                }\n\n                const renderedBuffer = await renderedBufferPromise;\n                const inputGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, inputGainNode);\n\n                const channelDatas: Float32Array[] = [];\n\n                for (let i = 0; i < renderedBuffer.numberOfChannels; i += 1) {\n                    channelDatas.push(renderedBuffer.getChannelData(i));\n                }\n\n                let lastOrientation = [channelDatas[0][0], channelDatas[1][0], channelDatas[2][0]];\n                let lastPosition = [channelDatas[3][0], channelDatas[4][0], channelDatas[5][0]];\n                let gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 1 });\n                let partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                    ...commonNativePannerNodeOptions,\n                    orientationX: lastOrientation[0],\n                    orientationY: lastOrientation[1],\n                    orientationZ: lastOrientation[2],\n                    positionX: lastPosition[0],\n                    positionY: lastPosition[1],\n                    positionZ: lastPosition[2]\n                });\n\n                inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                partialPannerNode.connect(nativeGainNode);\n\n                for (let i = 128; i < renderedBuffer.length; i += 128) {\n                    const orientation: [number, number, number] = [channelDatas[0][i], channelDatas[1][i], channelDatas[2][i]];\n                    const positon: [number, number, number] = [channelDatas[3][i], channelDatas[4][i], channelDatas[5][i]];\n\n                    if (\n                        orientation.some((value, index) => value !== lastOrientation[index]) ||\n                        positon.some((value, index) => value !== lastPosition[index])\n                    ) {\n                        lastOrientation = orientation;\n                        lastPosition = positon;\n\n                        const currentTime = i / nativeOfflineAudioContext.sampleRate;\n\n                        gateGainNode.gain.setValueAtTime(0, currentTime);\n\n                        gateGainNode = createNativeGainNode(nativeOfflineAudioContext, { ...commonAudioNodeOptions, gain: 0 });\n                        partialPannerNode = createNativePannerNode(nativeOfflineAudioContext, {\n                            ...commonNativePannerNodeOptions,\n                            orientationX: lastOrientation[0],\n                            orientationY: lastOrientation[1],\n                            orientationZ: lastOrientation[2],\n                            positionX: lastPosition[0],\n                            positionY: lastPosition[1],\n                            positionZ: lastPosition[2]\n                        });\n\n                        gateGainNode.gain.setValueAtTime(1, currentTime);\n\n                        inputGainNode.connect(gateGainNode).connect((<INativePannerNodeFaker>partialPannerNode).inputs[0]);\n                        partialPannerNode.connect(nativeGainNode);\n                    }\n                }\n\n                return nativeGainNode;\n            }\n\n            if (!nativePannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await renderAutomation(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationX, nativePannerNode.orientationX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationY, nativePannerNode.orientationY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.orientationZ, nativePannerNode.orientationZ);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionX, nativePannerNode.positionX);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionY, nativePannerNode.positionY);\n                await connectAudioParam(nativeOfflineAudioContext, proxy.positionZ, nativePannerNode.positionZ);\n            }\n\n            if (isNativeAudioNodeFaker(nativePannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativePannerNode);\n            }\n\n            return nativePannerNode;\n        };\n\n        return {\n            render(\n                proxy: IPannerNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeGainNode | TNativePannerNode> {\n                const renderedNativeGainNodeOrNativePannerNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeGainNodeOrNativePannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeGainNodeOrNativePannerNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { IPeriodicWave, IPeriodicWaveOptions } from '../interfaces';\nimport { TContext, TPeriodicWaveConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    disableNormalization: false\n} as const;\n\nexport const createPeriodicWaveConstructor: TPeriodicWaveConstructorFactory = (\n    createNativePeriodicWave,\n    getNativeContext,\n    periodicWaveStore,\n    sanitizePeriodicWaveOptions\n) => {\n    return class PeriodicWave<T extends TContext> implements IPeriodicWave {\n        constructor(context: T, options?: Partial<IPeriodicWaveOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = sanitizePeriodicWaveOptions({ ...DEFAULT_OPTIONS, ...options });\n            const periodicWave = createNativePeriodicWave(nativeContext, mergedOptions);\n\n            periodicWaveStore.add(periodicWave);\n\n            // This does violate all good pratices but it is used here to simplify the handling of periodic waves.\n            return periodicWave;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === PeriodicWave.prototype) ||\n                periodicWaveStore.has(<any>instance)\n            );\n        }\n    };\n};\n", "import { TRenderAutomationFactory } from '../types';\n\nexport const createRenderAutomation: TRenderAutomationFactory = (getAudioParamRenderer, renderInputsOfAudioParam) => {\n    return (nativeOfflineAudioContext, audioParam, nativeAudioParam) => {\n        const audioParamRenderer = getAudioParamRenderer(audioParam);\n\n        audioParamRenderer.replay(nativeAudioParam);\n\n        return renderInputsOfAudioParam(audioParam, nativeOfflineAudioContext, nativeAudioParam);\n    };\n};\n", "import { IAudioDestinationNode } from '../interfaces';\nimport { TRenderInputsOfAudioNodeFactory } from '../types';\n\nexport const createRenderInputsOfAudioNode: TRenderInputsOfAudioNodeFactory = (\n    getAudioNodeConnections,\n    getAudioNodeRenderer,\n    isPartOfACycle\n) => {\n    return async (audioNode, nativeOfflineAudioContext, nativeAudioNode) => {\n        const audioNodeConnections = getAudioNodeConnections(audioNode);\n\n        await Promise.all(\n            audioNodeConnections.activeInputs\n                .map((connections, input) =>\n                    Array.from(connections).map(async ([source, output]) => {\n                        const audioNodeRenderer = getAudioNodeRenderer(source);\n                        const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n                        const destination = <IAudioDestinationNode<typeof audioNode.context>>audioNode.context.destination;\n\n                        if (!isPartOfACycle(source) && (audioNode !== destination || !isPartOfACycle(audioNode))) {\n                            renderedNativeAudioNode.connect(nativeAudioNode, output, input);\n                        }\n                    })\n                )\n                .reduce((allRenderingPromises, renderingPromises) => [...allRenderingPromises, ...renderingPromises], [])\n        );\n    };\n};\n", "import { IAudioParam, IMinimalOfflineAudioContext, IOfflineAudioContext } from '../interfaces';\nimport { TNativeAudioParam, TNativeOfflineAudioContext, TRenderInputsOfAudioParamFactory } from '../types';\n\nexport const createRenderInputsOfAudioParam: TRenderInputsOfAudioParamFactory = (\n    getAudioNodeRenderer,\n    getAudioParamConnections,\n    isPartOfACycle\n) => {\n    return async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        audioParam: IAudioParam,\n        nativeOfflineAudioContext: TNativeOfflineAudioContext,\n        nativeAudioParam: TNativeAudioParam\n    ): Promise<void> => {\n        const audioParamConnections = getAudioParamConnections<T>(audioParam);\n\n        await Promise.all(\n            Array.from(audioParamConnections.activeInputs).map(async ([source, output]) => {\n                const audioNodeRenderer = getAudioNodeRenderer(source);\n                const renderedNativeAudioNode = await audioNodeRenderer.render(source, nativeOfflineAudioContext);\n\n                if (!isPartOfACycle(source)) {\n                    renderedNativeAudioNode.connect(nativeAudioParam, output);\n                }\n            })\n        );\n    };\n};\n", "import { testPromiseSupport } from '../helpers/test-promise-support';\nimport { IOfflineAudioCompletionEvent } from '../interfaces';\nimport { TNativeAudioBuffer, TRenderNativeOfflineAudioContextFactory } from '../types';\n\nexport const createRenderNativeOfflineAudioContext: TRenderNativeOfflineAudioContextFactory = (\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    testOfflineAudioContextCurrentTimeSupport\n) => {\n    return (nativeOfflineAudioContext) => {\n        // Bug #21: Safari does not support promises yet.\n        if (cacheTestResult(testPromiseSupport, () => testPromiseSupport(nativeOfflineAudioContext))) {\n            // Bug #158: Chrome and Edge do not advance currentTime if it is not accessed while rendering the audio.\n            return Promise.resolve(\n                cacheTestResult(testOfflineAudioContextCurrentTimeSupport, testOfflineAudioContextCurrentTimeSupport)\n            ).then((isOfflineAudioContextCurrentTimeSupported) => {\n                if (!isOfflineAudioContextCurrentTimeSupported) {\n                    const scriptProcessorNode = createNativeScriptProcessorNode(nativeOfflineAudioContext, 512, 0, 1);\n\n                    nativeOfflineAudioContext.oncomplete = () => {\n                        scriptProcessorNode.onaudioprocess = null; // tslint:disable-line:deprecation\n                        scriptProcessorNode.disconnect();\n                    };\n                    scriptProcessorNode.onaudioprocess = () => nativeOfflineAudioContext.currentTime; // tslint:disable-line:deprecation\n\n                    scriptProcessorNode.connect(nativeOfflineAudioContext.destination);\n                }\n\n                return nativeOfflineAudioContext.startRendering();\n            });\n        }\n\n        return new Promise<TNativeAudioBuffer>((resolve) => {\n            // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n            const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                channelCount: 1,\n                channelCountMode: 'explicit',\n                channelInterpretation: 'discrete',\n                gain: 0\n            });\n\n            nativeOfflineAudioContext.oncomplete = (event: IOfflineAudioCompletionEvent) => {\n                gainNode.disconnect();\n\n                resolve(event.renderedBuffer);\n            };\n\n            gainNode.connect(nativeOfflineAudioContext.destination);\n\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n", "import { TSetActiveAudioWorkletNodeInputsFactory } from '../types';\n\nexport const createSetActiveAudioWorkletNodeInputs: TSetActiveAudioWorkletNodeInputsFactory = (activeAudioWorkletNodeInputsStore) => {\n    return (nativeAudioWorkletNode, activeInputs) => {\n        activeAudioWorkletNodeInputsStore.set(nativeAudioWorkletNode, activeInputs);\n    };\n};\n", "import { TSetAudioNodeTailTimeFactory } from '../types';\n\nexport const createSetAudioNodeTailTime: TSetAudioNodeTailTimeFactory = (audioNodeTailTimeStore) => {\n    return (audioNode, tailTime) => audioNodeTailTimeStore.set(audioNode, tailTime);\n};\n", "import { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { TStartRenderingFactory } from '../types';\n\nexport const createStartRendering: TStartRenderingFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    return (destination, nativeOfflineAudioContext) =>\n        getAudioNodeRenderer(destination)\n            .render(destination, nativeOfflineAudioContext)\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to the\n             * destination.\n             */\n            .then(() =>\n                Promise.all(\n                    Array.from(getUnrenderedAudioWorkletNodes(nativeOfflineAudioContext)).map((audioWorkletNode) =>\n                        getAudioNodeRenderer(audioWorkletNode).render(audioWorkletNode, nativeOfflineAudioContext)\n                    )\n                )\n            )\n            .then(() => renderNativeOfflineAudioContext(nativeOfflineAudioContext))\n            .then((audioBuffer) => {\n                // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n                // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n                if (typeof audioBuffer.copyFromChannel !== 'function') {\n                    wrapAudioBufferCopyChannelMethods(audioBuffer);\n                    wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                    // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n                } else if (\n                    !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                        testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                    )\n                ) {\n                    wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n                }\n\n                audioBufferStore.add(audioBuffer);\n\n                return audioBuffer;\n            });\n};\n", "import { IAudioParam, IStereoPannerNode, IStereoPannerOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TStereoPannerNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    /*\n     * Bug #105: The channelCountMode should be 'clamped-max' according to the spec but is set to 'explicit' to achieve consistent\n     * behavior.\n     */\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    pan: 0\n} as const;\n\nexport const createStereoPannerNodeConstructor: TStereoPannerNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n) => {\n    return class StereoPannerNode<T extends TContext> extends audioNodeConstructor<T> implements IStereoPannerNode<T> {\n        private _pan: IAudioParam;\n\n        constructor(context: T, options?: Partial<IStereoPannerOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeStereoPannerNode = createNativeStereoPannerNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const stereoPannerNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createStereoPannerNodeRenderer() : null);\n\n            super(context, false, nativeStereoPannerNode, stereoPannerNodeRenderer);\n\n            this._pan = createAudioParam(this, isOffline, nativeStereoPannerNode.pan);\n        }\n\n        get pan(): IAudioParam {\n            return this._pan;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IStereoPannerNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeStereoPannerNode, TStereoPannerNodeRendererFactoryFactory } from '../types';\n\nexport const createStereoPannerNodeRendererFactory: TStereoPannerNodeRendererFactoryFactory = (\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeStereoPannerNodes = new WeakMap<TNativeOfflineAudioContext, TNativeStereoPannerNode>();\n\n        const createStereoPannerNode = async (proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeStereoPannerNode = getNativeAudioNode<T, TNativeStereoPannerNode>(proxy);\n\n            /*\n             * If the initially used nativeStereoPannerNode was not constructed on the same OfflineAudioContext it needs to be created\n             * again.\n             */\n            const nativeStereoPannerNodeIsOwnedByContext = isOwnedByContext(nativeStereoPannerNode, nativeOfflineAudioContext);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeStereoPannerNode.channelCount,\n                    channelCountMode: nativeStereoPannerNode.channelCountMode,\n                    channelInterpretation: nativeStereoPannerNode.channelInterpretation,\n                    pan: nativeStereoPannerNode.pan.value\n                };\n\n                nativeStereoPannerNode = createNativeStereoPannerNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeStereoPannerNodes.set(nativeOfflineAudioContext, nativeStereoPannerNode);\n\n            if (!nativeStereoPannerNodeIsOwnedByContext) {\n                await renderAutomation(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            } else {\n                await connectAudioParam(nativeOfflineAudioContext, proxy.pan, nativeStereoPannerNode.pan);\n            }\n\n            if (isNativeAudioNodeFaker(nativeStereoPannerNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeStereoPannerNode);\n            }\n\n            return nativeStereoPannerNode;\n        };\n\n        return {\n            render(proxy: IStereoPannerNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeStereoPannerNode> {\n                const renderedNativeStereoPannerNode = renderedNativeStereoPannerNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeStereoPannerNode !== undefined) {\n                    return Promise.resolve(renderedNativeStereoPannerNode);\n                }\n\n                return createStereoPannerNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TTestAudioBufferConstructorSupportFactory } from '../types';\n\n// Bug #33: Safari exposes an AudioBuffer but it can't be used as a constructor.\nexport const createTestAudioBufferConstructorSupport: TTestAudioBufferConstructorSupportFactory = (nativeAudioBufferConstructor) => {\n    return () => {\n        if (nativeAudioBufferConstructor === null) {\n            return false;\n        }\n\n        try {\n            new nativeAudioBufferConstructor({ length: 1, sampleRate: 44100 }); // tslint:disable-line:no-unused-expression\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n", "import { TTestAudioBufferCopyChannelMethodsSubarraySupportFactory } from '../types';\n\n/*\n * Firefox up to version 67 didn't fully support the copyFromChannel() and copyToChannel() methods. Therefore testing one of those methods\n * is enough to know if the other one is supported as well.\n */\nexport const createTestAudioBufferCopyChannelMethodsSubarraySupport: TTestAudioBufferCopyChannelMethodsSubarraySupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeAudioBuffer = nativeOfflineAudioContext.createBuffer(1, 1, 44100);\n\n        // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n        if (nativeAudioBuffer.copyToChannel === undefined) {\n            return true;\n        }\n\n        const source = new Float32Array(2);\n\n        try {\n            nativeAudioBuffer.copyFromChannel(source, 0, 0);\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n", "import { TTestAudioContextCloseMethodSupportFactory } from '../types';\n\nexport const createTestAudioContextCloseMethodSupport: TTestAudioContextCloseMethodSupportFactory = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n\n        // Try to check the prototype before constructing the AudioContext.\n        if (nativeAudioContextConstructor.prototype !== undefined && nativeAudioContextConstructor.prototype.close !== undefined) {\n            return true;\n        }\n\n        const audioContext = new nativeAudioContextConstructor();\n\n        const isAudioContextClosable = audioContext.close !== undefined;\n\n        try {\n            audioContext.close();\n        } catch {\n            // Ignore errors.\n        }\n\n        return isAudioContextClosable;\n    };\n};\n", "import { TTestAudioContextDecodeAudioDataMethodTypeErrorSupportFactory } from '../types';\n\n/**\n * Edge up to version 14, Firefox up to version 52, Safari up to version 9 and maybe other browsers\n * did not refuse to decode invalid parameters with a TypeError.\n */\nexport const createTestAudioContextDecodeAudioDataMethodTypeErrorSupport: TTestAudioContextDecodeAudioDataMethodTypeErrorSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            let isPending = true;\n\n            const resolvePromise = (err: Error) => {\n                if (isPending) {\n                    isPending = false;\n\n                    offlineAudioContext.startRendering();\n\n                    resolve(err instanceof TypeError);\n                }\n            };\n\n            let promise;\n\n            // Bug #26: Safari throws a synchronous error.\n            try {\n                promise = offlineAudioContext\n                    // Bug #1: Safari requires a successCallback.\n                    .decodeAudioData(\n                        <any>null,\n                        () => {\n                            // Ignore the success callback.\n                        },\n                        resolvePromise\n                    );\n            } catch (err) {\n                resolvePromise(err);\n            }\n\n            // Bug #21: Safari does not support promises yet.\n            if (promise !== undefined) {\n                // Bug #6: Chrome, Edge and Firefox do not call the errorCallback.\n                promise.catch(resolvePromise);\n            }\n        });\n    };\n};\n", "import { TTestAudioContextOptionsSupportFactory } from '../types';\n\nexport const createTestAudioContextOptionsSupport: TTestAudioContextOptionsSupportFactory = (nativeAudioContextConstructor) => {\n    return () => {\n        if (nativeAudioContextConstructor === null) {\n            return false;\n        }\n\n        let audioContext;\n\n        try {\n            audioContext = new nativeAudioContextConstructor({ latencyHint: 'balanced' });\n        } catch {\n            return false;\n        }\n\n        audioContext.close();\n\n        return true;\n    };\n};\n", "import { TTestAudioNodeConnectMethodSupportFactory } from '../types';\n\n// Safari up to version 12.0 (but not v12.1) didn't return the destination in case it was an AudioNode.\nexport const createTestAudioNodeConnectMethodSupport: TTestAudioNodeConnectMethodSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeGainNode = nativeOfflineAudioContext.createGain();\n        const isSupported = nativeGainNode.connect(nativeGainNode) === nativeGainNode;\n\n        nativeGainNode.disconnect(nativeGainNode);\n\n        return isSupported;\n    };\n};\n", "import { TTestAudioWorkletProcessorNoOutputsSupportFactory } from '../types';\n\n/**\n * Chrome version 66 and 67 did not call the process() function of an AudioWorkletProcessor if it had no outputs. AudioWorklet support was\n * enabled by default in version 66.\n */\nexport const createTestAudioWorkletProcessorNoOutputsSupport: TTestAudioWorkletProcessorNoOutputsSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            [\n                'let c,p;class A extends AudioWorkletProcessor{constructor(){super();this.port.onmessage=(e)=>{p=e.data;p.onmessage=()=>{p.postMessage(c);p.close()};this.port.postMessage(0)}}process(){c=1}}registerProcessor(\"a\",A)'\n            ],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        const messageChannel = new MessageChannel();\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isCallingProcess = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            await new Promise<void>((resolve) => {\n                audioWorkletNode.port.onmessage = () => resolve();\n                audioWorkletNode.port.postMessage(messageChannel.port2, [messageChannel.port2]);\n            });\n\n            audioWorkletNode.port.onmessage = () => (isCallingProcess = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n\n            isCallingProcess = await new Promise((resolve) => {\n                messageChannel.port1.onmessage = ({ data }) => resolve(data === 1);\n                messageChannel.port1.postMessage(0);\n            });\n        } catch {\n            // Ignore errors.\n        } finally {\n            messageChannel.port1.close();\n            URL.revokeObjectURL(url);\n        }\n\n        return isCallingProcess;\n    };\n};\n", "import { TTestAudioWorkletProcessorPostMessageSupportFactory } from '../types';\n\n// Bug #179: Firefox does not allow to transfer any buffer which has been passed to the process() method as an argument.\nexport const createTestAudioWorkletProcessorPostMessageSupport: TTestAudioWorkletProcessorPostMessageSupportFactory = (\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor\n) => {\n    return async () => {\n        // Bug #61: If there is no native AudioWorkletNode it gets faked and therefore it is no problem if the it doesn't exist.\n        if (nativeAudioWorkletNodeConstructor === null) {\n            return true;\n        }\n\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const blob = new Blob(\n            ['class A extends AudioWorkletProcessor{process(i){this.port.postMessage(i,[i[0][0].buffer])}}registerProcessor(\"a\",A)'],\n            {\n                type: 'application/javascript; charset=utf-8'\n            }\n        );\n        // Bug #141: Safari does not support creating an OfflineAudioContext with less than 44100 Hz.\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 128, 44100);\n        const url = URL.createObjectURL(blob);\n\n        let isEmittingMessageEvents = false;\n        let isEmittingProcessorErrorEvents = false;\n\n        try {\n            await offlineAudioContext.audioWorklet.addModule(url);\n\n            const audioWorkletNode = new nativeAudioWorkletNodeConstructor(offlineAudioContext, 'a', { numberOfOutputs: 0 });\n            const oscillator = offlineAudioContext.createOscillator();\n\n            audioWorkletNode.port.onmessage = () => (isEmittingMessageEvents = true);\n            audioWorkletNode.onprocessorerror = () => (isEmittingProcessorErrorEvents = true);\n\n            oscillator.connect(audioWorkletNode);\n            oscillator.start(0);\n\n            await offlineAudioContext.startRendering();\n\n            // Bug #197: Safari does not deliver the messages before the promise returned by startRendering() resolves.\n            await new Promise((resolve) => setTimeout(resolve));\n        } catch {\n            // Ignore errors.\n        } finally {\n            URL.revokeObjectURL(url);\n        }\n\n        return isEmittingMessageEvents && !isEmittingProcessorErrorEvents;\n    };\n};\n", "import { TTestChannelMergerNodeChannelCountSupportFactory } from '../types';\n\n/**\n * Firefox up to version 69 did not throw an error when setting a different channelCount or channelCountMode.\n */\nexport const createTestChannelMergerNodeChannelCountSupport: TTestChannelMergerNodeChannelCountSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeChannelMergerNode = offlineAudioContext.createChannelMerger();\n\n        /**\n         * Bug #15: Safari does not return the default properties. It still needs to be patched. This test is supposed to test the support\n         * in other browsers.\n         */\n        if (nativeChannelMergerNode.channelCountMode === 'max') {\n            return true;\n        }\n\n        try {\n            nativeChannelMergerNode.channelCount = 2;\n        } catch {\n            return true;\n        }\n\n        return false;\n    };\n};\n", "import { TTestConstantSourceNodeAccurateSchedulingSupportFactory } from '../types';\n\nexport const createTestConstantSourceNodeAccurateSchedulingSupport: TTestConstantSourceNodeAccurateSchedulingSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return true;\n        }\n\n        const nativeConstantSourceNode = nativeOfflineAudioContext.createConstantSource();\n\n        /*\n         * @todo This is using bug #75 to detect bug #70. That works because both bugs were unique to\n         * the implementation of Firefox right now, but it could probably be done in a better way.\n         */\n        return nativeConstantSourceNode.offset.maxValue !== Number.POSITIVE_INFINITY;\n    };\n};\n", "import { TTestConvolverNodeBufferReassignabilitySupportFactory } from '../types';\n\n// Opera up to version 57 did not allow to reassign the buffer of a ConvolverNode.\nexport const createTestConvolverNodeBufferReassignabilitySupport: TTestConvolverNodeBufferReassignabilitySupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeConvolverNode = offlineAudioContext.createConvolver();\n\n        nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n\n        try {\n            nativeConvolverNode.buffer = offlineAudioContext.createBuffer(1, 1, offlineAudioContext.sampleRate);\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n", "import { TTestConvolverNodeChannelCountSupportFactory } from '../types';\n\n// Chrome up to version v80, Edge up to version v80 and Opera up to version v67 did not allow to set the channelCount property of a ConvolverNode to 1. They also did not allow to set the channelCountMode to 'explicit'.\nexport const createTestConvolverNodeChannelCountSupport: TTestConvolverNodeChannelCountSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return false;\n        }\n\n        const offlineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n        const nativeConvolverNode = offlineAudioContext.createConvolver();\n\n        try {\n            nativeConvolverNode.channelCount = 1;\n        } catch {\n            return false;\n        }\n\n        return true;\n    };\n};\n", "import { TTestIsSecureContextSupportFactory } from '../types';\n\nexport const createTestIsSecureContextSupport: TTestIsSecureContextSupportFactory = (window) => {\n    return () => window !== null && window.hasOwnProperty('isSecureContext');\n};\n", "import { TTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupportFactory } from '../types';\n\n// Firefox up to version 68 did not throw an error when creating a MediaStreamAudioSourceNode with a mediaStream that had no audio track.\nexport const createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport: TTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupportFactory =\n    (nativeAudioContextConstructor) => {\n        return () => {\n            if (nativeAudioContextConstructor === null) {\n                return false;\n            }\n\n            const audioContext = new nativeAudioContextConstructor();\n\n            try {\n                audioContext.createMediaStreamSource(new MediaStream());\n\n                return false;\n            } catch (err) {\n                return true;\n            } finally {\n                audioContext.close();\n            }\n        };\n    };\n", "import { TTestOfflineAudioContextCurrentTimeSupportFactory } from '../types';\n\nexport const createTestOfflineAudioContextCurrentTimeSupport: TTestOfflineAudioContextCurrentTimeSupportFactory = (\n    createNativeGainNode,\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        // Bug #48: Safari does not render an OfflineAudioContext without any connected node.\n        const gainNode = createNativeGainNode(nativeOfflineAudioContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: 0\n        });\n\n        // Bug #21: Safari does not support promises yet.\n        return new Promise((resolve) => {\n            nativeOfflineAudioContext.oncomplete = () => {\n                gainNode.disconnect();\n\n                resolve(nativeOfflineAudioContext.currentTime !== 0);\n            };\n            nativeOfflineAudioContext.startRendering();\n        });\n    };\n};\n", "import { TTestStereoPannerNodeDefaultValueSupportFactory } from '../types';\n\n/**\n * Firefox up to version 62 did not kick off the processing of the StereoPannerNode if the value of pan was zero.\n */\nexport const createTestStereoPannerNodeDefaultValueSupport: TTestStereoPannerNodeDefaultValueSupportFactory = (\n    nativeOfflineAudioContextConstructor\n) => {\n    return () => {\n        if (nativeOfflineAudioContextConstructor === null) {\n            return Promise.resolve(false);\n        }\n\n        const nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n\n        /*\n         * Bug #105: Safari does not support the StereoPannerNode. Therefore the returned value should normally be false but the faker does\n         * support the tested behaviour.\n         */\n        if (nativeOfflineAudioContext.createStereoPanner === undefined) {\n            return Promise.resolve(true);\n        }\n\n        // Bug #62: Safari does not support ConstantSourceNodes.\n        if (nativeOfflineAudioContext.createConstantSource === undefined) {\n            return Promise.resolve(true);\n        }\n\n        const constantSourceNode = nativeOfflineAudioContext.createConstantSource();\n        const stereoPanner = nativeOfflineAudioContext.createStereoPanner();\n\n        constantSourceNode.channelCount = 1;\n        constantSourceNode.offset.value = 1;\n\n        stereoPanner.channelCount = 1;\n\n        constantSourceNode.start();\n\n        constantSourceNode.connect(stereoPanner).connect(nativeOfflineAudioContext.destination);\n\n        return nativeOfflineAudioContext.startRendering().then((buffer) => buffer.getChannelData(0)[0] !== 1);\n    };\n};\n", "import { TUnknownErrorFactory } from '../types';\n\nexport const createUnknownError: TUnknownErrorFactory = () => new DOMException('', 'UnknownError');\n", "import { IWaveShaperNode, IWaveShaperOptions } from '../interfaces';\nimport { TAudioNodeRenderer, TContext, TNativeWaveShaperNode, TOverSampleType, TWaveShaperNodeConstructorFactory } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    curve: null,\n    oversample: 'none'\n} as const;\n\nexport const createWaveShaperNodeConstructor: TWaveShaperNodeConstructorFactory = (\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n) => {\n    return class WaveShaperNode<T extends TContext> extends audioNodeConstructor<T> implements IWaveShaperNode<T> {\n        private _isCurveNullified: boolean;\n\n        private _nativeWaveShaperNode: TNativeWaveShaperNode;\n\n        constructor(context: T, options?: Partial<IWaveShaperOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeWaveShaperNode = createNativeWaveShaperNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const waveShaperNodeRenderer = <TAudioNodeRenderer<T, this>>(isOffline ? createWaveShaperNodeRenderer() : null);\n\n            // @todo Add a mechanism to only switch a WaveShaperNode to active while it is connected.\n            super(context, true, nativeWaveShaperNode, waveShaperNodeRenderer);\n\n            this._isCurveNullified = false;\n            this._nativeWaveShaperNode = nativeWaveShaperNode;\n\n            // @todo Determine a meaningful tail-time instead of just using one second.\n            setAudioNodeTailTime(this, 1);\n        }\n\n        get curve(): null | Float32Array {\n            if (this._isCurveNullified) {\n                return null;\n            }\n\n            return this._nativeWaveShaperNode.curve;\n        }\n\n        set curve(value) {\n            // Bug #103: Safari does not allow to set the curve to null.\n            if (value === null) {\n                this._isCurveNullified = true;\n                this._nativeWaveShaperNode.curve = new Float32Array([0, 0]);\n            } else {\n                // Bug #102: Safari does not throw an InvalidStateError when the curve has less than two samples.\n                // Bug #104: Chrome and Edge will throw an InvalidAccessError when the curve has less than two samples.\n                if (value.length < 2) {\n                    throw createInvalidStateError();\n                }\n\n                this._isCurveNullified = false;\n                this._nativeWaveShaperNode.curve = value;\n            }\n        }\n\n        get oversample(): TOverSampleType {\n            return this._nativeWaveShaperNode.oversample;\n        }\n\n        set oversample(value) {\n            this._nativeWaveShaperNode.oversample = value;\n        }\n    };\n};\n", "import { isNativeAudioNodeFaker } from '../guards/native-audio-node-faker';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport { IMinimalOfflineAudioContext, IOfflineAudioContext, IWaveShaperNode } from '../interfaces';\nimport { TNativeOfflineAudioContext, TNativeWaveShaperNode, TWaveShaperNodeRendererFactoryFactory } from '../types';\n\nexport const createWaveShaperNodeRendererFactory: TWaveShaperNodeRendererFactoryFactory = (\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>() => {\n        const renderedNativeWaveShaperNodes = new WeakMap<TNativeOfflineAudioContext, TNativeWaveShaperNode>();\n\n        const createWaveShaperNode = async (proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeWaveShaperNode = getNativeAudioNode<T, TNativeWaveShaperNode>(proxy);\n\n            // If the initially used nativeWaveShaperNode was not constructed on the same OfflineAudioContext it needs to be created again.\n            const nativeWaveShaperNodeIsOwnedByContext = isOwnedByContext(nativeWaveShaperNode, nativeOfflineAudioContext);\n\n            if (!nativeWaveShaperNodeIsOwnedByContext) {\n                const options = {\n                    channelCount: nativeWaveShaperNode.channelCount,\n                    channelCountMode: nativeWaveShaperNode.channelCountMode,\n                    channelInterpretation: nativeWaveShaperNode.channelInterpretation,\n                    curve: nativeWaveShaperNode.curve,\n                    oversample: nativeWaveShaperNode.oversample\n                };\n\n                nativeWaveShaperNode = createNativeWaveShaperNode(nativeOfflineAudioContext, options);\n            }\n\n            renderedNativeWaveShaperNodes.set(nativeOfflineAudioContext, nativeWaveShaperNode);\n\n            if (isNativeAudioNodeFaker(nativeWaveShaperNode)) {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode.inputs[0]);\n            } else {\n                await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeWaveShaperNode);\n            }\n\n            return nativeWaveShaperNode;\n        };\n\n        return {\n            render(proxy: IWaveShaperNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext): Promise<TNativeWaveShaperNode> {\n                const renderedNativeWaveShaperNode = renderedNativeWaveShaperNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeWaveShaperNode !== undefined) {\n                    return Promise.resolve(renderedNativeWaveShaperNode);\n                }\n\n                return createWaveShaperNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n", "import { TWindow, TWindowFactory } from '../types';\n\nexport const createWindow: TWindowFactory = () => (typeof window === 'undefined' ? null : <TWindow>window);\n", "import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethods: TWrapAudioBufferCopyChannelMethodsFactory = (\n    convertNumberToUnsignedLong,\n    createIndexSizeError\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = (destination, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const destinationLength = destination.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < destinationLength; i += 1) {\n                destination[i] = channelData[i + bufferOffset];\n            }\n        };\n\n        audioBuffer.copyToChannel = (source, channelNumberAsNumber, bufferOffsetAsNumber = 0) => {\n            const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n            const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n            if (channelNumber >= audioBuffer.numberOfChannels) {\n                throw createIndexSizeError();\n            }\n\n            const audioBufferLength = audioBuffer.length;\n            const channelData = audioBuffer.getChannelData(channelNumber);\n            const sourceLength = source.length;\n\n            for (let i = bufferOffset < 0 ? -bufferOffset : 0; i + bufferOffset < audioBufferLength && i < sourceLength; i += 1) {\n                channelData[i + bufferOffset] = source[i];\n            }\n        };\n    };\n};\n", "import { TNativeAudioBuffer, TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory } from '../types';\n\nexport const createWrapAudioBufferCopyChannelMethodsOutOfBounds: TWrapAudioBufferCopyChannelMethodsOutOfBoundsFactory = (\n    convertNumberToUnsignedLong\n) => {\n    return (audioBuffer: TNativeAudioBuffer): void => {\n        audioBuffer.copyFromChannel = ((copyFromChannel) => {\n            return (destination: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyFromChannel.call(audioBuffer, destination, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyFromChannel);\n\n        audioBuffer.copyToChannel = ((copyToChannel) => {\n            return (source: Float32Array, channelNumberAsNumber: number, bufferOffsetAsNumber = 0) => {\n                const bufferOffset = convertNumberToUnsignedLong(bufferOffsetAsNumber);\n                const channelNumber = convertNumberToUnsignedLong(channelNumberAsNumber);\n\n                if (bufferOffset < audioBuffer.length) {\n                    return copyToChannel.call(audioBuffer, source, channelNumber, bufferOffset);\n                }\n            };\n        })(audioBuffer.copyToChannel);\n    };\n};\n", "import { TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory } from '../types';\n\nexport const createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer: TWrapAudioBufferSourceNodeStopMethodNullifiedBufferFactory = (\n    overwriteAccessors\n) => {\n    return (nativeAudioBufferSourceNode, nativeContext) => {\n        const nullifiedBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n        if (nativeAudioBufferSourceNode.buffer === null) {\n            nativeAudioBufferSourceNode.buffer = nullifiedBuffer;\n        }\n\n        overwriteAccessors(\n            nativeAudioBufferSourceNode,\n            'buffer',\n            (get) => () => {\n                const value = get.call(nativeAudioBufferSourceNode);\n\n                return value === nullifiedBuffer ? null : value;\n            },\n            (set) => (value) => {\n                return set.call(nativeAudioBufferSourceNode, value === null ? nullifiedBuffer : value);\n            }\n        );\n    };\n};\n", "import { TWrapChannelMergerNodeFactory } from '../types';\n\nexport const createWrapChannelMergerNode: TWrapChannelMergerNodeFactory = (createInvalidStateError, monitorConnections) => {\n    return (nativeContext, channelMergerNode) => {\n        // Bug #15: Safari does not return the default properties.\n        channelMergerNode.channelCount = 1;\n        channelMergerNode.channelCountMode = 'explicit';\n\n        // Bug #16: Safari does not throw an error when setting a different channelCount or channelCountMode.\n        Object.defineProperty(channelMergerNode, 'channelCount', {\n            get: () => 1,\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        Object.defineProperty(channelMergerNode, 'channelCountMode', {\n            get: () => 'explicit',\n            set: () => {\n                throw createInvalidStateError();\n            }\n        });\n\n        // Bug #20: Safari requires a connection of any kind to treat the input signal correctly.\n        const audioBufferSourceNode = nativeContext.createBufferSource();\n\n        const whenConnected = () => {\n            const length = channelMergerNode.numberOfInputs;\n\n            for (let i = 0; i < length; i += 1) {\n                audioBufferSourceNode.connect(channelMergerNode, 0, i);\n            }\n        };\n        const whenDisconnected = () => audioBufferSourceNode.disconnect(channelMergerNode);\n\n        monitorConnections(channelMergerNode, whenConnected, whenDisconnected);\n    };\n};\n", "import { TGetFirstSampleFunction } from '../types';\n\nexport const getFirstSample: TGetFirstSampleFunction = (audioBuffer, buffer, channelNumber) => {\n    // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n    if (audioBuffer.copyFromChannel === undefined) {\n        return audioBuffer.getChannelData(channelNumber)[0];\n    }\n\n    audioBuffer.copyFromChannel(buffer, channelNumber);\n\n    return buffer[0];\n};\n", "import { TIsDCCurveFunction } from '../types';\n\nexport const isDCCurve: TIsDCCurveFunction = (curve) => {\n    if (curve === null) {\n        return false;\n    }\n\n    const length = curve.length;\n\n    if (length % 2 !== 0) {\n        return curve[Math.floor(length / 2)] !== 0;\n    }\n\n    return curve[length / 2 - 1] + curve[length / 2] !== 0;\n};\n", "import { TOverwriteAccessorsFunction } from '../types';\n\nexport const overwriteAccessors: TOverwriteAccessorsFunction = (object, property, createGetter, createSetter) => {\n    let prototype = object;\n\n    while (!prototype.hasOwnProperty(property)) {\n        prototype = Object.getPrototypeOf(prototype);\n    }\n\n    const { get, set } = <Required<PropertyDescriptor>>Object.getOwnPropertyDescriptor(prototype, property);\n\n    Object.defineProperty(object, property, { get: createGetter(get), set: createSetter(set) });\n};\n", "import { TSanitizeAudioWorkletNodeOptionsFunction } from '../types';\n\nexport const sanitizeAudioWorkletNodeOptions: TSanitizeAudioWorkletNodeOptionsFunction = (options) => {\n    return {\n        ...options,\n        outputChannelCount:\n            options.outputChannelCount !== undefined\n                ? options.outputChannelCount\n                : options.numberOfInputs === 1 && options.numberOfOutputs === 1\n                ? /*\n                   * Bug #61: This should be the computedNumberOfChannels, but unfortunately that is almost impossible to fake. That's why\n                   * the channelCountMode is required to be 'explicit' as long as there is not a native implementation in every browser. That\n                   * makes sure the computedNumberOfChannels is equivilant to the channelCount which makes it much easier to compute.\n                   */\n                  [options.channelCount]\n                : Array.from({ length: options.numberOfOutputs }, () => 1)\n    };\n};\n", "import { TSanitizeChannelSplitterOptionsFunction } from '../types';\n\nexport const sanitizeChannelSplitterOptions: TSanitizeChannelSplitterOptionsFunction = (options) => {\n    return { ...options, channelCount: options.numberOfOutputs };\n};\n", "import { TSanitizePeriodicWaveOptionsFunction } from '../types';\n\nexport const sanitizePeriodicWaveOptions: TSanitizePeriodicWaveOptionsFunction = (options) => {\n    const { imag, real } = options;\n\n    if (imag === undefined) {\n        if (real === undefined) {\n            return { ...options, imag: [0, 0], real: [0, 0] };\n        }\n\n        return { ...options, imag: Array.from(real, () => 0), real };\n    }\n\n    if (real === undefined) {\n        return { ...options, imag, real: Array.from(imag, () => 0) };\n    }\n\n    return { ...options, imag, real };\n};\n", "import { TSetValueAtTimeUntilPossibleFunction } from '../types';\n\nexport const setValueAtTimeUntilPossible: TSetValueAtTimeUntilPossibleFunction = (audioParam, value, startTime) => {\n    try {\n        audioParam.setValueAtTime(value, startTime);\n    } catch (err) {\n        if (err.code !== 9) {\n            throw err;\n        }\n\n        setValueAtTimeUntilPossible(audioParam, value, startTime + 1e-7);\n    }\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.start();\n    } catch {\n        return true;\n    }\n\n    return false;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStartMethodOffsetClampingSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n\n    try {\n        nativeAudioBufferSourceNode.start(0, 1);\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioBufferSourceNodeStopMethodNullifiedBufferSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.start();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStartMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.start(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBuffer = nativeContext.createBuffer(1, 1, 44100);\n    const nativeAudioBufferSourceNode = nativeContext.createBufferSource();\n\n    nativeAudioBufferSourceNode.buffer = nativeAudioBuffer;\n    nativeAudioBufferSourceNode.start();\n    nativeAudioBufferSourceNode.stop();\n\n    try {\n        nativeAudioBufferSourceNode.stop();\n\n        return true;\n    } catch {\n        return false;\n    }\n};\n", "import { TNativeContext } from '../types';\n\nexport const testAudioScheduledSourceNodeStopMethodNegativeParametersSupport = (nativeContext: TNativeContext) => {\n    const nativeAudioBufferSourceNode = nativeContext.createOscillator();\n\n    try {\n        nativeAudioBufferSourceNode.stop(-1);\n    } catch (err) {\n        return err instanceof RangeError;\n    }\n\n    return false;\n};\n", "import { TTestAudioWorkletNodeOptionsClonabilityFunction } from '../types';\n\nexport const testAudioWorkletNodeOptionsClonability: TTestAudioWorkletNodeOptionsClonabilityFunction = (audioWorkletNodeOptions) => {\n    const { port1, port2 } = new MessageChannel();\n\n    try {\n        // This will throw an error if the audioWorkletNodeOptions are not clonable.\n        port1.postMessage(audioWorkletNodeOptions);\n    } finally {\n        port1.close();\n        port2.close();\n    }\n};\n", "/*\n * Bug #122: Edge up to version v18 did not allow to construct a DOMException'. It also had a couple more bugs but since this is easy to\n * test it's used here as a placeholder.\n *\n * Bug #27: Edge up to version v18 did reject an invalid arrayBuffer passed to decodeAudioData() with a DOMException.\n *\n * Bug #50: Edge up to version v18 did not allow to create AudioNodes on a closed context.\n *\n * Bug #57: Edge up to version v18 did not throw an error when assigning the type of an OscillatorNode to 'custom'.\n *\n * Bug #63: Edge up to version v18 did not expose the mediaElement property of a MediaElementAudioSourceNode.\n *\n * Bug #64: Edge up to version v18 did not support the MediaStreamAudioDestinationNode.\n *\n * Bug #71: Edge up to version v18 did not allow to set the buffer of an AudioBufferSourceNode to null.\n *\n * Bug #93: Edge up to version v18 did set the sampleRate of an AudioContext to zero when it was closed.\n *\n * Bug #101: Edge up to version v18 refused to execute decodeAudioData() on a closed context.\n *\n * Bug #106: Edge up to version v18 did not expose the maxValue and minValue properties of the pan AudioParam of a StereoPannerNode.\n *\n * Bug #110: Edge up to version v18 did not expose the maxValue and minValue properties of the attack, knee, ratio, release and threshold AudioParams of a DynamicsCompressorNode.\n *\n * Bug #123: Edge up to version v18 did not support HRTF as the panningModel for a PannerNode.\n *\n * Bug #145: Edge up to version v18 did throw an IndexSizeError when an OfflineAudioContext was created with a sampleRate of zero.\n *\n * Bug #161: Edge up to version v18 did not expose the maxValue and minValue properties of the delayTime AudioParam of a DelayNode.\n */\nexport const testDomExceptionConstructorSupport = () => {\n    try {\n        new DOMException(); // tslint:disable-line:no-unused-expression\n    } catch {\n        return false;\n    }\n\n    return true;\n};\n", "// Safari at version 11 did not support transferables.\nexport const testTransferablesSupport = () =>\n    new Promise<boolean>((resolve) => {\n        const arrayBuffer = new ArrayBuffer(0);\n        const { port1, port2 } = new MessageChannel();\n\n        port1.onmessage = ({ data }) => resolve(data !== null);\n        port2.postMessage(arrayBuffer, [arrayBuffer]);\n    });\n", "import { TNativeAudioBufferSourceNode } from '../types';\n\nexport const wrapAudioBufferSourceNodeStartMethodOffsetClamping = (nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode): void => {\n    nativeAudioBufferSourceNode.start = ((start) => {\n        return (when = 0, offset = 0, duration?: number) => {\n            const buffer = nativeAudioBufferSourceNode.buffer;\n            // Bug #154: Safari does not clamp the offset if it is equal to or greater than the duration of the buffer.\n            const clampedOffset = buffer === null ? offset : Math.min(buffer.duration, offset);\n\n            // Bug #155: Safari does not handle the offset correctly if it would cause the buffer to be not be played at all.\n            if (buffer !== null && clampedOffset > buffer.duration - 0.5 / nativeAudioBufferSourceNode.context.sampleRate) {\n                start.call(nativeAudioBufferSourceNode, when, 0, 0);\n            } else {\n                start.call(nativeAudioBufferSourceNode, when, clampedOffset, duration);\n            }\n        };\n    })(nativeAudioBufferSourceNode.start);\n};\n", "import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n", "import { TWrapEventListenerFunction } from '../types';\n\nexport const wrapEventListener: TWrapEventListenerFunction = (target, eventListener) => {\n    return (event) => {\n        const descriptor = { value: target };\n\n        Object.defineProperties(event, {\n            currentTarget: descriptor,\n            target: descriptor\n        });\n\n        if (typeof eventListener === 'function') {\n            return eventListener.call(target, event);\n        }\n\n        return eventListener.handleEvent.call(target, event);\n    };\n};\n", "import {\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent\n} from 'automation-events';\nimport { createAbortError } from './factories/abort-error';\nimport { createAddActiveInputConnectionToAudioNode } from './factories/add-active-input-connection-to-audio-node';\nimport { createAddAudioNodeConnections } from './factories/add-audio-node-connections';\nimport { createAddAudioParamConnections } from './factories/add-audio-param-connections';\nimport { createAddAudioWorkletModule } from './factories/add-audio-worklet-module';\nimport { createAddConnectionToAudioNode } from './factories/add-connection-to-audio-node';\nimport { createAddPassiveInputConnectionToAudioNode } from './factories/add-passive-input-connection-to-audio-node';\nimport { createAddSilentConnection } from './factories/add-silent-connection';\nimport { createAddUnrenderedAudioWorkletNode } from './factories/add-unrendered-audio-worklet-node';\nimport { createAnalyserNodeConstructor } from './factories/analyser-node-constructor';\nimport { createAnalyserNodeRendererFactory } from './factories/analyser-node-renderer-factory';\nimport { createAudioBufferConstructor } from './factories/audio-buffer-constructor';\nimport { createAudioBufferSourceNodeConstructor } from './factories/audio-buffer-source-node-constructor';\nimport { createAudioBufferSourceNodeRendererFactory } from './factories/audio-buffer-source-node-renderer-factory';\nimport { createAudioContextConstructor } from './factories/audio-context-constructor';\nimport { createAudioDestinationNodeConstructor } from './factories/audio-destination-node-constructor';\nimport { createAudioDestinationNodeRenderer } from './factories/audio-destination-node-renderer-factory';\nimport { createAudioListenerFactory } from './factories/audio-listener-factory';\nimport { createAudioNodeConstructor } from './factories/audio-node-constructor';\nimport { createAudioParamFactory } from './factories/audio-param-factory';\nimport { createAudioParamRenderer } from './factories/audio-param-renderer';\nimport { createAudioWorkletNodeConstructor } from './factories/audio-worklet-node-constructor';\nimport { createAudioWorkletNodeRendererFactory } from './factories/audio-worklet-node-renderer-factory';\nimport { createBaseAudioContextConstructor } from './factories/base-audio-context-constructor';\nimport { createBiquadFilterNodeConstructor } from './factories/biquad-filter-node-constructor';\nimport { createBiquadFilterNodeRendererFactory } from './factories/biquad-filter-node-renderer-factory';\nimport { createCacheTestResult } from './factories/cache-test-result';\nimport { createChannelMergerNodeConstructor } from './factories/channel-merger-node-constructor';\nimport { createChannelMergerNodeRendererFactory } from './factories/channel-merger-node-renderer-factory';\nimport { createChannelSplitterNodeConstructor } from './factories/channel-splitter-node-constructor';\nimport { createChannelSplitterNodeRendererFactory } from './factories/channel-splitter-node-renderer-factory';\nimport { createConnectAudioParam } from './factories/connect-audio-param';\nimport { createConnectMultipleOutputs } from './factories/connect-multiple-outputs';\nimport { createConnectedNativeAudioBufferSourceNodeFactory } from './factories/connected-native-audio-buffer-source-node-factory';\nimport { createConstantSourceNodeConstructor } from './factories/constant-source-node-constructor';\nimport { createConstantSourceNodeRendererFactory } from './factories/constant-source-node-renderer-factory';\nimport { createConvertNumberToUnsignedLong } from './factories/convert-number-to-unsigned-long';\nimport { createConvolverNodeConstructor } from './factories/convolver-node-constructor';\nimport { createConvolverNodeRendererFactory } from './factories/convolver-node-renderer-factory';\nimport { createCreateNativeOfflineAudioContext } from './factories/create-native-offline-audio-context';\nimport { createDataCloneError } from './factories/data-clone-error';\nimport { createDecodeAudioData } from './factories/decode-audio-data';\nimport { createDecrementCycleCounter } from './factories/decrement-cycle-counter';\nimport { createDelayNodeConstructor } from './factories/delay-node-constructor';\nimport { createDelayNodeRendererFactory } from './factories/delay-node-renderer-factory';\nimport { createDeleteActiveInputConnectionToAudioNode } from './factories/delete-active-input-connection-to-audio-node';\nimport { createDeleteUnrenderedAudioWorkletNode } from './factories/delete-unrendered-audio-worklet-node';\nimport { createDetectCycles } from './factories/detect-cycles';\nimport { createDisconnectMultipleOutputs } from './factories/disconnect-multiple-outputs';\nimport { createDynamicsCompressorNodeConstructor } from './factories/dynamics-compressor-node-constructor';\nimport { createDynamicsCompressorNodeRendererFactory } from './factories/dynamics-compressor-node-renderer-factory';\nimport { createEncodingError } from './factories/encoding-error';\nimport { createEvaluateSource } from './factories/evaluate-source';\nimport { createEventTargetConstructor } from './factories/event-target-constructor';\nimport { createExposeCurrentFrameAndCurrentTime } from './factories/expose-current-frame-and-current-time';\nimport { createFetchSource } from './factories/fetch-source';\nimport { createGainNodeConstructor } from './factories/gain-node-constructor';\nimport { createGainNodeRendererFactory } from './factories/gain-node-renderer-factory';\nimport { createGetActiveAudioWorkletNodeInputs } from './factories/get-active-audio-worklet-node-inputs';\nimport { createGetAudioNodeRenderer } from './factories/get-audio-node-renderer';\nimport { createGetAudioNodeTailTime } from './factories/get-audio-node-tail-time';\nimport { createGetAudioParamRenderer } from './factories/get-audio-param-renderer';\nimport { createGetBackupOfflineAudioContext } from './factories/get-backup-offline-audio-context';\nimport { createGetNativeContext } from './factories/get-native-context';\nimport { createGetOrCreateBackupOfflineAudioContext } from './factories/get-or-create-backup-offline-audio-context';\nimport { createGetUnrenderedAudioWorkletNodes } from './factories/get-unrendered-audio-worklet-nodes';\nimport { createIIRFilterNodeConstructor } from './factories/iir-filter-node-constructor';\nimport { createIIRFilterNodeRendererFactory } from './factories/iir-filter-node-renderer-factory';\nimport { createIncrementCycleCounterFactory } from './factories/increment-cycle-counter-factory';\nimport { createIndexSizeError } from './factories/index-size-error';\nimport { createInvalidAccessError } from './factories/invalid-access-error';\nimport { createInvalidStateError } from './factories/invalid-state-error';\nimport { createIsAnyAudioContext } from './factories/is-any-audio-context';\nimport { createIsAnyAudioNode } from './factories/is-any-audio-node';\nimport { createIsAnyAudioParam } from './factories/is-any-audio-param';\nimport { createIsAnyOfflineAudioContext } from './factories/is-any-offline-audio-context';\nimport { createIsNativeAudioContext } from './factories/is-native-audio-context';\nimport { createIsNativeAudioNode } from './factories/is-native-audio-node';\nimport { createIsNativeAudioParam } from './factories/is-native-audio-param';\nimport { createIsNativeContext } from './factories/is-native-context';\nimport { createIsNativeOfflineAudioContext } from './factories/is-native-offline-audio-context';\nimport { createIsSecureContext } from './factories/is-secure-context';\nimport { createIsSupportedPromise } from './factories/is-supported-promise';\nimport { createMediaElementAudioSourceNodeConstructor } from './factories/media-element-audio-source-node-constructor';\nimport { createMediaStreamAudioDestinationNodeConstructor } from './factories/media-stream-audio-destination-node-constructor';\nimport { createMediaStreamAudioSourceNodeConstructor } from './factories/media-stream-audio-source-node-constructor';\nimport { createMediaStreamTrackAudioSourceNodeConstructor } from './factories/media-stream-track-audio-source-node-constructor';\nimport { createMinimalAudioContextConstructor } from './factories/minimal-audio-context-constructor';\nimport { createMinimalBaseAudioContextConstructor } from './factories/minimal-base-audio-context-constructor';\nimport { createMinimalOfflineAudioContextConstructor } from './factories/minimal-offline-audio-context-constructor';\nimport { createMonitorConnections } from './factories/monitor-connections';\nimport { createNativeAnalyserNodeFactory } from './factories/native-analyser-node-factory';\nimport { createNativeAudioBufferConstructor } from './factories/native-audio-buffer-constructor';\nimport { createNativeAudioBufferSourceNodeFactory } from './factories/native-audio-buffer-source-node-factory';\nimport { createNativeAudioContextConstructor } from './factories/native-audio-context-constructor';\nimport { createNativeAudioDestinationNodeFactory } from './factories/native-audio-destination-node';\nimport { createNativeAudioWorkletNodeConstructor } from './factories/native-audio-worklet-node-constructor';\nimport { createNativeAudioWorkletNodeFactory } from './factories/native-audio-worklet-node-factory';\nimport { createNativeAudioWorkletNodeFakerFactory } from './factories/native-audio-worklet-node-faker-factory';\nimport { createNativeBiquadFilterNode } from './factories/native-biquad-filter-node';\nimport { createNativeChannelMergerNodeFactory } from './factories/native-channel-merger-node-factory';\nimport { createNativeChannelSplitterNode } from './factories/native-channel-splitter-node';\nimport { createNativeConstantSourceNodeFactory } from './factories/native-constant-source-node-factory';\nimport { createNativeConstantSourceNodeFakerFactory } from './factories/native-constant-source-node-faker-factory';\nimport { createNativeConvolverNodeFactory } from './factories/native-convolver-node-factory';\nimport { createNativeDelayNode } from './factories/native-delay-node';\nimport { createNativeDynamicsCompressorNodeFactory } from './factories/native-dynamics-compressor-node-factory';\nimport { createNativeGainNode } from './factories/native-gain-node';\nimport { createNativeIIRFilterNodeFactory } from './factories/native-iir-filter-node-factory';\nimport { createNativeIIRFilterNodeFakerFactory } from './factories/native-iir-filter-node-faker-factory';\nimport { createNativeMediaElementAudioSourceNode } from './factories/native-media-element-audio-source-node';\nimport { createNativeMediaStreamAudioDestinationNode } from './factories/native-media-stream-audio-destination-node';\nimport { createNativeMediaStreamAudioSourceNode } from './factories/native-media-stream-audio-source-node';\nimport { createNativeMediaStreamTrackAudioSourceNodeFactory } from './factories/native-media-stream-track-audio-source-node-factory';\nimport { createNativeOfflineAudioContextConstructor } from './factories/native-offline-audio-context-constructor';\nimport { createNativeOscillatorNodeFactory } from './factories/native-oscillator-node-factory';\nimport { createNativePannerNodeFactory } from './factories/native-panner-node-factory';\nimport { createNativePannerNodeFakerFactory } from './factories/native-panner-node-faker-factory';\nimport { createNativePeriodicWaveFactory } from './factories/native-periodic-wave-factory';\nimport { createNativeScriptProcessorNode } from './factories/native-script-processor-node';\nimport { createNativeStereoPannerNodeFactory } from './factories/native-stereo-panner-node-factory';\nimport { createNativeStereoPannerNodeFakerFactory } from './factories/native-stereo-panner-node-faker-factory';\nimport { createNativeWaveShaperNodeFactory } from './factories/native-wave-shaper-node-factory';\nimport { createNativeWaveShaperNodeFakerFactory } from './factories/native-wave-shaper-node-faker-factory';\nimport { createNotSupportedError } from './factories/not-supported-error';\nimport { createOfflineAudioContextConstructor } from './factories/offline-audio-context-constructor';\nimport { createOscillatorNodeConstructor } from './factories/oscillator-node-constructor';\nimport { createOscillatorNodeRendererFactory } from './factories/oscillator-node-renderer-factory';\nimport { createPannerNodeConstructor } from './factories/panner-node-constructor';\nimport { createPannerNodeRendererFactory } from './factories/panner-node-renderer-factory';\nimport { createPeriodicWaveConstructor } from './factories/periodic-wave-constructor';\nimport { createRenderAutomation } from './factories/render-automation';\nimport { createRenderInputsOfAudioNode } from './factories/render-inputs-of-audio-node';\nimport { createRenderInputsOfAudioParam } from './factories/render-inputs-of-audio-param';\nimport { createRenderNativeOfflineAudioContext } from './factories/render-native-offline-audio-context';\nimport { createSetActiveAudioWorkletNodeInputs } from './factories/set-active-audio-worklet-node-inputs';\nimport { createSetAudioNodeTailTime } from './factories/set-audio-node-tail-time';\nimport { createStartRendering } from './factories/start-rendering';\nimport { createStereoPannerNodeConstructor } from './factories/stereo-panner-node-constructor';\nimport { createStereoPannerNodeRendererFactory } from './factories/stereo-panner-node-renderer-factory';\nimport { createTestAudioBufferConstructorSupport } from './factories/test-audio-buffer-constructor-support';\nimport { createTestAudioBufferCopyChannelMethodsSubarraySupport } from './factories/test-audio-buffer-copy-channel-methods-subarray-support';\nimport { createTestAudioContextCloseMethodSupport } from './factories/test-audio-context-close-method-support';\nimport { createTestAudioContextDecodeAudioDataMethodTypeErrorSupport } from './factories/test-audio-context-decode-audio-data-method-type-error-support';\nimport { createTestAudioContextOptionsSupport } from './factories/test-audio-context-options-support';\nimport { createTestAudioNodeConnectMethodSupport } from './factories/test-audio-node-connect-method-support';\nimport { createTestAudioWorkletProcessorNoOutputsSupport } from './factories/test-audio-worklet-processor-no-outputs-support';\nimport { createTestAudioWorkletProcessorPostMessageSupport } from './factories/test-audio-worklet-processor-post-message-support';\nimport { createTestChannelMergerNodeChannelCountSupport } from './factories/test-channel-merger-node-channel-count-support';\nimport { createTestConstantSourceNodeAccurateSchedulingSupport } from './factories/test-constant-source-node-accurate-scheduling-support';\nimport { createTestConvolverNodeBufferReassignabilitySupport } from './factories/test-convolver-node-buffer-reassignability-support';\nimport { createTestConvolverNodeChannelCountSupport } from './factories/test-convolver-node-channel-count-support';\nimport { createTestIsSecureContextSupport } from './factories/test-is-secure-context-support';\nimport { createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport } from './factories/test-media-stream-audio-source-node-media-stream-without-audio-track-support';\nimport { createTestOfflineAudioContextCurrentTimeSupport } from './factories/test-offline-audio-context-current-time-support';\nimport { createTestStereoPannerNodeDefaultValueSupport } from './factories/test-stereo-panner-node-default-value-support';\nimport { createUnknownError } from './factories/unknown-error';\nimport { createWaveShaperNodeConstructor } from './factories/wave-shaper-node-constructor';\nimport { createWaveShaperNodeRendererFactory } from './factories/wave-shaper-node-renderer-factory';\nimport { createWindow } from './factories/window';\nimport { createWrapAudioBufferCopyChannelMethods } from './factories/wrap-audio-buffer-copy-channel-methods';\nimport { createWrapAudioBufferCopyChannelMethodsOutOfBounds } from './factories/wrap-audio-buffer-copy-channel-methods-out-of-bounds';\nimport { createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer } from './factories/wrap-audio-buffer-source-node-stop-method-nullified-buffer';\nimport { createWrapChannelMergerNode } from './factories/wrap-channel-merger-node';\nimport {\n    AUDIO_NODE_CONNECTIONS_STORE,\n    AUDIO_NODE_STORE,\n    AUDIO_PARAM_CONNECTIONS_STORE,\n    AUDIO_PARAM_STORE,\n    CONTEXT_STORE,\n    CYCLE_COUNTERS\n} from './globals';\nimport { connectNativeAudioNodeToNativeAudioNode } from './helpers/connect-native-audio-node-to-native-audio-node';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from './helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from './helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from './helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from './helpers/get-event-listeners-of-audio-node';\nimport { getFirstSample } from './helpers/get-first-sample';\nimport { getNativeAudioNode } from './helpers/get-native-audio-node';\nimport { getNativeAudioParam } from './helpers/get-native-audio-param';\nimport { getValueForKey } from './helpers/get-value-for-key';\nimport { insertElementInSet } from './helpers/insert-element-in-set';\nimport { isActiveAudioNode } from './helpers/is-active-audio-node';\nimport { isDCCurve } from './helpers/is-dc-curve';\nimport { isPartOfACycle } from './helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from './helpers/is-passive-audio-node';\nimport { overwriteAccessors } from './helpers/overwrite-accessors';\nimport { pickElementFromSet } from './helpers/pick-element-from-set';\nimport { sanitizeAudioWorkletNodeOptions } from './helpers/sanitize-audio-worklet-node-options';\nimport { sanitizeChannelSplitterOptions } from './helpers/sanitize-channel-splitter-options';\nimport { sanitizePeriodicWaveOptions } from './helpers/sanitize-periodic-wave-options';\nimport { setValueAtTimeUntilPossible } from './helpers/set-value-at-time-until-possible';\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from './helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport } from './helpers/test-audio-buffer-source-node-start-method-consecutive-calls-support';\nimport { testAudioBufferSourceNodeStartMethodOffsetClampingSupport } from './helpers/test-audio-buffer-source-node-start-method-offset-clamping-support';\nimport { testAudioBufferSourceNodeStopMethodNullifiedBufferSupport } from './helpers/test-audio-buffer-source-node-stop-method-nullified-buffer-support';\nimport { testAudioScheduledSourceNodeStartMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-start-method-negative-parameters-support';\nimport { testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport } from './helpers/test-audio-scheduled-source-node-stop-method-consecutive-calls-support';\nimport { testAudioScheduledSourceNodeStopMethodNegativeParametersSupport } from './helpers/test-audio-scheduled-source-node-stop-method-negative-parameters-support';\nimport { testAudioWorkletNodeOptionsClonability } from './helpers/test-audio-worklet-node-options-clonability';\nimport { testDomExceptionConstructorSupport } from './helpers/test-dom-exception-constructor-support';\nimport { testPromiseSupport } from './helpers/test-promise-support';\nimport { testTransferablesSupport } from './helpers/test-transferables-support';\nimport { wrapAudioBufferSourceNodeStartMethodOffsetClamping } from './helpers/wrap-audio-buffer-source-node-start-method-offset-clamping';\nimport { wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls } from './helpers/wrap-audio-scheduled-source-node-stop-method-consecutive-calls';\nimport { wrapEventListener } from './helpers/wrap-event-listener';\nimport {\n    IAnalyserNode,\n    IAudioBuffer,\n    IAudioBufferSourceNode,\n    IAudioContext,\n    IAudioNode,\n    IAudioWorkletNode,\n    IBiquadFilterNode,\n    IConstantSourceNode,\n    IConvolverNode,\n    IDelayNode,\n    IDynamicsCompressorNode,\n    IGainNode,\n    IIIRFilterNode,\n    IMediaElementAudioSourceNode,\n    IMediaStreamAudioDestinationNode,\n    IMediaStreamAudioSourceNode,\n    IMediaStreamTrackAudioSourceNode,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IOfflineAudioContextConstructor,\n    IOscillatorNode,\n    IPannerNode,\n    IPeriodicWave,\n    IStereoPannerNode,\n    IWaveShaperNode\n} from './interfaces';\nimport {\n    TActiveAudioWorkletNodeInputsStore,\n    TAddAudioWorkletModuleFunction,\n    TAnalyserNodeConstructor,\n    TAudioBufferConstructor,\n    TAudioBufferSourceNodeConstructor,\n    TAudioBufferStore,\n    TAudioContextConstructor,\n    TAudioParamAudioNodeStore,\n    TAudioWorkletNodeConstructor,\n    TBackupOfflineAudioContextStore,\n    TBiquadFilterNodeConstructor,\n    TChannelMergerNodeConstructor,\n    TChannelSplitterNodeConstructor,\n    TConstantSourceNodeConstructor,\n    TContext,\n    TConvolverNodeConstructor,\n    TDecodeAudioDataFunction,\n    TDelayNodeConstructor,\n    TDynamicsCompressorNodeConstructor,\n    TGainNodeConstructor,\n    TIIRFilterNodeConstructor,\n    TMediaElementAudioSourceNodeConstructor,\n    TMediaStreamAudioDestinationNodeConstructor,\n    TMediaStreamAudioSourceNodeConstructor,\n    TMediaStreamTrackAudioSourceNodeConstructor,\n    TMinimalAudioContextConstructor,\n    TMinimalOfflineAudioContextConstructor,\n    TOscillatorNodeConstructor,\n    TPannerNodeConstructor,\n    TPeriodicWaveConstructor,\n    TStereoPannerNodeConstructor,\n    TUnrenderedAudioWorkletNodeStore,\n    TWaveShaperNodeConstructor\n} from './types';\n\n/*\n * @todo Explicitly referencing the barrel file seems to be necessary when enabling the\n * isolatedModules compiler option.\n */\nexport * from './interfaces/index';\nexport * from './types/index';\n\nconst addActiveInputConnectionToAudioNode = createAddActiveInputConnectionToAudioNode(insertElementInSet);\nconst addPassiveInputConnectionToAudioNode = createAddPassiveInputConnectionToAudioNode(insertElementInSet);\nconst deleteActiveInputConnectionToAudioNode = createDeleteActiveInputConnectionToAudioNode(pickElementFromSet);\nconst audioNodeTailTimeStore = new WeakMap();\nconst getAudioNodeTailTime = createGetAudioNodeTailTime(audioNodeTailTimeStore);\nconst cacheTestResult = createCacheTestResult(new Map(), new WeakMap());\nconst window = createWindow();\nconst createNativeAnalyserNode = createNativeAnalyserNodeFactory(cacheTestResult, createIndexSizeError);\nconst getAudioNodeRenderer = createGetAudioNodeRenderer(getAudioNodeConnections);\nconst renderInputsOfAudioNode = createRenderInputsOfAudioNode(getAudioNodeConnections, getAudioNodeRenderer, isPartOfACycle);\nconst createAnalyserNodeRenderer = createAnalyserNodeRendererFactory(createNativeAnalyserNode, getNativeAudioNode, renderInputsOfAudioNode);\nconst getNativeContext = createGetNativeContext(CONTEXT_STORE);\nconst nativeOfflineAudioContextConstructor = createNativeOfflineAudioContextConstructor(window);\nconst isNativeOfflineAudioContext = createIsNativeOfflineAudioContext(nativeOfflineAudioContextConstructor);\nconst audioParamAudioNodeStore: TAudioParamAudioNodeStore = new WeakMap();\nconst eventTargetConstructor = createEventTargetConstructor(wrapEventListener);\nconst nativeAudioContextConstructor = createNativeAudioContextConstructor(window);\nconst isNativeAudioContext = createIsNativeAudioContext(nativeAudioContextConstructor);\nconst isNativeAudioNode = createIsNativeAudioNode(window);\nconst isNativeAudioParam = createIsNativeAudioParam(window);\nconst nativeAudioWorkletNodeConstructor = createNativeAudioWorkletNodeConstructor(window);\nconst audioNodeConstructor = createAudioNodeConstructor(\n    createAddAudioNodeConnections(AUDIO_NODE_CONNECTIONS_STORE),\n    createAddConnectionToAudioNode(\n        addActiveInputConnectionToAudioNode,\n        addPassiveInputConnectionToAudioNode,\n        connectNativeAudioNodeToNativeAudioNode,\n        deleteActiveInputConnectionToAudioNode,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getAudioNodeTailTime,\n        getEventListenersOfAudioNode,\n        getNativeAudioNode,\n        insertElementInSet,\n        isActiveAudioNode,\n        isPartOfACycle,\n        isPassiveAudioNode\n    ),\n    cacheTestResult,\n    createIncrementCycleCounterFactory(\n        CYCLE_COUNTERS,\n        disconnectNativeAudioNodeFromNativeAudioNode,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        isActiveAudioNode\n    ),\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    createDecrementCycleCounter(\n        connectNativeAudioNodeToNativeAudioNode,\n        CYCLE_COUNTERS,\n        getAudioNodeConnections,\n        getNativeAudioNode,\n        getNativeAudioParam,\n        getNativeContext,\n        isActiveAudioNode,\n        isNativeOfflineAudioContext\n    ),\n    createDetectCycles(audioParamAudioNodeStore, getAudioNodeConnections, getValueForKey),\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n);\nconst analyserNodeConstructor: TAnalyserNodeConstructor = createAnalyserNodeConstructor(\n    audioNodeConstructor,\n    createAnalyserNodeRenderer,\n    createIndexSizeError,\n    createNativeAnalyserNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\n\ntype analyserNodeConstructor<T extends TContext> = IAnalyserNode<T>;\n\nexport { analyserNodeConstructor as AnalyserNode };\n\nconst audioBufferStore: TAudioBufferStore = new WeakSet();\nconst nativeAudioBufferConstructor = createNativeAudioBufferConstructor(window);\nconst convertNumberToUnsignedLong = createConvertNumberToUnsignedLong(new Uint32Array(1));\nconst wrapAudioBufferCopyChannelMethods = createWrapAudioBufferCopyChannelMethods(convertNumberToUnsignedLong, createIndexSizeError);\nconst wrapAudioBufferCopyChannelMethodsOutOfBounds = createWrapAudioBufferCopyChannelMethodsOutOfBounds(convertNumberToUnsignedLong);\nconst audioBufferConstructor: TAudioBufferConstructor = createAudioBufferConstructor(\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    createTestAudioBufferConstructorSupport(nativeAudioBufferConstructor),\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\ntype audioBufferConstructor = IAudioBuffer;\n\nexport { audioBufferConstructor as AudioBuffer };\n\nconst addSilentConnection = createAddSilentConnection(createNativeGainNode);\nconst renderInputsOfAudioParam = createRenderInputsOfAudioParam(getAudioNodeRenderer, getAudioParamConnections, isPartOfACycle);\nconst connectAudioParam = createConnectAudioParam(renderInputsOfAudioParam);\nconst createNativeAudioBufferSourceNode = createNativeAudioBufferSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport,\n    testAudioBufferSourceNodeStartMethodOffsetClampingSupport,\n    testAudioBufferSourceNodeStopMethodNullifiedBufferSupport,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioBufferSourceNodeStartMethodOffsetClamping,\n    createWrapAudioBufferSourceNodeStopMethodNullifiedBuffer(overwriteAccessors),\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst renderAutomation = createRenderAutomation(createGetAudioParamRenderer(getAudioParamConnections), renderInputsOfAudioParam);\nconst createAudioBufferSourceNodeRenderer = createAudioBufferSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst createAudioParam = createAudioParamFactory(\n    createAddAudioParamConnections(AUDIO_PARAM_CONNECTIONS_STORE),\n    audioParamAudioNodeStore,\n    AUDIO_PARAM_STORE,\n    createAudioParamRenderer,\n    createCancelAndHoldAutomationEvent,\n    createCancelScheduledValuesAutomationEvent,\n    createExponentialRampToValueAutomationEvent,\n    createLinearRampToValueAutomationEvent,\n    createSetTargetAutomationEvent,\n    createSetValueAutomationEvent,\n    createSetValueCurveAutomationEvent,\n    nativeAudioContextConstructor,\n    setValueAtTimeUntilPossible\n);\nconst audioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructor = createAudioBufferSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\n\ntype audioBufferSourceNodeConstructor<T extends TContext> = IAudioBufferSourceNode<T>;\n\nexport { audioBufferSourceNodeConstructor as AudioBufferSourceNode };\n\nconst audioDestinationNodeConstructor = createAudioDestinationNodeConstructor(\n    audioNodeConstructor,\n    createAudioDestinationNodeRenderer,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeAudioDestinationNodeFactory(createNativeGainNode, overwriteAccessors),\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    renderInputsOfAudioNode\n);\nconst createBiquadFilterNodeRenderer = createBiquadFilterNodeRendererFactory(\n    connectAudioParam,\n    createNativeBiquadFilterNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst setAudioNodeTailTime = createSetAudioNodeTailTime(audioNodeTailTimeStore);\nconst biquadFilterNodeConstructor: TBiquadFilterNodeConstructor = createBiquadFilterNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createBiquadFilterNodeRenderer,\n    createInvalidAccessError,\n    createNativeBiquadFilterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst monitorConnections = createMonitorConnections(insertElementInSet, isNativeAudioNode);\nconst wrapChannelMergerNode = createWrapChannelMergerNode(createInvalidStateError, monitorConnections);\nconst createNativeChannelMergerNode = createNativeChannelMergerNodeFactory(nativeAudioContextConstructor, wrapChannelMergerNode);\nconst createChannelMergerNodeRenderer = createChannelMergerNodeRendererFactory(\n    createNativeChannelMergerNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelMergerNodeConstructor: TChannelMergerNodeConstructor = createChannelMergerNodeConstructor(\n    audioNodeConstructor,\n    createChannelMergerNodeRenderer,\n    createNativeChannelMergerNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createChannelSplitterNodeRenderer = createChannelSplitterNodeRendererFactory(\n    createNativeChannelSplitterNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst channelSplitterNodeConstructor: TChannelSplitterNodeConstructor = createChannelSplitterNodeConstructor(\n    audioNodeConstructor,\n    createChannelSplitterNodeRenderer,\n    createNativeChannelSplitterNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    sanitizeChannelSplitterOptions\n);\nconst createNativeConstantSourceNodeFaker = createNativeConstantSourceNodeFakerFactory(\n    addSilentConnection,\n    createNativeAudioBufferSourceNode,\n    createNativeGainNode,\n    monitorConnections\n);\nconst createNativeConstantSourceNode = createNativeConstantSourceNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    createNativeConstantSourceNodeFaker,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport\n);\nconst createConstantSourceNodeRenderer = createConstantSourceNodeRendererFactory(\n    connectAudioParam,\n    createNativeConstantSourceNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst constantSourceNodeConstructor: TConstantSourceNodeConstructor = createConstantSourceNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createConstantSourceNodeRenderer,\n    createNativeConstantSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createNativeConvolverNode = createNativeConvolverNodeFactory(createNotSupportedError, overwriteAccessors);\nconst createConvolverNodeRenderer = createConvolverNodeRendererFactory(\n    createNativeConvolverNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst convolverNodeConstructor: TConvolverNodeConstructor = createConvolverNodeConstructor(\n    audioNodeConstructor,\n    createConvolverNodeRenderer,\n    createNativeConvolverNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createDelayNodeRenderer = createDelayNodeRendererFactory(\n    connectAudioParam,\n    createNativeDelayNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst delayNodeConstructor: TDelayNodeConstructor = createDelayNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDelayNodeRenderer,\n    createNativeDelayNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativeDynamicsCompressorNode = createNativeDynamicsCompressorNodeFactory(createNotSupportedError);\nconst createDynamicsCompressorNodeRenderer = createDynamicsCompressorNodeRendererFactory(\n    connectAudioParam,\n    createNativeDynamicsCompressorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst dynamicsCompressorNodeConstructor: TDynamicsCompressorNodeConstructor = createDynamicsCompressorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createDynamicsCompressorNodeRenderer,\n    createNativeDynamicsCompressorNode,\n    createNotSupportedError,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createGainNodeRenderer = createGainNodeRendererFactory(\n    connectAudioParam,\n    createNativeGainNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst gainNodeConstructor: TGainNodeConstructor = createGainNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createGainNodeRenderer,\n    createNativeGainNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNodeFaker = createNativeIIRFilterNodeFakerFactory(\n    createInvalidAccessError,\n    createInvalidStateError,\n    createNativeScriptProcessorNode,\n    createNotSupportedError\n);\nconst renderNativeOfflineAudioContext = createRenderNativeOfflineAudioContext(\n    cacheTestResult,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createTestOfflineAudioContextCurrentTimeSupport(createNativeGainNode, nativeOfflineAudioContextConstructor)\n);\nconst createIIRFilterNodeRenderer = createIIRFilterNodeRendererFactory(\n    createNativeAudioBufferSourceNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst createNativeIIRFilterNode = createNativeIIRFilterNodeFactory(createNativeIIRFilterNodeFaker);\nconst iIRFilterNodeConstructor: TIIRFilterNodeConstructor = createIIRFilterNodeConstructor(\n    audioNodeConstructor,\n    createNativeIIRFilterNode,\n    createIIRFilterNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createAudioListener = createAudioListenerFactory(\n    createAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    getFirstSample,\n    isNativeOfflineAudioContext,\n    overwriteAccessors\n);\nconst unrenderedAudioWorkletNodeStore: TUnrenderedAudioWorkletNodeStore = new WeakMap();\nconst minimalBaseAudioContextConstructor = createMinimalBaseAudioContextConstructor(\n    audioDestinationNodeConstructor,\n    createAudioListener,\n    eventTargetConstructor,\n    isNativeOfflineAudioContext,\n    unrenderedAudioWorkletNodeStore,\n    wrapEventListener\n);\nconst createNativeOscillatorNode = createNativeOscillatorNodeFactory(\n    addSilentConnection,\n    cacheTestResult,\n    testAudioScheduledSourceNodeStartMethodNegativeParametersSupport,\n    testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport,\n    testAudioScheduledSourceNodeStopMethodNegativeParametersSupport,\n    wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls\n);\nconst createOscillatorNodeRenderer = createOscillatorNodeRendererFactory(\n    connectAudioParam,\n    createNativeOscillatorNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst oscillatorNodeConstructor: TOscillatorNodeConstructor = createOscillatorNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeOscillatorNode,\n    createOscillatorNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n);\nconst createConnectedNativeAudioBufferSourceNode = createConnectedNativeAudioBufferSourceNodeFactory(createNativeAudioBufferSourceNode);\nconst createNativeWaveShaperNodeFaker = createNativeWaveShaperNodeFakerFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeGainNode,\n    isDCCurve,\n    monitorConnections\n);\nconst createNativeWaveShaperNode = createNativeWaveShaperNodeFactory(\n    createConnectedNativeAudioBufferSourceNode,\n    createInvalidStateError,\n    createNativeWaveShaperNodeFaker,\n    isDCCurve,\n    monitorConnections,\n    nativeAudioContextConstructor,\n    overwriteAccessors\n);\nconst createNativePannerNodeFaker = createNativePannerNodeFakerFactory(\n    connectNativeAudioNodeToNativeAudioNode,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    disconnectNativeAudioNodeFromNativeAudioNode,\n    getFirstSample,\n    monitorConnections\n);\nconst createNativePannerNode = createNativePannerNodeFactory(createNativePannerNodeFaker);\nconst createPannerNodeRenderer = createPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeChannelMergerNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativePannerNode,\n    getNativeAudioNode,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst pannerNodeConstructor: TPannerNodeConstructor = createPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativePannerNode,\n    createPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst createNativePeriodicWave = createNativePeriodicWaveFactory(createIndexSizeError);\nconst periodicWaveConstructor: TPeriodicWaveConstructor = createPeriodicWaveConstructor(\n    createNativePeriodicWave,\n    getNativeContext,\n    new WeakSet(),\n    sanitizePeriodicWaveOptions\n);\nconst nativeStereoPannerNodeFakerFactory = createNativeStereoPannerNodeFakerFactory(\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createNativeStereoPannerNode = createNativeStereoPannerNodeFactory(nativeStereoPannerNodeFakerFactory, createNotSupportedError);\nconst createStereoPannerNodeRenderer = createStereoPannerNodeRendererFactory(\n    connectAudioParam,\n    createNativeStereoPannerNode,\n    getNativeAudioNode,\n    renderAutomation,\n    renderInputsOfAudioNode\n);\nconst stereoPannerNodeConstructor: TStereoPannerNodeConstructor = createStereoPannerNodeConstructor(\n    audioNodeConstructor,\n    createAudioParam,\n    createNativeStereoPannerNode,\n    createStereoPannerNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createWaveShaperNodeRenderer = createWaveShaperNodeRendererFactory(\n    createNativeWaveShaperNode,\n    getNativeAudioNode,\n    renderInputsOfAudioNode\n);\nconst waveShaperNodeConstructor: TWaveShaperNodeConstructor = createWaveShaperNodeConstructor(\n    audioNodeConstructor,\n    createInvalidStateError,\n    createNativeWaveShaperNode,\n    createWaveShaperNodeRenderer,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    setAudioNodeTailTime\n);\nconst isSecureContext = createIsSecureContext(window);\nconst exposeCurrentFrameAndCurrentTime = createExposeCurrentFrameAndCurrentTime(window);\nconst backupOfflineAudioContextStore: TBackupOfflineAudioContextStore = new WeakMap();\nconst getOrCreateBackupOfflineAudioContext = createGetOrCreateBackupOfflineAudioContext(\n    backupOfflineAudioContextStore,\n    nativeOfflineAudioContextConstructor\n);\n\n// The addAudioWorkletModule() function is only available in a SecureContext.\nexport const addAudioWorkletModule: undefined | TAddAudioWorkletModuleFunction = isSecureContext\n    ? createAddAudioWorkletModule(\n          cacheTestResult,\n          createNotSupportedError,\n          createEvaluateSource(window),\n          exposeCurrentFrameAndCurrentTime,\n          createFetchSource(createAbortError),\n          getNativeContext,\n          getOrCreateBackupOfflineAudioContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          new WeakMap(),\n          new WeakMap(),\n          createTestAudioWorkletProcessorPostMessageSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n          // @todo window is guaranteed to be defined because isSecureContext checks that as well.\n          <NonNullable<typeof window>>window\n      )\n    : undefined;\n\nconst isNativeContext = createIsNativeContext(isNativeAudioContext, isNativeOfflineAudioContext);\n\nexport const decodeAudioData: TDecodeAudioDataFunction = createDecodeAudioData(\n    audioBufferStore,\n    cacheTestResult,\n    createDataCloneError,\n    createEncodingError,\n    new WeakSet(),\n    getNativeContext,\n    isNativeContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    testPromiseSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\n\nconst baseAudioContextConstructor = createBaseAudioContextConstructor(\n    addAudioWorkletModule,\n    analyserNodeConstructor,\n    audioBufferConstructor,\n    audioBufferSourceNodeConstructor,\n    biquadFilterNodeConstructor,\n    channelMergerNodeConstructor,\n    channelSplitterNodeConstructor,\n    constantSourceNodeConstructor,\n    convolverNodeConstructor,\n    decodeAudioData,\n    delayNodeConstructor,\n    dynamicsCompressorNodeConstructor,\n    gainNodeConstructor,\n    iIRFilterNodeConstructor,\n    minimalBaseAudioContextConstructor,\n    oscillatorNodeConstructor,\n    pannerNodeConstructor,\n    periodicWaveConstructor,\n    stereoPannerNodeConstructor,\n    waveShaperNodeConstructor\n);\nconst mediaElementAudioSourceNodeConstructor: TMediaElementAudioSourceNodeConstructor = createMediaElementAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaElementAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamAudioDestinationNodeConstructor: TMediaStreamAudioDestinationNodeConstructor =\n    createMediaStreamAudioDestinationNodeConstructor(\n        audioNodeConstructor,\n        createNativeMediaStreamAudioDestinationNode,\n        getNativeContext,\n        isNativeOfflineAudioContext\n    );\nconst mediaStreamAudioSourceNodeConstructor: TMediaStreamAudioSourceNodeConstructor = createMediaStreamAudioSourceNodeConstructor(\n    audioNodeConstructor,\n    createNativeMediaStreamAudioSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext\n);\nconst createNativeMediaStreamTrackAudioSourceNode = createNativeMediaStreamTrackAudioSourceNodeFactory(\n    createInvalidStateError,\n    isNativeOfflineAudioContext\n);\nconst mediaStreamTrackAudioSourceNodeConstructor: TMediaStreamTrackAudioSourceNodeConstructor =\n    createMediaStreamTrackAudioSourceNodeConstructor(audioNodeConstructor, createNativeMediaStreamTrackAudioSourceNode, getNativeContext);\nconst audioContextConstructor: TAudioContextConstructor = createAudioContextConstructor(\n    baseAudioContextConstructor,\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    mediaElementAudioSourceNodeConstructor,\n    mediaStreamAudioDestinationNodeConstructor,\n    mediaStreamAudioSourceNodeConstructor,\n    mediaStreamTrackAudioSourceNodeConstructor,\n    nativeAudioContextConstructor\n);\n\ntype audioContextConstructor = IAudioContext;\n\nexport { audioContextConstructor as AudioContext };\n\nconst getUnrenderedAudioWorkletNodes = createGetUnrenderedAudioWorkletNodes(unrenderedAudioWorkletNodeStore);\nconst addUnrenderedAudioWorkletNode = createAddUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst connectMultipleOutputs = createConnectMultipleOutputs(createIndexSizeError);\nconst deleteUnrenderedAudioWorkletNode = createDeleteUnrenderedAudioWorkletNode(getUnrenderedAudioWorkletNodes);\nconst disconnectMultipleOutputs = createDisconnectMultipleOutputs(createIndexSizeError);\nconst activeAudioWorkletNodeInputsStore: TActiveAudioWorkletNodeInputsStore = new WeakMap();\nconst getActiveAudioWorkletNodeInputs = createGetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore, getValueForKey);\nconst createNativeAudioWorkletNodeFaker = createNativeAudioWorkletNodeFakerFactory(\n    connectMultipleOutputs,\n    createIndexSizeError,\n    createInvalidStateError,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    createNativeScriptProcessorNode,\n    createNotSupportedError,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getActiveAudioWorkletNodeInputs,\n    monitorConnections\n);\nconst createNativeAudioWorkletNode = createNativeAudioWorkletNodeFactory(\n    createInvalidStateError,\n    createNativeAudioWorkletNodeFaker,\n    createNativeGainNode,\n    createNotSupportedError,\n    monitorConnections\n);\nconst createAudioWorkletNodeRenderer = createAudioWorkletNodeRendererFactory(\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n);\nconst getBackupOfflineAudioContext = createGetBackupOfflineAudioContext(backupOfflineAudioContextStore);\nconst setActiveAudioWorkletNodeInputs = createSetActiveAudioWorkletNodeInputs(activeAudioWorkletNodeInputsStore);\n\n// The AudioWorkletNode constructor is only available in a SecureContext.\nconst audioWorkletNodeConstructor: undefined | TAudioWorkletNodeConstructor = isSecureContext\n    ? createAudioWorkletNodeConstructor(\n          addUnrenderedAudioWorkletNode,\n          audioNodeConstructor,\n          createAudioParam,\n          createAudioWorkletNodeRenderer,\n          createNativeAudioWorkletNode,\n          getAudioNodeConnections,\n          getBackupOfflineAudioContext,\n          getNativeContext,\n          isNativeOfflineAudioContext,\n          nativeAudioWorkletNodeConstructor,\n          sanitizeAudioWorkletNodeOptions,\n          setActiveAudioWorkletNodeInputs,\n          testAudioWorkletNodeOptionsClonability,\n          wrapEventListener\n      )\n    : undefined;\n\ntype audioWorkletNodeConstructor<T extends TContext> = undefined | IAudioWorkletNode<T>;\n\nexport { audioWorkletNodeConstructor as AudioWorkletNode };\n\ntype biquadFilterNodeConstructor<T extends TContext> = IBiquadFilterNode<T>;\n\nexport { biquadFilterNodeConstructor as BiquadFilterNode };\n\ntype channelMergerNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelMergerNodeConstructor as ChannelMergerNode };\n\ntype channelSplitterNodeConstructor<T extends TContext> = IAudioNode<T>;\n\nexport { channelSplitterNodeConstructor as ChannelSplitterNode };\n\ntype constantSourceNodeConstructor<T extends TContext> = IConstantSourceNode<T>;\n\nexport { convolverNodeConstructor as ConvolverNode };\n\ntype convolverNodeConstructor<T extends TContext> = IConvolverNode<T>;\n\nexport { constantSourceNodeConstructor as ConstantSourceNode };\n\ntype delayNodeConstructor<T extends TContext> = IDelayNode<T>;\n\nexport { delayNodeConstructor as DelayNode };\n\ntype dynamicsCompressorNodeConstructor<T extends TContext> = IDynamicsCompressorNode<T>;\n\nexport { dynamicsCompressorNodeConstructor as DynamicsCompressorNode };\n\ntype gainNodeConstructor<T extends TContext> = IGainNode<T>;\n\nexport { gainNodeConstructor as GainNode };\n\ntype iIRFilterNodeConstructor<T extends TContext> = IIIRFilterNode<T>;\n\nexport { iIRFilterNodeConstructor as IIRFilterNode };\n\ntype mediaElementAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaElementAudioSourceNode<T>;\n\nexport { mediaElementAudioSourceNodeConstructor as MediaElementAudioSourceNode };\n\ntype mediaStreamAudioDestinationNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioDestinationNode<T>;\n\nexport { mediaStreamAudioDestinationNodeConstructor as MediaStreamAudioDestinationNode };\n\ntype mediaStreamAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamAudioSourceNode<T>;\n\nexport { mediaStreamAudioSourceNodeConstructor as MediaStreamAudioSourceNode };\n\ntype mediaStreamTrackAudioSourceNodeConstructor<T extends IAudioContext | IMinimalAudioContext> = IMediaStreamTrackAudioSourceNode<T>;\n\nexport { mediaStreamTrackAudioSourceNodeConstructor as MediaStreamTrackAudioSourceNode };\n\nconst minimalAudioContextConstructor: TMinimalAudioContextConstructor = createMinimalAudioContextConstructor(\n    createInvalidStateError,\n    createNotSupportedError,\n    createUnknownError,\n    minimalBaseAudioContextConstructor,\n    nativeAudioContextConstructor\n);\n\ntype minimalAudioContextConstructor = IMinimalAudioContext;\n\nexport { minimalAudioContextConstructor as MinimalAudioContext };\n\nconst createNativeOfflineAudioContext = createCreateNativeOfflineAudioContext(\n    createNotSupportedError,\n    nativeOfflineAudioContextConstructor\n);\nconst startRendering = createStartRendering(\n    audioBufferStore,\n    cacheTestResult,\n    getAudioNodeRenderer,\n    getUnrenderedAudioWorkletNodes,\n    renderNativeOfflineAudioContext,\n    testAudioBufferCopyChannelMethodsOutOfBoundsSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n);\nconst minimalOfflineAudioContextConstructor: TMinimalOfflineAudioContextConstructor = createMinimalOfflineAudioContextConstructor(\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    minimalBaseAudioContextConstructor,\n    startRendering\n);\n\ntype minimalOfflineAudioContextConstructor = IMinimalOfflineAudioContext;\n\nexport { minimalOfflineAudioContextConstructor as MinimalOfflineAudioContext };\n\nconst offlineAudioContextConstructor: IOfflineAudioContextConstructor = createOfflineAudioContextConstructor(\n    baseAudioContextConstructor,\n    cacheTestResult,\n    createInvalidStateError,\n    createNativeOfflineAudioContext,\n    startRendering\n);\n\ntype offlineAudioContextConstructor = IOfflineAudioContext;\n\nexport { offlineAudioContextConstructor as OfflineAudioContext };\n\ntype oscillatorNodeConstructor<T extends TContext> = IOscillatorNode<T>;\n\nexport { oscillatorNodeConstructor as OscillatorNode };\n\ntype pannerNodeConstructor<T extends TContext> = IPannerNode<T>;\n\nexport { pannerNodeConstructor as PannerNode };\n\ntype periodicWaveConstructor = IPeriodicWave;\n\nexport { periodicWaveConstructor as PeriodicWave };\n\ntype stereoPannerNodeConstructor<T extends TContext> = IStereoPannerNode<T>;\n\nexport { stereoPannerNodeConstructor as StereoPannerNode };\n\ntype waveShaperNodeConstructor<T extends TContext> = IWaveShaperNode<T>;\n\nexport { waveShaperNodeConstructor as WaveShaperNode };\n\nexport const isAnyAudioContext = createIsAnyAudioContext(CONTEXT_STORE, isNativeAudioContext);\n\nexport const isAnyAudioNode = createIsAnyAudioNode(AUDIO_NODE_STORE, isNativeAudioNode);\n\nexport const isAnyAudioParam = createIsAnyAudioParam(AUDIO_PARAM_STORE, isNativeAudioParam);\n\nexport const isAnyOfflineAudioContext = createIsAnyOfflineAudioContext(CONTEXT_STORE, isNativeOfflineAudioContext);\n\nexport const isSupported = () =>\n    createIsSupportedPromise(\n        cacheTestResult,\n        createTestAudioBufferCopyChannelMethodsSubarraySupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextCloseMethodSupport(nativeAudioContextConstructor),\n        createTestAudioContextDecodeAudioDataMethodTypeErrorSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioContextOptionsSupport(nativeAudioContextConstructor),\n        createTestAudioNodeConnectMethodSupport(nativeOfflineAudioContextConstructor),\n        createTestAudioWorkletProcessorNoOutputsSupport(nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor),\n        createTestChannelMergerNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        createTestConstantSourceNodeAccurateSchedulingSupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeBufferReassignabilitySupport(nativeOfflineAudioContextConstructor),\n        createTestConvolverNodeChannelCountSupport(nativeOfflineAudioContextConstructor),\n        testDomExceptionConstructorSupport,\n        createTestIsSecureContextSupport(window),\n        createTestMediaStreamAudioSourceNodeMediaStreamWithoutAudioTrackSupport(nativeAudioContextConstructor),\n        createTestStereoPannerNodeDefaultValueSupport(nativeOfflineAudioContextConstructor),\n        testTransferablesSupport\n    );\n", "/**\n * Assert that the statement is true, otherwise invoke the error.\n * @param statement\n * @param error The message which is passed into an Error\n */\nexport function assert(statement: boolean, error: string): void {\n\tif (!statement) {\n\t\tthrow new Error(error);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertRange(value: number, gte: number, lte = Infinity): void {\n\tif (!(gte <= value && value <= lte)) {\n\t\tthrow new RangeError(`Value must be within [${gte}, ${lte}], got: ${value}`);\n\t}\n}\n\n/**\n * Make sure that the given value is within the range\n */\nexport function assertContextRunning(context: import(\"../context/BaseContext\").BaseContext): void {\n\t// add a warning if the context is not started\n\tif (!context.isOffline && context.state !== \"running\") {\n\t\twarn(\"The AudioContext is \\\"suspended\\\". Invoke Tone.start() from a user action to start the audio.\");\n\t}\n}\n\n/**\n * A basic logging interface\n */\ninterface Logger {\n\tlog: (args?: any[]) => void;\n\twarn: (args?: any[]) => void;\n}\n\n/**\n * The default logger is the console\n */\nlet defaultLogger: Logger = console;\n\n/**\n * Set the logging interface\n */\nexport function setLogger(logger: Logger): void {\n\tdefaultLogger = logger;\n}\n\n/**\n * Log anything\n */\nexport function log(...args: any[]): void {\n\tdefaultLogger.log(...args);\n}\n\n/**\n * Warn anything\n */\nexport function warn(...args: any[]): void {\n\tdefaultLogger.warn(...args);\n}\n", "import { Note } from \"../type/Units\";\n\n/**\n * Test if the arg is undefined\n */\nexport function isUndef(arg: any): arg is undefined {\n\treturn typeof arg === \"undefined\";\n}\n\n/**\n * Test if the arg is not undefined\n */\nexport function isDefined<T>(arg: T | undefined): arg is T {\n\treturn !isUndef(arg);\n}\n\n/**\n * Test if the arg is a function\n */\nexport function isFunction(arg: any): arg is (a: any) => any {\n\treturn typeof arg === \"function\";\n}\n\n/**\n * Test if the argument is a number.\n */\nexport function isNumber(arg: any): arg is number {\n\treturn (typeof arg === \"number\");\n}\n\n/**\n * Test if the given argument is an object literal (i.e. `{}`);\n */\nexport function isObject(arg: any): arg is object {\n\treturn (Object.prototype.toString.call(arg) === \"[object Object]\" && arg.constructor === Object);\n}\n\n/**\n * Test if the argument is a boolean.\n */\nexport function isBoolean(arg: any): arg is boolean {\n\treturn (typeof arg === \"boolean\");\n}\n\n/**\n * Test if the argument is an Array\n */\nexport function isArray(arg: any): arg is any[] {\n\treturn (Array.isArray(arg));\n}\n\n/**\n * Test if the argument is a string.\n */\nexport function isString(arg: any): arg is string {\n\treturn (typeof arg === \"string\");\n}\n\n/**\n * Test if the argument is in the form of a note in scientific pitch notation.\n * e.g. \"C4\"\n */\nexport function isNote(arg: any): arg is Note {\n\treturn isString(arg) && /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i.test(arg);\n}\n", "import {\n\tAudioContext as stdAudioContext,\n\tAudioWorkletNode as stdAudioWorkletNode,\n\tOfflineAudioContext as stdOfflineAudioContext\n} from \"standardized-audio-context\";\nimport { assert } from \"../util/Debug\";\nimport { isDefined } from \"../util/TypeCheck\";\n\n/**\n * Create a new AudioContext\n */\nexport function createAudioContext(options?: AudioContextOptions): AudioContext {\n\treturn new stdAudioContext(options) as unknown as AudioContext;\n}\n\n/**\n * Create a new OfflineAudioContext\n */\nexport function createOfflineAudioContext(channels: number, length: number, sampleRate: number): OfflineAudioContext {\n\treturn new stdOfflineAudioContext(channels, length, sampleRate) as unknown as OfflineAudioContext;\n}\n\n/**\n * Either the online or offline audio context\n */\nexport type AnyAudioContext = AudioContext | OfflineAudioContext;\n\n/**\n * Interface for things that Tone.js adds to the window\n */\ninterface ToneWindow extends Window {\n\tTONE_SILENCE_LOGGING?: boolean;\n\tTONE_DEBUG_CLASS?: string;\n}\n\n/**\n * A reference to the window object\n * @hidden\n */\nexport const theWindow: ToneWindow | null = typeof self === \"object\" ? self : null;\n\n/**\n * If the browser has a window object which has an AudioContext\n * @hidden\n */\nexport const hasAudioContext = theWindow &&\n\t(theWindow.hasOwnProperty(\"AudioContext\") || theWindow.hasOwnProperty(\"webkitAudioContext\"));\n\nexport function createAudioWorkletNode(context: AnyAudioContext, name: string, options?: Partial<AudioWorkletNodeOptions>): AudioWorkletNode {\n\tassert(isDefined(stdAudioWorkletNode), \"This node only works in a secure context (https or localhost)\");\n\t// @ts-ignore\n\treturn new stdAudioWorkletNode(context, name, options);\n}\n\n/**\n * This promise resolves to a boolean which indicates if the \n * functionality is supported within the currently used browse. \n * Taken from [standardized-audio-context](https://github.com/chrisguttandin/standardized-audio-context#issupported)\n */\nexport { isSupported as supported } from \"standardized-audio-context\";\n", "import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n", "import {\n\tisAnyAudioContext, isAnyAudioNode,\n\tisAnyAudioParam, isAnyOfflineAudioContext,\n} from \"standardized-audio-context\";\n\n/**\n * Test if the given value is an instanceof AudioParam\n */\nexport function isAudioParam(arg: any): arg is AudioParam {\n\treturn isAnyAudioParam(arg);\n}\n\n/**\n * Test if the given value is an instanceof AudioNode\n */\nexport function isAudioNode(arg: any): arg is AudioNode {\n\treturn isAnyAudioNode(arg);\n}\n\n/**\n * Test if the arg is instanceof an OfflineAudioContext\n */\nexport function isOfflineAudioContext(arg: any): arg is OfflineAudioContext {\n\treturn isAnyOfflineAudioContext(arg);\n}\n\n/**\n * Test if the arg is an instanceof AudioContext\n */\nexport function isAudioContext(arg: any): arg is AudioContext {\n\treturn isAnyAudioContext(arg);\n}\n\n/**\n * Test if the arg is instanceof an AudioBuffer\n */\nexport function isAudioBuffer(arg: any): arg is AudioBuffer {\n\treturn arg instanceof AudioBuffer;\n}\n", "import { isAudioBuffer, isAudioNode, isAudioParam } from \"./AdvancedTypeCheck\";\nimport { isDefined, isObject, isUndef } from \"./TypeCheck\";\n\ntype BaseToneOptions = import(\"../Tone\").BaseToneOptions;\n\n/**\n * Some objects should not be merged\n */\nfunction noCopy(key: string, arg: any): boolean {\n\treturn key === \"value\" || isAudioParam(arg) || isAudioNode(arg) || isAudioBuffer(arg);\n}\n\n/**\n * Recursively merge an object\n * @param target the object to merge into\n * @param sources the source objects to merge\n */\nexport function deepMerge<T>(target: T): T;\nexport function deepMerge<T, U>(target: T, source1: U): T & U;\nexport function deepMerge<T, U, V>(target: T, source1: U, source2: V): T & U & V;\nexport function deepMerge<T, U, V, W>(target: T, source1: U, source2: V, source3: W): T & U & V & W;\nexport function deepMerge(target: any, ...sources: any[]): any {\n\tif (!sources.length) {\n\t\treturn target; \n\t}\n\tconst source = sources.shift();\n\n\tif (isObject(target) && isObject(source)) {\n\t\tfor (const key in source) {\n\t\t\tif (noCopy(key, source[key])) {\n\t\t\t\ttarget[key] = source[key];\n\t\t\t} else if (isObject(source[key])) {\n\t\t\t\tif (!target[key]) {\n\t\t\t\t\tObject.assign(target, { [key]: {} }); \n\t\t\t\t}\n\t\t\t\tdeepMerge(target[key], source[key] as any);\n\t\t\t} else {\n\t\t\t\tObject.assign(target, { [key]: source[key] as any });\n\t\t\t}\n\t\t}\n\t}\n\t// @ts-ignore\n\treturn deepMerge(target, ...sources);\n}\n\n/**\n * Returns true if the two arrays have the same value for each of the elements\n */\nexport function deepEquals<T>(arrayA: T[], arrayB: T[]): boolean {\n\treturn arrayA.length === arrayB.length && arrayA.every((element, index) => arrayB[index] === element);\n}\n\n/**\n * Convert an args array into an object.\n */\nexport function optionsFromArguments<T extends object>(\n\tdefaults: T,\n\targsArray: IArguments,\n\tkeys: Array<keyof T> = [],\n\tobjKey?: keyof T,\n): T {\n\tconst opts: Partial<T> = {};\n\tconst args = Array.from(argsArray);\n\t// if the first argument is an object and has an object key\n\tif (isObject(args[0]) && objKey && !Reflect.has(args[0], objKey)) {\n\t\t// if it's not part of the defaults\n\t\tconst partOfDefaults = Object.keys(args[0]).some(key => Reflect.has(defaults, key));\n\t\tif (!partOfDefaults) {\n\t\t\t// merge that key\n\t\t\tdeepMerge(opts, { [objKey]: args[0] });\n\t\t\t// remove the obj key from the keys\n\t\t\tkeys.splice(keys.indexOf(objKey), 1);\n\t\t\t// shift the first argument off\n\t\t\targs.shift();\n\t\t}\n\t}\n\tif (args.length === 1 && isObject(args[0])) {\n\t\tdeepMerge(opts, args[0]);\n\t} else {\n\t\tfor (let i = 0; i < keys.length; i++) {\n\t\t\tif (isDefined(args[i])) {\n\t\t\t\topts[keys[i]] = args[i];\n\t\t\t}\n\t\t}\n\t}\n\treturn deepMerge(defaults, opts);\n}\n\n/**\n * Return this instances default values by calling Constructor.getDefaults()\n */\nexport function getDefaultsFromInstance<T>(instance: T): BaseToneOptions {\n\ttype ToneClass = {\n\t\tconstructor: ToneClass;\n\t\tgetDefaults: () => BaseToneOptions;\n\t} & T;\n\n\treturn (instance as ToneClass).constructor.getDefaults();\n}\n\n/**\n * Returns the fallback if the given object is undefined.\n * Take an array of arguments and return a formatted options object.\n */\nexport function defaultArg<T>(given: T, fallback: T): T {\n\tif (isUndef(given)) {\n\t\treturn fallback;\n\t} else {\n\t\treturn given;\n\t}\n}\n\n/**\n * Remove all of the properties belonging to omit from obj.\n */\nexport function omitFromObject<T extends object, O extends string[]>(obj: T, omit: O): Omit<T, keyof O> {\n\tomit.forEach(prop => {\n\t\tif (Reflect.has(obj, prop)) {\n\t\t\tdelete obj[prop];\n\t\t}\n\t});\n\treturn obj;\n}\n", "/**\n * Tone.js\n * @author Yotam Mann\n * @license http://opensource.org/licenses/MIT MIT License\n * @copyright 2014-2019 Yotam Mann\n */\nimport { version } from \"../version\";\nimport { theWindow } from \"./context/AudioContext\";\nimport { log } from \"./util/Debug\";\n\n//-------------------------------------\n// \tTONE\n//-------------------------------------\n\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\nexport interface BaseToneOptions { }\n\n/**\n * @class  Tone is the base class of all other classes.\n * @category Core\n * @constructor\n */\nexport abstract class Tone {\n\n\t/**\n\t * The version number semver\n\t */\n\tstatic version: string = version;\n\n\t/**\n\t * The name of the class\n\t */\n\tprotected abstract name: string;\n\n\t/**\n\t * Returns all of the default options belonging to the class.\n\t */\n\tstatic getDefaults(): BaseToneOptions {\n\t\treturn {};\n\t}\n\n\t//-------------------------------------\n\t// \tDEBUGGING\n\t//-------------------------------------\n\n\t/**\n\t * Set this debug flag to log all events that happen in this class.\n\t */\n\tdebug = false;\n\n\t/**\n\t * Prints the outputs to the console log for debugging purposes.\n\t * Prints the contents only if either the object has a property\n\t * called `debug` set to true, or a variable called TONE_DEBUG_CLASS\n\t * is set to the name of the class.\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * // prints all logs originating from this oscillator\n\t * osc.debug = true;\n\t * // calls to start/stop will print in the console\n\t * osc.start();\n\t */\n\tprotected log(...args: any[]): void {\n\t\t// if the object is either set to debug = true\n\t\t// or if there is a string on the Tone.global.with the class name\n\t\tif (this.debug || (theWindow && this.toString() === theWindow.TONE_DEBUG_CLASS)) {\n\t\t\tlog(this, ...args);\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tDISPOSING\n\t//-------------------------------------\n\n\t/**\n\t * Indicates if the instance was disposed\n\t */\n\tprivate _wasDisposed = false;\n\n\t/**\n\t * disconnect and dispose.\n\t */\n\tdispose(): this {\n\t\tthis._wasDisposed = true;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Indicates if the instance was disposed. 'Disposing' an\n\t * instance means that all of the Web Audio nodes that were\n\t * created for the instance are disconnected and freed for garbage collection.\n\t */\n\tget disposed(): boolean {\n\t\treturn this._wasDisposed;\n\t}\n\n\t/**\n\t * Convert the class to a string\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * console.log(osc.toString());\n\t */\n\ttoString(): string {\n\t\treturn this.name;\n\t}\n}\n", "/**\n * The threshold for correctness for operators. Less than one sample even \n * at very high sampling rates (e.g. `1e-6 < 1 / 192000`).\n */\nconst EPSILON = 1e-6;\n\n/**\n * Test if A is greater than B\n */\nexport function GT(a: number, b: number): boolean {\n\treturn a > b + EPSILON;\n}\n\n/**\n * Test if A is greater than or equal to B\n */\nexport function GTE(a: number, b: number): boolean {\n\treturn GT(a, b) || EQ(a, b);\n}\n\n/**\n * Test if A is less than B\n */\nexport function LT(a: number, b: number): boolean {\n\treturn a + EPSILON < b;\n}\n\n/**\n * Test if A is less than B\n */\nexport function EQ(a: number, b: number): boolean {\n\treturn Math.abs(a - b) < EPSILON;\n}\n\n/**\n * Clamp the value within the given range\n */\nexport function clamp(value: number, min: number, max: number): number {\n\treturn Math.max(Math.min(value, max), min);\n}\n", "import { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last \n\t * element on the list. \n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tassert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tassert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (EQ(this._timeline[index].time, after)) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (EQ(this._timeline[i].time, after)) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (GTE(this._timeline[0].time, after)) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n\t\t\tlet lowerBound = upperBound;\n\t\t\tfor (let i = upperBound; i >= 0; i--) {\n\t\t\t\tif (EQ(this._timeline[i].time, time)) {\n\t\t\t\t\tlowerBound = i;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._iterate(event => {\n\t\t\t\tcallback(event);\n\t\t\t}, lowerBound, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n", "//-------------------------------------\n// INITIALIZING NEW CONTEXT\n//-------------------------------------\n\ntype Context = import(\"./Context\").Context;\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyNewContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to setup a new Context\n */\nexport function onContextInit(cb: (ctx: Context) => void): void {\n\tnotifyNewContext.push(cb);\n}\n\n/**\n * Invoke any classes which need to also be initialized when a new context is created.\n */\nexport function initializeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyNewContext.forEach(cb => cb(ctx));\n}\n\n/**\n * Array of callbacks to invoke when a new context is created\n */\nconst notifyCloseContext: Array<(ctx: Context) => void> = [];\n\n/**\n * Used internally to tear down a Context\n */\nexport function onContextClose(cb: (ctx: Context) => void): void {\n\tnotifyCloseContext.push(cb);\n}\n\nexport function closeContext(ctx: Context): void {\n\t// add any additional modules\n\tnotifyCloseContext.forEach(cb => cb(ctx));\n}\n", "import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n", "import { Seconds } from \"../type/Units\";\nimport { Emitter } from \"../util/Emitter\";\nimport { AnyAudioContext } from \"./AudioContext\";\n\ntype Draw = import(\"../util/Draw\").Draw;\ntype Destination = import(\"./Destination\").Destination;\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Listener = import(\"./Listener\").Listener;\n\n// these are either not used in Tone.js or deprecated and not implemented.\nexport type ExcludedFromBaseAudioContext =\n\t| \"onstatechange\"\n\t| \"addEventListener\"\n\t| \"removeEventListener\"\n\t| \"listener\"\n\t| \"dispatchEvent\"\n\t| \"audioWorklet\"\n\t| \"destination\"\n\t| \"createScriptProcessor\";\n\n// the subset of the BaseAudioContext which Tone.Context implements.\nexport type BaseAudioContextSubset = Omit<\nBaseAudioContext,\nExcludedFromBaseAudioContext\n>;\n\nexport type ContextLatencyHint = AudioContextLatencyCategory;\n\nexport abstract class BaseContext\n\textends Emitter<\"statechange\" | \"tick\">\n\timplements BaseAudioContextSubset {\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tabstract createAnalyser(): AnalyserNode;\n\n\tabstract createOscillator(): OscillatorNode;\n\n\tabstract createBufferSource(): AudioBufferSourceNode;\n\n\tabstract createBiquadFilter(): BiquadFilterNode;\n\n\tabstract createBuffer(\n\t\t_numberOfChannels: number,\n\t\t_length: number,\n\t\t_sampleRate: number\n\t): AudioBuffer;\n\n\tabstract createChannelMerger(\n\t\t_numberOfInputs?: number | undefined\n\t): ChannelMergerNode;\n\n\tabstract createChannelSplitter(\n\t\t_numberOfOutputs?: number | undefined\n\t): ChannelSplitterNode;\n\n\tabstract createConstantSource(): ConstantSourceNode;\n\n\tabstract createConvolver(): ConvolverNode;\n\n\tabstract createDelay(_maxDelayTime?: number | undefined): DelayNode;\n\n\tabstract createDynamicsCompressor(): DynamicsCompressorNode;\n\n\tabstract createGain(): GainNode;\n\n\tabstract createIIRFilter(\n\t\t_feedForward: number[] | Float32Array,\n\t\t_feedback: number[] | Float32Array\n\t): IIRFilterNode;\n\n\tabstract createPanner(): PannerNode;\n\n\tabstract createPeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined\n\t): PeriodicWave;\n\n\tabstract createStereoPanner(): StereoPannerNode;\n\n\tabstract createWaveShaper(): WaveShaperNode;\n\n\tabstract createMediaStreamSource(\n\t\t_stream: MediaStream\n\t): MediaStreamAudioSourceNode;\n\n\tabstract createMediaElementSource(\n\t\t_element: HTMLMediaElement\n\t): MediaElementAudioSourceNode;\n\n\tabstract createMediaStreamDestination(): MediaStreamAudioDestinationNode;\n\n\tabstract decodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer>;\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tabstract createAudioWorkletNode(\n\t\t_name: string,\n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode;\n\n\tabstract get rawContext(): AnyAudioContext;\n\n\tabstract async addAudioWorkletModule(\n\t\t_url: string,\n\t\t_name: string\n\t): Promise<void>;\n\n\tabstract lookAhead: number;\n\n\tabstract latencyHint: ContextLatencyHint | Seconds;\n\n\tabstract resume(): Promise<void>;\n\n\tabstract setTimeout(\n\t\t_fn: (...args: any[]) => void,\n\t\t_timeout: Seconds\n\t): number;\n\n\tabstract clearTimeout(_id: number): this;\n\n\tabstract setInterval(\n\t\t_fn: (...args: any[]) => void,\n\t\t_interval: Seconds\n\t): number;\n\n\tabstract clearInterval(_id: number): this;\n\n\tabstract getConstant(_val: number): AudioBufferSourceNode;\n\n\tabstract get currentTime(): Seconds;\n\n\tabstract get state(): AudioContextState;\n\n\tabstract get sampleRate(): number;\n\n\tabstract get listener(): Listener;\n\n\tabstract get transport(): Transport;\n\n\tabstract get draw(): Draw;\n\n\tabstract get destination(): Destination;\n\n\tabstract now(): Seconds;\n\n\tabstract immediate(): Seconds;\n\n\t/*\n\t * This is a placeholder so that JSON.stringify does not throw an error\n\t * This matches what JSON.stringify(audioContext) returns on a native\n\t * audioContext instance.\n\t */\n\ttoJSON(): Record<string, any> {\n\t\treturn {};\n\t}\n\n\treadonly isOffline: boolean = false;\n}\n", "import { Ticker, TickerClockSource } from \"../clock/Ticker\";\nimport { Seconds } from \"../type/Units\";\nimport { isAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined, isString } from \"../util/TypeCheck\";\nimport {\n\tAnyAudioContext,\n\tcreateAudioContext,\n\tcreateAudioWorkletNode,\n} from \"./AudioContext\";\nimport { closeContext, initializeContext } from \"./ContextInitialization\";\nimport { BaseContext, ContextLatencyHint } from \"./BaseContext\";\nimport { assert } from \"../util/Debug\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Destination = import(\"./Destination\").Destination;\ntype Listener = import(\"./Listener\").Listener;\ntype Draw = import(\"../util/Draw\").Draw;\n\nexport interface ContextOptions {\n\tclockSource: TickerClockSource;\n\tlatencyHint: ContextLatencyHint;\n\tlookAhead: Seconds;\n\tupdateInterval: Seconds;\n\tcontext: AnyAudioContext;\n}\n\nexport interface ContextTimeoutEvent {\n\tcallback: (...args: any[]) => void;\n\tid: number;\n\ttime: Seconds;\n}\n\n/**\n * Wrapper around the native AudioContext.\n * @category Core\n */\nexport class Context extends BaseContext {\n\treadonly name: string = \"Context\";\n\n\t/**\n\t * The amount of time into the future events are scheduled. Giving Web Audio\n\t * a short amount of time into the future to schedule events can reduce clicks and\n\t * improve performance. This value can be set to 0 to get the lowest latency.\n\t */\n\tlookAhead: Seconds;\n\n\t/**\n\t * private reference to the BaseAudioContext\n\t */\n\tprotected readonly _context: AnyAudioContext;\n\n\t/**\n\t * A reliable callback method\n\t */\n\tprivate readonly _ticker: Ticker;\n\n\t/**\n\t * The default latency hint\n\t */\n\tprivate _latencyHint!: ContextLatencyHint | Seconds;\n\n\t/**\n\t * An object containing all of the constants AudioBufferSourceNodes\n\t */\n\tprivate _constants = new Map<number, AudioBufferSourceNode>();\n\n\t/**\n\t * All of the setTimeout events.\n\t */\n\tprivate _timeouts: Timeline<ContextTimeoutEvent> = new Timeline();\n\n\t/**\n\t * The timeout id counter\n\t */\n\tprivate _timeoutIds = 0;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _transport!: Transport;\n\n\t/**\n\t * A reference the Listener singleton belonging to this context\n\t */\n\tprivate _listener!: Listener;\n\n\t/**\n\t * A reference the Destination singleton belonging to this context\n\t */\n\tprivate _destination!: Destination;\n\n\t/**\n\t * A reference the Transport singleton belonging to this context\n\t */\n\tprivate _draw!: Draw;\n\n\t/**\n\t * Private indicator if the context has been initialized\n\t */\n\tprivate _initialized = false;\n\n\t/**\n\t * Indicates if the context is an OfflineAudioContext or an AudioContext\n\t */\n\treadonly isOffline: boolean = false;\n\n\tconstructor(context?: AnyAudioContext);\n\tconstructor(options?: Partial<ContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Context.getDefaults(), arguments, [\n\t\t\t\"context\",\n\t\t]);\n\n\t\tif (options.context) {\n\t\t\tthis._context = options.context;\n\t\t} else {\n\t\t\tthis._context = createAudioContext({\n\t\t\t\tlatencyHint: options.latencyHint,\n\t\t\t});\n\t\t}\n\n\t\tthis._ticker = new Ticker(\n\t\t\tthis.emit.bind(this, \"tick\"),\n\t\t\toptions.clockSource,\n\t\t\toptions.updateInterval\n\t\t);\n\t\tthis.on(\"tick\", this._timeoutLoop.bind(this));\n\n\t\t// fwd events from the context\n\t\tthis._context.onstatechange = () => {\n\t\t\tthis.emit(\"statechange\", this.state);\n\t\t};\n\n\t\tthis._setLatencyHint(options.latencyHint);\n\t\tthis.lookAhead = options.lookAhead;\n\t}\n\n\tstatic getDefaults(): ContextOptions {\n\t\treturn {\n\t\t\tclockSource: \"worker\",\n\t\t\tlatencyHint: \"interactive\",\n\t\t\tlookAhead: 0.1,\n\t\t\tupdateInterval: 0.05,\n\t\t} as ContextOptions;\n\t}\n\n\t/**\n\t * Finish setting up the context. **You usually do not need to do this manually.**\n\t */\n\tprivate initialize(): this {\n\t\tif (!this._initialized) {\n\t\t\t// add any additional modules\n\t\t\tinitializeContext(this);\n\t\t\tthis._initialized = true;\n\t\t}\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn this._context.createAnalyser();\n\t}\n\tcreateOscillator(): OscillatorNode {\n\t\treturn this._context.createOscillator();\n\t}\n\tcreateBufferSource(): AudioBufferSourceNode {\n\t\treturn this._context.createBufferSource();\n\t}\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn this._context.createBiquadFilter();\n\t}\n\tcreateBuffer(\n\t\tnumberOfChannels: number,\n\t\tlength: number,\n\t\tsampleRate: number\n\t): AudioBuffer {\n\t\treturn this._context.createBuffer(numberOfChannels, length, sampleRate);\n\t}\n\tcreateChannelMerger(\n\t\tnumberOfInputs?: number | undefined\n\t): ChannelMergerNode {\n\t\treturn this._context.createChannelMerger(numberOfInputs);\n\t}\n\tcreateChannelSplitter(\n\t\tnumberOfOutputs?: number | undefined\n\t): ChannelSplitterNode {\n\t\treturn this._context.createChannelSplitter(numberOfOutputs);\n\t}\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn this._context.createConstantSource();\n\t}\n\tcreateConvolver(): ConvolverNode {\n\t\treturn this._context.createConvolver();\n\t}\n\tcreateDelay(maxDelayTime?: number | undefined): DelayNode {\n\t\treturn this._context.createDelay(maxDelayTime);\n\t}\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn this._context.createDynamicsCompressor();\n\t}\n\tcreateGain(): GainNode {\n\t\treturn this._context.createGain();\n\t}\n\tcreateIIRFilter(\n\t\tfeedForward: number[] | Float32Array,\n\t\tfeedback: number[] | Float32Array\n\t): IIRFilterNode {\n\t\t// @ts-ignore\n\t\treturn this._context.createIIRFilter(feedForward, feedback);\n\t}\n\tcreatePanner(): PannerNode {\n\t\treturn this._context.createPanner();\n\t}\n\tcreatePeriodicWave(\n\t\treal: number[] | Float32Array,\n\t\timag: number[] | Float32Array,\n\t\tconstraints?: PeriodicWaveConstraints | undefined\n\t): PeriodicWave {\n\t\treturn this._context.createPeriodicWave(real, imag, constraints);\n\t}\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn this._context.createStereoPanner();\n\t}\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn this._context.createWaveShaper();\n\t}\n\tcreateMediaStreamSource(stream: MediaStream): MediaStreamAudioSourceNode {\n\t\tassert(\n\t\t\tisAudioContext(this._context),\n\t\t\t\"Not available if OfflineAudioContext\"\n\t\t);\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaStreamSource(stream);\n\t}\n\tcreateMediaElementSource(\n\t\telement: HTMLMediaElement\n\t): MediaElementAudioSourceNode {\n\t\tassert(\n\t\t\tisAudioContext(this._context),\n\t\t\t\"Not available if OfflineAudioContext\"\n\t\t);\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaElementSource(element);\n\t}\n\tcreateMediaStreamDestination(): MediaStreamAudioDestinationNode {\n\t\tassert(\n\t\t\tisAudioContext(this._context),\n\t\t\t\"Not available if OfflineAudioContext\"\n\t\t);\n\t\tconst context = this._context as AudioContext;\n\t\treturn context.createMediaStreamDestination();\n\t}\n\tdecodeAudioData(audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn this._context.decodeAudioData(audioData);\n\t}\n\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget state(): AudioContextState {\n\t\treturn this._context.state;\n\t}\n\t/**\n\t * The current time in seconds of the AudioContext.\n\t */\n\tget sampleRate(): number {\n\t\treturn this._context.sampleRate;\n\t}\n\n\t/**\n\t * The listener\n\t */\n\tget listener(): Listener {\n\t\tthis.initialize();\n\t\treturn this._listener;\n\t}\n\tset listener(l) {\n\t\tassert(\n\t\t\t!this._initialized,\n\t\t\t\"The listener cannot be set after initialization.\"\n\t\t);\n\t\tthis._listener = l;\n\t}\n\n\t/**\n\t * There is only one Transport per Context. It is created on initialization.\n\t */\n\tget transport(): Transport {\n\t\tthis.initialize();\n\t\treturn this._transport;\n\t}\n\tset transport(t: Transport) {\n\t\tassert(\n\t\t\t!this._initialized,\n\t\t\t\"The transport cannot be set after initialization.\"\n\t\t);\n\t\tthis._transport = t;\n\t}\n\n\t/**\n\t * This is the Draw object for the context which is useful for synchronizing the draw frame with the Tone.js clock.\n\t */\n\tget draw(): Draw {\n\t\tthis.initialize();\n\t\treturn this._draw;\n\t}\n\tset draw(d) {\n\t\tassert(!this._initialized, \"Draw cannot be set after initialization.\");\n\t\tthis._draw = d;\n\t}\n\n\t/**\n\t * A reference to the Context's destination node.\n\t */\n\tget destination(): Destination {\n\t\tthis.initialize();\n\t\treturn this._destination;\n\t}\n\tset destination(d: Destination) {\n\t\tassert(\n\t\t\t!this._initialized,\n\t\t\t\"The destination cannot be set after initialization.\"\n\t\t);\n\t\tthis._destination = d;\n\t}\n\n\t//--------------------------------------------\n\t// AUDIO WORKLET\n\t//--------------------------------------------\n\n\t/**\n\t * Maps a module name to promise of the addModule method\n\t */\n\tprivate _workletModules: Map<string, Promise<void>> = new Map();\n\n\t/**\n\t * Create an audio worklet node from a name and options. The module\n\t * must first be loaded using [[addAudioWorkletModule]].\n\t */\n\tcreateAudioWorkletNode(\n\t\tname: string,\n\t\toptions?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn createAudioWorkletNode(this.rawContext, name, options);\n\t}\n\n\t/**\n\t * Add an AudioWorkletProcessor module\n\t * @param url The url of the module\n\t * @param name The name of the module\n\t */\n\tasync addAudioWorkletModule(url: string, name: string): Promise<void> {\n\t\tassert(\n\t\t\tisDefined(this.rawContext.audioWorklet),\n\t\t\t\"AudioWorkletNode is only available in a secure context (https or localhost)\"\n\t\t);\n\t\tif (!this._workletModules.has(name)) {\n\t\t\tthis._workletModules.set(\n\t\t\t\tname,\n\t\t\t\tthis.rawContext.audioWorklet.addModule(url)\n\t\t\t);\n\t\t}\n\t\tawait this._workletModules.get(name);\n\t}\n\n\t/**\n\t * Returns a promise which resolves when all of the worklets have been loaded on this context\n\t */\n\tprotected async workletsAreReady(): Promise<void> {\n\t\tconst promises: Promise<void>[] = [];\n\t\tthis._workletModules.forEach((promise) => promises.push(promise));\n\t\tawait Promise.all(promises);\n\t}\n\n\t//---------------------------\n\t// TICKER\n\t//---------------------------\n\n\t/**\n\t * How often the interval callback is invoked.\n\t * This number corresponds to how responsive the scheduling\n\t * can be. context.updateInterval + context.lookAhead gives you the\n\t * total latency between scheduling an event and hearing it.\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._ticker.updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._ticker.updateInterval = interval;\n\t}\n\n\t/**\n\t * What the source of the clock is, either \"worker\" (default),\n\t * \"timeout\", or \"offline\" (none).\n\t */\n\tget clockSource(): TickerClockSource {\n\t\treturn this._ticker.type;\n\t}\n\tset clockSource(type: TickerClockSource) {\n\t\tthis._ticker.type = type;\n\t}\n\n\t/**\n\t * The type of playback, which affects tradeoffs between audio\n\t * output latency and responsiveness.\n\t * In addition to setting the value in seconds, the latencyHint also\n\t * accepts the strings \"interactive\" (prioritizes low latency),\n\t * \"playback\" (prioritizes sustained playback), \"balanced\" (balances\n\t * latency and performance).\n\t * @example\n\t * // prioritize sustained playback\n\t * const context = new Tone.Context({ latencyHint: \"playback\" });\n\t * // set this context as the global Context\n\t * Tone.setContext(context);\n\t * // the global context is gettable with Tone.getContext()\n\t * console.log(Tone.getContext().latencyHint);\n\t */\n\tget latencyHint(): ContextLatencyHint | Seconds {\n\t\treturn this._latencyHint;\n\t}\n\n\t/**\n\t * Update the lookAhead and updateInterval based on the latencyHint\n\t */\n\tprivate _setLatencyHint(hint: ContextLatencyHint | Seconds): void {\n\t\tlet lookAheadValue = 0;\n\t\tthis._latencyHint = hint;\n\t\tif (isString(hint)) {\n\t\t\tswitch (hint) {\n\t\t\t\tcase \"interactive\":\n\t\t\t\t\tlookAheadValue = 0.1;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"playback\":\n\t\t\t\t\tlookAheadValue = 0.5;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"balanced\":\n\t\t\t\t\tlookAheadValue = 0.25;\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tthis.lookAhead = lookAheadValue;\n\t\tthis.updateInterval = lookAheadValue / 2;\n\t}\n\n\t/**\n\t * The unwrapped AudioContext or OfflineAudioContext\n\t */\n\tget rawContext(): AnyAudioContext {\n\t\treturn this._context;\n\t}\n\n\t/**\n\t * The current audio context time plus a short [[lookAhead]].\n\t */\n\tnow(): Seconds {\n\t\treturn this._context.currentTime + this.lookAhead;\n\t}\n\n\t/**\n\t * The current audio context time without the [[lookAhead]].\n\t * In most cases it is better to use [[now]] instead of [[immediate]] since\n\t * with [[now]] the [[lookAhead]] is applied equally to _all_ components including internal components,\n\t * to making sure that everything is scheduled in sync. Mixing [[now]] and [[immediate]]\n\t * can cause some timing issues. If no lookAhead is desired, you can set the [[lookAhead]] to `0`.\n\t */\n\timmediate(): Seconds {\n\t\treturn this._context.currentTime;\n\t}\n\n\t/**\n\t * Starts the audio context from a suspended state. This is required\n\t * to initially start the AudioContext. See [[Tone.start]]\n\t */\n\tresume(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\treturn this._context.resume();\n\t\t} else {\n\t\t\treturn Promise.resolve();\n\t\t}\n\t}\n\n\t/**\n\t * Close the context. Once closed, the context can no longer be used and\n\t * any AudioNodes created from the context will be silent.\n\t */\n\tasync close(): Promise<void> {\n\t\tif (isAudioContext(this._context)) {\n\t\t\tawait this._context.close();\n\t\t}\n\t\tif (this._initialized) {\n\t\t\tcloseContext(this);\n\t\t}\n\t}\n\n\t/**\n\t * **Internal** Generate a looped buffer at some constant value.\n\t */\n\tgetConstant(val: number): AudioBufferSourceNode {\n\t\tif (this._constants.has(val)) {\n\t\t\treturn this._constants.get(val) as AudioBufferSourceNode;\n\t\t} else {\n\t\t\tconst buffer = this._context.createBuffer(\n\t\t\t\t1,\n\t\t\t\t128,\n\t\t\t\tthis._context.sampleRate\n\t\t\t);\n\t\t\tconst arr = buffer.getChannelData(0);\n\t\t\tfor (let i = 0; i < arr.length; i++) {\n\t\t\t\tarr[i] = val;\n\t\t\t}\n\t\t\tconst constant = this._context.createBufferSource();\n\t\t\tconstant.channelCount = 1;\n\t\t\tconstant.channelCountMode = \"explicit\";\n\t\t\tconstant.buffer = buffer;\n\t\t\tconstant.loop = true;\n\t\t\tconstant.start(0);\n\t\t\tthis._constants.set(val, constant);\n\t\t\treturn constant;\n\t\t}\n\t}\n\n\t/**\n\t * Clean up. Also closes the audio context.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._ticker.dispose();\n\t\tthis._timeouts.dispose();\n\t\tObject.keys(this._constants).map((val) =>\n\t\t\tthis._constants[val].disconnect()\n\t\t);\n\t\treturn this;\n\t}\n\n\t//---------------------------\n\t// TIMEOUTS\n\t//---------------------------\n\n\t/**\n\t * The private loop which keeps track of the context scheduled timeouts\n\t * Is invoked from the clock source\n\t */\n\tprivate _timeoutLoop(): void {\n\t\tconst now = this.now();\n\t\tlet firstEvent = this._timeouts.peek();\n\t\twhile (this._timeouts.length && firstEvent && firstEvent.time <= now) {\n\t\t\t// invoke the callback\n\t\t\tfirstEvent.callback();\n\t\t\t// shift the first event off\n\t\t\tthis._timeouts.shift();\n\t\t\t// get the next one\n\t\t\tfirstEvent = this._timeouts.peek();\n\t\t}\n\t}\n\n\t/**\n\t * A setTimeout which is guaranteed by the clock source.\n\t * Also runs in the offline context.\n\t * @param  fn       The callback to invoke\n\t * @param  timeout  The timeout in seconds\n\t * @returns ID to use when invoking Context.clearTimeout\n\t */\n\tsetTimeout(fn: (...args: any[]) => void, timeout: Seconds): number {\n\t\tthis._timeoutIds++;\n\t\tconst now = this.now();\n\t\tthis._timeouts.add({\n\t\t\tcallback: fn,\n\t\t\tid: this._timeoutIds,\n\t\t\ttime: now + timeout,\n\t\t});\n\t\treturn this._timeoutIds;\n\t}\n\n\t/**\n\t * Clears a previously scheduled timeout with Tone.context.setTimeout\n\t * @param  id  The ID returned from setTimeout\n\t */\n\tclearTimeout(id: number): this {\n\t\tthis._timeouts.forEach((event) => {\n\t\t\tif (event.id === id) {\n\t\t\t\tthis._timeouts.remove(event);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clear the function scheduled by [[setInterval]]\n\t */\n\tclearInterval(id: number): this {\n\t\treturn this.clearTimeout(id);\n\t}\n\n\t/**\n\t * Adds a repeating event to the context's callback clock\n\t */\n\tsetInterval(fn: (...args: any[]) => void, interval: Seconds): number {\n\t\tconst id = ++this._timeoutIds;\n\t\tconst intervalFn = () => {\n\t\t\tconst now = this.now();\n\t\t\tthis._timeouts.add({\n\t\t\t\tcallback: () => {\n\t\t\t\t\t// invoke the callback\n\t\t\t\t\tfn();\n\t\t\t\t\t// invoke the event to repeat it\n\t\t\t\t\tintervalFn();\n\t\t\t\t},\n\t\t\t\tid,\n\t\t\t\ttime: now + interval,\n\t\t\t});\n\t\t};\n\t\t// kick it off\n\t\tintervalFn();\n\t\treturn id;\n\t}\n}\n", "import { BaseContext } from \"./BaseContext\";\nimport { Seconds } from \"../type/Units\";\nimport { AnyAudioContext } from \"./AudioContext\";\n\ntype Draw = import(\"../util/Draw\").Draw;\ntype Destination = import(\"./Destination\").Destination;\ntype Transport = import(\"../clock/Transport\").Transport;\ntype Listener = import(\"./Listener\").Listener;\n\nexport class DummyContext extends BaseContext {\n\t//---------------------------\n\t// BASE AUDIO CONTEXT METHODS\n\t//---------------------------\n\tcreateAnalyser(): AnalyserNode {\n\t\treturn {} as AnalyserNode;\n\t}\n\n\tcreateOscillator(): OscillatorNode {\n\t\treturn {} as OscillatorNode;\n\t}\n\n\tcreateBufferSource() {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tcreateBiquadFilter(): BiquadFilterNode {\n\t\treturn {} as BiquadFilterNode;\n\t}\n\n\tcreateBuffer(\n\t\t_numberOfChannels: number,\n\t\t_length: number,\n\t\t_sampleRate: number\n\t): AudioBuffer {\n\t\treturn {} as AudioBuffer;\n\t}\n\n\tcreateChannelMerger(\n\t\t_numberOfInputs?: number | undefined\n\t): ChannelMergerNode {\n\t\treturn {} as ChannelMergerNode;\n\t}\n\n\tcreateChannelSplitter(\n\t\t_numberOfOutputs?: number | undefined\n\t): ChannelSplitterNode {\n\t\treturn {} as ChannelSplitterNode;\n\t}\n\n\tcreateConstantSource(): ConstantSourceNode {\n\t\treturn {} as ConstantSourceNode;\n\t}\n\n\tcreateConvolver(): ConvolverNode {\n\t\treturn {} as ConvolverNode;\n\t}\n\n\tcreateDelay(_maxDelayTime?: number | undefined): DelayNode {\n\t\treturn {} as DelayNode;\n\t}\n\n\tcreateDynamicsCompressor(): DynamicsCompressorNode {\n\t\treturn {} as DynamicsCompressorNode;\n\t}\n\n\tcreateGain(): GainNode {\n\t\treturn {} as GainNode;\n\t}\n\n\tcreateIIRFilter(\n\t\t_feedForward: number[] | Float32Array,\n\t\t_feedback: number[] | Float32Array\n\t): IIRFilterNode {\n\t\treturn {} as IIRFilterNode;\n\t}\n\n\tcreatePanner(): PannerNode {\n\t\treturn {} as PannerNode;\n\t}\n\n\tcreatePeriodicWave(\n\t\t_real: number[] | Float32Array,\n\t\t_imag: number[] | Float32Array,\n\t\t_constraints?: PeriodicWaveConstraints | undefined\n\t): PeriodicWave {\n\t\treturn {} as PeriodicWave;\n\t}\n\n\tcreateStereoPanner(): StereoPannerNode {\n\t\treturn {} as StereoPannerNode;\n\t}\n\n\tcreateWaveShaper(): WaveShaperNode {\n\t\treturn {} as WaveShaperNode;\n\t}\n\n\tcreateMediaStreamSource(_stream: MediaStream): MediaStreamAudioSourceNode {\n\t\treturn {} as MediaStreamAudioSourceNode;\n\t}\n\n\tcreateMediaElementSource(\n\t\t_element: HTMLMediaElement\n\t): MediaElementAudioSourceNode {\n\t\treturn {} as MediaElementAudioSourceNode;\n\t}\n\n\tcreateMediaStreamDestination(): MediaStreamAudioDestinationNode {\n\t\treturn {} as MediaStreamAudioDestinationNode;\n\t}\n\n\tdecodeAudioData(_audioData: ArrayBuffer): Promise<AudioBuffer> {\n\t\treturn Promise.resolve({} as AudioBuffer);\n\t}\n\n\t//---------------------------\n\t// TONE AUDIO CONTEXT METHODS\n\t//---------------------------\n\n\tcreateAudioWorkletNode(\n\t\t_name: string,\n\t\t_options?: Partial<AudioWorkletNodeOptions>\n\t): AudioWorkletNode {\n\t\treturn {} as AudioWorkletNode;\n\t}\n\n\tget rawContext(): AnyAudioContext {\n\t\treturn {} as AnyAudioContext;\n\t}\n\n\tasync addAudioWorkletModule(_url: string, _name: string): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tlookAhead = 0;\n\n\tlatencyHint = 0;\n\n\tresume(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n\n\tsetTimeout(_fn: (...args: any[]) => void, _timeout: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearTimeout(_id: number): this {\n\t\treturn this;\n\t}\n\n\tsetInterval(_fn: (...args: any[]) => void, _interval: Seconds): number {\n\t\treturn 0;\n\t}\n\n\tclearInterval(_id: number): this {\n\t\treturn this;\n\t}\n\n\tgetConstant(_val: number): AudioBufferSourceNode {\n\t\treturn {} as AudioBufferSourceNode;\n\t}\n\n\tget currentTime(): Seconds {\n\t\treturn 0;\n\t}\n\n\tget state(): AudioContextState {\n\t\treturn {} as AudioContextState;\n\t}\n\n\tget sampleRate(): number {\n\t\treturn 0;\n\t}\n\n\tget listener(): Listener {\n\t\treturn {} as Listener;\n\t}\n\n\tget transport(): Transport {\n\t\treturn {} as Transport;\n\t}\n\n\tget draw(): Draw {\n\t\treturn {} as Draw;\n\t}\n\tset draw(_d) {}\n\n\tget destination(): Destination {\n\t\treturn {} as Destination;\n\t}\n\tset destination(_d: Destination) {}\n\n\tnow() {\n\t\treturn 0;\n\t}\n\n\timmediate() {\n\t\treturn 0;\n\t}\n\n\treadonly isOffline: boolean = false;\n}\n", "import { isArray } from \"./TypeCheck\";\n\n// return an interface which excludes certain keys\nexport type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;\n\n/**\n * Make the property not writable using `defineProperty`. Internal use only.\n */\nexport function readOnly(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => readOnly(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\tenumerable: true,\n\t\t\twritable: false,\n\t\t});\n\t}\n}\n\n/**\n * Make an attribute writeable. Internal use only.\n */\nexport function writable(target: object, property: string | string[]): void {\n\tif (isArray(property)) {\n\t\tproperty.forEach(str => writable(target, str));\n\t} else {\n\t\tObject.defineProperty(target, property, {\n\t\t\twritable: true,\n\t\t});\n\t}\n}\n\nexport const noOp: (...args: any[]) => any = () => {\n\t// no operation here!\n};\n\n/**\n * Recursive Partial taken from here: https://stackoverflow.com/a/51365037\n */\nexport type RecursivePartial<T> = {\n\t[P in keyof T]?:\n\tT[P] extends Array<infer U> ? Array<RecursivePartial<U>> :\n\t\tT[P] extends object ? RecursivePartial<T[P]> :\n\t\t\tT[P];\n};\n", "import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst doneLoading: Promise<void> = ToneAudioBuffer.load(url).then(audioBuffer => {\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t});\n\t\tToneAudioBuffer.downloads.push(doneLoading);\n\t\ttry {\n\t\t\tawait doneLoading;\n\t\t} finally {\n\t\t\t// remove the downloaded file\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tassert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<void>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\t// make sure there is a slash between the baseUrl and the url\n\t\tconst baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n\t\tconst response = await fetch(baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\t// this makes sure that the function is always async\n\t\tawait Promise.resolve();\n\t\twhile (ToneAudioBuffer.downloads.length) {\n\t\t\tawait ToneAudioBuffer.downloads[0];\n\t\t}\n\t}\n}\n", "import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, \n\t\tsampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n", "import { version } from \"../version\";\nimport { AnyAudioContext, hasAudioContext, theWindow } from \"./context/AudioContext\";\nimport { Context } from \"./context/Context\";\nimport { DummyContext } from \"./context/DummyContext\";\nimport { BaseContext } from \"./context/BaseContext\";\nimport { OfflineContext } from \"./context/OfflineContext\";\nimport { isAudioContext, isOfflineAudioContext } from \"./util/AdvancedTypeCheck\";\n\n/**\n * This dummy context is used to avoid throwing immediate errors when importing in Node.js\n */\nconst dummyContext = new DummyContext();\n\n/**\n * The global audio context which is getable and assignable through\n * getContext and setContext\n */\nlet globalContext: BaseContext = dummyContext;\n\n/**\n * Returns the default system-wide [[Context]]\n * @category Core\n */\nexport function getContext(): BaseContext {\n\tif (globalContext === dummyContext && hasAudioContext) {\n\t\tsetContext(new Context());\n\t}\n\treturn globalContext;\n}\n\n/**\n * Set the default audio context\n * @category Core\n */\nexport function setContext(context: BaseContext | AnyAudioContext): void {\n\tif (isAudioContext(context)) {\n\t\tglobalContext = new Context(context);\n\t} else if (isOfflineAudioContext(context)) {\n\t\tglobalContext = new OfflineContext(context);\n\t} else {\n\t\tglobalContext = context;\n\t}\n}\n\n/**\n * Most browsers will not play _any_ audio until a user\n * clicks something (like a play button). Invoke this method\n * on a click or keypress event handler to start the audio context.\n * More about the Autoplay policy\n * [here](https://developers.google.com/web/updates/2017/09/autoplay-policy-changes#webaudio)\n * @example\n * document.querySelector(\"button\").addEventListener(\"click\", async () => {\n * \tawait Tone.start();\n * \tconsole.log(\"context started\");\n * });\n * @category Core\n */\nexport function start(): Promise<void> {\n\treturn globalContext.resume();\n}\n\n/**\n * Log Tone.js + version in the console.\n */\nif (theWindow && !theWindow.TONE_SILENCE_LOGGING) {\n\tlet prefix = \"v\";\n\tif (version === \"dev\") {\n\t\tprefix = \"\";\n\t}\n\tconst printString = ` * Tone.js ${prefix}${version} * `;\n\t// eslint-disable-next-line no-console\n\tconsole.log(`%c${printString}`, \"background: #000; color: #fff\");\n}\n", "import { Decibels, GainFactor, Hertz, Interval, MidiNote, NormalRange } from \"./Units\";\n\n/**\n * Equal power gain scale. Good for cross-fading.\n * @param  percent (0-1)\n */\nexport function equalPowerScale(percent: NormalRange): number {\n\tconst piFactor = 0.5 * Math.PI;\n\treturn Math.sin(percent * piFactor);\n}\n\n/**\n * Convert decibels into gain.\n */\nexport function dbToGain(db: Decibels): GainFactor {\n\treturn Math.pow(10, db / 20);\n}\n\n/**\n * Convert gain to decibels.\n */\nexport function gainToDb(gain: GainFactor): Decibels {\n\treturn 20 * (Math.log(gain) / Math.LN10);\n}\n\n/**\n * Convert an interval (in semitones) to a frequency ratio.\n * @param interval the number of semitones above the base note\n * @example\n * Tone.intervalToFrequencyRatio(0); // 1\n * Tone.intervalToFrequencyRatio(12); // 2\n * Tone.intervalToFrequencyRatio(-12); // 0.5\n */\nexport function intervalToFrequencyRatio(interval: Interval): number {\n\treturn Math.pow(2, (interval / 12));\n}\n\n/**\n * The Global [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n * to generate all the other pitch values from notes. A4's values in Hertz.\n */\nlet A4: Hertz = 440;\n\nexport function getA4(): Hertz {\n\treturn A4;\n}\n\nexport function setA4(freq: Hertz): void {\n\tA4 = freq;\n}\n\n/**\n * Convert a frequency value to a MIDI note.\n * @param frequency The value to frequency value to convert.\n * @example\n * Tone.ftom(440); // returns 69\n */\nexport function ftom(frequency: Hertz): MidiNote {\n\treturn Math.round(ftomf(frequency)) as MidiNote;\n}\n\n/**\n * Convert a frequency to a floating point midi value\n */\nexport function ftomf(frequency: Hertz): number {\n\treturn 69 + 12 * Math.log2(frequency / A4);\n}\n\n/**\n * Convert a MIDI note to frequency value.\n * @param  midi The midi number to convert.\n * @return The corresponding frequency value\n * @example\n * Tone.mtof(69); // 440\n */\nexport function mtof(midi: MidiNote): Hertz {\n\treturn A4 * Math.pow(2, (midi - 69) / 12);\n}\n", "import { BaseContext } from \"../context/BaseContext\";\nimport { Tone } from \"../Tone\";\nimport { isDefined, isObject, isString, isUndef } from \"../util/TypeCheck\";\nimport { BPM, Hertz, MidiNote, Milliseconds, Samples, Seconds, Ticks, Time } from \"./Units\";\n\nexport type TimeValue = Time | TimeBaseClass<any, any>;\n\n/**\n * The units that the TimeBase can accept. extended by other classes\n */\nexport type TimeBaseUnit = \"s\" | \"n\" | \"t\" | \"m\" | \"i\" | \"hz\" | \"tr\" | \"samples\" | \"number\";\n\nexport interface TypeFunction {\n\tregexp: RegExp;\n\tmethod: (value: string, ...args: string[]) => number;\n}\n\nexport interface TimeExpression<Type extends number> {\n\t[key: string]: {\n\t\tregexp: RegExp;\n\t\tmethod: (value: string, ...args: string[]) => Type;\n\t};\n}\n\n/**\n * TimeBase is a flexible encoding of time which can be evaluated to and from a string.\n */\nexport abstract class TimeBaseClass<Type extends number, Unit extends string> extends Tone {\n\n\treadonly context: BaseContext;\n\n\t/**\n\t * The value of the units\n\t */\n\tprotected _val?: TimeValue;\n\n\t/**\n\t * The units of time\n\t */\n\tprotected _units?: Unit;\n\n\t/**\n\t * All of the conversion expressions\n\t */\n\tprotected _expressions: TimeExpression<Type>;\n\n\t/**\n\t * The default units\n\t */\n\treadonly defaultUnits: Unit = \"s\" as Unit;\n\n\t/**\n\t * @param context The context associated with the time value. Used to compute\n\t * Transport and context-relative timing.\n\t * @param  value  The time value as a number, string or object\n\t * @param  units  Unit values\n\t */\n\tconstructor(context: BaseContext, value?: TimeValue, units?: Unit) {\n\t\tsuper();\n\n\t\tthis._val = value;\n\t\tthis._units = units;\n\t\tthis.context = context;\n\t\tthis._expressions = this._getExpressions();\n\t}\n\n\t/**\n\t * All of the time encoding expressions\n\t */\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn {\n\t\t\thz: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._frequencyToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)hz$/i,\n\t\t\t},\n\t\t\ti: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._ticksToUnits(parseInt(value, 10));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)i$/i,\n\t\t\t},\n\t\t\tm: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._beatsToUnits(parseInt(value, 10) * this._getTimeSignature());\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)m$/i,\n\t\t\t},\n\t\t\tn: {\n\t\t\t\tmethod: (value, dot) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\tconst scalar = dot === \".\" ? 1.5 : 1;\n\t\t\t\t\tif (numericValue === 1) {\n\t\t\t\t\t\treturn this._beatsToUnits(this._getTimeSignature()) * scalar as Type;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn this._beatsToUnits(4 / numericValue) * scalar as Type;\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)n(\\.?)$/i,\n\t\t\t},\n\t\t\tnumber: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn this._expressions[this.defaultUnits].method.call(this, value);\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)$/,\n\t\t\t},\n\t\t\ts: {\n\t\t\t\tmethod: (value): Type => {\n\t\t\t\t\treturn this._secondsToUnits(parseFloat(value));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?)s$/,\n\t\t\t},\n\t\t\tsamples: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\treturn parseInt(value, 10) / this.context.sampleRate as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)samples$/,\n\t\t\t},\n\t\t\tt: {\n\t\t\t\tmethod: (value) => {\n\t\t\t\t\tconst numericValue = parseInt(value, 10);\n\t\t\t\t\treturn this._beatsToUnits(8 / (Math.floor(numericValue) * 3));\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+)t$/i,\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tmethod: (m, q, s) => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal += this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?$/,\n\t\t\t},\n\t\t};\n\t}\n\n\t//-------------------------------------\n\t// \tVALUE OF\n\t//-------------------------------------\n\n\t/**\n\t * Evaluate the time value. Returns the time in seconds.\n\t */\n\tvalueOf(): Type {\n\t\tif (this._val instanceof TimeBaseClass) {\n\t\t\tthis.fromType(this._val);\n\t\t}\n\t\tif (isUndef(this._val)) {\n\t\t\treturn this._noArg();\n\t\t} else if (isString(this._val) && isUndef(this._units)) {\n\t\t\tfor (const units in this._expressions) {\n\t\t\t\tif (this._expressions[units].regexp.test(this._val.trim())) {\n\t\t\t\t\tthis._units = units as Unit;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else if (isObject(this._val)) {\n\t\t\tlet total = 0;\n\t\t\tfor (const typeName in this._val) {\n\t\t\t\tif (isDefined(this._val[typeName])) {\n\t\t\t\t\tconst quantity = this._val[typeName];\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\tconst time = (new this.constructor(this.context, typeName)).valueOf() * quantity;\n\t\t\t\t\ttotal += time;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn total as Type;\n\t\t}\n\t\tif (isDefined(this._units)) {\n\t\t\tconst expr = this._expressions[this._units];\n\t\t\tconst matching = this._val.toString().trim().match(expr.regexp);\n\t\t\tif (matching) {\n\t\t\t\treturn expr.method.apply(this, matching.slice(1));\n\t\t\t} else {\n\t\t\t\treturn expr.method.call(this, this._val);\n\t\t\t}\n\t\t} else if (isString(this._val)) {\n\t\t\treturn parseFloat(this._val) as Type;\n\t\t} else {\n\t\t\treturn this._val as Type;\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn 1 / freq as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn (60 / this._getBpm()) * beats as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn seconds as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn (ticks * (this._beatsToUnits(1)) / this._getPPQ()) as Type;\n\t}\n\n\t/**\n\t * With no arguments, return 'now'\n\t */\n\tprotected _noArg(): Type {\n\t\treturn this._now();\n\t}\n\n\t//-------------------------------------\n\t// \tTEMPO CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the bpm\n\t */\n\tprotected _getBpm(): BPM {\n\t\treturn this.context.transport.bpm.value;\n\t}\n\n\t/**\n\t * Return the timeSignature\n\t */\n\tprotected _getTimeSignature(): number {\n\t\treturn this.context.transport.timeSignature as number;\n\t}\n\n\t/**\n\t * Return the PPQ or 192 if Transport is not available\n\t */\n\tprotected _getPPQ(): number {\n\t\treturn this.context.transport.PPQ;\n\t}\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected abstract _now(): Type;\n\n\t//-------------------------------------\n\t// \tCONVERSION INTERFACE\n\t//-------------------------------------\n\n\t/**\n\t * Coerce a time type into this units type.\n\t * @param type Any time type units\n\t */\n\tfromType(type: TimeBaseClass<any, any>): this {\n\t\tthis._units = undefined;\n\t\tswitch (this.defaultUnits) {\n\t\t\tcase \"s\":\n\t\t\t\tthis._val = type.toSeconds();\n\t\t\t\tbreak;\n\t\t\tcase \"i\":\n\t\t\t\tthis._val = type.toTicks();\n\t\t\t\tbreak;\n\t\t\tcase \"hz\":\n\t\t\t\tthis._val = type.toFrequency();\n\t\t\t\tbreak;\n\t\t\tcase \"midi\":\n\t\t\t\tthis._val = type.toMidi();\n\t\t\t\tbreak;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the value in seconds\n\t */\n\tabstract toSeconds(): Seconds;\n\n\t/**\n\t * Return the value as a Midi note\n\t */\n\tabstract toMidi(): MidiNote;\n\n\t/**\n\t * Convert the value into ticks\n\t */\n\tabstract toTicks(): Ticks;\n\n\t/**\n\t * Return the value in hertz\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn 1 / this.toSeconds();\n\t}\n\n\t/**\n\t * Return the time in samples\n\t */\n\ttoSamples(): Samples {\n\t\treturn this.toSeconds() * this.context.sampleRate;\n\t}\n\n\t/**\n\t * Return the time in milliseconds.\n\t */\n\ttoMilliseconds(): Milliseconds {\n\t\treturn this.toSeconds() * 1000;\n\t}\n}\n", "import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\n\textends TimeBaseClass<Type, Unit> {\n\n\treadonly name: string = \"TimeClass\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  subdiv    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Tone.Time(21).quantize(2); // returns 22\n\t * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t//-------------------------------------\n\t// CONVERSIONS\n\t//-------------------------------------\n\t/**\n\t * Convert a Time to Notation. The notation values are will be the\n\t * closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * // if the Transport is at 120bpm:\n\t * Tone.Time(2).toNotation(); // returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t * Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t * Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t * Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number. The time is computed against the \n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n", "import { getContext } from \"../Global\";\nimport { intervalToFrequencyRatio, mtof } from \"./Conversions\";\nimport { ftom, getA4, setA4 } from \"./Conversions\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { Frequency, Hertz, Interval, MidiNote, Note, Seconds, Ticks } from \"./Units\";\n\nexport type FrequencyUnit = TimeBaseUnit | \"midi\";\n\n/**\n * Frequency is a primitive type for encoding Frequency values.\n * Eventually all time values are evaluated to hertz using the `valueOf` method.\n * @example\n * Tone.Frequency(\"C3\"); // 261\n * Tone.Frequency(38, \"midi\");\n * Tone.Frequency(\"C3\").transpose(4);\n * @category Unit\n */\nexport class FrequencyClass<Type extends number = Hertz> extends TimeClass<Type, FrequencyUnit> {\n\n\treadonly name: string = \"Frequency\";\n\n\treadonly defaultUnits: FrequencyUnit = \"hz\";\n\n\t/**\n\t * The [concert tuning pitch](https://en.wikipedia.org/wiki/Concert_pitch) which is used\n\t * to generate all the other pitch values from notes. A4's values in Hertz.\n\t */\n\tstatic get A4(): Hertz {\n\t\treturn getA4();\n\t}\n\tstatic set A4(freq: Hertz) {\n\t\tsetA4(freq);\n\t}\n\n\t//-------------------------------------\n\t// \tAUGMENT BASE EXPRESSIONS\n\t//-------------------------------------\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign({}, super._getExpressions(), {\n\t\t\tmidi: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?midi)/,\n\t\t\t\tmethod(value): number {\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn value;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(value);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\tnote: {\n\t\t\t\tregexp: /^([a-g]{1}(?:b|#|x|bb)?)(-?[0-9]+)/i,\n\t\t\t\tmethod(pitch, octave): number {\n\t\t\t\t\tconst index = noteToScaleIndex[pitch.toLowerCase()];\n\t\t\t\t\tconst noteNumber = index + (parseInt(octave, 10) + 1) * 12;\n\t\t\t\t\tif (this.defaultUnits === \"midi\") {\n\t\t\t\t\t\treturn noteNumber;\n\t\t\t\t\t} else {\n\t\t\t\t\t\treturn FrequencyClass.mtof(noteNumber);\n\t\t\t\t\t}\n\t\t\t\t},\n\t\t\t},\n\t\t\ttr: {\n\t\t\t\tregexp: /^(\\d+(?:\\.\\d+)?):(\\d+(?:\\.\\d+)?):?(\\d+(?:\\.\\d+)?)?/,\n\t\t\t\tmethod(m, q, s): number {\n\t\t\t\t\tlet total = 1;\n\t\t\t\t\tif (m && m !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(this._getTimeSignature() * parseFloat(m));\n\t\t\t\t\t}\n\t\t\t\t\tif (q && q !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(q));\n\t\t\t\t\t}\n\t\t\t\t\tif (s && s !== \"0\") {\n\t\t\t\t\t\ttotal *= this._beatsToUnits(parseFloat(s) / 4);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t},\n\t\t\t},\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tEXPRESSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return  A new transposed frequency\n\t * @example\n\t * Tone.Frequency(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): FrequencyClass {\n\t\treturn new FrequencyClass(this.context, this.valueOf() * intervalToFrequencyRatio(interval));\n\t}\n\n\t/**\n\t * Takes an array of semitone intervals and returns\n\t * an array of frequencies transposed by those intervals.\n\t * @return  Returns an array of Frequencies\n\t * @example\n\t * Tone.Frequency(\"A4\").harmonize([0, 3, 7]); // [\"A4\", \"C5\", \"E5\"]\n\t */\n\tharmonize(intervals: Interval[]): FrequencyClass[] {\n\t\treturn intervals.map(interval => {\n\t\t\treturn this.transpose(interval);\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS\n\t//-------------------------------------\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Frequency(\"C4\").toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.valueOf());\n\t}\n\n\t/**\n\t * Return the value of the frequency in Scientific Pitch Notation\n\t * @example\n\t * Tone.Frequency(69, \"midi\").toNote(); // \"A4\"\n\t */\n\ttoNote(): Note {\n\t\tconst freq = this.toFrequency();\n\t\tconst log = Math.log2(freq / FrequencyClass.A4);\n\t\tlet noteNumber = Math.round(12 * log) + 57;\n\t\tconst octave = Math.floor(noteNumber / 12);\n\t\tif (octave < 0) {\n\t\t\tnoteNumber += -12 * octave;\n\t\t}\n\t\tconst noteName = scaleIndexToNote[noteNumber % 12];\n\t\treturn noteName + octave.toString() as Note;\n\t}\n\n\t/**\n\t * Return the duration of one cycle in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn 1 / super.toSeconds();\n\t}\n\n\t/**\n\t * Return the duration of one cycle in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.floor(quarters * this._getPPQ());\n\t}\n\n\t//-------------------------------------\n\t// \tUNIT CONVERSIONS HELPERS\n\t//-------------------------------------\n\n\t/**\n\t * With no arguments, return 0\n\t */\n\tprotected _noArg(): Type {\n\t\treturn 0 as Type;\n\t}\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): Type {\n\t\treturn freq as Type;\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Type {\n\t\treturn 1 / ((ticks * 60) / (this._getBpm() * this._getPPQ())) as Type;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Type {\n\t\treturn 1 / super._beatsToUnits(beats) as Type;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Type {\n\t\treturn 1 / seconds as Type;\n\t}\n\n\t/**\n\t * Convert a MIDI note to frequency value.\n\t * @param  midi The midi number to convert.\n\t * @return The corresponding frequency value\n\t */\n\tstatic mtof(midi: MidiNote): Hertz {\n\t\treturn mtof(midi);\n\t}\n\n\t/**\n\t * Convert a frequency value to a MIDI note.\n\t * @param frequency The value to frequency value to convert.\n\t */\n\tstatic ftom(frequency: Hertz): MidiNote {\n\t\treturn ftom(frequency);\n\t}\n}\n\n//-------------------------------------\n// \tFREQUENCY CONVERSIONS\n//-------------------------------------\n\n/**\n * Note to scale index. \n * @hidden\n */\nconst noteToScaleIndex = {\n\tcbb: -2, cb: -1, c: 0, \"c#\": 1, cx: 2,\n\tdbb: 0, db: 1, d: 2, \"d#\": 3, dx: 4,\n\tebb: 2, eb: 3, e: 4, \"e#\": 5, ex: 6,\n\tfbb: 3, fb: 4, f: 5, \"f#\": 6, fx: 7,\n\tgbb: 5, gb: 6, g: 7, \"g#\": 8, gx: 9,\n\tabb: 7, ab: 8, a: 9, \"a#\": 10, ax: 11,\n\tbbb: 9, bb: 10, b: 11, \"b#\": 12, bx: 13,\n};\n\n/**\n * scale index to note (sharps)\n * @hidden\n */\nconst scaleIndexToNote = [\"C\", \"C#\", \"D\", \"D#\", \"E\", \"F\", \"F#\", \"G\", \"G#\", \"A\", \"A#\", \"B\"];\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n * @example\n * const midi = Tone.Frequency(\"C3\").toMidi();\n * console.log(midi);\n * @example\n * const hertz = Tone.Frequency(38, \"midi\").toFrequency();\n * console.log(hertz);\n */\nexport function Frequency(value?: TimeValue | Frequency, units?: FrequencyUnit): FrequencyClass {\n\treturn new FrequencyClass(getContext(), value, units);\n}\n", "import { getContext } from \"../Global\";\nimport { Seconds, Ticks } from \"../type/Units\";\nimport { TimeClass } from \"./Time\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to Tone.Time, but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport class TransportTimeClass<Type extends Seconds | Ticks = Seconds> extends TimeClass<Type> {\n\n\treadonly name: string = \"TransportTime\";\n\n\t/**\n\t * Return the current time in whichever context is relevant\n\t */\n\tprotected _now(): Type {\n\t\treturn this.context.transport.seconds as Type;\n\t}\n}\n\n/**\n * TransportTime is a the time along the Transport's\n * timeline. It is similar to [[Time]], but instead of evaluating\n * against the AudioContext's clock, it is evaluated against\n * the Transport's position. See [TransportTime wiki](https://github.com/Tonejs/Tone.js/wiki/TransportTime).\n * @category Unit\n */\nexport function TransportTime(value?: TimeValue, units?: TimeBaseUnit): TransportTimeClass {\n\treturn new TransportTimeClass(getContext(), value, units);\n}\n", "import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { FrequencyClass } from \"../type/Frequency\";\nimport { TimeClass } from \"../type/Time\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { getDefaultsFromInstance, optionsFromArguments } from \"../util/Defaults\";\nimport { RecursivePartial } from \"../util/Interface\";\nimport { isArray, isBoolean, isDefined, isNumber, isString, isUndef } from \"../util/TypeCheck\";\nimport { BaseContext } from \"./BaseContext\";\n\n/**\n * A unit which process audio\n */\nexport interface ToneWithContextOptions {\n\tcontext: BaseContext;\n}\n\n/**\n * The Base class for all nodes that have an AudioContext.\n */\nexport abstract class ToneWithContext<Options extends ToneWithContextOptions> extends Tone {\n\n\t/**\n\t * The context belonging to the node.\n\t */\n\treadonly context: BaseContext;\n\n\t/**\n\t * The default context to use if no AudioContext is passed in to the constructor.\n\t * Probably should not be set manually. Used internally.\n\t * @hidden\n\t */\n\treadonly defaultContext?: BaseContext;\n\n\t/**\n\t * Pass in a constructor as the first argument\n\t */\n\tconstructor(context?: BaseContext)\n\tconstructor(options?: Partial<ToneWithContextOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(ToneWithContext.getDefaults(), arguments, [\"context\"]);\n\t\tif (this.defaultContext) {\n\t\t\tthis.context = this.defaultContext;\n\t\t} else {\n\t\t\tthis.context = options.context;\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneWithContextOptions {\n\t\treturn {\n\t\t\tcontext: getContext(),\n\t\t};\n\t}\n\n\t/**\n\t * Return the current time of the Context clock plus the lookAhead.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(Tone.now());\n\t * }, 100);\n\t */\n\tnow(): Seconds {\n\t\treturn this.context.currentTime + this.context.lookAhead;\n\t}\n\n\t/**\n\t * Return the current time of the Context clock without any lookAhead.\n\t * @example\n\t * setInterval(() => {\n\t * \tconsole.log(Tone.immediate());\n\t * }, 100);\n\t */\n\timmediate(): Seconds {\n\t\treturn this.context.currentTime;\n\t}\n\n\t/**\n\t * The duration in seconds of one sample.\n\t * @example\n\t * console.log(Tone.Transport.sampleTime);\n\t */\n\tget sampleTime(): Seconds {\n\t\treturn 1 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * The number of seconds of 1 processing block (128 samples)\n\t * @example\n\t * console.log(Tone.Destination.blockTime);\n\t */\n\tget blockTime(): Seconds {\n\t\treturn 128 / this.context.sampleRate;\n\t}\n\n\t/**\n\t * Convert the incoming time to seconds. \n\t * This is calculated against the current [[Tone.Transport]] bpm\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * setInterval(() => console.log(gain.toSeconds(\"4n\")), 100);\n\t * // ramp the tempo to 60 bpm over 30 seconds\n\t * Tone.getTransport().bpm.rampTo(60, 30);\n\t */\n\ttoSeconds(time?: Time): Seconds {\n\t\treturn new TimeClass(this.context, time).toSeconds();\n\t}\n\n\t/**\n\t * Convert the input to a frequency number\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toFrequency(\"4n\"));\n\t */\n\ttoFrequency(freq: Frequency): Hertz {\n\t\treturn new FrequencyClass(this.context, freq).toFrequency();\n\t}\n\n\t/**\n\t * Convert the input time into ticks\n\t * @example\n\t * const gain = new Tone.Gain();\n\t * console.log(gain.toTicks(\"4n\"));\n\t */\n\ttoTicks(time?: Time | TimeClass): Ticks {\n\t\treturn new TransportTimeClass(this.context, time).toTicks();\n\t}\n\n\t//-------------------------------------\n\t// \tGET/SET\n\t//-------------------------------------\n\n\t/**\n\t * Get a subset of the properties which are in the partial props\n\t */\n\tprotected _getPartialProperties(props: Options): Partial<Options> {\n\t\tconst options = this.get();\n\t\t// remove attributes from the prop that are not in the partial\n\t\tObject.keys(options).forEach(name => {\n\t\t\tif (isUndef(props[name])) {\n\t\t\t\tdelete options[name];\n\t\t\t}\n\t\t});\n\t\treturn options;\n\t}\n\n\t/**\n\t * Get the object's attributes.\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * console.log(osc.get());\n\t */\n\tget(): Options {\n\t\tconst defaults = getDefaultsFromInstance(this) as Options;\n\t\tObject.keys(defaults).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute)) {\n\t\t\t\tconst member = this[attribute];\n\t\t\t\tif (isDefined(member) && isDefined(member.value) && isDefined(member.setValueAtTime)) {\n\t\t\t\t\tdefaults[attribute] = member.value;\n\t\t\t\t} else if (member instanceof ToneWithContext) {\n\t\t\t\t\tdefaults[attribute] = member._getPartialProperties(defaults[attribute]);\n\t\t\t\t\t// otherwise make sure it's a serializable type\n\t\t\t\t} else if (isArray(member) || isNumber(member) || isString(member) || isBoolean(member)) {\n\t\t\t\t\tdefaults[attribute] = member;\n\t\t\t\t} else {\n\t\t\t\t\t// remove all undefined and unserializable attributes\n\t\t\t\t\tdelete defaults[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\treturn defaults;\n\t}\n\n\t/**\n\t * Set multiple properties at once with an object.\n\t * @example\n\t * const filter = new Tone.Filter().toDestination();\n\t * // set values using an object\n\t * filter.set({\n\t * \tfrequency: \"C6\",\n\t * \ttype: \"highpass\"\n\t * });\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/Analogsynth_octaves_highmid.mp3\").connect(filter);\n\t * player.autostart = true;\n\t */\n\tset(props: RecursivePartial<Options>): this {\n\t\tObject.keys(props).forEach(attribute => {\n\t\t\tif (Reflect.has(this, attribute) && isDefined(this[attribute])) {\n\t\t\t\tif (this[attribute] && isDefined(this[attribute].value) && isDefined(this[attribute].setValueAtTime)) {\n\t\t\t\t\t// small optimization\n\t\t\t\t\tif (this[attribute].value !== props[attribute]) {\n\t\t\t\t\t\tthis[attribute].value = props[attribute];\n\t\t\t\t\t}\n\t\t\t\t} else if (this[attribute] instanceof ToneWithContext) {\n\t\t\t\t\tthis[attribute].set(props[attribute]);\n\t\t\t\t} else {\n\t\t\t\t\tthis[attribute] = props[attribute];\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n}\n", "import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t\tthis.setStateAtTime(this._initial, 0);\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\tassertRange(time, 0);\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n", "import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { Decibels, Frequency, Positive, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n\nexport interface ParamOptions<TypeName extends UnitName> extends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tassert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\t// the value can't be 0\n\t\tnumericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\t\t\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[TypeName], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n", "import { isAudioNode, isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { Param } from \"./Param\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { assert, warn } from \"../util/Debug\";\n\nexport type InputNode = ToneAudioNode | AudioNode | Param<any> | AudioParam;\nexport type OutputNode = ToneAudioNode | AudioNode;\n\ninterface ChannelProperties {\n\tchannelCount: number;\n\tchannelCountMode: ChannelCountMode;\n\tchannelInterpretation: ChannelInterpretation;\n}\n\n/**\n * The possible options for this node\n */\nexport type ToneAudioNodeOptions = ToneWithContextOptions;\n\n/**\n * ToneAudioNode is the base class for classes which process audio.\n */\nexport abstract class ToneAudioNode<Options extends ToneAudioNodeOptions = ToneAudioNodeOptions>\n\textends ToneWithContext<Options> {\n\n\t/**\n\t * The name of the class\n\t */\n\tabstract readonly name: string = \"ToneAudioNode\";\n\n\t/**\n\t * The input node or nodes. If the object is a source,\n\t * it does not have any input and this.input is undefined.\n\t */\n\tabstract input: InputNode | undefined;\n\n\t/**\n\t * The output nodes. If the object is a sink,\n\t * it does not have any output and this.output is undefined.\n\t */\n\tabstract output: OutputNode | undefined;\n\n\t/**\n\t * The number of inputs feeding into the AudioNode.\n\t * For source nodes, this will be 0.\n\t * @example\n\t * const node = new Tone.Gain();\n\t * console.log(node.numberOfInputs);\n\t */\n\tget numberOfInputs(): number {\n\t\tif (isDefined(this.input)) {\n\t\t\tif (isAudioParam(this.input) || this.input instanceof Param) {\n\t\t\t\treturn 1;\n\t\t\t} else {\n\t\t\t\treturn this.input.numberOfInputs;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of outputs of the AudioNode.\n\t * @example\n\t * const node = new Tone.Gain();\n\t * console.log(node.numberOfOutputs);\n\t */\n\tget numberOfOutputs(): number {\n\t\tif (isDefined(this.output)) {\n\t\t\treturn this.output.numberOfOutputs;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * List all of the node that must be set to match the ChannelProperties\n\t */\n\tprotected _internalChannels: OutputNode[] = [];\n\n\t//-------------------------------------\n\t// AUDIO PROPERTIES\n\t//-------------------------------------\n\n\t/**\n\t * Used to decide which nodes to get/set properties on\n\t */\n\tprivate _isAudioNode(node: any): node is AudioNode | ToneAudioNode {\n\t\treturn isDefined(node) && (node instanceof ToneAudioNode || isAudioNode(node));\n\t}\n\n\t/**\n\t * Get all of the audio nodes (either internal or input/output) which together\n\t * make up how the class node responds to channel input/output\n\t */\n\tprivate _getInternalNodes(): OutputNode[] {\n\t\tconst nodeList = this._internalChannels.slice(0);\n\t\tif (this._isAudioNode(this.input)) {\n\t\t\tnodeList.push(this.input);\n\t\t}\n\t\tif (this._isAudioNode(this.output)) {\n\t\t\tif (this.input !== this.output) {\n\t\t\t\tnodeList.push(this.output);\n\t\t\t}\n\t\t}\n\t\treturn nodeList;\n\t}\n\n\t/**\n\t * Set the audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t * @param options\n\t */\n\tprivate _setChannelProperties(options: ChannelProperties): void {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tnodeList.forEach(node => {\n\t\t\tnode.channelCount = options.channelCount;\n\t\t\tnode.channelCountMode = options.channelCountMode;\n\t\t\tnode.channelInterpretation = options.channelInterpretation;\n\t\t});\n\t}\n\n\t/**\n\t * Get the current audio options for this node such as channelInterpretation\n\t * channelCount, etc.\n\t */\n\tprivate _getChannelProperties(): ChannelProperties {\n\t\tconst nodeList = this._getInternalNodes();\n\t\tassert(nodeList.length > 0, \"ToneAudioNode does not have any internal nodes\");\n\t\t// use the first node to get properties\n\t\t// they should all be the same\n\t\tconst node = nodeList[0];\n\t\treturn {\n\t\t\tchannelCount: node.channelCount,\n\t\t\tchannelCountMode: node.channelCountMode,\n\t\t\tchannelInterpretation: node.channelInterpretation,\n\t\t};\n\t}\n\n\t/**\n\t * channelCount is the number of channels used when up-mixing and down-mixing\n\t * connections to any inputs to the node. The default value is 2 except for\n\t * specific nodes where its value is specially determined.\n\t */\n\tget channelCount(): number {\n\t\treturn this._getChannelProperties().channelCount;\n\t}\n\tset channelCount(channelCount) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCount }));\n\t}\n\n\t/**\n\t * channelCountMode determines how channels will be counted when up-mixing and\n\t * down-mixing connections to any inputs to the node.\n\t * The default value is \"max\". This attribute has no effect for nodes with no inputs.\n\t * * \"max\" - computedNumberOfChannels is the maximum of the number of channels of all connections to an input. In this mode channelCount is ignored.\n\t * * \"clamped-max\" - computedNumberOfChannels is determined as for \"max\" and then clamped to a maximum value of the given channelCount.\n\t * * \"explicit\" - computedNumberOfChannels is the exact value as specified by the channelCount.\n\t */\n\tget channelCountMode(): ChannelCountMode {\n\t\treturn this._getChannelProperties().channelCountMode;\n\t}\n\tset channelCountMode(channelCountMode) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelCountMode }));\n\t}\n\n\t/**\n\t * channelInterpretation determines how individual channels will be treated\n\t * when up-mixing and down-mixing connections to any inputs to the node.\n\t * The default value is \"speakers\".\n\t */\n\tget channelInterpretation(): ChannelInterpretation {\n\t\treturn this._getChannelProperties().channelInterpretation;\n\t}\n\tset channelInterpretation(channelInterpretation) {\n\t\tconst props = this._getChannelProperties();\n\t\t// merge it with the other properties\n\t\tthis._setChannelProperties(Object.assign(props, { channelInterpretation }));\n\t}\n\n\t//-------------------------------------\n\t// CONNECTIONS\n\t//-------------------------------------\n\n\t/**\n\t * connect the output of a ToneAudioNode to an AudioParam, AudioNode, or ToneAudioNode\n\t * @param destination The output to connect to\n\t * @param outputNum The output to connect from\n\t * @param inputNum The input to connect to\n\t */\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * @example\n\t * const osc = new Tone.Oscillator(\"C2\").start();\n\t * osc.toDestination();\n\t */\n\ttoDestination(): this {\n\t\tthis.connect(this.context.destination);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output to the context's destination node.\n\t * See [[toDestination]]\n\t * @deprecated\n\t */\n\ttoMaster(): this {\n\t\twarn(\"toMaster() has been renamed toDestination()\");\n\t\treturn this.toDestination();\n\t}\n\n\t/**\n\t * disconnect the output\n\t */\n\tdisconnect(destination?: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tdisconnect(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the output of this node to the rest of the nodes in series.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/handdrum-loop.mp3\");\n\t * player.autostart = true;\n\t * const filter = new Tone.AutoFilter(4).start();\n\t * const distortion = new Tone.Distortion(0.5);\n\t * // connect the player to the filter, distortion and then to the master output\n\t * player.chain(filter, distortion, Tone.Destination);\n\t */\n\tchain(...nodes: InputNode[]): this {\n\t\tconnectSeries(this, ...nodes);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the output of this node to the rest of the nodes in parallel.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/conga-rhythm.mp3\");\n\t * player.autostart = true;\n\t * const pitchShift = new Tone.PitchShift(4).toDestination();\n\t * const filter = new Tone.Filter(\"G5\").toDestination();\n\t * // connect a node to the pitch shift and filter in parallel\n\t * player.fan(pitchShift, filter);\n\t */\n\tfan(...nodes: InputNode[]): this {\n\t\tnodes.forEach(node => this.connect(node));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Dispose and disconnect\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (isDefined(this.input)) {\n\t\t\tif (this.input instanceof ToneAudioNode) {\n\t\t\t\tthis.input.dispose();\n\t\t\t} else if (isAudioNode(this.input)) {\n\t\t\t\tthis.input.disconnect();\n\t\t\t}\n\t\t}\n\t\tif (isDefined(this.output)) {\n\t\t\tif (this.output instanceof ToneAudioNode) {\n\t\t\t\tthis.output.dispose();\n\t\t\t} else if (isAudioNode(this.output)) {\n\t\t\t\tthis.output.disconnect();\n\t\t\t}\n\t\t}\n\t\tthis._internalChannels = [];\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// CONNECTIONS\n//-------------------------------------\n\n/**\n * connect together all of the arguments in series\n * @param nodes\n */\nexport function connectSeries(...nodes: InputNode[]): void {\n\tconst first = nodes.shift();\n\tnodes.reduce((prev, current) => {\n\t\tif (prev instanceof ToneAudioNode) {\n\t\t\tprev.connect(current);\n\t\t} else if (isAudioNode(prev)) {\n\t\t\tconnect(prev, current);\n\t\t}\n\t\treturn current;\n\t}, first);\n}\n\n/**\n * Connect two nodes together so that signal flows from the\n * first node to the second. Optionally specify the input and output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function connect(srcNode: OutputNode, dstNode: InputNode, outputNumber = 0, inputNumber = 0): void {\n\n\tassert(isDefined(srcNode), \"Cannot connect from undefined node\");\n\tassert(isDefined(dstNode), \"Cannot connect to undefined node\");\n\n\tif (dstNode instanceof ToneAudioNode || isAudioNode(dstNode)) {\n\t\tassert(dstNode.numberOfInputs > 0, \"Cannot connect to node with no inputs\");\n\t}\n\tassert(srcNode.numberOfOutputs > 0, \"Cannot connect from node with no outputs\");\n\n\t// resolve the input of the dstNode\n\twhile ((dstNode instanceof ToneAudioNode || dstNode instanceof Param)) {\n\t\tif (isDefined(dstNode.input)) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\twhile (srcNode instanceof ToneAudioNode) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\t// make the connection\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.connect(dstNode as AudioParam, outputNumber);\n\t} else {\n\t\tsrcNode.connect(dstNode, outputNumber, inputNumber);\n\t}\n}\n\n/**\n * Disconnect a node from all nodes or optionally include a destination node and input/output channels.\n * @param srcNode The source node\n * @param dstNode The destination node\n * @param outputNumber The output channel of the srcNode\n * @param inputNumber The input channel of the dstNode\n */\nexport function disconnect(\n\tsrcNode: OutputNode,\n\tdstNode?: InputNode,\n\toutputNumber = 0,\n\tinputNumber = 0,\n): void {\n\n\t// resolve the destination node\n\tif (isDefined(dstNode)) {\n\t\twhile (dstNode instanceof ToneAudioNode) {\n\t\t\tdstNode = dstNode.input;\n\t\t}\n\t}\n\n\t// resolve the src node\n\twhile (!(isAudioNode(srcNode))) {\n\t\tif (isDefined(srcNode.output)) {\n\t\t\tsrcNode = srcNode.output;\n\t\t}\n\t}\n\n\tif (isAudioParam(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber);\n\t} else if (isAudioNode(dstNode)) {\n\t\tsrcNode.disconnect(dstNode, outputNumber, inputNumber);\n\t} else {\n\t\tsrcNode.disconnect();\n\t}\n}\n", "import { Param } from \"../context/Param\";\nimport { UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface GainOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tgain: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * A thin wrapper around the Native Web Audio GainNode.\n * The GainNode is a basic building block of the Web Audio\n * API and is useful for routing audio and adjusting gains.\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst gainNode = new Tone.Gain(0).toDestination();\n * \tconst osc = new Tone.Oscillator(30).connect(gainNode).start();\n * \tgainNode.gain.rampTo(1, 0.1);\n * \tgainNode.gain.rampTo(0, 0.4, 0.2);\n * }, 0.7, 1);\n */\nexport class Gain<TypeName extends \"gain\" | \"decibels\" | \"normalRange\" = \"gain\"> extends ToneAudioNode<GainOptions<TypeName>> {\n\n\treadonly name: string = \"Gain\";\n\n\t/**\n\t * The gain parameter of the gain node.\n\t * @example\n\t * const gainNode = new Tone.Gain(0).toDestination();\n\t * const osc = new Tone.Oscillator().connect(gainNode).start();\n\t * gainNode.gain.rampTo(1, 0.1);\n\t * gainNode.gain.rampTo(0, 2, \"+0.5\");\n\t */\n\treadonly gain: Param<TypeName>;\n\n\t/**\n\t * The wrapped GainNode.\n\t */\n\tprivate _gainNode: GainNode = this.context.createGain();\n\n\t// input = output\n\treadonly input: GainNode = this._gainNode;\n\treadonly output: GainNode = this._gainNode;\n\n\t/**\n\t * @param  gain The initial gain of the GainNode\n\t * @param units The units of the gain parameter.\n\t */\n\tconstructor(gain?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<GainOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]));\n\t\tconst options = optionsFromArguments(Gain.getDefaults(), arguments, [\"gain\", \"units\"]);\n\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._gainNode.gain,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.gain,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t\treadOnly(this, \"gain\");\n\t}\n\n\tstatic getDefaults(): GainOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tgain: 1,\n\t\t\tunits: \"gain\",\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../core/context/Gain\";\nimport {\n\tToneAudioNode,\n\tToneAudioNodeOptions,\n} from \"../core/context/ToneAudioNode\";\nimport { GainFactor, Seconds, Time } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assert } from \"../core/util/Debug\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport type OneShotSourceCurve = \"linear\" | \"exponential\";\n\ntype onEndedCallback = (source: OneShotSource<any>) => void;\n\nexport interface OneShotSourceOptions extends ToneAudioNodeOptions {\n\tonended: onEndedCallback;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tcurve: OneShotSourceCurve;\n}\n\n/**\n * Base class for fire-and-forget nodes\n */\nexport abstract class OneShotSource<\n\tOptions extends ToneAudioNodeOptions\n> extends ToneAudioNode<Options> {\n\t/**\n\t * The callback to invoke after the\n\t * source is done playing.\n\t */\n\tonended: onEndedCallback = noOp;\n\n\t/**\n\t * Sources do not have input nodes\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The start time\n\t */\n\tprotected _startTime = -1;\n\n\t/**\n\t * The stop time\n\t */\n\tprotected _stopTime = -1;\n\n\t/**\n\t * The id of the timeout\n\t */\n\tprivate _timeout = -1;\n\n\t/**\n\t * The public output node\n\t */\n\toutput: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output gain node.\n\t */\n\tprotected _gainNode = this.output;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tprotected _curve: OneShotSourceCurve;\n\n\tconstructor(options: OneShotSourceOptions) {\n\t\tsuper(options);\n\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t\tthis._curve = options.curve;\n\t\tthis.onended = options.onended;\n\t}\n\n\tstatic getDefaults(): OneShotSourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tcurve: \"linear\" as OneShotSourceCurve,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tonended: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Stop the source node\n\t */\n\tprotected abstract _stopSource(time: Seconds): void;\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the node\n\t */\n\tprotected abstract start(time?: Time): this;\n\t/**\n\t * Start the source at the given time\n\t * @param  time When to start the source\n\t */\n\tprotected _startGain(time: Seconds, gain: GainFactor = 1): this {\n\t\tassert(\n\t\t\tthis._startTime === -1,\n\t\t\t\"Source cannot be started more than once\"\n\t\t);\n\t\t// apply a fade in envelope\n\t\tconst fadeInTime = this.toSeconds(this._fadeIn);\n\n\t\t// record the start time\n\t\tthis._startTime = time + fadeInTime;\n\t\tthis._startTime = Math.max(this._startTime, this.context.currentTime);\n\n\t\t// schedule the envelope\n\t\tif (fadeInTime > 0) {\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampToValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime + fadeInTime\n\t\t\t\t);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.exponentialApproachValueAtTime(\n\t\t\t\t\tgain,\n\t\t\t\t\ttime,\n\t\t\t\t\tfadeInTime\n\t\t\t\t);\n\t\t\t}\n\t\t} else {\n\t\t\tthis._gainNode.gain.setValueAtTime(gain, time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source node at the given time.\n\t * @param time When to stop the source\n\t */\n\tstop(time?: Time): this {\n\t\tthis.log(\"stop\", time);\n\t\tthis._stopGain(this.toSeconds(time));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the given time\n\t * @param  time When to stop the source\n\t */\n\tprotected _stopGain(time: Seconds): this {\n\t\tassert(this._startTime !== -1, \"'start' must be called before 'stop'\");\n\t\t// cancel the previous stop\n\t\tthis.cancelStop();\n\n\t\t// the fadeOut time\n\t\tconst fadeOutTime = this.toSeconds(this._fadeOut);\n\n\t\t// schedule the stop callback\n\t\tthis._stopTime = this.toSeconds(time) + fadeOutTime;\n\t\tthis._stopTime = Math.max(this._stopTime, this.context.currentTime);\n\t\tif (fadeOutTime > 0) {\n\t\t\t// start the fade out curve at the given time\n\t\t\tif (this._curve === \"linear\") {\n\t\t\t\tthis._gainNode.gain.linearRampTo(0, fadeOutTime, time);\n\t\t\t} else {\n\t\t\t\tthis._gainNode.gain.targetRampTo(0, fadeOutTime, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// stop any ongoing ramps, and set the value to 0\n\t\t\tthis._gainNode.gain.cancelAndHoldAtTime(time);\n\t\t\tthis._gainNode.gain.setValueAtTime(0, time);\n\t\t}\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._timeout = this.context.setTimeout(() => {\n\t\t\t// allow additional time for the exponential curve to fully decay\n\t\t\tconst additionalTail =\n\t\t\t\tthis._curve === \"exponential\" ? fadeOutTime * 2 : 0;\n\t\t\tthis._stopSource(this.now() + additionalTail);\n\t\t\tthis._onended();\n\t\t}, this._stopTime - this.context.currentTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the onended callback\n\t */\n\tprotected _onended(): void {\n\t\tif (this.onended !== noOp) {\n\t\t\tthis.onended(this);\n\t\t\t// overwrite onended to make sure it only is called once\n\t\t\tthis.onended = noOp;\n\t\t\t// dispose when it's ended to free up for garbage collection only in the online context\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tconst disposeCallback = () => this.dispose();\n\t\t\t\t// @ts-ignore\n\t\t\t\tif (typeof window.requestIdleCallback !== \"undefined\") {\n\t\t\t\t\t// @ts-ignore\n\t\t\t\t\twindow.requestIdleCallback(disposeCallback);\n\t\t\t\t} else {\n\t\t\t\t\tsetTimeout(disposeCallback, 1000);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the playback state at the given time\n\t */\n\tgetStateAtTime = function(time: Time): BasicPlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (\n\t\t\tthis._startTime !== -1 &&\n\t\t\tcomputedTime >= this._startTime &&\n\t\t\t(this._stopTime === -1 || computedTime <= this._stopTime)\n\t\t) {\n\t\t\treturn \"started\";\n\t\t} else {\n\t\t\treturn \"stopped\";\n\t\t}\n\t};\n\n\t/**\n\t * Get the playback state at the current time\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Cancel a scheduled stop event\n\t */\n\tcancelStop(): this {\n\t\tthis.log(\"cancelStop\");\n\t\tassert(this._startTime !== -1, \"Source is not started\");\n\t\t// cancel the stop envelope\n\t\tthis._gainNode.gain.cancelScheduledValues(\n\t\t\tthis._startTime + this.sampleTime\n\t\t);\n\t\tthis.context.clearTimeout(this._timeout);\n\t\tthis._stopTime = -1;\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { connect } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { Seconds, Time, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../source/OneShotSource\";\n\nexport interface ToneConstantSourceOptions<TypeName extends UnitName> extends OneShotSourceOptions {\n\tconvert: boolean;\n\toffset: UnitMap[TypeName];\n\tunits: TypeName;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * Wrapper around the native fire-and-forget ConstantSource.\n * Adds the ability to reschedule the stop method.\n * @category Signal\n */\nexport class ToneConstantSource<TypeName extends UnitName = \"number\"> extends OneShotSource<ToneConstantSourceOptions<TypeName>> {\n\n\treadonly name: string = \"ToneConstantSource\";\n\n\t/**\n\t * The signal generator\n\t */\n\tprivate _source = this.context.createConstantSource();\n\n\t/**\n\t * The offset of the signal generator\n\t */\n\treadonly offset: Param<TypeName>;\n\n\t/**\n\t * @param  offset   The offset value\n\t */\n\tconstructor(offset: UnitMap[TypeName]);\n\tconstructor(options?: Partial<ToneConstantSourceOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]));\n\t\tconst options = optionsFromArguments(ToneConstantSource.getDefaults(), arguments, [\"offset\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\n\t\tthis.offset = new Param({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tparam: this._source.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.offset,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t}\n\n\tstatic getDefaults(): ToneConstantSourceOptions<any> {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\toffset: 1,\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the source node at the given time\n\t * @param  time When to start the source\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._source.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._source.stop(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._source.disconnect();\n\t\tthis.offset.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AbstractParam } from \"../core/context/AbstractParam\";\nimport { Param } from \"../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connect } from \"../core/context/ToneAudioNode\";\nimport { Time, UnitMap, UnitName } from \"../core/type/Units\";\nimport { isAudioParam } from \"../core/util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n\nexport interface SignalOptions<TypeName extends UnitName> extends ToneAudioNodeOptions {\n\tvalue: UnitMap[TypeName];\n\tunits: TypeName;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n}\n\n/**\n * A signal is an audio-rate value. Tone.Signal is a core component of the library.\n * Unlike a number, Signals can be scheduled with sample-level accuracy. Tone.Signal\n * has all of the methods available to native Web Audio\n * [AudioParam](http://webaudio.github.io/web-audio-api/#the-audioparam-interface)\n * as well as additional conveniences. Read more about working with signals\n * [here](https://github.com/Tonejs/Tone.js/wiki/Signals).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // a scheduleable signal which can be connected to control an AudioParam or another Signal\n * const signal = new Tone.Signal({\n * \tvalue: \"C4\",\n * \tunits: \"frequency\"\n * }).connect(osc.frequency);\n * // the scheduled ramp controls the connected signal\n * signal.rampTo(\"C2\", 4, \"+0.5\");\n * @category Signal\n */\nexport class Signal<TypeName extends UnitName = \"number\"> extends ToneAudioNode<SignalOptions<any>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Signal\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection.\n\t */\n\treadonly override: boolean = true;\n\n\t/**\n\t * The constant source node which generates the signal\n\t */\n\tprotected _constantSource: ToneConstantSource<TypeName>;\n\treadonly output: OutputNode;\n\tprotected _param: Param<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis.output = this._constantSource = new ToneConstantSource({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\t\tthis._constantSource.start(0);\n\t\tthis.input = this._param = this._constantSource.offset;\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\t// start it only when connected to something\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// just a proxy for the ConstantSourceNode's offset AudioParam\n\t// all docs are generated from AbstractParam.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.setValueAtTime(value, time);\n\t\treturn this;\n\t}\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\treturn this._param.getValueAtTime(time);\n\t}\n\tsetRampPoint(time: Time): this {\n\t\tthis._param.setRampPoint(time);\n\t\treturn this;\n\t}\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.linearRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tthis._param.exponentialRampToValueAtTime(value, time);\n\t\treturn this;\n\t}\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.exponentialRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.linearRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.targetRampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\tthis._param.exponentialApproachValueAtTime(value, time, rampTime);\n\t\treturn this;\n\t}\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: number): this {\n\t\tthis._param.setTargetAtTime(value, startTime, timeConstant);\n\t\treturn this;\n\t}\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling?: number): this {\n\t\tthis._param.setValueCurveAtTime(values, startTime, duration, scaling);\n\t\treturn this;\n\t}\n\tcancelScheduledValues(time: Time): this {\n\t\tthis._param.cancelScheduledValues(time);\n\t\treturn this;\n\t}\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tthis._param.cancelAndHoldAtTime(time);\n\t\treturn this;\n\t}\n\trampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tthis._param.rampTo(value, rampTime, startTime);\n\t\treturn this;\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\treturn this._param.value;\n\t}\n\tset value(value: UnitMap[TypeName]) {\n\t\tthis._param.value = value;\n\t}\n\n\tget convert(): boolean {\n\t\treturn this._param.convert;\n\t}\n\tset convert(convert: boolean) {\n\t\tthis._param.convert = convert;\n\t}\n\n\tget units(): UnitName {\n\t\treturn this._param.units;\n\t}\n\n\tget overridden(): boolean {\n\t\treturn this._param.overridden;\n\t}\n\tset overridden(overridden: boolean) {\n\t\tthis._param.overridden = overridden;\n\t}\n\n\tget maxValue(): number {\n\t\treturn this._param.maxValue;\n\t}\n\tget minValue(): number {\n\t\treturn this._param.minValue;\n\t}\n\n\t/**\n\t * See [[Param.apply]].\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tthis._param.apply(param);\n\t\treturn this;\n\t}\n}\n\n/**\n * When connecting from a signal, it's necessary to zero out the node destination\n * node if that node is also a signal. If the destination is not 0, then the values\n * will be summed. This method insures that the output of the destination signal will\n * be the same as the source signal, making the destination signal a pass through node.\n * @param signal The output signal to connect from\n * @param destination the destination to connect to\n * @param outputNum the optional output number\n * @param inputNum the input number\n */\nexport function connectSignal(signal: OutputNode, destination: InputNode, outputNum?: number, inputNum?: number): void {\n\tif (destination instanceof Param || isAudioParam(destination) ||\n\t\t(destination instanceof Signal && destination.override)) {\n\t\t// cancel changes\n\t\tdestination.cancelScheduledValues(0);\n\t\t// reset the value\n\t\tdestination.setValueAtTime(0, 0);\n\t\t// mark the value as overridden\n\t\tif (destination instanceof Signal) {\n\t\t\tdestination.overridden = true;\n\t\t}\n\t}\n\tconnect(signal, destination, outputNum, inputNum);\n}\n", "import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName> extends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<TypeName extends \"hertz\" | \"bpm\"> extends Param<TypeName> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.cancelScheduledValues(0);\n\t\tthis.setValueAtTime(currentVal, 0);\n\t}\n}\n", "import { Signal, SignalOptions } from \"../../signal/Signal\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n\ninterface TickSignalOptions<TypeName extends UnitName> extends SignalOptions<TypeName> {\n\tvalue: UnitMap[TypeName];\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal<TypeName extends \"hertz\" | \"bpm\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"TickSignal\";\n\n\t/**\n\t * The param which controls the output signal value\n\t */\n\tprotected _param: TickParam<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: UnitMap[TypeName]);\n\tconstructor(options: Partial<TickSignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.input = this._param = new TickParam({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tmultiplier: options.multiplier,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): TickSignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this._param.ticksToTime(ticks, when);\n\t}\n\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\treturn this._param.timeToTicks(duration, when);\n\t}\n\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\treturn this._param.getTimeOfTick(tick);\n\t}\n\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\treturn this._param.getDurationOfTicks(ticks, time);\n\t}\n\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._param.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._param.multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\tthis._param.multiplier = m;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: number, endTime: number, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n", "import { Param } from \"../context/Param\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\nexport interface DelayOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * Wrapper around Web Audio's native [DelayNode](http://webaudio.github.io/web-audio-api/#the-delaynode-interface).\n * @category Core\n * @example\n * return Tone.Offline(() => {\n * \tconst delay = new Tone.Delay(0.1).toDestination();\n * \t// connect the signal to both the delay and the destination\n * \tconst pulse = new Tone.PulseOscillator().connect(delay).toDestination();\n * \t// start and stop the pulse\n * \tpulse.start(0).stop(0.01);\n * }, 0.5, 1);\n */\nexport class Delay extends ToneAudioNode<DelayOptions> {\n\n\treadonly name: string = \"Delay\";\n\n\t/**\n\t * Private holder of the max delay time\n\t */\n\tprivate _maxDelay: Seconds;\n\n\t/**\n\t * The amount of time the incoming signal is delayed.\n\t * @example\n\t * const delay = new Tone.Delay().toDestination();\n\t * // modulate the delayTime between 0.1 and 1 seconds\n\t * const delayLFO = new Tone.LFO(0.5, 0.1, 1).start().connect(delay.delayTime);\n\t * const pulse = new Tone.PulseOscillator().connect(delay).start();\n\t * // the change in delayTime causes the pitch to go up and down\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Private reference to the internal DelayNode\n\t */\n\tprivate _delayNode: DelayNode;\n\treadonly input: DelayNode;\n\treadonly output: DelayNode;\n\n\t/**\n\t * @param delayTime The delay applied to the incoming signal.\n\t * @param maxDelay The maximum delay time.\n\t */\n\tconstructor(delayTime?: Time, maxDelay?: Time);\n\tconstructor(options?: Partial<DelayOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]));\n\n\t\tconst options = optionsFromArguments(Delay.getDefaults(), arguments, [\"delayTime\", \"maxDelay\"]);\n\n\t\tconst maxDelayInSeconds = this.toSeconds(options.maxDelay);\n\t\tthis._maxDelay = Math.max(maxDelayInSeconds, this.toSeconds(options.delayTime));\n\n\t\tthis._delayNode = this.input = this.output = this.context.createDelay(maxDelayInSeconds);\n\n\t\tthis.delayTime = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._delayNode.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t\tminValue: 0,\n\t\t\tmaxValue: this.maxDelay,\n\t\t});\n\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): DelayOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The maximum delay time. This cannot be changed after\n\t * the value is passed into the constructor.\n\t */\n\tget maxDelay(): Seconds {\n\t\treturn this._maxDelay;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.disconnect();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n", "import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport. \n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n", "import { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isString } from \"../util/TypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\nimport { assert } from \"../util/Debug\";\n\nexport interface ToneAudioBuffersUrlMap {\n\t[name: string]: string | AudioBuffer | ToneAudioBuffer;\n\t[name: number]: string | AudioBuffer | ToneAudioBuffer;\n}\n\ninterface ToneAudioBuffersOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tonload: () => void;\n\tonerror?: (error: Error) => void;\n\tbaseUrl: string;\n}\n\n/**\n * A data structure for holding multiple buffers in a Map-like datastructure.\n *\n * @example\n * const pianoSamples = new Tone.ToneAudioBuffers({\n * \tA1: \"https://tonejs.github.io/audio/casio/A1.mp3\",\n * \tA2: \"https://tonejs.github.io/audio/casio/A2.mp3\",\n * }, () => {\n * \tconst player = new Tone.Player().toDestination();\n * \t// play one of the samples when they all load\n * \tplayer.buffer = pianoSamples.get(\"A2\");\n * \tplayer.start();\n * });\n * @example\n * // To pass in additional parameters in the second parameter\n * const buffers = new Tone.ToneAudioBuffers({\n * \t urls: {\n * \t\t A1: \"A1.mp3\",\n * \t\t A2: \"A2.mp3\",\n * \t },\n * \t onload: () => console.log(\"loaded\"),\n * \t baseUrl: \"https://tonejs.github.io/audio/casio/\"\n * });\n * @category Core\n */\nexport class ToneAudioBuffers extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffers\";\n\n\t/**\n\t * All of the buffers\n\t */\n\tprivate _buffers: Map<string, ToneAudioBuffer> = new Map();\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tbaseUrl: string;\n\n\t/**\n\t * Keep track of the number of loaded buffers\n\t */\n\tprivate _loadingCount = 0;\n\n\t/**\n\t * @param  urls  An object literal or array of urls to load.\n\t * @param onload  The callback to invoke when the buffers are loaded.\n\t * @param baseUrl A prefix url to add before all the urls\n\t */\n\tconstructor(\n\t\turls?: ToneAudioBuffersUrlMap,\n\t\tonload?: () => void,\n\t\tbaseUrl?: string,\n\t);\n\tconstructor(options?: Partial<ToneAudioBuffersOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\t\tconst options = optionsFromArguments(\n\t\t\tToneAudioBuffers.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\",\n\t\t);\n\n\t\tthis.baseUrl = options.baseUrl;\n\t\t// add each one\n\t\tObject.keys(options.urls).forEach(name => {\n\t\t\tthis._loadingCount++;\n\t\t\tconst url = options.urls[name];\n\t\t\tthis.add(name, url, this._bufferLoaded.bind(this, options.onload), options.onerror);\n\t\t});\n\n\t}\n\n\tstatic getDefaults(): ToneAudioBuffersOptions {\n\t\treturn {\n\t\t\tbaseUrl: \"\",\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\turls: {},\n\t\t};\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param  name  The key or index of the buffer.\n\t */\n\thas(name: string | number): boolean {\n\t\treturn this._buffers.has(name.toString());\n\t}\n\n\t/**\n\t * Get a buffer by name. If an array was loaded,\n\t * then use the array index.\n\t * @param  name  The key or index of the buffer.\n\t */\n\tget(name: string | number): ToneAudioBuffer {\n\t\tassert(this.has(name), `ToneAudioBuffers has no buffer named: ${name}`);\n\t\treturn this._buffers.get(name.toString()) as ToneAudioBuffer;\n\t}\n\n\t/**\n\t * A buffer was loaded. decrement the counter.\n\t */\n\tprivate _bufferLoaded(callback: () => void): void {\n\t\tthis._loadingCount--;\n\t\tif (this._loadingCount === 0 && callback) {\n\t\t\tcallback();\n\t\t}\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn Array.from(this._buffers).every(([_, buffer]) => buffer.loaded);\n\t}\n\n\t/**\n\t * Add a buffer by name and url to the Buffers\n\t * @param  name      A unique name to give the buffer\n\t * @param  url  Either the url of the bufer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t * @param  onerror  Invoked if the buffer can't be loaded\n\t */\n\tadd(\n\t\tname: string | number,\n\t\turl: string | AudioBuffer | ToneAudioBuffer,\n\t\tcallback: () => void = noOp,\n\t\tonerror: (e: Error) => void = noOp,\n\t): this {\n\t\tif (isString(url)) {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(this.baseUrl + url, callback, onerror));\n\t\t} else {\n\t\t\tthis._buffers.set(name.toString(), new ToneAudioBuffer(url, callback, onerror));\n\t\t}\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.forEach(buffer => buffer.dispose());\n\t\tthis._buffers.clear();\n\t\treturn this;\n\t}\n}\n", "import { getContext } from \"../Global\";\nimport { ftom, mtof } from \"./Conversions\";\nimport { FrequencyClass, FrequencyUnit } from \"./Frequency\";\nimport { TimeValue } from \"./TimeBase\";\nimport { Hertz, Interval, MidiNote, Seconds, Ticks } from \"./Units\";\n\n/**\n * Midi is a primitive type for encoding Time values.\n * Midi can be constructed with or without the `new` keyword. Midi can be passed\n * into the parameter of any method which takes time as an argument.\n * @category Unit\n */\nexport class MidiClass extends FrequencyClass<MidiNote> {\n\n\treadonly name: string = \"MidiClass\";\n\n\treadonly defaultUnits = \"midi\";\n\n\t/**\n\t * Returns the value of a frequency in the current units\n\t */\n\tprotected _frequencyToUnits(freq: Hertz): MidiNote {\n\t\treturn ftom(super._frequencyToUnits(freq));\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): MidiNote {\n\t\treturn ftom(super._ticksToUnits(ticks));\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): MidiNote {\n\t\treturn ftom(super._beatsToUnits(beats));\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): MidiNote {\n\t\treturn ftom(super._secondsToUnits(seconds));\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Midi(60).toMidi(); // 60\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value of the frequency as a MIDI note\n\t * @example\n\t * Tone.Midi(60).toFrequency(); // 261.6255653005986\n\t */\n\ttoFrequency(): Hertz {\n\t\treturn mtof(this.toMidi());\n\t}\n\n\t/**\n\t * Transposes the frequency by the given number of semitones.\n\t * @return A new transposed MidiClass\n\t * @example\n\t * Tone.Midi(\"A4\").transpose(3); // \"C5\"\n\t */\n\ttranspose(interval: Interval): MidiClass {\n\t\treturn new MidiClass(this.context, this.toMidi() + interval);\n\t}\n}\n\n/**\n * Convert a value into a FrequencyClass object.\n * @category Unit\n */\nexport function Midi(value?: TimeValue, units?: FrequencyUnit): MidiClass {\n\treturn new MidiClass(getContext(), value, units);\n}\n", "import { getContext } from \"../Global\";\nimport { TimeBaseUnit, TimeValue } from \"./TimeBase\";\nimport { TransportTimeClass } from \"./TransportTime\";\nimport { Seconds, Ticks } from \"./Units\";\n\n/**\n * Ticks is a primitive type for encoding Time values.\n * Ticks can be constructed with or without the `new` keyword. Ticks can be passed\n * into the parameter of any method which takes time as an argument.\n * @example\n * const t = Tone.Ticks(\"4n\"); // a quarter note as ticks\n * @category Unit\n */\nexport class TicksClass extends TransportTimeClass<Ticks> {\n\n\treadonly name: string = \"Ticks\";\n\n\treadonly defaultUnits: TimeBaseUnit = \"i\";\n\n\t/**\n\t * Get the current time in the given units\n\t */\n\tprotected _now(): Ticks {\n\t\treturn this.context.transport.ticks;\n\t}\n\n\t/**\n\t * Return the value of the beats in the current units\n\t */\n\tprotected _beatsToUnits(beats: number): Ticks {\n\t\treturn this._getPPQ() * beats;\n\t}\n\n\t/**\n\t * Returns the value of a second in the current units\n\t */\n\tprotected _secondsToUnits(seconds: Seconds): Ticks {\n\t\treturn Math.floor(seconds / (60 / this._getBpm()) * this._getPPQ());\n\t}\n\n\t/**\n\t * Returns the value of a tick in the current time units\n\t */\n\tprotected _ticksToUnits(ticks: Ticks): Ticks {\n\t\treturn ticks;\n\t}\n\n\t/**\n\t * Return the time in ticks\n\t */\n\ttoTicks(): Ticks {\n\t\treturn this.valueOf() as Ticks;\n\t}\n\n\t/**\n\t * Return the time in seconds\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn (this.valueOf() / this._getPPQ()) * (60 / this._getBpm());\n\t}\n}\n\n/**\n * Convert a time representation to ticks\n * @category Unit\n */\nexport function Ticks(value?: TimeValue, units?: TimeBaseUnit): TicksClass {\n\treturn new TicksClass(getContext(), value, units);\n}\n", "import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\treadonly name: string = \"Draw\";\n\n\t/**\n\t * The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t * The amount of time before the scheduled time\n\t * that the callback can be invoked. Default is\n\t * half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t * All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame = -1;\n\n\t/**\n\t * Schedule a function at the given time to be invoked\n\t * on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t * @example\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tTone.Draw.schedule(() => console.log(time), time);\n\t * }, 1);\n\t * Tone.Transport.start();\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime: this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.draw = new Draw({ context });\n});\n\nonContextClose(context => {\n\tcontext.draw.dispose();\n});\n", "import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tassert(isDefined(event.time), \"Events must have a time property\");\n\t\tassert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n", "export * from \"./NoteUnits\";\n\nimport { Note } from \"./NoteUnits\";\n\n/**\n * A number representing a time in seconds\n * @category Unit\n */\nexport type Seconds = number;\n\n/**\n * A number used to measure the intensity of a sound on a logarithmic scale.\n * @category Unit\n */\nexport type Decibels = number;\n\n/**\n * A number that is between [0, 1]\n * @category Unit\n */\nexport type NormalRange = number;\n\n/**\n * A number that is between [-1, 1]\n * @category Unit\n */\nexport type AudioRange = number;\n\n/**\n * Half-step note increments, i.e. 12 is an octave above the root. and 1 is a half-step up.\n * @category Unit\n */\nexport type Interval = number;\n\n/**\n * A number representing the multiplication factor applied to a signal\n * @category Unit\n */\nexport type GainFactor = number;\n\n/**\n * A number greater than or equal to 0.\n * @category Unit\n */\nexport type Positive = number;\n\n/**\n * Represents a subdivision of a measure.\n * The number represents the subdivision. \"t\" represents a triplet. A \".\" add a half.\n * e.g. \"4n\" is a quarter note, \"4t\" is a quarter note triplet, and \"4n.\" is a dotted quarter note.\n * @category Unit\n */\nexport type Subdivision = \"1m\" | \"1n\" | \"1n.\" | \"2n\" | \"2n.\" | \"2t\" | \"4n\" | \"4n.\" | \"4t\" | \"8n\" | \"8n.\" | \"8t\" |\n\"16n\" | \"16n.\" | \"16t\" | \"32n\" | \"32n.\" | \"32t\" | \"64n\" | \"64n.\" | \"64t\" | \"128n\" | \"128n.\" | \"128t\" |\n\"256n\" | \"256n.\" | \"256t\" | \"0\";\n\n/**\n * A time object has a subdivision as the keys and a number as the values.\n * @example\n * Tone.Time({\n * \t\"2n\": 1,\n * \t\"8n\": 3\n * }).valueOf(); // 2n + 8n * 3\n * @category Unit\n */\nexport type TimeObject = {\n\t[sub in Subdivision]?: number;\n};\n\n/**\n * Time can be described in a number of ways. Read more [Time](https://github.com/Tonejs/Tone.js/wiki/Time).\n * * Numbers, which will be taken literally as the time (in seconds).\n * * Notation, (\"4n\", \"8t\") describes time in BPM and time signature relative values.\n * * TransportTime, (\"4:3:2\") will also provide tempo and time signature relative times in the form BARS:QUARTERS:SIXTEENTHS.\n * * Frequency, (\"8hz\") is converted to the length of the cycle in seconds.\n * * Now-Relative, (\"+1\") prefix any of the above with \"+\" and it will be interpreted as \"the current time plus whatever expression follows\".\n * * Object, ({\"4n\" : 3, \"8t\" : -1}). The resulting time is equal to the sum of all of the keys multiplied by the values in the object.\n * * No Argument, for methods which accept time, no argument will be interpreted as \"now\" (i.e. the currentTime).\n * @category Unit\n */\nexport type Time = string | Seconds | TimeObject | Subdivision;\n\n/**\n * Frequency can be described similar to time, except ultimately the\n * values are converted to frequency instead of seconds. A number\n * is taken literally as the value in hertz. Additionally any of the\n * Time encodings can be used. Note names in the form\n * of NOTE OCTAVE (i.e. C4) are also accepted and converted to their\n * frequency value.\n * @category Unit\n */\nexport type Frequency = Subdivision | Note | string | Hertz;\n\n/**\n *\n * @category Unit\n */\nexport type TimeSignature = number | number[];\n\n/**\n * TransportTime describes a position along the Transport's timeline. It is\n * similar to Time in that it uses all the same encodings, but TransportTime specifically\n * pertains to the Transport's timeline, which is startable, stoppable, loopable, and seekable.\n * [Read more](https://github.com/Tonejs/Tone.js/wiki/TransportTime)\n * @category Unit\n */\nexport type TransportTime = Time;\n\n/**\n * Ticks are the basic subunit of the Transport. They are\n * the smallest unit of time that the Transport supports.\n * @category Unit\n */\nexport type Ticks = number;\n\n/**\n * Beats per minute\n * @category Unit\n */\nexport type BPM = number;\n\n/**\n * Angle between 0 and 360.\n * @category Unit\n */\nexport type Degrees = number;\n\n/**\n * Angle between 0 and 2 * PI.\n * @category Unit\n */\nexport type Radians = number;\n\n/**\n * A colon-separated representation of time in the form of\n * Bars:Beats:Sixteenths.\n * @category Unit\n */\nexport type BarsBeatsSixteenths = string;\n/**\n * Sampling is the reduction of a continuous signal to a discrete signal.\n * Audio is typically sampled 44100 times per second.\n * @category Unit\n */\nexport type Samples = number;\n\n/**\n * Hertz are a frequency representation defined as one cycle per second.\n * @category Unit\n */\nexport type Hertz = number;\n\n/**\n * A Cent is 1/100th of a semitone.\n * e.g. a value of 50 cents would be halfway between two intervals.\n * @category Unit\n */\nexport type Cents = number;\n\n/**\n * One millisecond is a thousandth of a second.\n * @category Unit\n */\nexport type Milliseconds = number;\n\n/**\n * A value which is a power of 2\n * @category Unit\n */\nexport type PowerOfTwo = number;\n\n/**\n * Map the unit name to a unit value\n */\nexport interface UnitMap {\n\tnumber: number;\n\tdecibels: Decibels;\n\tnormalRange: NormalRange;\n\taudioRange: AudioRange;\n\tgain: GainFactor;\n\tpositive: Positive;\n\ttime: Time;\n\tfrequency: Frequency;\n\ttransportTime: TransportTime;\n\tticks: Ticks;\n\tbpm: BPM;\n\tdegrees: Degrees;\n\tradians: Radians;\n\tsamples: Samples;\n\thertz: Hertz;\n\tcents: Cents;\n}\n\n/**\n * All of the unit types\n * @category Unit\n */\nexport type Unit = UnitMap[keyof UnitMap];\n\n/**\n * All of the unit names\n * @category Unit\n */\nexport type UnitName = keyof UnitMap;\n", "import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface VolumeOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * Volume is a simple volume node, useful for creating a volume fader.\n *\n * @example\n * const vol = new Tone.Volume(-12).toDestination();\n * const osc = new Tone.Oscillator().connect(vol).start();\n * @category Component\n */\nexport class Volume extends ToneAudioNode<VolumeOptions> {\n\n\treadonly name: string = \"Volume\";\n\n\t/**\n\t * the output node\n\t */\n\toutput: Gain<\"decibels\">;\n\n\t/**\n\t * Input and output are the same\n\t */\n\tinput: Gain<\"decibels\">;\n\n\t/**\n\t * The unmuted volume\n\t */\n\tprivate _unmutedVolume: Decibels;\n\n\t/**\n\t * The volume control in decibels.\n\t * @example\n\t * const vol = new Tone.Volume().toDestination();\n\t * const osc = new Tone.Oscillator().connect(vol).start();\n\t * vol.volume.value = -20;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume the initial volume in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<VolumeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(Volume.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.volume,\n\t\t\tunits: \"decibels\",\n\t\t});\n\t\tthis.volume = this.output.gain;\n\t\treadOnly(this, \"volume\");\n\t\tthis._unmutedVolume = options.volume;\n\n\t\t// set the mute initially\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): VolumeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const vol = new Tone.Volume(-12).toDestination();\n\t * const osc = new Tone.Oscillator().connect(vol).start();\n\t * // mute the output\n\t * vol.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this.volume.value === -Infinity;\n\t}\n\tset mute(mute: boolean) {\n\t\tif (!this.mute && mute) {\n\t\t\tthis._unmutedVolume = this.volume.value;\n\t\t\t// maybe it should ramp here?\n\t\t\tthis.volume.value = -Infinity;\n\t\t} else if (this.mute && !mute) {\n\t\t\tthis.volume.value = this._unmutedVolume;\n\t\t}\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Volume } from \"../../component/channel/Volume\";\nimport { Decibels } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\nimport { Gain } from \"./Gain\";\nimport { Param } from \"./Param\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\n\ninterface DestinationOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n\n/**\n * A single master output which is connected to the\n * AudioDestinationNode (aka your speakers).\n * It provides useful conveniences such as the ability\n * to set the volume and mute the entire application.\n * It also gives you the ability to apply master effects to your application.\n *\n * @example\n * const oscillator = new Tone.Oscillator().start();\n * // the audio will go from the oscillator to the speakers\n * oscillator.connect(Tone.getDestination());\n * // a convenience for connecting to the master output is also provided:\n * oscillator.toDestination();\n * @category Core\n */\nexport class Destination extends ToneAudioNode<DestinationOptions> {\n\n\treadonly name: string = \"Destination\";\n\n\tinput: Volume = new Volume({ context: this.context });\n\toutput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The volume of the master output in decibels. -Infinity is silent, and 0 is no change. \n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * osc.start();\n\t * // ramp the volume down to silent over 10 seconds\n\t * Tone.getDestination().volume.rampTo(-Infinity, 10);\n\t */\n\tvolume: Param<\"decibels\"> = this.input.volume;\n\n\tconstructor(options: Partial<DestinationOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Destination.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Destination.getDefaults(), arguments);\n\n\t\tconnectSeries(this.input, this.output, this.context.rawContext.destination);\n\n\t\tthis.mute = options.mute;\n\t\tthis._internalChannels = [this.input, this.context.rawContext.destination, this.output];\n\t}\n\n\tstatic getDefaults(): DestinationOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const oscillator = new Tone.Oscillator().start().toDestination();\n\t * setTimeout(() => {\n\t * \t// mute the output\n\t * \tTone.Destination.mute = true;\n\t * }, 1000);\n\t */\n\tget mute(): boolean {\n\t\treturn this.input.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis.input.mute = mute;\n\t}\n\n\t/**\n\t * Add a master effects chain. NOTE: this will disconnect any nodes which were previously\n\t * chained in the master effects chain.\n\t * @param args All arguments will be connected in a row and the Master will be routed through it.\n\t * @example\n\t * // route all audio through a filter and compressor\n\t * const lowpass = new Tone.Filter(800, \"lowpass\");\n\t * const compressor = new Tone.Compressor(-18);\n\t * Tone.Destination.chain(lowpass, compressor);\n\t */\n\tchain(...args: Array<AudioNode | ToneAudioNode>): this {\n\t\tthis.input.disconnect();\n\t\targs.unshift(this.input);\n\t\targs.push(this.output);\n\t\tconnectSeries(...args);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The maximum number of channels the system can output\n\t * @example\n\t * console.log(Tone.Destination.maxChannelCount);\n\t */\n\tget maxChannelCount(): number {\n\t\treturn this.context.rawContext.destination.maxChannelCount;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.destination = new Destination({ context });\n});\n\nonContextClose(context => {\n\tcontext.destination.dispose();\n});\n", "import { Timeline, TimelineEvent } from \"./Timeline\";\nimport { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\n\ninterface TimelineValueEvent<T> extends TimelineEvent {\n\tvalue: T;\n}\n\n/**\n * Represents a single value which is gettable and settable in a timed way\n */\nexport class TimelineValue<Type> extends Tone {\n\n\treadonly name: string = \"TimelineValue\";\n\n\t/**\n\t * The timeline which stores the values\n\t */\n\tprivate _timeline: Timeline<TimelineValueEvent<Type>> = new Timeline({ memory: 10 })\n\n\t/**\n\t * Hold the value to return if there is no scheduled values\n\t */\n\tprivate _initialValue: Type;\n\n\t/**\n\t * @param initialValue The value to return if there is no scheduled values\n\t */\n\tconstructor(initialValue: Type) {\n\n\t\tsuper();\n\t\tthis._initialValue = initialValue;\n\t}\n\n\t/**\n\t * Set the value at the given time\n\t */\n\tset(value: Type, time: Seconds): this {\n\t\tthis._timeline.add({\n\t\t\tvalue, time\n\t\t});\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Get the value at the given time\n\t */\n\tget(time: Seconds): Type {\n\t\tconst event = this._timeline.get(time);\n\t\tif (event) {\n\t\t\treturn event.value;\n\t\t} else {\n\t\t\treturn this._initialValue;\n\t\t}\n\t}\n}\n", "import { Seconds, Ticks } from \"../type/Units\";\nimport { noOp } from \"../util/Interface\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\nexport interface TransportEventOptions {\n\tcallback: (time: number) => void;\n\tonce: boolean;\n\ttime: Ticks;\n}\n\n/**\n * TransportEvent is an internal class used by [[Transport]]\n * to schedule events. Do no invoke this class directly, it is\n * handled from within Tone.Transport.\n */\nexport class TransportEvent {\n\n\t/**\n\t * Reference to the Transport that created it\n\t */\n\tprotected transport: Transport;\n\n\t/**\n\t * The unique id of the event\n\t */\n\tid: number = TransportEvent._eventId++;\n\n\t/**\n\t * The time the event starts\n\t */\n\ttime: Ticks;\n\n\t/**\n\t * The callback to invoke\n\t */\n\tprivate callback?: (time: Seconds) => void;\n\n\t/**\n\t * If the event should be removed after being invoked.\n\t */\n\tprivate _once: boolean;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportEventOptions>) {\n\n\t\tconst options: TransportEventOptions = Object.assign(TransportEvent.getDefaults(), opts);\n\n\t\tthis.transport = transport;\n\t\tthis.callback = options.callback;\n\t\tthis._once = options.once;\n\t\tthis.time = options.time;\n\t}\n\n\tstatic getDefaults(): TransportEventOptions {\n\t\treturn {\n\t\t\tcallback: noOp,\n\t\t\tonce: false,\n\t\t\ttime: 0,\n\t\t};\n\t}\n\n\t/**\n\t * Current ID counter\n\t */\n\tprivate static _eventId = 0;\n\n\t/**\n\t * Invoke the event callback.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\tif (this.callback) {\n\t\t\tthis.callback(time);\n\t\t\tif (this._once) {\n\t\t\t\tthis.transport.clear(this.id);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tthis.callback = undefined;\n\t\treturn this;\n\t}\n}\n", "import { BaseContext } from \"../context/BaseContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { TransportEvent, TransportEventOptions } from \"./TransportEvent\";\n\ntype Transport = import(\"../clock/Transport\").Transport;\n\ninterface TransportRepeatEventOptions extends TransportEventOptions {\n\tinterval: Ticks;\n\tduration: Ticks;\n}\n\n/**\n * TransportRepeatEvent is an internal class used by Tone.Transport\n * to schedule repeat events. This class should not be instantiated directly.\n */\nexport class TransportRepeatEvent extends TransportEvent {\n\n\t/**\n\t * When the event should stop repeating\n\t */\n\tprivate duration: Ticks;\n\n\t/**\n\t * The interval of the repeated event\n\t */\n\tprivate _interval: Ticks;\n\n\t/**\n\t * The ID of the current timeline event\n\t */\n\tprivate _currentId = -1;\n\n\t/**\n\t * The ID of the next timeline event\n\t */\n\tprivate _nextId = -1;\n\n\t/**\n\t * The time of the next event\n\t */\n\tprivate _nextTick = this.time;\n\n\t/**\n\t * a reference to the bound start method\n\t */\n\tprivate _boundRestart = this._restart.bind(this);\n\n\t/**\n\t * The audio context belonging to this event\n\t */\n\tprotected context: BaseContext;\n\n\t/**\n\t * @param transport The transport object which the event belongs to\n\t */\n\tconstructor(transport: Transport, opts: Partial<TransportRepeatEventOptions>) {\n\n\t\tsuper(transport, opts);\n\n\t\tconst options = Object.assign(TransportRepeatEvent.getDefaults(), opts);\n\n\t\tthis.duration = new TicksClass(transport.context, options.duration).valueOf();\n\t\tthis._interval = new TicksClass(transport.context, options.interval).valueOf();\n\t\tthis._nextTick = options.time;\n\t\tthis.transport.on(\"start\", this._boundRestart);\n\t\tthis.transport.on(\"loopStart\", this._boundRestart);\n\t\tthis.context = this.transport.context;\n\t\tthis._restart();\n\t}\n\n\tstatic getDefaults(): TransportRepeatEventOptions {\n\t\treturn Object.assign({}, TransportEvent.getDefaults(), {\n\t\t\tduration: Infinity,\n\t\t\tinterval: 1,\n\t\t\tonce: false,\n\t\t});\n\t}\n\n\t/**\n\t * Invoke the callback. Returns the tick time which\n\t * the next event should be scheduled at.\n\t * @param  time  The AudioContext time in seconds of the event\n\t */\n\tinvoke(time: Seconds): void {\n\t\t// create more events if necessary\n\t\tthis._createEvents(time);\n\t\t// call the super class\n\t\tsuper.invoke(time);\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _createEvents(time: Seconds): void {\n\t\t// schedule the next event\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks >= this.time && ticks >= this._nextTick && this._nextTick + this._interval < this.time + this.duration) {\n\t\t\tthis._nextTick += this._interval;\n\t\t\tthis._currentId = this._nextId;\n\t\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\t}\n\t}\n\n\t/**\n\t * Push more events onto the timeline to keep up with the position of the timeline\n\t */\n\tprivate _restart(time?: Time): void {\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis._nextTick = this.time;\n\t\tconst ticks = this.transport.getTicksAtTime(time);\n\t\tif (ticks > this.time) {\n\t\t\tthis._nextTick = this.time + Math.ceil((ticks - this.time) / this._interval) * this._interval;\n\t\t}\n\t\tthis._currentId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t\tthis._nextTick += this._interval;\n\t\tthis._nextId = this.transport.scheduleOnce(this.invoke.bind(this),\n\t\t\tnew TicksClass(this.context, this._nextTick).toSeconds());\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.transport.clear(this._currentId);\n\t\tthis.transport.clear(this._nextId);\n\t\tthis.transport.off(\"start\", this._boundRestart);\n\t\tthis.transport.off(\"loopStart\", this._boundRestart);\n\t\treturn this;\n\t}\n}\n", "import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport {\n\tBarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime\n} from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TickParam } from \"./TickParam\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * Tone.Transport.bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Tone.Transport.start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Tone.Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.setValueAtTime(options.bpm, 0);\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * // schedule an event on the 16th measure\n\t * Tone.Transport.schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Tone.Transport.scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Tone.Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Tone.Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * // common time\n\t * Tone.Transport.timeSignature = 4;\n\t * // 7/8\n\t * Tone.Transport.timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Tone.Transport.timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * // loop over the first measure\n\t * Tone.Transport.setLoopPoints(0, \"1m\");\n\t * Tone.Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\t\t// schedule to start on the next tick, #573\n\t\t\t\tconst remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n\t\t\t\tconst time = now + remainingTick;\n\t\t\t\tthis.emit(\"stop\", time);\n\t\t\t\tthis._clock.setTicksAtTime(t, time);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * // the transport must be started, otherwise returns 0\n\t * Tone.Transport.start(); \n\t * Tone.Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tratio: ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n", "import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. \n * start/stop of this.context.transport.\n * \n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const source = new Tone.PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\t\tthis._state.increasing = true;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tprotected abstract _restart(time: Seconds, offset?: Time, duration?: Time): void;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\t// time should be strictly greater than the previous start time\n\t\t\tassert(GT(computedTime, (this._state.get(computedTime) as StateTimelineEvent).time), \"Start time must be strictly greater than previous start time\");\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if the transport is already started\n\t\t\t\t// and the time is greater than where the transport is\n\t\t\t\tif (this.context.transport.state === \"started\" && \n\t\t\t\t\tthis.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassertContextRunning(this.context);\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n\t\t\tthis.log(\"stop\", computedTime);\n\t\t\tif (!this._synced) {\n\t\t\t\tthis._stop(computedTime);\n\t\t\t} else {\n\t\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\t\t\t}\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the source.\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._restart(time, offset, duration);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Tone.Transport.start();\n\t * // set it to loop once a second\n\t * Tone.Transport.loop = true;\n\t * Tone.Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration: number | undefined;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\t// stop it also\n\t\tthis._stop(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n", "import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(url?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\treadonly name: string = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * const noise = new Tone.Noise().toDestination().start();\n\t * noise.type = \"brown\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tassert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t * internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\turl: buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\tprotected _restart(time?: Time): void {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n", "import { connect, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels } from \"../core/type/Units\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n\nexport interface UserMediaOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input. \n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode<UserMediaOptions> {\n\n\treadonly name: string = \"UserMedia\";\n\n\treadonly input: undefined;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The MediaStreamNode\n\t */\n\tprivate _mediaStream?: MediaStreamAudioSourceNode;\n\n\t/**\n\t * The media stream created by getUserMedia.\n\t */\n\tprivate _stream?: MediaStream;\n\n\t/**\n\t * The open device\n\t */\n\tprivate _device?: MediaDeviceInfo;\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The level of the input in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<UserMediaOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): UserMediaOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0\n\t\t});\n\t}\n\n\t/**\n\t * Open the media stream. If a string is passed in, it is assumed\n\t * to be the label or id of the stream, if a number is passed in,\n\t * it is the input number of the stream.\n\t * @param  labelOrId The label or id of the audio input media device.\n\t *                   With no argument, the default stream is opened.\n\t * @return The promise is resolved when the stream is open.\n\t */\n\tasync open(labelOrId?: string | number): Promise<this> {\n\t\tassert(UserMedia.supported, \"UserMedia is not supported\");\n\t\t// close the previous stream\n\t\tif (this.state === \"started\") {\n\t\t\tthis.close();\n\t\t}\n\t\tconst devices = await UserMedia.enumerateDevices();\n\t\tif (isNumber(labelOrId)) {\n\t\t\tthis._device = devices[labelOrId];\n\t\t} else {\n\t\t\tthis._device = devices.find((device) => {\n\t\t\t\treturn device.label === labelOrId || device.deviceId === labelOrId;\n\t\t\t});\n\t\t\t// didn't find a matching device\n\t\t\tif (!this._device && devices.length > 0) {\n\t\t\t\tthis._device = devices[0];\n\t\t\t}\n\t\t\tassert(isDefined(this._device), `No matching device ${labelOrId}`);\n\t\t}\n\t\t// do getUserMedia\n\t\tconst constraints = {\n\t\t\taudio: {\n\t\t\t\techoCancellation: false,\n\t\t\t\tsampleRate: this.context.sampleRate,\n\t\t\t\tnoiseSuppression: false,\n\t\t\t\tmozNoiseSuppression: false,\n\t\t\t}\n\t\t};\n\t\tif (this._device) {\n\t\t\t// @ts-ignore\n\t\t\tconstraints.audio.deviceId = this._device.deviceId;\n\t\t}\n\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t// start a new source only if the previous one is closed\n\t\tif (!this._stream) {\n\t\t\tthis._stream = stream;\n\t\t\t// Wrap a MediaStreamSourceNode around the live input stream.\n\t\t\tconst mediaStreamNode = this.context.createMediaStreamSource(stream);\n\t\t\t// Connect the MediaStreamSourceNode to a gate gain node\n\t\t\tconnect(mediaStreamNode, this.output);\n\t\t\tthis._mediaStream = mediaStreamNode;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Close the media stream\n\t */\n\tclose(): this {\n\t\tif (this._stream && this._mediaStream) {\n\t\t\tthis._stream.getAudioTracks().forEach((track) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tthis._stream = undefined;\n\t\t\t// remove the old media stream\n\t\t\tthis._mediaStream.disconnect();\n\t\t\tthis._mediaStream = undefined;\n\t\t}\n\t\tthis._device = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a promise which resolves with the list of audio input devices available.\n\t * @return The promise that is resolved with the devices\n\t * @example\n\t * Tone.UserMedia.enumerateDevices().then((devices) => {\n\t * \t// print the device labels\n\t * \tconsole.log(devices.map(device => device.label));\n\t * });\n\t */\n\tstatic async enumerateDevices(): Promise<MediaDeviceInfo[]> {\n\t\tconst allDevices = await navigator.mediaDevices.enumerateDevices();\n\t\treturn allDevices.filter(device => {\n\t\t\treturn device.kind === \"audioinput\";\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, \"started\" when the microphone is open\n\t * and \"stopped\" when the mic is closed.\n\t */\n\tget state() {\n\t\treturn this._stream && this._stream.active ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * Returns an identifier for the represented device that is\n\t * persisted across sessions. It is un-guessable by other applications and\n\t * unique to the origin of the calling application. It is reset when the\n\t * user clears cookies (for Private Browsing, a different identifier is\n\t * used that is not persisted across sessions). Returns undefined when the\n\t * device is not open.\n\t */\n\tget deviceId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.deviceId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a group identifier. Two devices have the\n\t * same group identifier if they belong to the same physical device.\n\t * Returns null  when the device is not open.\n\t */\n\tget groupId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.groupId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a label describing this device (for example \"Built-in Microphone\").\n\t * Returns undefined when the device is not open or label is not available\n\t * because of permissions.\n\t */\n\tget label(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.label;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const mic = new Tone.UserMedia();\n\t * mic.open().then(() => {\n\t * \t// promise resolves when input is available\n\t * });\n\t * // mute the output\n\t * mic.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.close();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * If getUserMedia is supported by the browser.\n\t */\n\tstatic get supported(): boolean {\n\t\treturn isDefined(navigator.mediaDevices) &&\n\t\t\tisDefined(navigator.mediaDevices.getUserMedia);\n\t}\n}\n", "import { AudioRange, Cents, Degrees, Frequency, Positive } from \"../../core/type/Units\";\nimport { Omit } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { SourceOptions } from \"../Source\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\n\n/**\n * The common interface of all Oscillators\n */\nexport interface ToneOscillatorInterface {\n\n\t/**\n\t * The oscillator type without the partialsCount appended to the end\n\t * @example\n\t * const osc = new Tone.Oscillator();\n\t * osc.type = \"sine2\";\n\t * console.log(osc.baseType); // \"sine\"\n\t */\n\tbaseType: OscillatorType | \"pulse\" | \"pwm\";\n\n\t/**\n\t * The oscillator's type. Also capable of setting the first x number of partials of the oscillator. \n\t * For example: \"sine4\" would set be the first 4 partials of the sine wave and \"triangle8\" would \n\t * set the first 8 partials of the triangle wave.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.Oscillator().toDestination().start();\n\t * \tosc.type = \"sine2\";\n\t * }, 0.1, 1);\n\t */\n\ttype: ExtendedToneOscillatorType;\n\n\t/**\n\t * The frequency value of the oscillator\n\t * @example\n\t * const osc = new Tone.FMOscillator(\"Bb4\").toDestination().start();\n\t * osc.frequency.rampTo(\"D2\", 3);\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune value in cents (100th of a semitone).\n\t * @example\n\t * const osc = new Tone.PulseOscillator(\"F3\").toDestination().start();\n\t * // pitch it 1 octave = 12 semitones = 1200 cents\n\t * osc.detune.setValueAtTime(-1200, Tone.now());\n\t * osc.detune.setValueAtTime(1200, Tone.now() + 0.5);\n\t * osc.detune.linearRampToValueAtTime(0, Tone.now() + 1);\n\t * osc.stop(Tone.now() + 1.5);\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The phase is the starting position within the oscillator's cycle. For example\n\t * a phase of 180 would start halfway through the oscillator's cycle. \n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.Oscillator({\n\t * \t\tfrequency: 20,\n\t * \t\tphase: 90\n\t * \t}).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\tphase: Degrees;\n\n\t/**\n\t * The partials describes the relative amplitude of each of the harmonics of the oscillator. \n\t * The first value in the array is the first harmonic (i.e. the fundamental frequency), the \n\t * second harmonic is an octave up, the third harmonic is an octave and a fifth, etc. The resulting\n\t * oscillator output is composed of a sine tone at the relative amplitude at each of the harmonic intervals. \n\t * \n\t * Setting this value will automatically set the type to \"custom\".\n\t * The value is an empty array when the type is not \"custom\".\n\t * @example\n\t * const osc = new Tone.Oscillator(\"F3\").toDestination().start();\n\t * setInterval(() => {\n\t * \t// generate 8 random partials\n\t * \tosc.partials = new Array(8).fill(0).map(() => Math.random());\n\t * }, 1000);\n\t */\n\tpartials: number[];\n\n\t/**\n\t * 'partialCount' offers an alternative way to set the number of used partials.\n\t * When partialCount is 0, the maximum number of partials are used when representing\n\t * the waveform using the periodicWave. When 'partials' is set, this value is\n\t * not settable, but equals the length of the partials array. A square wave wave\n\t * is composed of only odd harmonics up through the harmonic series. Partial count\n\t * can limit the number of harmonics which are used to generate the waveform.\n\t * @example\n\t * const osc = new Tone.Oscillator(\"C3\", \"square\").toDestination().start();\n\t * osc.partialCount = 1;\n\t * setInterval(() => {\n\t * \tosc.partialCount++;\n\t * \tconsole.log(osc.partialCount);\n\t * }, 500);\n\t */\n\tpartialCount?: number;\n\n\t/**\n\t * Returns an array of values which represents the waveform.\n\t * @param length The length of the waveform to return\n\t */\n\tasArray(length: number): Promise<Float32Array>;\n}\n\n/**\n * Render a segment of the oscillator to an offline context and return the results as an array\n */\nexport async function generateWaveform(instance: any, length: number): Promise<Float32Array> {\n\tconst duration = length / instance.context.sampleRate;\n\tconst context = new OfflineContext(1, duration, instance.context.sampleRate);\n\tconst clone = new instance.constructor(Object.assign(instance.get(), {\n\t\t// should do 2 iterations\n\t\tfrequency: 2 / duration,\n\t\t// zero out the detune\n\t\tdetune: 0,\n\t\tcontext\n\t})).toDestination();\n\tclone.start(0);\n\tconst buffer = await context.render();\n\treturn buffer.getChannelData(0);\n}\n\n/**\n * Oscillators with partials\n */\ntype SineWithPartials =\n\t\"sine1\" | \"sine2\" | \"sine3\" | \"sine4\" | \"sine5\" | \"sine6\" | \"sine7\" | \"sine8\" | \"sine9\" |\n\t\"sine10\" | \"sine11\" | \"sine12\" | \"sine13\" | \"sine14\" | \"sine15\" | \"sine16\" | \"sine17\" | \"sine18\" | \"sine19\" |\n\t\"sine20\" | \"sine21\" | \"sine22\" | \"sine23\" | \"sine24\" | \"sine25\" | \"sine26\" | \"sine27\" | \"sine28\" | \"sine29\" |\n\t\"sine30\" | \"sine31\" | \"sine32\";\n\ntype SquareWithPartials =\n\t\"square1\" | \"square2\" | \"square3\" | \"square4\" | \"square5\" | \"square6\" | \"square7\" | \"square8\" | \"square9\" |\n\t\"square10\" | \"square11\" | \"square12\" | \"square13\" | \"square14\" | \"square15\" | \"square16\" | \"square17\" | \"square18\" | \"square19\" |\n\t\"square20\" | \"square21\" | \"square22\" | \"square23\" | \"square24\" | \"square25\" | \"square26\" | \"square27\" | \"square28\" | \"square29\" |\n\t\"square30\" | \"square31\" | \"square32\";\n\ntype SawtoothWithPartials =\n\t\"sawtooth1\" | \"sawtooth2\" | \"sawtooth3\" | \"sawtooth4\" | \"sawtooth5\" | \"sawtooth6\" | \"sawtooth7\" | \"sawtooth8\" | \"sawtooth9\" |\n\t\"sawtooth10\" | \"sawtooth11\" | \"sawtooth12\" | \"sawtooth13\" | \"sawtooth14\" | \"sawtooth15\" | \"sawtooth16\" | \"sawtooth17\" | \"sawtooth18\" | \"sawtooth19\" |\n\t\"sawtooth20\" | \"sawtooth21\" | \"sawtooth22\" | \"sawtooth23\" | \"sawtooth24\" | \"sawtooth25\" | \"sawtooth26\" | \"sawtooth27\" | \"sawtooth28\" | \"sawtooth29\" |\n\t\"sawtooth30\" | \"sawtooth31\" | \"sawtooth32\";\n\ntype TriangleWithPartials =\n\t\"triangle1\" | \"triangle2\" | \"triangle3\" | \"triangle4\" | \"triangle5\" | \"triangle6\" | \"triangle7\" | \"triangle8\" | \"triangle9\" |\n\t\"triangle10\" | \"triangle11\" | \"triangle12\" | \"triangle13\" | \"triangle14\" | \"triangle15\" | \"triangle16\" | \"triangle17\" | \"triangle18\" | \"triangle19\" |\n\t\"triangle20\" | \"triangle21\" | \"triangle22\" | \"triangle23\" | \"triangle24\" | \"triangle25\" | \"triangle26\" | \"triangle27\" | \"triangle28\" | \"triangle29\" |\n\t\"triangle30\" | \"triangle31\" | \"triangle32\";\n\ntype TypeWithPartials = SineWithPartials | SquareWithPartials | TriangleWithPartials | SawtoothWithPartials;\n\ninterface BaseOscillatorOptions extends SourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tphase: Degrees;\n}\n\nexport type NonCustomOscillatorType = Exclude<OscillatorType, \"custom\">;\n\ntype AllNonCustomOscillatorType = NonCustomOscillatorType | TypeWithPartials;\n\nexport type ToneOscillatorType = AllNonCustomOscillatorType | \"custom\";\n\nexport type ExtendedToneOscillatorType = ToneOscillatorType | \"pwm\" | \"pulse\";\n\n/**\n * Oscillator Interfaces\n */\ninterface ToneCustomOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface ToneTypeOscillatorOptions extends BaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface TonePartialOscillatorOptions extends BaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type ToneOscillatorConstructorOptions = ToneCustomOscillatorOptions | ToneTypeOscillatorOptions | TonePartialOscillatorOptions;\n\nexport interface ToneOscillatorOptions extends BaseOscillatorOptions {\n\ttype: ToneOscillatorType;\n\tpartialCount: number;\n\tpartials: number[];\n}\n\n/**\n * FMOscillator Interface\n */\ninterface FMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface FMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface FMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FMConstructorOptions = FMTypeOscillatorOptions | FMCustomOscillatorOptions | FMPartialsOscillatorOptions;\n\nexport interface FMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\n/**\n * AMOscillator Interface\n */\ninterface AMBaseOscillatorOptions extends BaseOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n\ninterface AMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface AMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialsCount?: number;\n}\n\ninterface AMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type AMConstructorOptions = AMCustomOscillatorOptions | AMTypeOscillatorOptions | AMPartialsOscillatorOptions;\n\nexport interface AMOscillatorOptions extends ToneOscillatorOptions {\n\tharmonicity: Positive;\n\tmodulationType: AllNonCustomOscillatorType;\n}\n/**\n * FatOscillator\n */\ninterface FatBaseOscillatorOptions extends BaseOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\ninterface FatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"custom\";\n\tpartials: number[];\n}\n\ninterface FatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: NonCustomOscillatorType;\n\tpartialCount?: number;\n}\n\ninterface FatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: TypeWithPartials;\n}\n\nexport type FatConstructorOptions = FatCustomOscillatorOptions | FatTypeOscillatorOptions | FatPartialsOscillatorOptions;\n\nexport interface FatOscillatorOptions extends ToneOscillatorOptions {\n\tspread: Cents;\n\tcount: Positive;\n}\n\n/**\n * Pulse Oscillator\n */\nexport interface PulseOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pulse\";\n\twidth: AudioRange;\n}\n\n/**\n * PWM Oscillator\n */\nexport interface PWMOscillatorOptions extends BaseOscillatorOptions {\n\ttype: \"pwm\";\n\tmodulationFrequency: Frequency;\n}\n\n/**\n * OMNI OSCILLATOR\n */\n\n/**\n * FM Oscillators with partials\n */\ntype FMSineWithPartials =\n\t\"fmsine1\" | \"fmsine2\" | \"fmsine3\" | \"fmsine4\" | \"fmsine5\" | \"fmsine6\" | \"fmsine7\" | \"fmsine8\" | \"fmsine9\" |\n\t\"fmsine10\" | \"fmsine11\" | \"fmsine12\" | \"fmsine13\" | \"fmsine14\" | \"fmsine15\" | \"fmsine16\" | \"fmsine17\" | \"fmsine18\" | \"fmsine19\" |\n\t\"fmsine20\" | \"fmsine21\" | \"fmsine22\" | \"fmsine23\" | \"fmsine24\" | \"fmsine25\" | \"fmsine26\" | \"fmsine27\" | \"fmsine28\" | \"fmsine29\" |\n\t\"fmsine30\" | \"fmsine31\" | \"fmsine32\";\n\ntype FMSquareWithPartials =\n\t\"fmsquare1\" | \"fmsquare2\" | \"fmsquare3\" | \"fmsquare4\" | \"fmsquare5\" | \"fmsquare6\" | \"fmsquare7\" | \"fmsquare8\" | \"fmsquare9\" |\n\t\"fmsquare10\" | \"fmsquare11\" | \"fmsquare12\" | \"fmsquare13\" | \"fmsquare14\" | \"fmsquare15\" | \"fmsquare16\" | \"fmsquare17\" | \"fmsquare18\" | \"fmsquare19\" |\n\t\"fmsquare20\" | \"fmsquare21\" | \"fmsquare22\" | \"fmsquare23\" | \"fmsquare24\" | \"fmsquare25\" | \"fmsquare26\" | \"fmsquare27\" | \"fmsquare28\" | \"fmsquare29\" |\n\t\"fmsquare30\" | \"fmsquare31\" | \"fmsquare32\";\n\ntype FMSawtoothWithPartials =\n\t\"fmsawtooth1\" | \"fmsawtooth2\" | \"fmsawtooth3\" | \"fmsawtooth4\" | \"fmsawtooth5\" | \"fmsawtooth6\" | \"fmsawtooth7\" | \"fmsawtooth8\" | \"fmsawtooth9\" |\n\t\"fmsawtooth10\" | \"fmsawtooth11\" | \"fmsawtooth12\" | \"fmsawtooth13\" | \"fmsawtooth14\" | \"fmsawtooth15\" | \"fmsawtooth16\" | \"fmsawtooth17\" | \"fmsawtooth18\" | \"fmsawtooth19\" |\n\t\"fmsawtooth20\" | \"fmsawtooth21\" | \"fmsawtooth22\" | \"fmsawtooth23\" | \"fmsawtooth24\" | \"fmsawtooth25\" | \"fmsawtooth26\" | \"fmsawtooth27\" | \"fmsawtooth28\" | \"fmsawtooth29\" |\n\t\"fmsawtooth30\" | \"fmsawtooth31\" | \"fmsawtooth32\";\n\ntype FMTriangleWithPartials =\n\t\"fmtriangle1\" | \"fmtriangle2\" | \"fmtriangle3\" | \"fmtriangle4\" | \"fmtriangle5\" | \"fmtriangle6\" | \"fmtriangle7\" | \"fmtriangle8\" | \"fmtriangle9\" |\n\t\"fmtriangle10\" | \"fmtriangle11\" | \"fmtriangle12\" | \"fmtriangle13\" | \"fmtriangle14\" | \"fmtriangle15\" | \"fmtriangle16\" | \"fmtriangle17\" | \"fmtriangle18\" | \"fmtriangle19\" |\n\t\"fmtriangle20\" | \"fmtriangle21\" | \"fmtriangle22\" | \"fmtriangle23\" | \"fmtriangle24\" | \"fmtriangle25\" | \"fmtriangle26\" | \"fmtriangle27\" | \"fmtriangle28\" | \"fmtriangle29\" |\n\t\"fmtriangle30\" | \"fmtriangle31\" | \"fmtriangle32\";\n\ntype FMTypeWithPartials = FMSineWithPartials | FMSquareWithPartials | FMSawtoothWithPartials | FMTriangleWithPartials;\n\n/**\n * AM Oscillators with partials\n */\ntype AMSineWithPartials =\n\t\"amsine1\" | \"amsine2\" | \"amsine3\" | \"amsine4\" | \"amsine5\" | \"amsine6\" | \"amsine7\" | \"amsine8\" | \"amsine9\" |\n\t\"amsine10\" | \"amsine11\" | \"amsine12\" | \"amsine13\" | \"amsine14\" | \"amsine15\" | \"amsine16\" | \"amsine17\" | \"amsine18\" | \"amsine19\" |\n\t\"amsine20\" | \"amsine21\" | \"amsine22\" | \"amsine23\" | \"amsine24\" | \"amsine25\" | \"amsine26\" | \"amsine27\" | \"amsine28\" | \"amsine29\" |\n\t\"amsine30\" | \"amsine31\" | \"amsine32\";\n\ntype AMSquareWithPartials =\n\t\"amsquare1\" | \"amsquare2\" | \"amsquare3\" | \"amsquare4\" | \"amsquare5\" | \"amsquare6\" | \"amsquare7\" | \"amsquare8\" | \"amsquare9\" |\n\t\"amsquare10\" | \"amsquare11\" | \"amsquare12\" | \"amsquare13\" | \"amsquare14\" | \"amsquare15\" | \"amsquare16\" | \"amsquare17\" | \"amsquare18\" | \"amsquare19\" |\n\t\"amsquare20\" | \"amsquare21\" | \"amsquare22\" | \"amsquare23\" | \"amsquare24\" | \"amsquare25\" | \"amsquare26\" | \"amsquare27\" | \"amsquare28\" | \"amsquare29\" |\n\t\"amsquare30\" | \"amsquare31\" | \"amsquare32\";\n\ntype AMSawtoothWithPartials =\n\t\"amsawtooth1\" | \"amsawtooth2\" | \"amsawtooth3\" | \"amsawtooth4\" | \"amsawtooth5\" | \"amsawtooth6\" | \"amsawtooth7\" | \"amsawtooth8\" | \"amsawtooth9\" |\n\t\"amsawtooth10\" | \"amsawtooth11\" | \"amsawtooth12\" | \"amsawtooth13\" | \"amsawtooth14\" | \"amsawtooth15\" | \"amsawtooth16\" | \"amsawtooth17\" | \"amsawtooth18\" | \"amsawtooth19\" |\n\t\"amsawtooth20\" | \"amsawtooth21\" | \"amsawtooth22\" | \"amsawtooth23\" | \"amsawtooth24\" | \"amsawtooth25\" | \"amsawtooth26\" | \"amsawtooth27\" | \"amsawtooth28\" | \"amsawtooth29\" |\n\t\"amsawtooth30\" | \"amsawtooth31\" | \"amsawtooth32\";\n\ntype AMTriangleWithPartials =\n\t\"amtriangle1\" | \"amtriangle2\" | \"amtriangle3\" | \"amtriangle4\" | \"amtriangle5\" | \"amtriangle6\" | \"amtriangle7\" | \"amtriangle8\" | \"amtriangle9\" |\n\t\"amtriangle10\" | \"amtriangle11\" | \"amtriangle12\" | \"amtriangle13\" | \"amtriangle14\" | \"amtriangle15\" | \"amtriangle16\" | \"amtriangle17\" | \"amtriangle18\" | \"amtriangle19\" |\n\t\"amtriangle20\" | \"amtriangle21\" | \"amtriangle22\" | \"amtriangle23\" | \"amtriangle24\" | \"amtriangle25\" | \"amtriangle26\" | \"amtriangle27\" | \"amtriangle28\" | \"amtriangle29\" |\n\t\"amtriangle30\" | \"amtriangle31\" | \"amtriangle32\";\n\ntype AMTypeWithPartials = AMSineWithPartials | AMSquareWithPartials | AMSawtoothWithPartials | AMTriangleWithPartials;\n\n/**\n * Fat Oscillators with partials\n */\ntype FatSineWithPartials =\n\t\"fatsine1\" | \"fatsine2\" | \"fatsine3\" | \"fatsine4\" | \"fatsine5\" | \"fatsine6\" | \"fatsine7\" | \"fatsine8\" | \"fatsine9\" |\n\t\"fatsine10\" | \"fatsine11\" | \"fatsine12\" | \"fatsine13\" | \"fatsine14\" | \"fatsine15\" | \"fatsine16\" | \"fatsine17\" | \"fatsine18\" | \"fatsine19\" |\n\t\"fatsine20\" | \"fatsine21\" | \"fatsine22\" | \"fatsine23\" | \"fatsine24\" | \"fatsine25\" | \"fatsine26\" | \"fatsine27\" | \"fatsine28\" | \"fatsine29\" |\n\t\"fatsine30\" | \"fatsine31\" | \"fatsine32\";\n\ntype FatSquareWithPartials =\n\t\"fatsquare1\" | \"fatsquare2\" | \"fatsquare3\" | \"fatsquare4\" | \"fatsquare5\" | \"fatsquare6\" | \"fatsquare7\" | \"fatsquare8\" | \"fatsquare9\" |\n\t\"fatsquare10\" | \"fatsquare11\" | \"fatsquare12\" | \"fatsquare13\" | \"fatsquare14\" | \"fatsquare15\" | \"fatsquare16\" | \"fatsquare17\" | \"fatsquare18\" | \"fatsquare19\" |\n\t\"fatsquare20\" | \"fatsquare21\" | \"fatsquare22\" | \"fatsquare23\" | \"fatsquare24\" | \"fatsquare25\" | \"fatsquare26\" | \"fatsquare27\" | \"fatsquare28\" | \"fatsquare29\" |\n\t\"fatsquare30\" | \"fatsquare31\" | \"fatsquare32\";\n\ntype FatSawtoothWithPartials =\n\t\"fatsawtooth1\" | \"fatsawtooth2\" | \"fatsawtooth3\" | \"fatsawtooth4\" | \"fatsawtooth5\" | \"fatsawtooth6\" | \"fatsawtooth7\" | \"fatsawtooth8\" | \"fatsawtooth9\" |\n\t\"fatsawtooth10\" | \"fatsawtooth11\" | \"fatsawtooth12\" | \"fatsawtooth13\" | \"fatsawtooth14\" | \"fatsawtooth15\" | \"fatsawtooth16\" | \"fatsawtooth17\" | \"fatsawtooth18\" | \"fatsawtooth19\" |\n\t\"fatsawtooth20\" | \"fatsawtooth21\" | \"fatsawtooth22\" | \"fatsawtooth23\" | \"fatsawtooth24\" | \"fatsawtooth25\" | \"fatsawtooth26\" | \"fatsawtooth27\" | \"fatsawtooth28\" | \"fatsawtooth29\" |\n\t\"fatsawtooth30\" | \"fatsawtooth31\" | \"fatsawtooth32\";\n\ntype FatTriangleWithPartials =\n\t\"fattriangle1\" | \"fattriangle2\" | \"fattriangle3\" | \"fattriangle4\" | \"fattriangle5\" | \"fattriangle6\" | \"fattriangle7\" | \"fattriangle8\" | \"fattriangle9\" |\n\t\"fattriangle10\" | \"fattriangle11\" | \"fattriangle12\" | \"fattriangle13\" | \"fattriangle14\" | \"fattriangle15\" | \"fattriangle16\" | \"fattriangle17\" | \"fattriangle18\" | \"fattriangle19\" |\n\t\"fattriangle20\" | \"fattriangle21\" | \"fattriangle22\" | \"fattriangle23\" | \"fattriangle24\" | \"fattriangle25\" | \"fattriangle26\" | \"fattriangle27\" | \"fattriangle28\" | \"fattriangle29\" |\n\t\"fattriangle30\" | \"fattriangle31\" | \"fattriangle32\";\n\ntype FatTypeWithPartials = FatSineWithPartials | FatSquareWithPartials | FatSawtoothWithPartials | FatTriangleWithPartials;\n\n/**\n * Omni FM\n */\ninterface OmniFMCustomOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFMTypeOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: \"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFMPartialsOscillatorOptions extends FMBaseOscillatorOptions {\n\ttype: FMTypeWithPartials;\n}\n\n/**\n * Omni AM\n */\ninterface OmniAMCustomOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amcustom\";\n\tpartials: number[];\n}\n\ninterface OmniAMTypeOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: \"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniAMPartialsOscillatorOptions extends AMBaseOscillatorOptions {\n\ttype: AMTypeWithPartials;\n}\n\n/**\n * Omni Fat\n */\ninterface OmniFatCustomOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatcustom\";\n\tpartials: number[];\n}\n\ninterface OmniFatTypeOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: \"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\";\n\tpartialsCount?: number;\n}\n\ninterface OmniFatPartialsOscillatorOptions extends FatBaseOscillatorOptions {\n\ttype: FatTypeWithPartials;\n}\n\nexport type OmniOscillatorType =\n\t\"fatsine\" | \"fatsquare\" | \"fatsawtooth\" | \"fattriangle\" | \"fatcustom\" | FatTypeWithPartials |\n\t\"fmsine\" | \"fmsquare\" | \"fmsawtooth\" | \"fmtriangle\" | \"fmcustom\" | FMTypeWithPartials |\n\t\"amsine\" | \"amsquare\" | \"amsawtooth\" | \"amtriangle\" | \"amcustom\" | AMTypeWithPartials |\n\tTypeWithPartials | OscillatorType | \"pulse\" | \"pwm\";\n\nexport type OmniOscillatorOptions =\n\tPulseOscillatorOptions | PWMOscillatorOptions |\n\tOmniFatCustomOscillatorOptions | OmniFatTypeOscillatorOptions | OmniFatPartialsOscillatorOptions |\n\tOmniFMCustomOscillatorOptions | OmniFMTypeOscillatorOptions | OmniFMPartialsOscillatorOptions |\n\tOmniAMCustomOscillatorOptions | OmniAMTypeOscillatorOptions | OmniAMPartialsOscillatorOptions |\n\tToneOscillatorConstructorOptions;\n\ntype OmitSourceOptions<T extends BaseOscillatorOptions> = Omit<T, \"frequency\" | \"detune\" | \"context\">;\n\n/**\n * The settable options for the omni oscillator inside of the source which excludes certain attributes that are defined by the parent class\n */\nexport type OmniOscillatorSynthOptions =\n\tOmitSourceOptions<PulseOscillatorOptions> | OmitSourceOptions<PWMOscillatorOptions> |\n\tOmitSourceOptions<OmniFatCustomOscillatorOptions> | OmitSourceOptions<OmniFatTypeOscillatorOptions> | OmitSourceOptions<OmniFatPartialsOscillatorOptions> |\n\tOmitSourceOptions<OmniFMCustomOscillatorOptions> | OmitSourceOptions<OmniFMTypeOscillatorOptions> | OmitSourceOptions<OmniFMPartialsOscillatorOptions> |\n\tOmitSourceOptions<OmniAMCustomOscillatorOptions> | OmitSourceOptions<OmniAMTypeOscillatorOptions> | OmitSourceOptions<OmniAMPartialsOscillatorOptions> |\n\tOmitSourceOptions<ToneCustomOscillatorOptions> | OmitSourceOptions<ToneTypeOscillatorOptions> | OmitSourceOptions<TonePartialOscillatorOptions>\n", "import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { Cents, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OneShotSource, OneShotSourceOptions } from \"../OneShotSource\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface ToneOscillatorNodeOptions extends OneShotSourceOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\ttype: OscillatorType;\n}\n\n/**\n * Wrapper around the native fire-and-forget OscillatorNode.\n * Adds the ability to reschedule the stop method.\n * ***[[Oscillator]] is better for most use-cases***\n * @category Source\n */\nexport class ToneOscillatorNode extends OneShotSource<ToneOscillatorNodeOptions> {\n\n\treadonly name: string = \"ToneOscillatorNode\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _oscillator = this.context.createOscillator();\n\tprotected _internalChannels = [this._oscillator];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator\n\t */\n\treadonly detune: Param<\"cents\">;\n\n\t/**\n\t * @param  frequency   The frequency value\n\t * @param  type  The basic oscillator type\n\t */\n\tconstructor(\n\t\tfrequency: Frequency,\n\t\ttype: OscillatorType,\n\t);\n\tconstructor(options?: Partial<ToneOscillatorNodeOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(ToneOscillatorNode.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tconnect(this._oscillator, this._gainNode);\n\n\t\tthis.type = options.type;\n\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.frequency,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._oscillator.detune,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ToneOscillatorNodeOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\ttype: \"sine\" as OscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * Start the oscillator node at the given time\n\t * @param  time When to start the oscillator\n\t */\n\tstart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tthis._startGain(computedTime);\n\t\tthis._oscillator.start(computedTime);\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\t/**\n\t * Sets an arbitrary custom periodic waveform given a PeriodicWave.\n\t * @param  periodicWave PeriodicWave should be created with context.createPeriodicWave\n\t */\n\tsetPeriodicWave(periodicWave: PeriodicWave): this {\n\t\tthis._oscillator.setPeriodicWave(periodicWave);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type. Either 'sine', 'sawtooth', 'square', or 'triangle'\n\t */\n\tget type(): OscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type: OscillatorType) {\n\t\tthis._oscillator.type = type;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this.state === \"started\") {\n\t\t\tthis.stop();\n\t\t}\n\t\tthis._oscillator.disconnect();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AudioRange, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport {\n\tgenerateWaveform, ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\tprotected _restart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Tone.Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t\twave: PeriodicWave;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): { real: Float32Array; imag: Float32Array; partials: number[]; wave: PeriodicWave } | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { partials, wave } = cache;\n\t\t\t\tthis._wave = wave;\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t\twave: this._wave,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => fullPartials[i] = v);\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n", "import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { connectSignal } from \"./Signal\";\n\nexport type SignalOperatorOptions = ToneAudioNodeOptions;\n\n/**\n * A signal operator has an input and output and modifies the signal.\n */\nexport abstract class SignalOperator<Options extends SignalOperatorOptions> extends ToneAudioNode<Options> {\n\n\tconstructor(options?: Partial<Options>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(SignalOperator.getDefaults(), arguments, [\"context\"])));\n\t}\n\n\tconnect(destination: InputNode, outputNum = 0, inputNum = 0): this {\n\t\tconnectSignal(this, destination, outputNum, inputNum);\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * const shaper = new Tone.WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tassert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * AudioToGain converts an input in AudioRange [-1,1] to NormalRange [0,1].\n * See [[GainToAudio]].\n * @category Signal\n */\nexport class AudioToGain extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"AudioToGain\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => (x + 1) / 2,\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The GainRange output [0, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { InputNode, OutputNode } from \"../core/context/ToneAudioNode\";\n\n/**\n * Multiply two incoming signals. Or, if a number is given in the constructor,\n * multiplies the incoming signal by that value.\n *\n * @example\n * // multiply two signals\n * const mult = new Tone.Multiply();\n * const sigA = new Tone.Signal(3);\n * const sigB = new Tone.Signal(4);\n * sigA.connect(mult);\n * sigB.connect(mult.factor);\n * // output of mult is 12.\n * @example\n * // multiply a signal and a number\n * const mult = new Tone.Multiply(10);\n * const sig = new Tone.Signal(2).connect(mult);\n * // the output of mult is 20.\n * @category Signal\n */\nexport class Multiply<TypeName extends \"number\" | \"positive\" = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"Multiply\";\n\n\t/**\n\t * Indicates if the value should be overridden on connection\n\t */\n\treadonly override = false;\n\n\t/**\n\t * the input gain node\n\t */\n\tprivate _mult: Gain;\n\n\t/**\n\t * The multiplicand input.\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The product of the input and [[factor]]\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The multiplication factor. Can be set directly or a signal can be connected to it.\n\t */\n\tfactor: Param<TypeName>;\n\n\t/**\n\t * @param value Constant value to multiple\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Multiply.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._mult = this.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tminValue: options.minValue,\n\t\t\tmaxValue: options.maxValue,\n\t\t});\n\n\t\tthis.factor = this._param = this._mult.gain as unknown as Param<TypeName>;\n\t\tthis.factor.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): SignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tAMConstructorOptions, AMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType,\n\tToneOscillatorInterface,\n\tToneOscillatorType\n} from \"./OscillatorInterface\";\n\nexport { AMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * An amplitude modulated oscillator node. It is implemented with\n * two oscillators, one which modulators the other's amplitude\n * through a gain node.\n * ```\n *    +-------------+       +----------+\n *    | Carrier Osc +>------> GainNode |\n *    +-------------+       |          +--->Output\n *                      +---> gain     |\n * +---------------+    |   +----------+\n * | Modulator Osc +>---+\n * +---------------+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst amOsc = new Tone.AMOscillator(30, \"sine\", \"square\").toDestination().start();\n * }, 0.2, 1);\n * @category Source\n */\nexport class AMOscillator extends Source<AMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"AMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * convert the -1,1 output to 0,1\n\t */\n\tprivate _modulationScale = new AudioToGain({ context: this.context });\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const amOsc = new Tone.AMOscillator(\"D2\").toDestination().start();\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tamOsc.harmonicity.setValueAtTime(1, time);\n\t * \tamOsc.harmonicity.setValueAtTime(0.5, time + 0.5);\n\t * \tamOsc.harmonicity.setValueAtTime(1.5, time + 1);\n\t * \tamOsc.harmonicity.setValueAtTime(1, time + 2);\n\t * \tamOsc.harmonicity.linearRampToValueAtTime(2, time + 4);\n\t * }, 4);\n\t * Tone.Transport.start();\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode = new Gain({\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<AMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(AMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\t\tthis.frequency = this._carrier.frequency,\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\n\t\treadOnly(this, [\"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): AMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Seconds): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Seconds): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t}\n\n\t/**\n\t * The type of the carrier oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFMConstructorOptions, FMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const fmOsc = new Tone.FMOscillator(\"D2\").toDestination().start();\n\t * // pitch the modulator an octave below carrier\n\t * fmOsc.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { AudioRange, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { WaveShaper } from \"../../signal/WaveShaper\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform, PulseOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\n\nexport { PulseOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PulseOscillator is an oscillator with control over pulse width,\n * also known as the duty cycle. At 50% duty cycle (width = 0) the wave is\n * a square wave.\n * [Read more](https://wigglewave.wordpress.com/2014/08/16/pulse-waveforms-and-harmonics/).\n * ```\n *    width = -0.25        width = 0.0          width = 0.25\n *\n *   +-----+            +-------+       +    +-------+     +-+\n *   |     |            |       |       |            |     |\n *   |     |            |       |       |            |     |\n * +-+     +-------+    +       +-------+            +-----+\n *\n *\n *    width = -0.5                              width = 0.5\n *\n *     +---+                                 +-------+   +---+\n *     |   |                                         |   |\n *     |   |                                         |   |\n * +---+   +-------+                                 +---+\n *\n *\n *    width = -0.75                             width = 0.75\n *\n *       +-+                                 +-------+ +-----+\n *       | |                                         | |\n *       | |                                         | |\n * +-----+ +-------+                                 +-+\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst pulse = new Tone.PulseOscillator(50, 0.4).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PulseOscillator extends Source<PulseOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PulseOscillator\";\n\n\t/**\n\t * The width of the pulse.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst pulse = new Tone.PulseOscillator(20, 0.8).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\treadonly width: Signal<\"audioRange\">;\n\n\t/**\n\t * gate the width amount\n\t */\n\tprivate _widthGate: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * the sawtooth oscillator\n\t */\n\tprivate _triangle: Oscillator;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Threshold the signal to turn it into a square\n\t */\n\tprivate _thresh = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => val <= 0 ? -1 : 1,\n\t});\n\n\t/**\n\t * @param frequency The frequency of the oscillator\n\t * @param width The width of the pulse\n\t */\n\tconstructor(frequency?: Frequency, width?: AudioRange);\n\tconstructor(options?: Partial<PulseOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]));\n\t\tconst options = optionsFromArguments(PulseOscillator.getDefaults(), arguments, [\"frequency\", \"width\"]);\n\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: options.width,\n\t\t});\n\n\t\tthis._triangle = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: \"triangle\",\n\t\t});\n\t\tthis.frequency = this._triangle.frequency;\n\t\tthis.detune = this._triangle.detune;\n\n\t\t// connections\n\t\tthis._triangle.chain(this._thresh, this.output);\n\t\tthis.width.chain(this._widthGate, this._thresh);\n\t\treadOnly(this, [\"width\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PulseOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tphase: 0,\n\t\t\ttype: \"pulse\" as \"pulse\",\n\t\t\twidth: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._triangle.start(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._triangle.stop(time);\n\t\t// the width is still connected to the output.\n\t\t// that needs to be stopped also\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(0, time);\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._triangle.restart(time);\n\t\tthis._widthGate.gain.cancelScheduledValues(time);\n\t\tthis._widthGate.gain.setValueAtTime(1, time);\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._triangle.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._triangle.phase = phase;\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pulse\".\n\t */\n\tget type(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pulse\".\n\t */\n\tget baseType(): \"pulse\" {\n\t\treturn \"pulse\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * *Internal use* The carrier oscillator type is fed through the \n\t * waveshaper node to create the pulse. Using different carrier oscillators\n\t * changes oscillator's behavior. \n\t */\n\tset carrierType(type: \"triangle\" | \"sine\") {\n\t\tthis._triangle.type = type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up method.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._triangle.dispose();\n\t\tthis.width.dispose();\n\t\tthis._widthGate.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFatConstructorOptions, FatOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, spread?: Cents);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._forEach(osc => osc.restart(time));\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tvolume: -6 - count * 1.1,\n\t\t\t\t\ttype: this._type as NonCustomOscillatorType,\n\t\t\t\t\tphase: this._phase + (i / count) * 360,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t}\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.detune.overridden = false;\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach((osc, i) => osc.phase = this._phase + (i / this.count) * 360);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n", "import { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform, PWMOscillatorOptions, ToneOscillatorInterface } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\n\nexport { PWMOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * PWMOscillator modulates the width of a Tone.PulseOscillator\n * at the modulationFrequency. This has the effect of continuously\n * changing the timbre of the oscillator by altering the harmonics\n * generated.\n * @example\n * return Tone.Offline(() => {\n * \tconst pwm = new Tone.PWMOscillator(60, 0.3).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class PWMOscillator extends Source<PWMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"PWMOscillator\";\n\n\treadonly sourceType = \"pwm\";\n\n\t/**\n\t * the pulse oscillator\n\t */\n\tprivate _pulse: PulseOscillator;\n\t/**\n\t * the modulator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Scale the oscillator so it doesn't go silent\n\t * at the extreme values.\n\t */\n\tprivate _scale: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: 2,\n\t});\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune of the oscillator.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The width modulation rate of the oscillator.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst osc = new Tone.PWMOscillator(20, 2).toDestination().start();\n\t * }, 0.1, 1);\n\t */\n\treadonly modulationFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param {Frequency} frequency The starting frequency of the oscillator.\n\t * @param {Frequency} modulationFrequency The modulation frequency of the width of the pulse.\n\t */\n\tconstructor(frequency?: Frequency, modulationFrequency?: Frequency);\n\tconstructor(options?: Partial<PWMOscillatorOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]));\n\t\tconst options = optionsFromArguments(PWMOscillator.getDefaults(), arguments, [\"frequency\", \"modulationFrequency\"]);\n\n\t\tthis._pulse = new PulseOscillator({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.modulationFrequency,\n\t\t});\n\t\t// change the pulse oscillator type\n\t\tthis._pulse.carrierType = \"sine\";\n\n\t\tthis.modulationFrequency = this._pulse.frequency;\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: options.frequency,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t});\n\n\t\tthis.frequency = this._modulator.frequency;\n\t\tthis.detune = this._modulator.detune;\n\n\t\t// connections\n\t\tthis._modulator.chain(this._scale, this._pulse.width);\n\t\tthis._pulse.connect(this.output);\n\t\treadOnly(this, [\"modulationFrequency\", \"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): PWMOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tmodulationFrequency: 0.4,\n\t\t\tphase: 0,\n\t\t\ttype: \"pwm\" as \"pwm\",\n\t\t});\n\t}\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.start(time);\n\t\tthis._pulse.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._modulator.stop(time);\n\t\tthis._pulse.stop(time);\n\t}\n\n\t/**\n\t * restart the oscillator\n\t */\n\tprotected _restart(time: Seconds): void {\n\t\tthis._modulator.restart(time);\n\t\tthis._pulse.restart(time);\n\t}\n\n\t/**\n\t * The type of the oscillator. Always returns \"pwm\".\n\t */\n\tget type(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The baseType of the oscillator. Always returns \"pwm\".\n\t */\n\tget baseType(): \"pwm\" {\n\t\treturn \"pwm\";\n\t}\n\n\t/**\n\t * The partials of the waveform. Cannot set partials for this waveform type\n\t */\n\tget partials(): number[] {\n\t\treturn [];\n\t}\n\n\t/**\n\t * No partials for this waveform type.\n\t */\n\tget partialCount(): number {\n\t\treturn 0;\n\t}\n\n\t/**\n\t * The phase of the oscillator in degrees.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._modulator.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._pulse.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._modulator.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tgenerateWaveform,\n\tOmniOscillatorOptions, \n\tOmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates all of the oscillator types into one. \n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not. \n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator. See [[Oscillator.baseType]]\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n\t * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * See [[PWMOscillator.width]]\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types. \n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * See [[FMOscillator]].\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see [[PWMOscillator]]\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n", "import { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Signal, SignalOptions } from \"./Signal\";\n\n/**\n * Add a signal and a number or two signals. When no value is\n * passed into the constructor, Tone.Add will sum input and `addend`\n * If a value is passed into the constructor, the it will be added to the input.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst add = new Tone.Add(2).toDestination();\n * \tadd.addend.setValueAtTime(1, 0.2);\n * \tconst signal = new Tone.Signal(2);\n * \t// add a signal and a scalar\n * \tsignal.connect(add);\n * \tsignal.setValueAtTime(1, 0.1);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Add extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Add\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input = this._sum;\n\treadonly output = this._sum;\n\n\t/**\n\t * The value which is added to the input signal\n\t */\n\treadonly addend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value If no value is provided, will sum the input and [[addend]].\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Add.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, OutputNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Add } from \"./Add\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport interface ScaleOptions extends ToneAudioNodeOptions {\n\tmin: number;\n\tmax: number;\n}\n\n/**\n * Performs a linear scaling on an input signal.\n * Scales a NormalRange input to between\n * outputMin and outputMax.\n *\n * @example\n * const scale = new Tone.Scale(50, 100);\n * const signal = new Tone.Signal(0.5).connect(scale);\n * // the output of scale equals 75\n * @category Signal\n */\nexport class Scale<Options extends ScaleOptions = ScaleOptions> extends SignalOperator<Options> {\n\n\treadonly name: string = \"Scale\";\n\n\tinput: InputNode;\n\toutput: OutputNode;\n\n\t/**\n\t * Hold the multiple\n\t */\n\tprotected _mult: Multiply;\n\n\t/**\n\t * Hold the adder\n\t */\n\tprotected _add: Add;\n\n\t/**\n\t * Private reference to the min value\n\t */\n\tprivate _min: number;\n\n\t/**\n\t * Private reference to the max value\n\t */\n\tprivate _max: number;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t */\n\tconstructor(min?: number, max?: number);\n\tconstructor(options?: Partial<ScaleOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"])));\n\t\tconst options = optionsFromArguments(Scale.getDefaults(), arguments, [\"min\", \"max\"]);\n\n\t\tthis._mult = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.max - options.min,\n\t\t});\n\n\t\tthis._add = this.output = new Add({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.min,\n\t\t});\n\n\t\tthis._min = options.min;\n\t\tthis._max = options.max;\n\n\t\tthis.input.connect(this.output);\n\t}\n\n\tstatic getDefaults(): ScaleOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The minimum output value. This number is output when the value input value is 0.\n\t */\n\tget min(): number {\n\t\treturn this._min;\n\t}\n\tset min(min) {\n\t\tthis._min = min;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * The maximum output value. This number is output when the value input value is 1.\n\t */\n\tget max(): number {\n\t\treturn this._max;\n\t}\n\tset max(max) {\n\t\tthis._max = max;\n\t\tthis._setRange();\n\t}\n\n\t/**\n\t * set the values\n\t */\n\tprivate _setRange(): void {\n\t\tthis._add.value = this._min;\n\t\tthis._mult.value = this._max - this._min;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._add.dispose();\n\t\tthis._mult.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../core/context/Gain\";\nimport { connect, disconnect, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Tone.Zero outputs 0's at audio-rate. The reason this has to be\n * it's own class is that many browsers optimize out Tone.Signal\n * with a value of 0 and will not process nodes further down the graph.\n * @category Signal\n */\nexport class Zero extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Zero\";\n\n\t/**\n\t * The gain node which connects the constant source to the output\n\t */\n\tprivate _gain = new Gain({ context: this.context });\n\n\t/**\n\t * Only outputs 0\n\t */\n\toutput = this._gain;\n\n\t/**\n\t * no input node\n\t */\n\tinput = undefined;\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Zero.getDefaults(), arguments)));\n\t\tconnect(this.context.getConstant(0), this._gain);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tdisconnect(this.context.getConstant(0), this._gain);\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, Frequency, NormalRange, Time, UnitName } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorOptions } from \"./OscillatorInterface\";\n\nexport type LFOOptions = {\n\tmin: number;\n\tmax: number;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n} & ToneOscillatorOptions;\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the [[units]]\n\t */\n\tconvert = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n\n\t\tthis._oscillator = new Oscillator(options as ToneOscillatorConstructorOptions);\n\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.units = options.units;\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\ttype: \"sine\",\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * const lfo = new Tone.LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n\t */\n\tprivate _setStoppedValue() {\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator: See [[Oscillator.type]]\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The oscillator's partials array: See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tthis._oscillator.partials = partials;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\t// @ts-ignore\n\tprivate _clampValue = Param.prototype._clampValue;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n", "import { assertRange } from \"./Debug\";\nimport { Time } from \"../type/Units\";\n\n/**\n * Assert that the number is in the given range.\n */\nexport function range(min: number, max = Infinity) {\n\tconst valueMap: WeakMap<any, number> = new WeakMap();\n\treturn function(target: any, propertyKey: string | symbol) {\n\t\tReflect.defineProperty(\n\t\t\ttarget,\n\t\t\tpropertyKey,\n\t\t\t{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn valueMap.get(this);\n\t\t\t\t},\n\t\t\t\tset: function(newValue: number) {\n\t\t\t\t\tassertRange(newValue, min, max);\n\t\t\t\t\tvalueMap.set(this, newValue);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t};\n}\n\n/**\n * Convert the time to seconds and assert that the time is in between the two\n * values when being set.\n */\nexport function timeRange(min: number, max = Infinity) {\n\tconst valueMap: WeakMap<any, Time> = new WeakMap();\n\treturn function(target: any, propertyKey: string) {\n\t\tReflect.defineProperty(\n\t\t\ttarget,\n\t\t\tpropertyKey,\n\t\t\t{\n\t\t\t\tconfigurable: true,\n\t\t\t\tenumerable: true,\n\t\t\t\tget: function() {\n\t\t\t\t\treturn valueMap.get(this);\n\t\t\t\t},\n\t\t\t\tset: function(newValue: Time) {\n\t\t\t\t\tassertRange(this.toSeconds(newValue), min, max);\n\t\t\t\t\tvalueMap.set(this, newValue);\n\t\t\t\t}\n\t\t\t},\n\t\t);\n\t};\n}\n", "import { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isUndef } from \"../../core/util/TypeCheck\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { timeRange } from \"../../core/util/Decorator\";\n\nexport interface PlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tplaybackRate: Positive;\n\tloop: boolean;\n\tautostart: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n\treverse: boolean;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n}\n\n/**\n * Player is an audio file player with start, loop, and stop functions.\n * @example\n * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gong_1.mp3\").toDestination();\n * // play as soon as the buffer is loaded\n * player.autostart = true;\n * @category Source\n */\nexport class Player extends Source<PlayerOptions> {\n\n\treadonly name: string = \"Player\";\n\n\t/**\n\t * If the file should play as soon\n\t * as the buffer is loaded.\n\t */\n\tautostart: boolean;\n\n\t/**\n\t * The buffer\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * if the buffer should loop once it's over\n\t */\n\tprivate _loop: boolean;\n\n\t/**\n\t * if 'loop' is true, the loop will start at this position\n\t */\n\tprivate _loopStart: Time;\n\n\t/**\n\t * if 'loop' is true, the loop will end at this position\n\t */\n\tprivate _loopEnd: Time;\n\n\t/**\n\t * the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * All of the active buffer source nodes\n\t */\n\tprivate _activeSources: Set<ToneBufferSource> = new Set();\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\t@timeRange(0)\n\tfadeOut: Time;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<PlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Player.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer({\n\t\t\tonload: this._onload.bind(this, options.onload),\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis.autostart = options.autostart;\n\t\tthis._loop = options.loop;\n\t\tthis._loopStart = options.loopStart;\n\t\tthis._loopEnd = options.loopEnd;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.fadeIn = options.fadeIn;\n\t\tthis.fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tautostart: false,\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\treverse: false,\n\t\t});\n\t}\n\n\t/**\n\t * Load the audio file as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * Note: this does not need to be called if a url\n\t * was passed in to the constructor. Only use this\n\t * if you want to manually load a new url.\n\t * @param url The url of the buffer to load. Filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tawait this._buffer.load(url);\n\t\tthis._onload();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal callback when the buffer is loaded.\n\t */\n\tprivate _onload(callback: () => void = noOp): void {\n\t\tcallback();\n\t\tif (this.autostart) {\n\t\t\tthis.start();\n\t\t}\n\t}\n\n\t/**\n\t * Internal callback when the buffer is done playing.\n\t */\n\tprivate _onSourceEnd(source: ToneBufferSource): void {\n\t\t// invoke the onstop function\n\t\tthis.onstop(this);\n\n\t\t// delete the source from the active sources\n\t\tthis._activeSources.delete(source);\n\t\tif (this._activeSources.size === 0 && !this._synced &&\n\t\t\tthis._state.getValueAtTime(this.now()) === \"started\") {\n\t\t\t// remove the 'implicitEnd' event and replace with an explicit end\n\t\t\tthis._state.cancel(this.now());\n\t\t\tthis._state.setStateAtTime(\"stopped\", this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Play the buffer at the given startTime. Optionally add an offset\n\t * and/or duration which will play the buffer from a position\n\t * within the buffer for the given duration.\n\t *\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tsuper.start(time, offset, duration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(startTime?: Time, offset?: Time, duration?: Time): void {\n\t\t// if it's a loop the default offset is the loopStart point\n\t\tif (this._loop) {\n\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\n\t\t// compute the values in seconds\n\t\tconst computedOffset = this.toSeconds(offset);\n\n\t\t// compute the duration which is either the passed in duration of the buffer.duration - offset\n\t\tconst origDuration = duration;\n\t\tduration = defaultArg(duration, Math.max(this._buffer.duration - computedOffset, 0));\n\t\tlet computedDuration = this.toSeconds(duration);\n\n\t\t// scale it by the playback rate\n\t\tcomputedDuration = computedDuration / this._playbackRate;\n\n\t\t// get the start time\n\t\tstartTime = this.toSeconds(startTime);\n\n\t\t// make the source\n\t\tconst source = new ToneBufferSource({\n\t\t\turl: this._buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this.fadeIn,\n\t\t\tfadeOut: this.fadeOut,\n\t\t\tloop: this._loop,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\tloopStart: this._loopStart,\n\t\t\tonended: this._onSourceEnd.bind(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\n\t\t// set the looping properties\n\t\tif (!this._loop && !this._synced) {\n\t\t\t// cancel the previous stop\n\t\t\tthis._state.cancel(startTime + computedDuration);\n\t\t\t// if it's not looping, set the state change at the end of the sample\n\t\t\tthis._state.setStateAtTime(\"stopped\", startTime + computedDuration, {\n\t\t\t\timplicitEnd: true,\n\t\t\t});\n\t\t}\n\n\t\t// add it to the array of active sources\n\t\tthis._activeSources.add(source);\n\n\t\t// start it\n\t\tif (this._loop && isUndef(origDuration)) {\n\t\t\tsource.start(startTime, computedOffset);\n\t\t} else {\n\t\t\t// subtract the fade out time\n\t\t\tsource.start(startTime, computedOffset, computedDuration - this.toSeconds(this.fadeOut));\n\t\t}\n\t}\n\n\t/**\n\t * Stop playback.\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(source => source.stop(computedTime));\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Seek to a specific time in the player's buffer. If the\n\t * source is no longer playing at that time, it will stop.\n\t * @param offset The time to seek to.\n\t * @param when The time for the seek event to occur.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/gurgling_theremin_1.mp3\", () => {\n\t * \tplayer.start();\n\t * \t// seek to the offset in 1 second from now\n\t * \tplayer.seek(0.4, \"+1\");\n\t * }).toDestination();\n\t */\n\tseek(offset: Time, when?: Time): this {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tconst computedOffset = this.toSeconds(offset);\n\t\t\t// if it's currently playing, stop it\n\t\t\tthis._stop(computedTime);\n\t\t\t// restart it at the given time\n\t\t\tthis._start(computedTime, computedOffset);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the loop start and end. Will only loop if loop is set to true.\n\t * @param loopStart The loop start time\n\t * @param loopEnd The loop end time\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/malevoices_aa2_F3.mp3\").toDestination();\n\t * // loop between the given points\n\t * player.setLoopPoints(0.2, 0.3);\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tsetLoopPoints(loopStart: Time, loopEnd: Time): this {\n\t\tthis.loopStart = loopStart;\n\t\tthis.loopEnd = loopEnd;\n\t\treturn this;\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = loopStart;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopStart), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopStart = loopStart;\n\t\t});\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = loopEnd;\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(loopEnd), 0, this.buffer.duration);\n\t\t}\n\t\t// get the current source\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loopEnd = loopEnd;\n\t\t});\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/drum-samples/breakbeat.mp3\").toDestination();\n\t * player.loop = true;\n\t * player.autostart = true;\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\t// if no change, do nothing\n\t\tif (this._loop === loop) {\n\t\t\treturn;\n\t\t}\n\t\tthis._loop = loop;\n\t\t// set the loop of all of the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.loop = loop;\n\t\t});\n\t\tif (loop) {\n\t\t\t// remove the next stopEvent\n\t\t\tconst stopEvent = this._state.getNextState(\"stopped\", this.now());\n\t\t\tif (stopEvent) {\n\t\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Normal speed is 1. The pitch will change with the playback rate.\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/femalevoices_aa2_A5.mp3\").toDestination();\n\t * // play at 1/4 speed\n\t * player.playbackRate = 0.25;\n\t * // play as soon as the buffer is loaded\n\t * player.autostart = true;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tconst now = this.now();\n\n\t\t// cancel the stop event since it's at a different time now\n\t\tconst stopEvent = this._state.getNextState(\"stopped\", now);\n\t\tif (stopEvent && stopEvent.implicitEnd) {\n\t\t\tthis._state.cancel(stopEvent.time);\n\t\t\tthis._activeSources.forEach(source => source.cancelStop());\n\t\t}\n\n\t\t// set all the sources\n\t\tthis._activeSources.forEach(source => {\n\t\t\tsource.playbackRate.setValueAtTime(rate, now);\n\t\t});\n\t}\n\n\t/**\n\t * If the buffer should be reversed\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/chime_1.mp3\").toDestination();\n\t * player.autostart = true;\n\t * player.reverse = true;\n\t */\n\tget reverse(): boolean {\n\t\treturn this._buffer.reverse;\n\t}\n\tset reverse(rev) {\n\t\tthis._buffer.reverse = rev;\n\t}\n\n\t/**\n\t * If the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t// disconnect all of the players\n\t\tthis._activeSources.forEach(source => source.dispose());\n\t\tthis._activeSources.clear();\n\t\tthis._buffer.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Volume } from \"../../component/channel/Volume\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers, ToneAudioBuffersUrlMap } from \"../../core/context/ToneAudioBuffers\";\nimport { OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { assert } from \"../../core/util/Debug\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { Source, SourceOptions } from \"../Source\";\nimport { Player } from \"./Player\";\n\nexport interface PlayersOptions extends SourceOptions {\n\turls: ToneAudioBuffersUrlMap;\n\tvolume: Decibels;\n\tmute: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Players combines multiple [[Player]] objects.\n * @category Source\n */\nexport class Players extends ToneAudioNode<PlayersOptions> {\n\n\treadonly name: string = \"Players\";\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * The combined output of all of the players\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * Players has no input.\n\t */\n\treadonly input = undefined;\n\n\t/**\n\t * The container of all of the players\n\t */\n\tprivate _players: Map<string, Player> = new Map();\n\n\t/**\n\t * The container of all the buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * private holder of the fadeIn time\n\t */\n\tprivate _fadeIn: Time;\n\n\t/**\n\t * private holder of the fadeOut time\n\t */\n\tprivate _fadeOut: Time;\n\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param onload The function to invoke when all buffers are loaded.\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, onload?: () => void);\n\t/**\n\t * @param urls An object mapping a name to a url.\n\t * @param options The remaining options associated with the players\n\t */\n\tconstructor(urls?: ToneAudioBuffersUrlMap, options?: Partial<Omit<PlayersOptions, \"urls\">>);\n\tconstructor(options?: Partial<PlayersOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Players.getDefaults(), arguments, [\"urls\", \"onload\"], \"urls\");\n\n\t\t/**\n\t\t * The output volume node\n\t\t */\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: options.urls, \n\t\t\tonload: options.onload, \n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror\n\t\t});\n\t\t// mute initially\n\t\tthis.mute = options.mute;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): PlayersOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tbaseUrl: \"\",\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tmute: false,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\turls: {},\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Mute the output.\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t/**\n\t * The fadeIn time of the envelope applied to the source.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(fadeIn) {\n\t\tthis._fadeIn = fadeIn;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeIn = fadeIn;\n\t\t});\n\t}\n\n\t/**\n\t * The fadeOut time of the each of the sources.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(fadeOut) {\n\t\tthis._fadeOut = fadeOut;\n\t\tthis._players.forEach(player => {\n\t\t\tplayer.fadeOut = fadeOut;\n\t\t});\n\t}\n\n\t/**\n\t * The state of the players object. Returns \"started\" if any of the players are playing.\n\t */\n\tget state(): BasicPlaybackState {\n\t\tconst playing = Array.from(this._players).some(([_, player]) => player.state === \"started\");\n\t\treturn playing ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * True if the buffers object has a buffer by that name.\n\t * @param name  The key or index of the buffer.\n\t */\n\thas(name: string): boolean {\n\t\treturn this._buffers.has(name);\n\t}\n\n\t/**\n\t * Get a player by name.\n\t * @param  name  The players name as defined in the constructor object or `add` method.\n\t */\n\tplayer(name: string): Player {\n\t\tassert(this.has(name), `No Player with the name ${name} exists on this object`);\n\t\tif (!this._players.has(name)) {\n\t\t\tconst player = new Player({\n\t\t\t\tcontext: this.context,\n\t\t\t\tfadeIn: this._fadeIn,\n\t\t\t\tfadeOut: this._fadeOut,\n\t\t\t\turl: this._buffers.get(name),\n\t\t\t}).connect(this.output);\n\t\t\tthis._players.set(name, player);\n\t\t}\n\t\treturn this._players.get(name) as Player;\n\t}\n\n\t/**\n\t * If all the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Add a player by name and url to the Players\n\t * @param  name A unique name to give the player\n\t * @param  url  Either the url of the bufer or a buffer which will be added with the given name.\n\t * @param callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(name: string, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tassert(!this._buffers.has(name), \"A buffer with that name already exists on this object\");\n\t\tthis._buffers.add(name, url, callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop all of the players at the given time\n\t * @param time The time to stop all of the players.\n\t */\n\tstopAll(time?: Time): this {\n\t\tthis._players.forEach(player => player.stop(time));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._players.forEach(player => player.dispose());\n\t\tthis._buffers.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Source, SourceOptions } from \"../Source\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Clock } from \"../../core/clock/Clock\";\nimport { Cents, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { ToneBufferSource } from \"./ToneBufferSource\";\nimport { intervalToFrequencyRatio } from \"../../core/type/Conversions\";\nimport { assertRange } from \"../../core/util/Debug\";\n\ninterface GrainPlayerOptions extends SourceOptions {\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\treverse: boolean;\n\turl?: ToneAudioBuffer | string | AudioBuffer;\n\toverlap: Seconds;\n\tgrainSize: Seconds;\n\tplaybackRate: Positive;\n\tdetune: Cents;\n\tloop: boolean;\n\tloopStart: Time;\n\tloopEnd: Time;\n}\n\n/**\n * GrainPlayer implements [granular synthesis](https://en.wikipedia.org/wiki/Granular_synthesis).\n * Granular Synthesis enables you to adjust pitch and playback rate independently. The grainSize is the\n * amount of time each small chunk of audio is played for and the overlap is the\n * amount of crossfading transition time between successive grains.\n * @category Source\n */\nexport class GrainPlayer extends Source<GrainPlayerOptions> {\n\n\treadonly name: string = \"GrainPlayer\";\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tbuffer: ToneAudioBuffer;\n\n\t/**\n\t * Create a repeating tick to schedule the grains.\n\t */\n\tprivate _clock: Clock;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopStart = 0;\n\n\t/**\n\t * Internal loopStart value\n\t */\n\tprivate _loopEnd = 0;\n\n\t/**\n\t * All of the currently playing BufferSources\n\t */\n\tprivate _activeSources: ToneBufferSource[] = [];\n\n\t/**\n\t * Internal reference to the playback rate\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * Internal grain size reference;\n\t */\n\tprivate _grainSize: Seconds;\n\n\t/**\n\t * Internal overlap reference;\n\t */\n\tprivate _overlap: Seconds;\n\n\t/**\n\t * Adjust the pitch independently of the playbackRate.\n\t */\n\tdetune: Cents;\n\n\t/**\n\t * If the buffer should loop back to the loopStart when completed\n\t */\n\tloop: boolean;\n\n\t/**\n\t * @param url Either the AudioBuffer or the url from which to load the AudioBuffer\n\t * @param onload The function to invoke when the buffer is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<GrainPlayerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(GrainPlayer.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis.buffer = new ToneAudioBuffer({\n\t\t\tonload: options.onload,\n\t\t\tonerror: options.onerror,\n\t\t\treverse: options.reverse,\n\t\t\turl: options.url,\n\t\t});\n\t\tthis._clock = new Clock({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tfrequency: 1 / options.grainSize\n\t\t});\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._grainSize = options.grainSize;\n\t\tthis._overlap = options.overlap;\n\t\tthis.detune = options.detune;\n\n\t\t// setup\n\t\tthis.overlap = options.overlap;\n\t\tthis.loop = options.loop;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.grainSize = options.grainSize;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.reverse = options.reverse;\n\t\tthis._clock.on(\"stop\", this._onstop.bind(this));\n\t}\n\n\tstatic getDefaults(): GrainPlayerOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\toverlap: 0.1,\n\t\t\tgrainSize: 0.2,\n\t\t\tplaybackRate: 1,\n\t\t\tdetune: 0,\n\t\t\tloop: false,\n\t\t\tloopStart: 0,\n\t\t\tloopEnd: 0,\n\t\t\treverse: false\n\t\t});\n\t}\n\n\t/**\n\t * Internal start method\n\t */\n\tprotected _start(time?: Time, offset?: Time, duration?: Time): void {\n\t\toffset = defaultArg(offset, 0);\n\t\toffset = this.toSeconds(offset);\n\t\ttime = this.toSeconds(time);\n\n\t\tconst grainSize = 1 / this._clock.frequency.getValueAtTime(time);\n\t\tthis._clock.start(time, offset / grainSize);\n\n\t\tif (duration) {\n\t\t\tthis.stop(time + this.toSeconds(duration));\n\t\t}\n\t}\n\n\t/**\n\t * Stop and then restart the player from the beginning (or offset)\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, \n\t * \t\t\t\t\tit will default to the full length of the sample (minus any offset)\n\t */\n\trestart(time?: Seconds, offset?: Time, duration?: Time): this {\n\t\tsuper.restart(time, offset, duration);\n\t\treturn this;\n\t}\n\n\tprotected _restart(time?: Seconds, offset?: Time, duration?: Time): void {\n\t\tthis._stop(time);\n\t\tthis._start(time, offset, duration);\n\t}\n\n\t/**\n\t * Internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tthis._clock.stop(time);\n\t}\n\n\t/**\n\t * Invoked when the clock is stopped\n\t */\n\tprivate _onstop(time: Seconds): void {\n\t\t// stop the players\n\t\tthis._activeSources.forEach((source) => {\n\t\t\tsource.fadeOut = 0;\n\t\t\tsource.stop(time);\n\t\t});\n\t\tthis.onstop(this);\n\t}\n\n\t/**\n\t * Invoked on each clock tick. scheduled a new grain at this time.\n\t */\n\tprivate _tick(time: Seconds): void {\n\t\t// check if it should stop looping\n\t\tconst ticks = this._clock.getTicksAtTime(time);\n\t\tconst offset = ticks * this._grainSize;\n\t\tthis.log(\"offset\", offset);\n\n\t\tif (!this.loop && offset > this.buffer.duration) {\n\t\t\tthis.stop(time);\n\t\t\treturn;\n\t\t}\n\n\t\t// at the beginning of the file, the fade in should be 0\n\t\tconst fadeIn = offset < this._overlap ? 0 : this._overlap;\n\n\t\t// create a buffer source\n\t\tconst source = new ToneBufferSource({\n\t\t\tcontext: this.context,\n\t\t\turl: this.buffer,\n\t\t\tfadeIn: fadeIn,\n\t\t\tfadeOut: this._overlap,\n\t\t\tloop: this.loop,\n\t\t\tloopStart: this._loopStart,\n\t\t\tloopEnd: this._loopEnd,\n\t\t\t// compute the playbackRate based on the detune\n\t\t\tplaybackRate: intervalToFrequencyRatio(this.detune / 100)\n\t\t}).connect(this.output);\n\n\t\tsource.start(time, this._grainSize * ticks);\n\t\tsource.stop(time + this._grainSize / this.playbackRate);\n\n\t\t// add it to the active sources\n\t\tthis._activeSources.push(source);\n\t\t// remove it when it's done\n\t\tsource.onended = () => {\n\t\t\tconst index = this._activeSources.indexOf(source);\n\t\t\tif (index !== -1) {\n\t\t\t\tthis._activeSources.splice(index, 1);\n\t\t\t}\n\t\t};\n\t}\n\n\t/**\n\t * The playback rate of the sample\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tassertRange(rate, 0.001);\n\t\tthis._playbackRate = rate;\n\t\tthis.grainSize = this._grainSize;\n\t}\n\n\t/**\n\t * The loop start time.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(time) {\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(time), 0, this.buffer.duration);\n\t\t}\n\t\tthis._loopStart = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The loop end time.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(time) {\n\t\tif (this.buffer.loaded) {\n\t\t\tassertRange(this.toSeconds(time), 0, this.buffer.duration);\n\t\t}\n\t\tthis._loopEnd = this.toSeconds(time);\n\t}\n\n\t/**\n\t * The direction the buffer should play in\n\t */\n\tget reverse() {\n\t\treturn this.buffer.reverse;\n\t}\n\n\tset reverse(rev) {\n\t\tthis.buffer.reverse = rev;\n\t}\n\n\t/**\n\t * The size of each chunk of audio that the\n\t * buffer is chopped into and played back at.\n\t */\n\tget grainSize(): Time {\n\t\treturn this._grainSize;\n\t}\n\tset grainSize(size) {\n\t\tthis._grainSize = this.toSeconds(size);\n\t\tthis._clock.frequency.setValueAtTime(this._playbackRate / this._grainSize, this.now());\n\t}\n\n\t/**\n\t * The duration of the cross-fade between successive grains.\n\t */\n\tget overlap(): Time {\n\t\treturn this._overlap;\n\t}\n\tset overlap(time) {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassertRange(computedTime, 0);\n\t\tthis._overlap = computedTime;\n\t}\n\n\t/**\n\t * If all the buffer is loaded\n\t */\n\tget loaded(): boolean {\n\t\treturn this.buffer.loaded;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.buffer.dispose();\n\t\tthis._clock.dispose();\n\t\tthis._activeSources.forEach((source) => source.dispose());\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * Return the absolute value of an incoming signal.\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst abs = new Tone.Abs().toDestination();\n * \tconst signal = new Tone.Signal(1);\n * \tsignal.rampTo(-1, 0.5);\n * \tsignal.connect(abs);\n * }, 0.5, 1);\n * @category Signal\n */\nexport class Abs extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Abs\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _abs = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: val => {\n\t\t\tif (Math.abs(val) < 0.001) {\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn Math.abs(val);\n\t\t\t}\n\t\t},\n\t});\n\n\t/**\n\t * The AudioRange input [-1, 1]\n\t */\n\tinput = this._abs;\n\n\t/**\n\t * The output range [0, 1]\n\t */\n\toutput = this._abs;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { WaveShaper } from \"./WaveShaper\";\n\n/**\n * GainToAudio converts an input in NormalRange [0,1] to AudioRange [-1,1].\n * See [[AudioToGain]].\n * @category Signal\n */\nexport class GainToAudio extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"GainToAudio\";\n\n\t/**\n\t * The node which converts the audio ranges\n\t */\n\tprivate _norm = new WaveShaper({\n\t\tcontext: this.context,\n\t\tmapping: x => Math.abs(x) * 2 - 1,\n\t});\n\n\t/**\n\t * The NormalRange input [0, 1]\n\t */\n\tinput = this._norm;\n\n\t/**\n\t * The AudioRange output [-1, 1]\n\t */\n\toutput = this._norm;\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._norm.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Multiply } from \"./Multiply\";\nimport { SignalOperator } from \"./SignalOperator\";\n\n/**\n * Negate the incoming signal. i.e. an input signal of 10 will output -10\n *\n * @example\n * const neg = new Tone.Negate();\n * const sig = new Tone.Signal(-2).connect(neg);\n * // output of neg is positive 2.\n * @category Signal\n */\nexport class Negate extends SignalOperator<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"Negate\";\n\n\t/**\n\t * negation is done by multiplying by -1\n\t */\n\tprivate _multiply: Multiply = new Multiply({\n\t\tcontext: this.context,\n\t\tvalue: -1,\n\t});\n\n\t/**\n\t * The input and output are equal to the multiply node\n\t */\n\tinput = this._multiply;\n\toutput = this._multiply;\n\n\t/**\n\t * clean up\n\t * @returns {Negate} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._multiply.dispose();\n\t\treturn this;\n\t}\n}\n", "import { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal, SignalOptions } from \"../signal/Signal\";\n\n/**\n * Subtract the signal connected to the input is subtracted from the signal connected\n * The subtrahend.\n *\n * @example\n * // subtract a scalar from a signal\n * const sub = new Tone.Subtract(1);\n * const sig = new Tone.Signal(4).connect(sub);\n * // the output of sub is 3.\n * @example\n * // subtract two signals\n * const sub = new Tone.Subtract();\n * const sigA = new Tone.Signal(10);\n * const sigB = new Tone.Signal(2.5);\n * sigA.connect(sub);\n * sigB.connect(sub.subtrahend);\n * // output of sub is 7.5\n * @category Signal\n */\nexport class Subtract extends Signal {\n\n\toverride = false;\n\n\treadonly name: string = \"Subtract\";\n\n\t/**\n\t * the summing node\n\t */\n\tprivate _sum: Gain = new Gain({ context: this.context });\n\treadonly input: Gain = this._sum;\n\treadonly output: Gain = this._sum;\n\n\t/**\n\t * Negate the input of the second input before connecting it to the summing node.\n\t */\n\tprivate _neg: Negate = new Negate({ context: this.context });\n\n\t/**\n\t * The value which is subtracted from the main signal\n\t */\n\tsubtrahend: Param<\"number\"> = this._param;\n\n\t/**\n\t * @param value The value to subtract from the incoming signal. If the value\n\t *             is omitted, it will subtract the second signal from the first.\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<SignalOptions<\"number\">>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Subtract.getDefaults(), arguments, [\"value\"])));\n\n\t\tconnectSeries(this._constantSource, this._neg, this._sum);\n\t}\n\n\tstatic getDefaults(): SignalOptions<\"number\"> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._neg.dispose();\n\t\tthis._sum.dispose();\n\t\treturn this;\n\t}\n}\n", "import { SignalOperator, SignalOperatorOptions } from \"./SignalOperator\";\nimport { Multiply } from \"./Multiply\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { WaveShaper } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\n\nexport type GreaterThanZeroOptions = SignalOperatorOptions\n\n/**\n * GreaterThanZero outputs 1 when the input is strictly greater than zero\n * @example\n * return Tone.Offline(() => {\n * \tconst gt0 = new Tone.GreaterThanZero().toDestination();\n * \tconst sig = new Tone.Signal(0.5).connect(gt0);\n * \tsig.setValueAtTime(-1, 0.05);\n * }, 0.1, 1);\n * @category Signal\n */\nexport class GreaterThanZero extends SignalOperator<GreaterThanZeroOptions> {\n\n\treadonly name: string = \"GreaterThanZero\";\n\n\t/**\n\t * The waveshaper\n\t */\n\tprivate _thresh: WaveShaper;\n\n\t/**\n\t * Scale the first thresholded signal by a large value.\n\t * this will help with values which are very close to 0\n\t */\n\tprivate _scale: Multiply;\n\n\treadonly output: ToneAudioNode;\n\treadonly input: ToneAudioNode;\n\n\tconstructor(options?: Partial<GreaterThanZeroOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(GreaterThanZero.getDefaults(), arguments)));\n\n\t\tthis._thresh = this.output = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 127,\n\t\t\tmapping: (val) => {\n\t\t\t\tif (val <= 0) {\n\t\t\t\t\treturn 0;\n\t\t\t\t} else {\n\t\t\t\t\treturn 1;\n\t\t\t\t}\n\t\t\t},\n\t\t});\n\t\tthis._scale = this.input = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 10000\n\t\t});\n\n\t\t// connections\n\t\tthis._scale.connect(this._thresh);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._scale.dispose();\n\t\tthis._thresh.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Subtract } from \"./Subtract\";\nimport { Signal, SignalOptions } from \"./Signal\";\nimport { GreaterThanZero } from \"./GreaterThanZero\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\n\nexport type GreaterThanOptions = SignalOptions<\"number\">;\n\n/**\n * Output 1 if the signal is greater than the value, otherwise outputs 0.\n * can compare two signals or a signal and a number.\n * \n * @example\n * return Tone.Offline(() => {\n * \tconst gt = new Tone.GreaterThan(2).toDestination();\n * \tconst sig = new Tone.Signal(4).connect(gt);\n * }, 0.1, 1);\n * @category Signal\n */\nexport class GreaterThan extends Signal<\"number\"> {\n\n\treadonly name: string = \"GreaterThan\"\n\n\treadonly override: boolean = false;\n\n\treadonly input: ToneAudioNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * compare that amount to zero after subtracting\n\t */\n\tprivate _gtz: GreaterThanZero;\n\n\t/**\n\t * Subtract the value from the input node\n\t */\n\tprivate _subtract: Subtract;\n\n\t/**\n\t * The signal to compare to the incoming signal against.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \t// change the comparison value\n\t * \tconst gt = new Tone.GreaterThan(1.5).toDestination();\n\t * \tconst signal = new Tone.Signal(1).connect(gt);\n\t * \tgt.comparator.setValueAtTime(0.5, 0.1);\n\t * }, 0.5, 1);\n\t */\n\treadonly comparator: Param<\"number\">\n\n\t/**\n\t * @param value The value to compare to\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<GreaterThanOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(GreaterThan.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(GreaterThan.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._subtract = this.input = new Subtract({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.value\n\t\t});\n\t\tthis._gtz = this.output = new GreaterThanZero({ context: this.context });\n\n\t\tthis.comparator = this._param = this._subtract.subtrahend;\n\t\treadOnly(this, \"comparator\");\n\n\t\t// connect\n\t\tthis._subtract.connect(this._gtz);\n\t}\n\n\tstatic getDefaults(): GreaterThanOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tvalue: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gtz.dispose();\n\t\tthis._subtract.dispose();\n\t\tthis.comparator.dispose();\n\t\treturn this;\n\t}\n}\n", "import { WaveShaper, WaveShaperMappingFn } from \"./WaveShaper\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { SignalOperator } from \"./SignalOperator\";\nimport { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\n\nexport interface PowOptions extends ToneAudioNodeOptions {\n\tvalue: number;\n}\n\n/**\n * Pow applies an exponent to the incoming signal. The incoming signal must be AudioRange [-1, 1]\n *\n * @example\n * const pow = new Tone.Pow(2);\n * const sig = new Tone.Signal(0.5).connect(pow);\n * // output of pow is 0.25. \n * @category Signal\n */\nexport class Pow extends SignalOperator<PowOptions> {\n\n\treadonly name: string = \"Pow\";\n\n\tprivate _exponent: number;\n\n\tprivate _exponentScaler: WaveShaper;\n\n\tinput: WaveShaper;\n\n\toutput: WaveShaper;\n\n\t/**\n\t * @param value Constant exponent value to use\n\t */\n\tconstructor(value?: number);\n\tconstructor(options?: Partial<PowOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"])));\n\t\tconst options = optionsFromArguments(Pow.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis._exponentScaler = this.input = this.output = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tmapping: this._expFunc(options.value),\n\t\t\tlength: 8192,\n\t\t});\n\n\t\tthis._exponent = options.value;\n\t}\n\n\tstatic getDefaults(): PowOptions {\n\t\treturn Object.assign(SignalOperator.getDefaults(), {\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\t/**\n\t * the function which maps the waveshaper\n\t * @param exponent exponent value\n\t */\n\tprivate _expFunc(exponent: number): WaveShaperMappingFn {\n\t\treturn (val: number) => {\n\t\t\treturn Math.pow(Math.abs(val), exponent);\n\t\t};\n\t}\n\n\t/**\n\t * The value of the exponent.\n\t */\n\tget value(): number {\n\t\treturn this._exponent;\n\t}\n\tset value(exponent: number) {\n\t\tthis._exponent = exponent;\n\t\tthis._exponentScaler.setMap(this._expFunc(this._exponent));\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponentScaler.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Scale, ScaleOptions } from \"./Scale\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Pow } from \"./Pow\";\n\nexport interface ScaleExpOptions extends ScaleOptions {\n\texponent: Positive;\n}\n\n/**\n * Performs an exponential scaling on an input signal.\n * Scales a NormalRange value [0,1] exponentially\n * to the output range of outputMin to outputMax.\n * @example\n * const scaleExp = new Tone.ScaleExp(0, 100, 2);\n * const signal = new Tone.Signal(0.5).connect(scaleExp);\n * @category Signal\n */\nexport class ScaleExp extends Scale<ScaleExpOptions> {\n\n\treadonly name: string = \"ScaleExp\";\n\n\t/**\n\t * The exponent scaler\n\t */\n\tprivate _exp: Pow;\n\n\t/**\n\t * @param min The output value when the input is 0.\n\t * @param max The output value when the input is 1.\n\t * @param exponent The exponent which scales the incoming signal.\n\t */\n\tconstructor(min?: number, max?: number, exponent?: number);\n\tconstructor(options?: Partial<ScaleExpOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"])));\n\t\tconst options = optionsFromArguments(ScaleExp.getDefaults(), arguments, [\"min\", \"max\", \"exponent\"]);\n\n\t\tthis.input = this._exp = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent,\n\t\t});\n\t\tthis._exp.connect(this._mult);\n\t}\n\n\tstatic getDefaults(): ScaleExpOptions {\n\t\treturn Object.assign(Scale.getDefaults(), {\n\t\t\texponent: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Instead of interpolating linearly between the [[min]] and\n\t * [[max]] values, setting the exponent will interpolate between\n\t * the two values with an exponential curve.\n\t */\n\tget exponent(): Positive {\n\t\treturn this._exp.value;\n\t}\n\tset exponent(exp) {\n\t\tthis._exp.value = exp;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exp.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Signal, SignalOptions } from \"./Signal\";\nimport { NormalRange, Seconds, Time, TransportTime, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\nimport { OutputNode } from \"../core/context/ToneAudioNode\";\n\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport class SyncedSignal<TypeName extends UnitName = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"SyncedSignal\";\n\t\n\t/**\n\t * Don't override when something is connected to the input\n\t */\n\treadonly override = false;\n\n\treadonly output: OutputNode;\n\n\t/**\n\t * Keep track of the last value as an optimization.\n\t */\n\tprivate _lastVal: UnitMap[TypeName];\n\n\t/**\n\t * The ID returned from scheduleRepeat\n\t */\n\tprivate _synced: number;\n\n\t/**\n\t * Remember the callback value\n\t */\n\tprivate _syncedCallback: () => void;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis._lastVal = options.value;\n\t\tthis._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n\n\t\tthis._syncedCallback = this._anchorValue.bind(this);\n\t\tthis.context.transport.on(\"start\", this._syncedCallback);\n\t\tthis.context.transport.on(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.on(\"stop\", this._syncedCallback);\n\n\t\t// disconnect the constant source from the output and replace it with another one\n\t\tthis._constantSource.disconnect();\n\t\tthis._constantSource.stop(0);\n\n\t\t// create a new one\n\t\tthis._constantSource = this.output = new ToneConstantSource<TypeName>({ \n\t\t\tcontext: this.context,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t}).start(0);\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\t/**\n\t * Callback which is invoked every tick.\n\t */\n\tprivate _onTick(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\t// approximate ramp curves with linear ramps\n\t\tif (this._lastVal !== val) {\n\t\t\tthis._lastVal = val;\n\t\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t\t}\n\t}\n\n\t/**\n\t * Anchor the value at the start and stop of the Transport\n\t */\n\tprivate _anchorValue(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\tthis._lastVal = val;\n\t\tthis._constantSource.offset.cancelAndHoldAtTime(time);\n\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t}\n\n\tgetValueAtTime(time: TransportTime): UnitMap[TypeName] {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\treturn super.getValueAtTime(computedTime);\n\t}\n\t\n\tsetValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.linearRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.exponentialRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value, startTime: TransportTime, timeConstant: number): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.setTargetAtTime(value, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(startTime: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.cancelScheduledValues(computedTime);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: TransportTime, duration: Time, scaling: NormalRange): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tduration = this.toSeconds(duration);\n\t\tsuper.setValueCurveAtTime(values, computedTime, duration, scaling);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.cancelAndHoldAtTime(computedTime);\n\t\treturn this;\n\t}\n\t\n\tsetRampPoint(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setRampPoint(computedTime);\n\t\treturn this;\n\t}\n\t\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.exponentialRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\t\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.linearRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.targetRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.transport.clear(this._synced);\n\t\tthis.context.transport.off(\"start\", this._syncedCallback);\n\t\tthis.context.transport.off(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.off(\"stop\", this._syncedCallback);\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tdecay: Time;\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\t@range(0, 1)\n\tsustain: NormalRange;\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<\"normalRange\"> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * synchronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope(0.4).toDestination();\n\t * \tenv.attackCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\trelease: 0.8\n\t * \t}).toDestination();\n\t * \tenv.triggerAttack();\n\t * \t// release curve could also be defined by an array\n\t * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n\t * \tenv.triggerRelease(0.2);\n\t * }, 1, 1);\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\tsustain: 0.1,\n\t * \t\tdecay: 0.5\n\t * \t}).toDestination();\n\t * \tenv.decayCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tassert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack < this.sampleTime) {\n\t\t\tthis._sig.cancelScheduledValues(time);\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay && this.sustain < 1) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n\t\t\t} else {\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator({\n\t * \ttype: \"sawtooth\"\n\t * }).connect(env).start();\n\t * env.triggerAttack();\n\t * // trigger the release half a second after the attack\n\t * env.triggerRelease(\"+0.5\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (release < this.sampleTime) {\n\t\t\t\tthis._sig.setValueAtTime(0, time);\n\t\t\t} else if (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tassert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t * @example\n\t * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n\t * env.triggerAttackRelease(2);\n\t * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the release 0.5 seconds after the attack\n\t * env.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Render the envelope curve to an array of the given length. \n\t * Good for visualizing the envelope curve. Rescales the duration of the\n\t * envelope to fit the length.\n\t */\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\tconst duration = length / this.context.sampleRate;\n\t\tconst context = new OfflineContext(1, duration, this.context.sampleRate);\n\t\t// normalize the ADSR for the given duration with 20% sustain time\n\t\tconst attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n\t\tconst envelopeDuration = attackPortion + this.toSeconds(this.release);\n\t\tconst sustainTime = envelopeDuration * 0.1;\n\t\tconst totalDuration = envelopeDuration + sustainTime;\n\t\t// @ts-ignore\n\t\tconst clone = new this.constructor(Object.assign(this.get(), {\n\t\t\tattack: duration * this.toSeconds(this.attack) / totalDuration,\n\t\t\tdecay: duration * this.toSeconds(this.decay) / totalDuration,\n\t\t\trelease: duration * this.toSeconds(this.release) / totalDuration,\n\t\t\tcontext\n\t\t})) as Envelope;\n\t\tclone._sig.toDestination();\n\t\tclone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n\t\tconst buffer = await context.render();\n\t\treturn buffer.getChannelData(0);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as \"exponential\",\n\t\tlinear: \"linear\" as \"linear\",\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n", "import { Volume } from \"../component/channel/Volume\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface InstrumentOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n}\n\n/**\n * Base-class for all instruments\n */\nexport abstract class Instrument<Options extends InstrumentOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output and volume triming node\n\t */\n\tprivate _volume: Volume;\n\toutput: OutputNode;\n\n\t/**\n\t * The instrument only has an output\n\t */\n\tinput: undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const amSynth = new Tone.AMSynth().toDestination();\n\t * amSynth.volume.value = -6;\n\t * amSynth.triggerAttackRelease(\"G#3\", 0.2);\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * Keep track of all events scheduled to the transport\n\t * when the instrument is 'synced'\n\t */\n\tprivate _scheduledEvents: number[] = [];\n\n\t/**\n\t * If the instrument is currently synced\n\t */\n\tprivate _synced = false;\n\n\tconstructor(options?: Partial<InstrumentOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Instrument.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Instrument.getDefaults(), arguments);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t}\n\n\tstatic getDefaults(): InstrumentOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Sync the instrument to the Transport. All subsequent calls of\n\t * [[triggerAttack]] and [[triggerRelease]] will be scheduled along the transport.\n\t * @example\n\t * const fmSynth = new Tone.FMSynth().toDestination();\n\t * fmSynth.volume.value = -6;\n\t * fmSynth.sync();\n\t * // schedule 3 notes when the transport first starts\n\t * fmSynth.triggerAttackRelease(\"C4\", \"8n\", 0);\n\t * fmSynth.triggerAttackRelease(\"E4\", \"8n\", \"8n\");\n\t * fmSynth.triggerAttackRelease(\"G4\", \"8n\", \"4n\");\n\t * // start the transport to hear the notes\n\t * Tone.Transport.start();\n\t */\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * set _sync\n\t */\n\tprotected _syncState(): boolean {\n\t\tlet changed = false;\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tchanged = true;\n\t\t}\n\t\treturn changed;\n\t}\n\n\t/**\n\t * Wrap the given method so that it can be synchronized\n\t * @param method Which method to wrap and sync\n\t * @param  timePosition What position the time argument appears in\n\t */\n\tprotected _syncMethod(method: string, timePosition: number): void {\n\t\tconst originalMethod = this[\"_original_\" + method] = this[method];\n\t\tthis[method] = (...args: any[]) => {\n\t\t\tconst time = args[timePosition];\n\t\t\tconst id = this.context.transport.schedule((t) => {\n\t\t\t\targs[timePosition] = t;\n\t\t\t\toriginalMethod.apply(this, args);\n\t\t\t}, time);\n\t\t\tthis._scheduledEvents.push(id);\n\t\t};\n\t}\n\n\t/**\n\t * Unsync the instrument from the Transport\n\t */\n\tunsync(): this {\n\t\tthis._scheduledEvents.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduledEvents = [];\n\t\tif (this._synced) {\n\t\t\tthis._synced = false;\n\t\t\tthis.triggerAttack = this._original_triggerAttack;\n\t\t\tthis.triggerRelease = this._original_triggerRelease;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and then the release after the duration.\n\t * @param  note     The note to trigger.\n\t * @param  duration How long the note should be held for before\n\t *                         triggering the release. This value must be greater than 0.\n\t * @param time  When the note should be triggered.\n\t * @param  velocity The velocity the note should be triggered at.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger \"C4\" for the duration of an 8th note\n\t * synth.triggerAttackRelease(\"C4\", \"8n\");\n\t */\n\ttriggerAttackRelease(note: Frequency, duration: Time, time?: Time, velocity?: NormalRange): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tthis.triggerAttack(note, computedTime, velocity);\n\t\tthis.triggerRelease(computedTime + computedDuration);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the instrument's note.\n\t * @param note the note to trigger\n\t * @param time the time to trigger the ntoe\n\t * @param velocity the velocity to trigger the note (betwee 0-1)\n\t */\n\tabstract triggerAttack(note: Frequency, time?: Time, velocity?: NormalRange): this;\n\tprivate _original_triggerAttack = this.triggerAttack;\n\n\t/**\n\t * Trigger the release phase of the current note.\n\t * @param time when to trigger the release\n\t */\n\tabstract triggerRelease(...args: any[]): this;\n\tprivate _original_triggerRelease = this.triggerRelease;\n\n\t/**\n\t * clean up\n\t * @returns {Instrument} this\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.unsync();\n\t\tthis._scheduledEvents = [];\n\t\treturn this;\n\t}\n}\n", "import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\nimport { timeRange } from \"../core/util/Decorator\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\n\n/**\n * AmplitudeEnvelope is a Tone.Envelope connected to a gain node.\n * Unlike Tone.Envelope, which outputs the envelope's value, AmplitudeEnvelope accepts\n * an audio signal as the input and will apply the envelope to the amplitude\n * of the signal.\n * Read more about ADSR Envelopes on [Wikipedia](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope).\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst ampEnv = new Tone.AmplitudeEnvelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 1.0,\n * \t\trelease: 0.8\n * \t}).toDestination();\n * \t// create an oscillator and connect it\n * \tconst osc = new Tone.Oscillator().connect(ampEnv).start();\n * \t// trigger the envelopes attack and release \"8t\" apart\n * \tampEnv.triggerAttackRelease(\"8t\");\n * }, 1.5, 1);\n * @category Component\n */\nexport class AmplitudeEnvelope extends Envelope {\n\n\treadonly name: string = \"AmplitudeEnvelope\";\n\n\tprivate _gainNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\toutput: Gain = this._gainNode;\n\tinput: Gain = this._gainNode;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from 0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AmplitudeEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tthis._sig.connect(this._gainNode.gain);\n\t\tthis.output = this._gainNode;\n\t\tthis.input = this._gainNode;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._gainNode.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorOptions, OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t) as OmniOscillatorOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Gain } from \"../core/context/Gain\";\nimport { NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Monophonic } from \"./Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\n\nexport interface ModulationSynthOptions extends SynthOptions {\n\tharmonicity: Positive;\n\tmodulationEnvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tmodulation: OmniOscillatorSynthOptions;\n}\n/**\n * Base class for both AM and FM synths\n */\nexport abstract class ModulationSynth<Options extends ModulationSynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"ModulationSynth\";\n\n\t/**\n\t * The carrier voice.\n\t */\n\tprotected _carrier: Synth;\n\n\t/**\n\t * The modulator voice.\n\t */\n\n\tprotected _modulator: Synth;\n\n\t/**\n\t * The carrier's oscillator\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The carrier's envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * The modulator's oscillator which is applied to the amplitude of the oscillator\n\t */\n\treadonly modulation: OmniOscillator<any>;\n\n\t/**\n\t * The modulator's envelope\n\t */\n\treadonly modulationEnvelope: AmplitudeEnvelope;\n\n\t/**\n\t * The frequency control\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune in cents\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const amSynth = new Tone.AMSynth().toDestination();\n\t * // pitch the modulator an octave below oscillator\n\t * amSynth.harmonicity.value = 0.5;\n\t * amSynth.triggerAttackRelease(\"C5\", \"4n\");\n\t */\n\treadonly harmonicity: Multiply;\n\n\t/**\n\t * The node where the modulation happens\n\t */\n\tprotected _modulationNode: Gain;\n\n\tconstructor(options?: RecursivePartial<ModulationSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(ModulationSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(ModulationSynth.getDefaults(), arguments);\n\n\t\tthis._carrier = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.oscillator,\n\t\t\tenvelope: options.envelope,\n\t\t\tonsilence: () => this.onsilence(this),\n\t\t\tvolume: -10,\n\t\t});\n\t\tthis._modulator = new Synth({\n\t\t\tcontext: this.context,\n\t\t\toscillator: options.modulation,\n\t\t\tenvelope: options.modulationEnvelope,\n\t\t\tvolume: -10,\n\t\t});\n\n\t\tthis.oscillator = this._carrier.oscillator;\n\t\tthis.envelope = this._carrier.envelope;\n\t\tthis.modulation = this._modulator.oscillator;\n\t\tthis.modulationEnvelope = this._modulator.envelope;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.detune,\n\t\t\tunits: \"cents\"\n\t\t});\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.harmonicity,\n\t\t\tminValue: 0,\n\t\t});\n\t\tthis._modulationNode = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"harmonicity\", \"oscillator\", \"envelope\", \"modulation\", \"modulationEnvelope\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): ModulationSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tharmonicity: 3,\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sine\"\n\t\t\t\t}\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.01,\n\t\t\t\t\tdecay: 0.01,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t),\n\t\t\tmodulation: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [\n\t\t\t\t\t...Object.keys(Source.getDefaults()),\n\t\t\t\t\t\"frequency\",\n\t\t\t\t\t\"detune\"\n\t\t\t\t]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"square\"\n\t\t\t\t}\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t\tmodulationEnvelope: Object.assign(\n\t\t\t\tomitFromObject(\n\t\t\t\t\tEnvelope.getDefaults(),\n\t\t\t\t\tObject.keys(ToneAudioNode.getDefaults())\n\t\t\t\t),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.5,\n\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\tsustain: 1,\n\t\t\t\t\trelease: 0.5\n\t\t\t\t}\n\t\t\t)\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeAttack(time, velocity);\n\t}\n\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis._carrier._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis._modulator._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._modulationNode.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AudioToGain } from \"../signal/AudioToGain\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth\";\n\nexport type AMSynthOptions = ModulationSynthOptions;\n\n/**\n * AMSynth uses the output of one Tone.Synth to modulate the\n * amplitude of another Tone.Synth. The harmonicity (the ratio between\n * the two signals) affects the timbre of the output signal greatly.\n * Read more about Amplitude Modulation Synthesis on\n * [SoundOnSound](https://web.archive.org/web/20160404103653/http://www.soundonsound.com:80/sos/mar00/articles/synthsecrets.htm).\n *\n * @example\n * const synth = new Tone.AMSynth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"4n\");\n * \n * @category Instrument\n */\nexport class AMSynth extends ModulationSynth<AMSynthOptions> {\n\n\treadonly name: string = \"AMSynth\";\n\n\t/**\n\t * Scale the oscillator from -1,1 to 0-1\n\t */\n\tprivate _modulationScale: AudioToGain;\n\n\tconstructor(options?: RecursivePartial<AMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(AMSynth.getDefaults(), arguments));\n\n\t\tthis._modulationScale = new AudioToGain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.chain(this._modulationScale, this._modulationNode.gain);\n\t\tthis._carrier.chain(this._modulationNode, this.output);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._modulationScale.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Cents, Frequency, GainFactor } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Param } from \"../../core/context/Param\";\nimport { assert } from \"../../core/util/Debug\";\n\nexport interface BiquadFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\tdetune: Cents;\n\tQ: number;\n\ttype: BiquadFilterType;\n\tgain: GainFactor;\n}\n\n/**\n * Thin wrapper around the native Web Audio [BiquadFilterNode](https://webaudio.github.io/web-audio-api/#biquadfilternode). \n * BiquadFilter is similar to [[Filter]] but doesn't have the option to set the \"rolloff\" value. \n * @category Component\n */\nexport class BiquadFilter extends ToneAudioNode<BiquadFilterOptions> {\n\treadonly name: string = \"BiquadFilter\";\n\n\treadonly input: BiquadFilterNode;\n\treadonly output: BiquadFilterNode;\n\n\t/**\n\t * The frequency of the filter\n\t */\n\treadonly frequency: Param<\"frequency\">;\n\n\t/**\n\t * A detune value, in cents, for the frequency.\n\t */\n\treadonly detune: Param<\"cents\">;\n\t\n\t/**\n\t * The Q factor of the filter.\n\t * For lowpass and highpass filters the Q value is interpreted to be in dB. \n\t * For these filters the nominal range is [−𝑄𝑙𝑖𝑚,𝑄𝑙𝑖𝑚] where 𝑄𝑙𝑖𝑚 is the largest value for which 10𝑄/20 does not overflow. This is approximately 770.63678.\n\t * For the bandpass, notch, allpass, and peaking filters, this value is a linear value. \n\t * The value is related to the bandwidth of the filter and hence should be a positive value. The nominal range is \n\t * [0,3.4028235𝑒38], the upper limit being the most-positive-single-float.\n\t * This is not used for the lowshelf and highshelf filters.\n\t */\n\treadonly Q: Param<\"number\">;\n\n\t/**\n\t * The gain of the filter. Its value is in dB units. The gain is only used for lowshelf, highshelf, and peaking filters.\n\t */\n\treadonly gain: Param<\"decibels\">;\n\n\tprivate readonly _filter: BiquadFilterNode;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType);\n\tconstructor(options?: Partial<BiquadFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BiquadFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(BiquadFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis._filter = this.context.createBiquadFilter();\n\t\tthis.input = this.output = this._filter;\n\n\t\tthis.Q = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"number\",\n\t\t\tvalue: options.Q,\n\t\t\tparam: this._filter.Q,\n\t\t});\n\t\t\n\t\tthis.frequency = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tparam: this._filter.frequency,\n\t\t});\n\t\t\n\t\tthis.detune = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t\tparam: this._filter.detune,\n\t\t});\n\t\t\n\t\tthis.gain = new Param({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tconvert: false,\n\t\t\tvalue: options.gain,\n\t\t\tparam: this._filter.gain,\n\t\t});\n\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): BiquadFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\ttype: \"lowpass\" as const,\n\t\t\tfrequency: 350,\n\t\t\tdetune: 0,\n\t\t\tgain: 0,\n\t\t});\n\t}\n\n\t/**\n\t * The type of this BiquadFilterNode. For a complete list of types and their attributes, see the\n\t * [Web Audio API](https://webaudio.github.io/web-audio-api/#dom-biquadfiltertype-lowpass)\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._filter.type;\n\t}\n\tset type(type) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tassert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._filter.type = type;\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\t// start with all 1s\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\t// clone the filter to remove any connections which may be changing the value\n\t\tconst filterClone = this.context.createBiquadFilter();\n\t\tfilterClone.type = this.type;\n\t\tfilterClone.Q.value = this.Q.value;\n\t\tfilterClone.frequency.value = this.frequency.value as number;\n\t\tfilterClone.gain.value = this.gain.value as number;\n\t\tfilterClone.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filter.disconnect();\n\t\tthis.Q.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.gain.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { isNumber } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { assert } from \"../../core/util/Debug\";\nimport { BiquadFilter, BiquadFilterOptions } from \"./BiquadFilter\";\n\nexport type FilterRollOff = -12 | -24 | -48 | -96;\n\nexport type FilterOptions = BiquadFilterOptions & {\n\trolloff: FilterRollOff;\n}\n\n/**\n * Tone.Filter is a filter which allows for all of the same native methods\n * as the [BiquadFilterNode](http://webaudio.github.io/web-audio-api/#the-biquadfilternode-interface).\n * Tone.Filter has the added ability to set the filter rolloff at -12\n * (default), -24 and -48.\n * @example\n * const filter = new Tone.Filter(1500, \"highpass\").toDestination();\n * filter.frequency.rampTo(20000, 10);\n * const noise = new Tone.Noise().connect(filter).start();\n * @category Component\n */\nexport class Filter extends ToneAudioNode<FilterOptions> {\n\n\treadonly name: string = \"Filter\";\n\n\treadonly input = new Gain({ context: this.context });\n\treadonly output = new Gain({ context: this.context });\n\tprivate _filters: BiquadFilter[] = [];\n\n\t/**\n\t * the rolloff value of the filter\n\t */\n\tprivate _rolloff!: FilterRollOff;\n\tprivate _type: BiquadFilterType;\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The cutoff frequency of the filter.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune parameter\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The gain of the filter, only used in certain filter types\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * @param frequency The cutoff frequency of the filter.\n\t * @param type The type of filter.\n\t * @param rolloff The drop in decibels per octave after the cutoff frequency\n\t */\n\tconstructor(frequency?: Frequency, type?: BiquadFilterType, rolloff?: FilterRollOff);\n\tconstructor(options?: Partial<FilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]));\n\t\tconst options = optionsFromArguments(Filter.getDefaults(), arguments, [\"frequency\", \"type\", \"rolloff\"]);\n\n\t\tthis._filters = [];\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\tthis.gain = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tconvert: false,\n\t\t\tvalue: options.gain,\n\t\t});\n\t\tthis._type = options.type;\n\t\tthis.rolloff = options.rolloff;\n\t\treadOnly(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): FilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\tdetune: 0,\n\t\t\tfrequency: 350,\n\t\t\tgain: 0,\n\t\t\trolloff: -12 as FilterRollOff,\n\t\t\ttype: \"lowpass\" as BiquadFilterType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the filter. Types: \"lowpass\", \"highpass\",\n\t * \"bandpass\", \"lowshelf\", \"highshelf\", \"notch\", \"allpass\", or \"peaking\".\n\t */\n\tget type(): BiquadFilterType {\n\t\treturn this._type;\n\t}\n\tset type(type: BiquadFilterType) {\n\t\tconst types: BiquadFilterType[] = [\"lowpass\", \"highpass\", \"bandpass\",\n\t\t\t\"lowshelf\", \"highshelf\", \"notch\", \"allpass\", \"peaking\"];\n\t\tassert(types.indexOf(type) !== -1, `Invalid filter type: ${type}`);\n\t\tthis._type = type;\n\t\tthis._filters.forEach(filter => filter.type = type);\n\t}\n\n\t/**\n\t * The rolloff of the filter which is the drop in db\n\t * per octave. Implemented internally by cascading filters.\n\t * Only accepts the values -12, -24, -48 and -96.\n\t */\n\tget rolloff(): FilterRollOff {\n\t\treturn this._rolloff;\n\t}\n\tset rolloff(rolloff) {\n\t\tconst rolloffNum = isNumber(rolloff) ? rolloff : parseInt(rolloff, 10) as FilterRollOff;\n\t\tconst possibilities = [-12, -24, -48, -96];\n\t\tlet cascadingCount = possibilities.indexOf(rolloffNum);\n\t\t// check the rolloff is valid\n\t\tassert(cascadingCount !== -1, `rolloff can only be ${possibilities.join(\", \")}`);\n\t\tcascadingCount += 1;\n\n\t\tthis._rolloff = rolloffNum;\n\t\tthis.input.disconnect();\n\t\tthis._filters.forEach(filter => filter.disconnect());\n\n\t\tthis._filters = new Array(cascadingCount);\n\t\tfor (let count = 0; count < cascadingCount; count++) {\n\t\t\tconst filter = new BiquadFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tfilter.type = this._type;\n\t\t\tthis.frequency.connect(filter.frequency);\n\t\t\tthis.detune.connect(filter.detune);\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tthis.gain.connect(filter.gain);\n\t\t\tthis._filters[count] = filter;\n\t\t}\n\t\tthis._internalChannels = this._filters;\n\t\tconnectSeries(this.input, ...this._internalChannels, this.output);\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\tconst filterClone = new BiquadFilter({\n\t\t\tfrequency: this.frequency.value,\n\t\t\tgain: this.gain.value,\n\t\t\tQ: this.Q.value,\n\t\t\ttype: this._type,\n\t\t\tdetune: this.detune.value,\n\t\t});\n\t\t// start with all 1s\n\t\tconst totalResponse = new Float32Array(len).map(() => 1);\n\t\tthis._filters.forEach(() => {\n\t\t\tconst response = filterClone.getFrequencyResponse(len);\n\t\t\tresponse.forEach((val, i) => totalResponse[i] *= val);\n\t\t});\n\t\tfilterClone.dispose();\n\t\treturn totalResponse;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._filters.forEach(filter => {\n\t\t\tfilter.dispose();\n\t\t});\n\t\twritable(this, [\"detune\", \"frequency\", \"gain\", \"Q\"]);\n\t\tthis.frequency.dispose();\n\t\tthis.Q.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.gain.dispose();\n\t\treturn this;\n\t}\n}\n", "import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Frequency, Hertz, NormalRange, Time } from \"../../core/type/Units\";\nimport { Envelope, EnvelopeOptions } from \"./Envelope\";\nimport { Scale } from \"../../signal/Scale\";\nimport { Pow } from \"../../signal/Pow\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport interface FrequencyEnvelopeOptions extends EnvelopeOptions {\n\tbaseFrequency: Frequency;\n\toctaves: number;\n\texponent: number;\n}\n/**\n * FrequencyEnvelope is an [[Envelope]] which ramps between [[baseFrequency]]\n * and [[octaves]]. It can also have an optional [[exponent]] to adjust the curve\n * which it ramps. \n * @example\n * const oscillator = new Tone.Oscillator().toDestination().start();\n * const freqEnv = new Tone.FrequencyEnvelope({\n * \tattack: 0.2,\n * \tbaseFrequency: \"C2\",\n * \toctaves: 4\n * });\n * freqEnv.connect(oscillator.frequency);\n * freqEnv.triggerAttack();\n * @category Component\n */\nexport class FrequencyEnvelope extends Envelope {\n\n\treadonly name: string = \"FrequencyEnvelope\";\n\n\t/**\n\t * Private reference to the base frequency as a number\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * The number of octaves\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Internal scaler from 0-1 to the final output range\n\t */\n\tprivate _scale: Scale;\n\n\t/**\n\t * Apply a power curve to the output\n\t */\n\tprivate _exponent: Pow;\n\n\t/**\n\t * @param attack\tthe attack time in seconds\n\t * @param decay\t\tthe decay time in seconds\n\t * @param sustain \ta percentage (0-1) of the full amplitude\n\t * @param release\tthe release time in seconds\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<FrequencyEnvelopeOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(FrequencyEnvelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis._octaves = options.octaves;\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\n\t\tthis._exponent = this.input = new Pow({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.exponent\n\t\t});\n\t\tthis._scale = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: this._baseFrequency,\n\t\t\tmax: this._baseFrequency * Math.pow(2, this._octaves),\n\t\t});\n\t\tthis._sig.chain(this._exponent, this._scale);\n\t}\n\n\tstatic getDefaults(): FrequencyEnvelopeOptions {\n\t\treturn Object.assign(Envelope.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\texponent: 1,\n\t\t\toctaves: 4,\n\t\t});\n\t}\n\n\t/**\n\t * The envelope's minimum output value. This is the value which it\n\t * starts at.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(min) {\n\t\tconst freq = this.toFrequency(min);\n\t\tassertRange(freq, 0);\n\t\tthis._baseFrequency = freq;\n\t\tthis._scale.min = this._baseFrequency;\n\t\t// update the max value when the min changes\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the baseFrequency that the\n\t * envelope will scale to.\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves: number) {\n\t\tthis._octaves = octaves;\n\t\tthis._scale.max = this._baseFrequency * Math.pow(2, octaves);\n\t}\n\n\t/**\n\t * The envelope's exponent value.\n\t */\n\tget exponent(): number {\n\t\treturn this._exponent.value;\n\t}\n\tset exponent(exponent) {\n\t\tthis._exponent.value = exponent;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._exponent.dispose();\n\t\tthis._scale.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic, MonophonicOptions } from \"../instrument/Monophonic\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { FrequencyEnvelope, FrequencyEnvelopeOptions } from \"../component/envelope/FrequencyEnvelope\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\n\nexport interface MonoSynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilterEnvelope: Omit<FrequencyEnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tfilter: Omit<FilterOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MonoSynth is composed of one `oscillator`, one `filter`, and two `envelopes`.\n * The amplitude of the Oscillator and the cutoff frequency of the\n * Filter are controlled by Envelopes.\n * <img src=\"https://docs.google.com/drawings/d/1gaY1DF9_Hzkodqf8JI1Cg2VZfwSElpFQfI94IQwad38/pub?w=924&h=240\">\n * @example\n * const synth = new Tone.MonoSynth({\n * \toscillator: {\n * \t\ttype: \"square\"\n * \t},\n * \tenvelope: {\n * \t\tattack: 0.1\n * \t}\n * }).toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class MonoSynth extends Monophonic<MonoSynthOptions> {\n\n\treadonly name = \"MonoSynth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency control.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control.\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The filter.\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The filter envelope.\n\t */\n\treadonly filterEnvelope: FrequencyEnvelope;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<MonoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MonoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MonoSynth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign(options.oscillator, {\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}));\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\t\tthis.filter = new Filter(Object.assign(options.filter, { context: this.context }));\n\t\tthis.filterEnvelope = new FrequencyEnvelope(Object.assign(options.filterEnvelope, { context: this.context }));\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign(options.envelope, { context: this.context }));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.filter, this.envelope, this.output);\n\n\t\t// connect the filter envelope\n\t\tthis.filterEnvelope.connect(this.filter.frequency);\n\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"filter\", \"filterEnvelope\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MonoSynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.9,\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilter: Object.assign(\n\t\t\t\tomitFromObject(Filter.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tQ: 1,\n\t\t\t\t\trolloff: -12,\n\t\t\t\t\ttype: \"lowpass\",\n\t\t\t\t},\n\t\t\t),\n\t\t\tfilterEnvelope: Object.assign(\n\t\t\t\tomitFromObject(FrequencyEnvelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.6,\n\t\t\t\t\tbaseFrequency: 200,\n\t\t\t\t\tdecay: 0.2,\n\t\t\t\t\texponent: 2,\n\t\t\t\t\toctaves: 3,\n\t\t\t\t\trelease: 2,\n\t\t\t\t\tsustain: 0.5,\n\t\t\t\t}\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"sawtooth\",\n\t\t\t\t},\n\t\t\t) as OmniOscillatorSynthOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity = 1): void {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.filterEnvelope.triggerAttack(time);\n\t\tthis.oscillator.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.filterEnvelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis.filterEnvelope.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Monophonic, MonophonicOptions } from \"./Monophonic\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain, } from \"../core/context/Gain\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface DuoSynthOptions extends MonophonicOptions {\n\tvoice0: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tvoice1: Omit<MonoSynthOptions, keyof MonophonicOptions>;\n\tharmonicity: Positive;\n\tvibratoRate: Frequency;\n\tvibratoAmount: Positive;\n}\n\n/**\n * DuoSynth is a monophonic synth composed of two [[MonoSynths]] run in parallel with control over the\n * frequency ratio between the two voices and vibrato effect.\n * @example\n * const duoSynth = new Tone.DuoSynth().toDestination();\n * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n * @category Instrument\n */\nexport class DuoSynth extends Monophonic<DuoSynthOptions> {\n\n\treadonly name: string = \"DuoSynth\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * the first voice\n\t */\n\treadonly voice0: MonoSynth;\n\n\t/**\n\t * the second voice\n\t */\n\treadonly voice1: MonoSynth;\n\n\t/**\n\t * The amount of vibrato\n\t */\n\tpublic vibratoAmount: Param<\"normalRange\">;\n\n\t/**\n\t * the vibrato frequency\n\t */\n\tpublic vibratoRate: Signal<\"frequency\">;\n\n\t/**\n\t * Harmonicity is the ratio between the two voices. A harmonicity of\n\t * 1 is no change. Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const duoSynth = new Tone.DuoSynth().toDestination();\n\t * duoSynth.triggerAttackRelease(\"C4\", \"2n\");\n\t * // pitch voice1 an octave below voice0\n\t * duoSynth.harmonicity.value = 0.5;\n\t */\n\tpublic harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The vibrato LFO.\n\t */\n\tprivate _vibrato: LFO;\n\n\t/**\n\t * the vibrato gain\n\t */\n\tprivate _vibratoGain: Gain<\"normalRange\">;\n\n\tconstructor(options?: RecursivePartial<DuoSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DuoSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(DuoSynth.getDefaults(), arguments);\n\n\t\tthis.voice0 = new MonoSynth(Object.assign(options.voice0, {\n\t\t\tcontext: this.context,\n\t\t\tonsilence: () => this.onsilence(this)\n\t\t}));\n\t\tthis.voice1 = new MonoSynth(Object.assign(options.voice1, {\n\t\t\tcontext: this.context,\n\t\t}));\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis._vibrato = new LFO({\n\t\t\tfrequency: options.vibratoRate,\n\t\t\tcontext: this.context,\n\t\t\tmin: -50,\n\t\t\tmax: 50\n\t\t});\n\t\t// start the vibrato immediately\n\t\tthis._vibrato.start();\n\t\tthis.vibratoRate = this._vibrato.frequency;\n\t\tthis._vibratoGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tgain: options.vibratoAmount\n\t\t});\n\t\tthis.vibratoAmount = this._vibratoGain.gain;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: 440\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this.voice0.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this.voice1.frequency);\n\n\t\tthis._vibrato.connect(this._vibratoGain);\n\t\tthis._vibratoGain.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.detune.fan(this.voice0.detune, this.voice1.detune);\n\n\t\tthis.voice0.connect(this.output);\n\t\tthis.voice1.connect(this.output);\n\n\t\treadOnly(this, [\"voice0\", \"voice1\", \"frequency\", \"vibratoAmount\", \"vibratoRate\"]);\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.voice0.envelope.getValueAtTime(time) + this.voice1.envelope.getValueAtTime(time);\n\t}\n\n\tstatic getDefaults(): DuoSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tvibratoAmount: 0.5,\n\t\t\tvibratoRate: 5,\n\t\t\tharmonicity: 1.5,\n\t\t\tvoice0: deepMerge(\n\t\t\t\tomitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t\tvoice1: deepMerge(\n\t\t\t\tomitFromObject(MonoSynth.getDefaults(), Object.keys(Monophonic.getDefaults())),\n\t\t\t\t{\n\n\t\t\t\t\tfilterEnvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t},\n\t\t\t\t\tenvelope: {\n\t\t\t\t\t\tattack: 0.01,\n\t\t\t\t\t\tdecay: 0.0,\n\t\t\t\t\t\tsustain: 1,\n\t\t\t\t\t\trelease: 0.5\n\t\t\t\t\t}\n\t\t\t\t}),\n\t\t}) as DuoSynthOptions;\n\t}\n\t/**\n\t * Trigger the attack portion of the note\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeAttack(time, velocity);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeAttack(time, velocity);\n\t}\n\n\t/**\n\t * Trigger the release portion of the note\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds) {\n\t\t// @ts-ignore\n\t\tthis.voice0._triggerEnvelopeRelease(time);\n\t\t// @ts-ignore\n\t\tthis.voice1._triggerEnvelopeRelease(time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.voice0.dispose();\n\t\tthis.voice1.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._vibrato.dispose();\n\t\tthis.vibratoRate.dispose();\n\t\tthis._vibratoGain.dispose();\n\t\tthis.harmonicity.dispose();\n\t\treturn this;\n\t}\n}\n\n", "import { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { ModulationSynth, ModulationSynthOptions } from \"./ModulationSynth\";\n\nexport interface FMSynthOptions extends ModulationSynthOptions {\n\tmodulationIndex: Positive;\n}\n\n/**\n * FMSynth is composed of two Tone.Synths where one Tone.Synth modulates\n * the frequency of a second Tone.Synth. A lot of spectral content\n * can be explored using the modulationIndex parameter. Read more about\n * frequency modulation synthesis on Sound On Sound: [Part 1](https://web.archive.org/web/20160403123704/http://www.soundonsound.com/sos/apr00/articles/synthsecrets.htm), [Part 2](https://web.archive.org/web/20160403115835/http://www.soundonsound.com/sos/may00/articles/synth.htm).\n *\n * @example\n * const fmSynth = new Tone.FMSynth().toDestination();\n * fmSynth.triggerAttackRelease(\"C5\", \"4n\");\n * \n * @category Instrument\n */\n\nexport class FMSynth extends ModulationSynth<FMSynthOptions> {\n\treadonly name: string = \"FMSynth\";\n\n\t/**\n\t * The modulation index which essentially the depth or amount of the modulation. It is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Multiply;\n\n\tconstructor(options?: RecursivePartial<FMSynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FMSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(FMSynth.getDefaults(), arguments);\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// control the two voices frequency\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis.detune.fan(this._carrier.detune, this._modulator.detune);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t}\n\n\tstatic getDefaults(): FMSynthOptions {\n\t\treturn Object.assign(ModulationSynth.getDefaults(), {\n\t\t\tmodulationIndex: 10,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Positive, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp, RecursivePartial } from \"../core/util/Interface\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FMOscillator } from \"../source/oscillator/FMOscillator\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface MetalSynthOptions extends MonophonicOptions {\n\tharmonicity: Positive;\n\tmodulationIndex: Positive;\n\toctaves: number;\n\tresonance: Frequency;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Inharmonic ratio of frequencies based on the Roland TR-808\n * Taken from https://ccrma.stanford.edu/papers/tr-808-cymbal-physically-informed-circuit-bendable-digital-model\n */\nconst inharmRatios: number[] = [1.0, 1.483, 1.932, 2.546, 2.630, 3.897];\n\n/**\n * A highly inharmonic and spectrally complex source with a highpass filter\n * and amplitude envelope which is good for making metallophone sounds.\n * Based on CymbalSynth by [@polyrhythmatic](https://github.com/polyrhythmatic).\n * Inspiration from [Sound on Sound](https://shorturl.at/rSZ12).\n * @category Instrument\n */\nexport class MetalSynth extends Monophonic<MetalSynthOptions> {\n\n\treadonly name: string = \"MetalSynth\";\n\n\t/**\n\t * The frequency of the cymbal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune applied to the oscillators\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of FMOscillators\n\t */\n\tprivate _oscillators: FMOscillator[] = [];\n\n\t/**\n\t * The frequency multipliers\n\t */\n\tprivate _freqMultipliers: Multiply[] = [];\n\n\t/**\n\t * The gain node for the envelope.\n\t */\n\tprivate _amplitude: Gain;\n\n\t/**\n\t * Highpass the output\n\t */\n\tprivate _highpass: Filter;\n\n\t/**\n\t * The number of octaves the highpass\n\t * filter frequency ramps\n\t */\n\tprivate _octaves: number;\n\n\t/**\n\t * Scale the body envelope for the highpass filter\n\t */\n\tprivate _filterFreqScaler: Scale;\n\n\t/**\n\t * The envelope which is connected both to the\n\t * amplitude and a highpass filter's cutoff frequency.\n\t * The lower-limit of the filter is controlled by the [[resonance]]\n\t */\n\treadonly envelope: Envelope;\n\n\tconstructor(options?: RecursivePartial<MetalSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MetalSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MetalSynth.getDefaults(), arguments);\n\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t});\n\n\t\tthis._amplitude = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: 0,\n\t\t}).connect(this.output);\n\n\t\tthis._highpass = new Filter({\n\t\t\t// Q: -3.0102999566398125,\n\t\t\tQ: 0,\n\t\t\tcontext: this.context,\n\t\t\ttype: \"highpass\",\n\t\t}).connect(this._amplitude);\n\n\t\tfor (let i = 0; i < inharmRatios.length; i++) {\n\t\t\tconst osc = new FMOscillator({\n\t\t\t\tcontext: this.context,\n\t\t\t\tharmonicity: options.harmonicity,\n\t\t\t\tmodulationIndex: options.modulationIndex,\n\t\t\t\tmodulationType: \"square\",\n\t\t\t\tonstop: i === 0 ? () => this.onsilence(this) : noOp,\n\t\t\t\ttype: \"square\",\n\t\t\t});\n\t\t\tosc.connect(this._highpass);\n\t\t\tthis._oscillators[i] = osc;\n\n\t\t\tconst mult = new Multiply({\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue: inharmRatios[i],\n\t\t\t});\n\t\t\tthis._freqMultipliers[i] = mult;\n\t\t\tthis.frequency.chain(mult, osc.frequency);\n\t\t\tthis.detune.connect(osc.detune);\n\t\t}\n\n\t\tthis._filterFreqScaler = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: 7000,\n\t\t\tmin: this.toFrequency(options.resonance),\n\t\t});\n\n\t\tthis.envelope = new Envelope({\n\t\t\tattack: options.envelope.attack,\n\t\t\tattackCurve: \"linear\",\n\t\t\tcontext: this.context,\n\t\t\tdecay: options.envelope.decay,\n\t\t\trelease: options.envelope.release,\n\t\t\tsustain: 0,\n\t\t});\n\n\t\tthis.envelope.chain(this._filterFreqScaler, this._highpass.frequency);\n\t\tthis.envelope.connect(this._amplitude.gain);\n\t\t// set the octaves\n\t\tthis._octaves = options.octaves;\n\t\tthis.octaves = options.octaves;\n\t}\n\n\tstatic getDefaults(): MetalSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.001,\n\t\t\t\t\tdecay: 1.4,\n\t\t\t\t\trelease: 0.2,\n\t\t\t\t},\n\t\t\t),\n\t\t\tharmonicity: 5.1,\n\t\t\tmodulationIndex: 32,\n\t\t\toctaves: 1.5,\n\t\t\tresonance: 4000,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity that the envelope should be triggered at.\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange = 1): this {\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis._oscillators.forEach(osc => osc.start(time));\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis._oscillators.forEach(osc => {\n\t\t\t\tosc.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\t\n\t/**\n\t * Trigger the release of the envelope.\n\t * @param time When the release should be triggered.\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): this {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis._oscillators.forEach(osc => osc.stop(time + this.toSeconds(this.envelope.release)));\n\t\treturn this;\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * The modulationIndex of the oscillators which make up the source.\n\t * see [[FMOscillator.modulationIndex]]\n\t * @min 1\n\t * @max 100\n\t */\n\tget modulationIndex(): number {\n\t\treturn this._oscillators[0].modulationIndex.value;\n\t}\n\tset modulationIndex(val) {\n\t\tthis._oscillators.forEach(osc => (osc.modulationIndex.value = val));\n\t}\n\n\t/**\n\t * The harmonicity of the oscillators which make up the source.\n\t * see Tone.FMOscillator.harmonicity\n\t * @min 0.1\n\t * @max 10\n\t */\n\tget harmonicity(): number {\n\t\treturn this._oscillators[0].harmonicity.value;\n\t}\n\tset harmonicity(val) {\n\t\tthis._oscillators.forEach(osc => (osc.harmonicity.value = val));\n\t}\n\n\t/**\n\t * The lower level of the highpass filter which is attached to the envelope.\n\t * This value should be between [0, 7000]\n\t * @min 0\n\t * @max 7000\n\t */\n\tget resonance(): Frequency {\n\t\treturn this._filterFreqScaler.min;\n\t}\n\tset resonance(val) {\n\t\tthis._filterFreqScaler.min = this.toFrequency(val);\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The number of octaves above the \"resonance\" frequency\n\t * that the filter ramps during the attack/decay envelope\n\t * @min 0\n\t * @max 8\n\t */\n\tget octaves(): number {\n\t\treturn this._octaves;\n\t}\n\tset octaves(val) {\n\t\tthis._octaves = val;\n\t\tthis._filterFreqScaler.max = this._filterFreqScaler.min * Math.pow(2, val);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillators.forEach(osc => osc.dispose());\n\t\tthis._freqMultipliers.forEach(freqMult => freqMult.dispose());\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._filterFreqScaler.dispose();\n\t\tthis._amplitude.dispose();\n\t\tthis.envelope.dispose();\n\t\tthis._highpass.dispose();\n\t\treturn this;\n\t}\n}\n", "import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Positive, Time } from \"../core/type/Units\";\nimport { deepMerge, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../core/util/Interface\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { range, timeRange } from \"../core/util/Decorator\";\n\nexport interface MembraneSynthOptions extends SynthOptions {\n\tpitchDecay: Time;\n\toctaves: Positive;\n}\n\n/**\n * MembraneSynth makes kick and tom sounds using a single oscillator\n * with an amplitude envelope and frequency ramp. A Tone.OmniOscillator\n * is routed through a Tone.AmplitudeEnvelope to the output. The drum\n * quality of the sound comes from the frequency envelope applied\n * during MembraneSynth.triggerAttack(note). The frequency envelope\n * starts at <code>note * .octaves</code> and ramps to <code>note</code>\n * over the duration of <code>.pitchDecay</code>.\n * @example\n * const synth = new Tone.MembraneSynth().toDestination();\n * synth.triggerAttackRelease(\"C2\", \"8n\");\n * @category Instrument\n */\nexport class MembraneSynth extends Synth<MembraneSynthOptions> {\n\n\treadonly name: string = \"MembraneSynth\";\n\n\t/**\n\t * The number of octaves the pitch envelope ramps.\n\t * @min 0.5\n\t * @max 8\n\t */\n\t@range(0)\n\toctaves: Positive;\n\n\t/**\n\t * The amount of time the frequency envelope takes.\n\t * @min 0\n\t * @max 0.5\n\t */\n\t@timeRange(0)\n\tpitchDecay: Time;\n\n\t/**\n\t * Portamento is ignored in this synth. use pitch decay instead.\n\t */\n\treadonly portamento = 0;\n\n\t/**\n\t * @param options the options available for the synth see defaults\n\t */\n\tconstructor(options?: RecursivePartial<MembraneSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(MembraneSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(MembraneSynth.getDefaults(), arguments);\n\n\t\tthis.pitchDecay = options.pitchDecay;\n\t\tthis.octaves = options.octaves;\n\t\treadOnly(this, [\"oscillator\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): MembraneSynthOptions {\n\t\treturn deepMerge(Monophonic.getDefaults(), Synth.getDefaults(), {\n\t\t\tenvelope: {\n\t\t\t\tattack: 0.001,\n\t\t\t\tattackCurve: \"exponential\",\n\t\t\t\tdecay: 0.4,\n\t\t\t\trelease: 1.4,\n\t\t\t\tsustain: 0.01,\n\t\t\t},\n\t\t\toctaves: 10,\n\t\t\toscillator: {\n\t\t\t\ttype: \"sine\",\n\t\t\t},\n\t\t\tpitchDecay: 0.05,\n\t\t});\n\t}\n\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst seconds = this.toSeconds(time);\n\t\tconst hertz = this.toFrequency(note instanceof FrequencyClass ? note.toFrequency() : note);\n\t\tconst maxNote = hertz * this.octaves;\n\t\tthis.oscillator.frequency.setValueAtTime(maxNote, seconds);\n\t\tthis.oscillator.frequency.exponentialRampToValueAtTime(hertz, seconds + this.toSeconds(this.pitchDecay));\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise, NoiseOptions } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Source } from \"../source/Source\";\n\nexport interface NoiseSynthOptions extends InstrumentOptions {\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tnoise: Omit<NoiseOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]]. \n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * const noiseSynth = new Tone.NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\nexport class NoiseSynth extends Instrument<NoiseSynthOptions> {\n\n\treadonly name = \"NoiseSynth\";\n\n\t/**\n\t * The noise source.\n\t */\n\treadonly noise: Noise;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<NoiseSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(NoiseSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(NoiseSynth.getDefaults(), arguments);\n\t\tthis.noise = new Noise(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.noise));\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the noise to the output\n\t\tthis.noise.chain(this.envelope, this.output);\n\t}\n\n\tstatic getDefaults(): NoiseSynthOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\tsustain: 0.0,\n\t\t\t\t},\n\t\t\t),\n\t\t\tnoise: Object.assign(\n\t\t\t\tomitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"white\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * Start the attack portion of the envelopes. Unlike other\n\t * instruments, Tone.NoiseSynth doesn't have a note.\n\t * @example\n\t * const noiseSynth = new Tone.NoiseSynth().toDestination();\n\t * noiseSynth.triggerAttack();\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\t// start the noise\n\t\tthis.noise.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the release portion of the envelopes.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.noise.stop(time + this.toSeconds(this.envelope.release));\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 0);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tduration = this.toSeconds(duration);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + duration);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.noise.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n", "/**\n * All of the classes or functions which are loaded into the AudioWorkletGlobalScope\n */\nconst workletContext: Set<string> = new Set();\n\n/**\n * Add a class to the AudioWorkletGlobalScope\n */\nexport function addToWorklet(classOrFunction: string) {\n\tworkletContext.add(classOrFunction);\n}\n\n/**\n * Register a processor in the AudioWorkletGlobalScope with the given name\n */\nexport function registerProcessor(name: string, classDesc: string) {\n\tconst processor = /* javascript */`registerProcessor(\"${name}\", ${classDesc})`;\n\tworkletContext.add(processor);\n}\n\n/**\n * Get all of the modules which have been registered to the AudioWorkletGlobalScope\n */\nexport function getWorkletGlobalScope(): string {\n\treturn Array.from(workletContext).join(\"\\n\");\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../context/ToneAudioNode\";\nimport { noOp } from \"../util/Interface\";\nimport { getWorkletGlobalScope } from \"./WorkletGlobalScope\";\n\nexport type ToneAudioWorkletOptions = ToneAudioNodeOptions;\n\nexport abstract class ToneAudioWorklet<Options extends ToneAudioWorkletOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"ToneAudioWorklet\";\n\n\t/**\n\t * The processing node\n\t */\n\tprotected _worklet!: AudioWorkletNode;\n\n\t/**\n\t * A dummy gain node to create a dummy audio param from\n\t */\n\tprivate _dummyGain: GainNode;\n\n\t/**\n\t * A dummy audio param to use when creating Params\n\t */\n\tprotected _dummyParam: AudioParam;\n\n\t/**\n\t * The constructor options for the node\n\t */\n\tprotected workletOptions: Partial<AudioWorkletNodeOptions> = {};\n\n\t/**\n\t * Get the name of the audio worklet\n\t */\n\tprotected abstract _audioWorkletName(): string;\n\n\t/**\n\t * Invoked when the module is loaded and the node is created\n\t */\n\tprotected abstract onReady(node: AudioWorkletNode): void;\n\n\t/**\n\t * Callback which is invoked when there is an error in the processing\n\t */\n\tonprocessorerror: (e: string) => void = noOp;\n\n\tconstructor(options: Options) {\n\t\tsuper(options);\n\n\t\tconst blobUrl = URL.createObjectURL(new Blob([getWorkletGlobalScope()], { type: \"text/javascript\" }));\n\t\tconst name = this._audioWorkletName();\n\n\t\tthis._dummyGain = this.context.createGain();\n\t\tthis._dummyParam = this._dummyGain.gain;\n\n\t\t// Register the processor\n\t\tthis.context.addAudioWorkletModule(blobUrl, name).then(() => {\n\t\t\t// create the worklet when it's read\n\t\t\tif (!this.disposed) {\n\t\t\t\tthis._worklet = this.context.createAudioWorkletNode(name, this.workletOptions);\n\t\t\t\tthis._worklet.onprocessorerror = this.onprocessorerror.bind(this);\n\t\t\t\tthis.onReady(this._worklet);\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyGain.disconnect();\n\t\tif (this._worklet) {\n\t\t\tthis._worklet.port.postMessage(\"dispose\");\n\t\t\tthis._worklet.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n\n}\n", "import { addToWorklet } from \"./WorkletGlobalScope\";\n\nconst toneAudioWorkletProcessor = /* javascript */ `\n\t/**\n\t * The base AudioWorkletProcessor for use in Tone.js. Works with the [[ToneAudioWorklet]]. \n\t */\n\tclass ToneAudioWorkletProcessor extends AudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\t\n\t\t\tsuper(options);\n\t\t\t/**\n\t\t\t * If the processor was disposed or not. Keep alive until it's disposed.\n\t\t\t */\n\t\t\tthis.disposed = false;\n\t\t   \t/** \n\t\t\t * The number of samples in the processing block\n\t\t\t */\n\t\t\tthis.blockSize = 128;\n\t\t\t/**\n\t\t\t * the sample rate\n\t\t\t */\n\t\t\tthis.sampleRate = sampleRate;\n\n\t\t\tthis.port.onmessage = (event) => {\n\t\t\t\t// when it receives a dispose \n\t\t\t\tif (event.data === \"dispose\") {\n\t\t\t\t\tthis.disposed = true;\n\t\t\t\t}\n\t\t\t};\n\t\t}\n\t}\n`;\n\naddToWorklet(toneAudioWorkletProcessor);\n", "import \"./ToneAudioWorkletProcessor.worklet\";\nimport { addToWorklet } from \"./WorkletGlobalScope\";\n\nexport const singleIOProcess = /* javascript */ `\n\t/**\n\t * Abstract class for a single input/output processor. \n\t * has a 'generate' function which processes one sample at a time\n\t */\n\tclass SingleIOProcessor extends ToneAudioWorkletProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(Object.assign(options, {\n\t\t\t\tnumberOfInputs: 1,\n\t\t\t\tnumberOfOutputs: 1\n\t\t\t}));\n\t\t\t/**\n\t\t\t * Holds the name of the parameter and a single value of that\n\t\t\t * parameter at the current sample\n\t\t\t * @type { [name: string]: number }\n\t\t\t */\n\t\t\tthis.params = {}\n\t\t}\n\n\t\t/**\n\t\t * Generate an output sample from the input sample and parameters\n\t\t * @abstract\n\t\t * @param input number\n\t\t * @param channel number\n\t\t * @param parameters { [name: string]: number }\n\t\t * @returns number\n\t\t */\n\t\tgenerate(){}\n\n\t\t/**\n\t\t * Update the private params object with the \n\t\t * values of the parameters at the given index\n\t\t * @param parameters { [name: string]: Float32Array },\n\t\t * @param index number\n\t\t */\n\t\tupdateParams(parameters, index) {\n\t\t\tfor (const paramName in parameters) {\n\t\t\t\tconst param = parameters[paramName];\n\t\t\t\tif (param.length > 1) {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][index];\n\t\t\t\t} else {\n\t\t\t\t\tthis.params[paramName] = parameters[paramName][0];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Process a single frame of the audio\n\t\t * @param inputs Float32Array[][]\n\t\t * @param outputs Float32Array[][]\n\t\t */\n\t\tprocess(inputs, outputs, parameters) {\n\t\t\tconst input = inputs[0];\n\t\t\tconst output = outputs[0];\n\t\t\t// get the parameter values\n\t\t\tconst channelCount = Math.max(input && input.length || 0, output.length);\n\t\t\tfor (let sample = 0; sample < this.blockSize; sample++) {\n\t\t\t\tthis.updateParams(parameters, sample);\n\t\t\t\tfor (let channel = 0; channel < channelCount; channel++) {\n\t\t\t\t\tconst inputSample = input && input.length ? input[channel][sample] : 0;\n\t\t\t\t\toutput[channel][sample] = this.generate(inputSample, channel, this.params);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn !this.disposed;\n\t\t}\n\t};\n`;\n\naddToWorklet(singleIOProcess);\n", "import { addToWorklet } from \"./WorkletGlobalScope\";\n\nconst delayLine = /* javascript */ `\n\t/**\n\t * A multichannel buffer for use within an AudioWorkletProcessor as a delay line\n\t */\n\tclass DelayLine {\n\t\t\n\t\tconstructor(size, channels) {\n\t\t\tthis.buffer = [];\n\t\t\tthis.writeHead = []\n\t\t\tthis.size = size;\n\n\t\t\t// create the empty channels\n\t\t\tfor (let i = 0; i < channels; i++) {\n\t\t\t\tthis.buffer[i] = new Float32Array(this.size);\n\t\t\t\tthis.writeHead[i] = 0;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Push a value onto the end\n\t\t * @param channel number\n\t\t * @param value number\n\t\t */\n\t\tpush(channel, value) {\n\t\t\tthis.writeHead[channel] += 1;\n\t\t\tif (this.writeHead[channel] > this.size) {\n\t\t\t\tthis.writeHead[channel] = 0;\n\t\t\t}\n\t\t\tthis.buffer[channel][this.writeHead[channel]] = value;\n\t\t}\n\n\t\t/**\n\t\t * Get the recorded value of the channel given the delay\n\t\t * @param channel number\n\t\t * @param delay number delay samples\n\t\t */\n\t\tget(channel, delay) {\n\t\t\tlet readHead = this.writeHead[channel] - Math.floor(delay);\n\t\t\tif (readHead < 0) {\n\t\t\t\treadHead += this.size;\n\t\t\t}\n\t\t\treturn this.buffer[channel][readHead];\n\t\t}\n\t}\n`;\n\naddToWorklet(delayLine);\n", "import \"../../core/worklet/SingleIOProcessor.worklet\";\nimport \"../../core/worklet/DelayLine.worklet\";\nimport { registerProcessor } from \"../../core/worklet/WorkletGlobalScope\";\n\nexport const workletName = \"feedback-comb-filter\";\n\nconst feedbackCombFilter = /* javascript */`\n\tclass FeedbackCombFilterWorklet extends SingleIOProcessor {\n\n\t\tconstructor(options) {\n\t\t\tsuper(options);\n\t\t\tthis.delayLine = new DelayLine(this.sampleRate, options.channelCount || 2);\n\t\t}\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"delayTime\",\n\t\t\t\tdefaultValue: 0.1,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 1,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}, {\n\t\t\t\tname: \"feedback\",\n\t\t\t\tdefaultValue: 0.5,\n\t\t\t\tminValue: 0,\n\t\t\t\tmaxValue: 0.9999,\n\t\t\t\tautomationRate: \"k-rate\"\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, channel, parameters) {\n\t\t\tconst delayedSample = this.delayLine.get(channel, parameters.delayTime * this.sampleRate);\n\t\t\tthis.delayLine.push(channel, input + delayedSample * parameters.feedback);\n\t\t\treturn delayedSample;\n\t\t}\n\t}\n`;\n\nregisterProcessor(workletName, feedbackCombFilter);\n", "import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\nimport { ToneAudioWorklet } from \"../../core/worklet/ToneAudioWorklet\";\nimport { workletName } from \"./FeedbackCombFilter.worklet\";\n\nexport interface FeedbackCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n}\n\n/**\n * Comb filters are basic building blocks for physical modeling. Read more\n * about comb filters on [CCRMA's website](https://ccrma.stanford.edu/~jos/pasp/Feedback_Comb_Filters.html).\n * \n * This comb filter is implemented with the AudioWorkletNode which allows it to have feedback delays less than the \n * Web Audio processing block of 128 samples. There is a polyfill for browsers that don't yet support the \n * AudioWorkletNode, but it will add some latency and have slower performance than the AudioWorkletNode. \n * @category Component\n */\nexport class FeedbackCombFilter extends ToneAudioWorklet<FeedbackCombFilterOptions> {\n\n\treadonly name = \"FeedbackCombFilter\";\n\n\t/**\n\t * The amount of delay of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param delayTime The delay time of the filter.\n\t * @param resonance The amount of feedback the filter has.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange);\n\tconstructor(options?: RecursivePartial<FeedbackCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]));\n\t\tconst options = optionsFromArguments(FeedbackCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\"]);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.delayTime = new Param<\"time\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.delayTime,\n\t\t\tunits: \"time\",\n\t\t\tminValue: 0,\n\t\t\tmaxValue: 1,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\n\t\tthis.resonance = new Param<\"normalRange\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.resonance,\n\t\t\tunits: \"normalRange\",\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\n\t\treadOnly(this, [\"resonance\", \"delayTime\"]);\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\t/**\n\t * The default parameters\n\t */\n\tstatic getDefaults(): FeedbackCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst delayTime = node.parameters.get(\"delayTime\") as AudioParam;;\n\t\tthis.delayTime.setParam(delayTime);\n\t\tconst feedback = node.parameters.get(\"feedback\") as AudioParam;;\n\t\tthis.resonance.setParam(feedback);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.delayTime.dispose();\n\t\tthis.resonance.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport type OnePoleFilterType = \"highpass\" | \"lowpass\";\n\nexport interface OnePoleFilterOptions extends ToneAudioNodeOptions {\n\tfrequency: Frequency;\n\ttype: OnePoleFilterType;\n}\n\n/**\n * A one pole filter with 6db-per-octave rolloff. Either \"highpass\" or \"lowpass\". \n * Note that changing the type or frequency may result in a discontinuity which\n * can sound like a click or pop. \n * References: \n * * http://www.earlevel.com/main/2012/12/15/a-one-pole-filter/  \n * * http://www.dspguide.com/ch19/2.htm\n * * https://github.com/vitaliy-bobrov/js-rocks/blob/master/src/app/audio/effects/one-pole-filters.ts\n * @category Component\n */\nexport class OnePoleFilter extends ToneAudioNode<OnePoleFilterOptions> {\n\t\n\treadonly name: string = \"OnePoleFilter\";\n\n\t/**\n\t * Hold the current frequency\n\t */\n\tprivate _frequency: Frequency;\n\n\t/**\n\t * the current one pole type\n\t */\n\tprivate _type: OnePoleFilterType;\n\n\t/**\n\t * the current one pole filter\n\t */\n\tprivate _filter!: IIRFilterNode;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param frequency The frequency\n\t * @param type The  filter type, either \"lowpass\" or \"highpass\"\n\t */\n\tconstructor(frequency?: Frequency, type?: OnePoleFilterType);\n\tconstructor(options?: Partial<OnePoleFilterOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OnePoleFilter.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis._frequency = options.frequency;\n\t\tthis._type = options.type;\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis._createFilter();\n\t}\n\n\tstatic getDefaults(): OnePoleFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfrequency: 880,\n\t\t\ttype: \"lowpass\" as OnePoleFilterType\n\t\t});\n\t}\n\n\t/**\n\t * Create a filter and dispose the old one\n\t */\n\tprivate _createFilter() {\n\t\tconst oldFilter = this._filter;\n\t\tconst freq = this.toFrequency(this._frequency);\n\t\tconst t = 1 / (2 * Math.PI * freq);\n\t\tif (this._type === \"lowpass\") {\n\t\t\tconst a0 = 1 / (t * this.context.sampleRate);\n\t\t\tconst b1 = a0 - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([a0, 0], [1, b1]);\n\t\t} else {\n\t\t\tconst b1 = 1 / (t * this.context.sampleRate) - 1;\n\t\t\tthis._filter = this.context.createIIRFilter([1, -1], [1, b1]);\n\t\t}\n\t\t\n\t\tthis.input.chain(this._filter, this.output);\n\t\tif (oldFilter) {\n\t\t\t// dispose it on the next block\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tif (!this.disposed) {\n\t\t\t\t\tthis.input.disconnect(oldFilter);\n\t\t\t\t\toldFilter.disconnect();\n\t\t\t\t}\n\t\t\t}, this.blockTime);\n\t\t}\n\t}\n\n\t/**\n\t * The frequency value. \n\t */\n\tget frequency(): Frequency {\n\t\treturn this._frequency;\n\t}\n\tset frequency(fq) {\n\t\tthis._frequency = fq;\n\t\tthis._createFilter();\n\t}\n\t\n\t/**\n\t * The OnePole Filter type, either \"highpass\" or \"lowpass\"\n\t */\n\tget type(): OnePoleFilterType {\n\t\treturn this._type;\n\t}\n\tset type(t) {\n\t\tthis._type = t;\n\t\tthis._createFilter();\n\t}\n\n\t/**\n\t * Get the frequency response curve. This curve represents how the filter\n\t * responses to frequencies between 20hz-20khz.\n\t * @param  len The number of values to return\n\t * @return The frequency response curve between 20-20kHz\n\t */\n\tgetFrequencyResponse(len = 128): Float32Array {\n\t\tconst freqValues = new Float32Array(len);\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tconst norm = Math.pow(i / len, 2);\n\t\t\tconst freq = norm * (20000 - 20) + 20;\n\t\t\tfreqValues[i] = freq;\n\t\t}\n\t\tconst magValues = new Float32Array(len);\n\t\tconst phaseValues = new Float32Array(len);\n\t\tthis._filter.getFrequencyResponse(freqValues, magValues, phaseValues);\n\t\treturn magValues;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis._filter.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { RecursivePartial } from \"../../core/util/Interface\";\nimport { FeedbackCombFilter } from \"./FeedbackCombFilter\";\nimport { OnePoleFilter } from \"./OnePoleFilter\";\n\ninterface LowpassCombFilterOptions extends ToneAudioNodeOptions {\n\tdelayTime: Time;\n\tresonance: NormalRange;\n\tdampening: Frequency;\n}\n\n/**\n * A lowpass feedback comb filter. It is similar to\n * [[FeedbackCombFilter]], but includes a lowpass filter.\n * @category Component\n */\nexport class LowpassCombFilter extends ToneAudioNode<LowpassCombFilterOptions> {\n\n\treadonly name = \"LowpassCombFilter\";\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _combFilter: FeedbackCombFilter;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The delayTime of the comb filter.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * The amount of feedback of the delayed signal.\n\t */\n\treadonly resonance: Param<\"normalRange\">;\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * @param delayTime The delay time of the comb filter\n\t * @param resonance The resonance (feedback) of the comb filter\n\t * @param dampening The cutoff of the lowpass filter dampens the signal as it is fedback.\n\t */\n\tconstructor(delayTime?: Time, resonance?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: RecursivePartial<LowpassCombFilterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(LowpassCombFilter.getDefaults(), arguments, [\"delayTime\", \"resonance\", \"dampening\"]);\n\n\t\tthis._combFilter = this.output = new FeedbackCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tresonance: options.resonance,\n\t\t});\n\t\tthis.delayTime = this._combFilter.delayTime;\n\t\tthis.resonance = this._combFilter.resonance;\n\n\t\tthis._lowpass = this.input = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.dampening,\n\t\t\ttype: \"lowpass\",\n\t\t});\n\n\t\t// connections\n\t\tthis._lowpass.connect(this._combFilter);\n\t}\n\n\tstatic getDefaults(): LowpassCombFilterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tdampening: 3000,\n\t\t\tdelayTime: 0.1,\n\t\t\tresonance: 0.5,\n\t\t});\n\t}\n\t\n\t/**\n\t * The dampening control of the feedback\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lowpass.frequency;\n\t}\n\tset dampening(fq) {\n\t\tthis._lowpass.frequency = fq;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._combFilter.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\nimport { deepMerge } from \"../core/util/Defaults\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\n\nexport interface PluckSynthOptions extends InstrumentOptions {\n\tattackNoise: number;\n\tdampening: Frequency;\n\tresonance: NormalRange;\n\trelease: Time;\n}\n\n/**\n * Karplus-String string synthesis.\n * @example\n * const plucky = new Tone.PluckSynth().toDestination();\n * plucky.triggerAttack(\"C4\", \"+0.5\");\n * plucky.triggerAttack(\"C3\", \"+1\");\n * plucky.triggerAttack(\"C2\", \"+1.5\");\n * plucky.triggerAttack(\"C1\", \"+2\");\n * @category Instrument\n */\nexport class PluckSynth extends Instrument<PluckSynthOptions> {\n\n\treadonly name = \"PluckSynth\";\n\n\t/**\n\t * Noise burst at the beginning\n\t */\n\tprivate _noise: Noise;\n\tprivate _lfcf: LowpassCombFilter;\n\n\t/**\n\t * The amount of noise at the attack.\n\t * Nominal range of [0.1, 20]\n\t * @min 0.1\n\t * @max 20\n\t */\n\tattackNoise: number;\n\n\t/**\n\t * The amount of resonance of the pluck. Also correlates to the sustain duration.\n\t */\n\tresonance: NormalRange;\n\n\t/**\n\t * The release time which corresponds to a resonance ramp down to 0\n\t */\n\trelease: Time;\n\n\tconstructor(options?: RecursivePartial<PluckSynthOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PluckSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(PluckSynth.getDefaults(), arguments);\n\n\t\tthis._noise = new Noise({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"pink\"\n\t\t});\n\n\t\tthis.attackNoise = options.attackNoise;\n\n\t\tthis._lfcf = new LowpassCombFilter({\n\t\t\tcontext: this.context,\n\t\t\tdampening: options.dampening,\n\t\t\tresonance: options.resonance,\n\t\t});\n\n\t\tthis.resonance = options.resonance;\n\t\tthis.release = options.release;\n\n\t\tthis._noise.connect(this._lfcf);\n\t\tthis._lfcf.connect(this.output);\n\t}\n\n\tstatic getDefaults(): PluckSynthOptions {\n\t\treturn deepMerge(Instrument.getDefaults(), {\n\t\t\tattackNoise: 1,\n\t\t\tdampening: 4000,\n\t\t\tresonance: 0.7,\n\t\t\trelease: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The dampening control. i.e. the lowpass filter frequency of the comb filter\n\t * @min 0\n\t * @max 7000\n\t */\n\tget dampening(): Frequency {\n\t\treturn this._lfcf.dampening;\n\t}\n\tset dampening(fq) {\n\t\tthis._lfcf.dampening = fq;\n\t}\n\n\ttriggerAttack(note: Frequency, time?: Time): this {\n\t\tconst freq = this.toFrequency(note);\n\t\ttime = this.toSeconds(time);\n\t\tconst delayAmount = 1 / freq;\n\t\tthis._lfcf.delayTime.setValueAtTime(delayAmount, time);\n\t\tthis._noise.start(time);\n\t\tthis._noise.stop(time + delayAmount * this.attackNoise);\n\t\tthis._lfcf.resonance.cancelScheduledValues(time);\n\t\tthis._lfcf.resonance.setValueAtTime(this.resonance, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Ramp down the [[resonance]] to 0 over the duration of the release time.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis._lfcf.resonance.linearRampTo(0, this.release, time);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._noise.dispose();\n\t\tthis._lfcf.dispose();\n\t\treturn this;\n\t}\n}\n", "import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends MonoSynth ? MonoSynthOptions :\n\t\t\t\t\tT extends AMSynth ? AMSynthOptions :\n\t\t\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{ midi: MidiNote; voice: Voice; released: boolean }> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote, voice, released: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes. \n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach(voice => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tassert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: urlMap,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as \"exponential\",\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n\t\t\tconst midi = Math.round(midiFloat) as MidiNote;\n\t\t\tconst remainder = midiFloat - midi;\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference + remainder);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\turl: buffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tassert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n", "import \"../core/clock/Transport\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline } from \"../core/util/StateTimeline\";\nimport { isBoolean, isNumber } from \"../core/util/TypeCheck\";\n\nexport type ToneEventCallback<T> = (time: Seconds, value: T) => void;\n\nexport interface ToneEventOptions<T> extends ToneWithContextOptions {\n\tcallback: ToneEventCallback<T>;\n\tloop: boolean | number;\n\tloopEnd: Time;\n\tloopStart: Time;\n\tplaybackRate: Positive;\n\tvalue?: T;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * ToneEvent abstracts away this.context.transport.schedule and provides a schedulable\n * callback for a single or repeatable events along the timeline.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * const chordEvent = new Tone.ToneEvent(((time, chord) => {\n * \t// the chord as well as the exact time of the event\n * \t// are passed in as arguments to the callback function\n * \tsynth.triggerAttackRelease(chord, 0.5, time);\n * }), [\"D4\", \"E4\", \"F4\"]);\n * // start the chord at the beginning of the transport timeline\n * chordEvent.start();\n * // loop it every measure for 8 measures\n * chordEvent.loop = 8;\n * chordEvent.loopEnd = \"1m\";\n * @category Event\n */\nexport class ToneEvent<ValueType = any> extends ToneWithContext<ToneEventOptions<ValueType>> {\n\n\treadonly name: string = \"ToneEvent\";\n\n\t/**\n\t * Loop value\n\t */\n\tprotected _loop: boolean | number;\n\n\t/**\n\t * The callback to invoke.\n\t */\n\tcallback: ToneEventCallback<ValueType>;\n\n\t/**\n\t * The value which is passed to the\n\t * callback function.\n\t */\n\tvalue: ValueType;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopStart: Ticks;\n\n\t/**\n\t * When the note is scheduled to start.\n\t */\n\tprotected _loopEnd: Ticks;\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The playback speed of the note. A speed of 1\n\t * is no change.\n\t */\n\tprotected _playbackRate: Positive;\n\n\t/**\n\t * A delay time from when the event is scheduled to start\n\t */\n\tprotected _startOffset: Ticks = 0;\n\n\t/**\n\t * private holder of probability value\n\t */\n\tprotected _probability: NormalRange;\n\n\t/**\n\t * the amount of variation from the given time.\n\t */\n\tprotected _humanize: boolean | Time;\n\n\t/**\n\t * If mute is true, the callback won't be invoked.\n\t */\n\tmute: boolean;\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param value The value or values which should be passed to the callback function on invocation.\n\t */\n\tconstructor(callback?: ToneEventCallback<ValueType>, value?: ValueType);\n\tconstructor(options?: Partial<ToneEventOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]));\n\t\tconst options = optionsFromArguments(ToneEvent.getDefaults(), arguments, [\"callback\", \"value\"]);\n\n\t\tthis._loop = options.loop;\n\t\tthis.callback = options.callback;\n\t\tthis.value = options.value;\n\t\tthis._loopStart = this.toTicks(options.loopStart);\n\t\tthis._loopEnd = this.toTicks(options.loopEnd);\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._probability = options.probability;\n\t\tthis._humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis._state.increasing = true;\n\t\t// schedule the events for the first time\n\t\tthis._rescheduleEvents();\n\t}\n\n\tstatic getDefaults(): ToneEventOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp,\n\t\t\thumanize: false,\n\t\t\tloop: false,\n\t\t\tloopEnd: \"1m\",\n\t\t\tloopStart: 0,\n\t\t\tmute: false,\n\t\t\tplaybackRate: 1,\n\t\t\tprobability: 1,\n\t\t\tvalue: null,\n\t\t});\n\t}\n\n\t/**\n\t * Reschedule all of the events along the timeline\n\t * with the updated values.\n\t * @param after Only reschedules events after the given time.\n\t */\n\tprivate _rescheduleEvents(after: Ticks = -1): void {\n\t\t// if no argument is given, schedules all of the events\n\t\tthis._state.forEachFrom(after, event => {\n\t\t\tlet duration;\n\t\t\tif (event.state === \"started\") {\n\t\t\t\tif (event.id !== -1) {\n\t\t\t\t\tthis.context.transport.clear(event.id);\n\t\t\t\t}\n\t\t\t\tconst startTick = event.time + Math.round(this.startOffset / this._playbackRate);\n\t\t\t\tif (this._loop === true || isNumber(this._loop) && this._loop > 1) {\n\t\t\t\t\tduration = Infinity;\n\t\t\t\t\tif (isNumber(this._loop)) {\n\t\t\t\t\t\tduration = (this._loop) * this._getLoopDuration();\n\t\t\t\t\t}\n\t\t\t\t\tconst nextEvent = this._state.getAfter(startTick);\n\t\t\t\t\tif (nextEvent !== null) {\n\t\t\t\t\t\tduration = Math.min(duration, nextEvent.time - startTick);\n\t\t\t\t\t}\n\t\t\t\t\tif (duration !== Infinity) {\n\t\t\t\t\t\t// schedule a stop since it's finite duration\n\t\t\t\t\t\tthis._state.setStateAtTime(\"stopped\", startTick + duration + 1, { id: -1 });\n\t\t\t\t\t\tduration = new TicksClass(this.context, duration);\n\t\t\t\t\t}\n\t\t\t\t\tconst interval = new TicksClass(this.context, this._getLoopDuration());\n\t\t\t\t\tevent.id = this.context.transport.scheduleRepeat(\n\t\t\t\t\t\tthis._tick.bind(this), interval, new TicksClass(this.context, startTick), duration);\n\t\t\t\t} else {\n\t\t\t\t\tevent.id = this.context.transport.schedule(this._tick.bind(this), new TicksClass(this.context, startTick));\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the note, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._state.getValueAtTime(this.context.transport.ticks) as BasicPlaybackState;\n\t}\n\n\t/**\n\t * The start from the scheduled start time.\n\t */\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t}\n\n\t/**\n\t * The probability of the notes being triggered.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t}\n\n\t/**\n\t * If set to true, will apply small random variation\n\t * to the callback time. If the value is given as a time, it will randomize\n\t * by that amount.\n\t * @example\n\t * const event = new Tone.ToneEvent();\n\t * event.humanize = true;\n\t */\n\tget humanize(): Time | boolean {\n\t\treturn this._humanize;\n\t}\n\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t}\n\n\t/**\n\t * Start the note at the given time.\n\t * @param  time  When the event should start.\n\t */\n\tstart(time?: TransportTime | TransportTimeClass): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"stopped\") {\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._rescheduleEvents(ticks);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the Event at the given time.\n\t * @param  time  When the event should stop.\n\t */\n\tstop(time?: TransportTime | TransportTimeClass): this {\n\t\tthis.cancel(time);\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"stopped\", ticks, { id: -1 });\n\t\t\tconst previousEvent = this._state.getBefore(ticks);\n\t\t\tlet reschedulTime = ticks;\n\t\t\tif (previousEvent !== null) {\n\t\t\t\treschedulTime = previousEvent.time;\n\t\t\t}\n\t\t\tthis._rescheduleEvents(reschedulTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime | TransportTimeClass): this {\n\t\ttime = defaultArg(time, -Infinity);\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.forEachFrom(ticks, event => {\n\t\t\tthis.context.transport.clear(event.id);\n\t\t});\n\t\tthis._state.cancel(ticks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The callback function invoker. Also\n\t * checks if the Event is done playing\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst ticks = this.context.transport.getTicksAtTime(time);\n\t\tif (!this.mute && this._state.getValueAtTime(ticks) === \"started\") {\n\t\t\tif (this.probability < 1 && Math.random() > this.probability) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (this.humanize) {\n\t\t\t\tlet variation = 0.02;\n\t\t\t\tif (!isBoolean(this.humanize)) {\n\t\t\t\t\tvariation = this.toSeconds(this.humanize);\n\t\t\t\t}\n\t\t\t\ttime += (Math.random() * 2 - 1) * variation;\n\t\t\t}\n\t\t\tthis.callback(time, this.value);\n\t\t}\n\t}\n\n\t/**\n\t * Get the duration of the loop.\n\t */\n\tprotected _getLoopDuration(): Ticks {\n\t\treturn Math.round((this._loopEnd - this._loopStart) / this._playbackRate);\n\t}\n\n\t/**\n\t * If the note should loop or not\n\t * between ToneEvent.loopStart and\n\t * ToneEvent.loopEnd. If set to true,\n\t * the event will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The playback rate of the note. Defaults to 1.\n\t * @example\n\t * const note = new Tone.ToneEvent();\n\t * note.loop = true;\n\t * // repeat the note twice as fast\n\t * note.playbackRate = 2;\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._rescheduleEvents();\n\t}\n\n\t/**\n\t * The loopEnd point is the time the event will loop\n\t * if ToneEvent.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The time when the loop should start.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._rescheduleEvents();\n\t\t}\n\t}\n\n\t/**\n\t * The current progress of the loop interval.\n\t * Returns 0 if the event is not started yet or\n\t * it is not set to loop.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this._loop) {\n\t\t\tconst ticks = this.context.transport.ticks;\n\t\t\tconst lastEvent = this._state.get(ticks);\n\t\t\tif (lastEvent !== null && lastEvent.state === \"started\") {\n\t\t\t\tconst loopDuration = this._getLoopDuration();\n\t\t\t\tconst progress = (ticks - lastEvent.time) % loopDuration;\n\t\t\t\treturn progress / loopDuration;\n\t\t\t} else {\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.cancel();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneEvent } from \"./ToneEvent\";\nimport { NormalRange, Positive, Seconds, Time, TransportTime } from \"../core/type/Units\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport interface LoopOptions extends ToneWithContextOptions {\n\tcallback: (time: Seconds) => void;\n\tinterval: Time;\n\tplaybackRate: Positive;\n\titerations: number;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * Loop creates a looped callback at the \n * specified interval. The callback can be \n * started, stopped and scheduled along\n * the Transport's timeline. \n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note. \n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop<Options extends LoopOptions = LoopOptions> extends ToneWithContext<Options> {\n\n\treadonly name: string = \"Loop\";\n\n\t/**\n\t * The event which produces the callbacks\n\t */\n\tprivate _event: ToneEvent;\n\n\t/**\n\t * The callback to invoke with the next event in the pattern\n\t */\n\tcallback: (time: Seconds) => void\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param interval The time between successive callback calls. \n\t */\n\tconstructor(callback?: (time: Seconds) => void, interval?: Time);\n\tconstructor(options?: Partial<LoopOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n\t\tconst options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n\n\t\tthis._event = new ToneEvent({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tloop: true,\n\t\t\tloopEnd: options.interval,\n\t\t\tplaybackRate: options.playbackRate,\n\t\t\tprobability: options.probability\n\t\t});\n\n\t\tthis.callback = options.callback;\n\t\t// set the iterations\n\t\tthis.iterations = options.iterations;\n\t}\n\n\tstatic getDefaults(): LoopOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tinterval: \"4n\",\n\t\t\tcallback: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\titerations: Infinity,\n\t\t\tprobability: 1,\n\t\t\tmute: false,\n\t\t\thumanize: false\n\t\t});\n\t}\n\n\t/**\n\t * Start the loop at the specified time along the Transport's timeline.\n\t * @param  time  When to start the Loop.\n\t */\n\tstart(time?: TransportTime): this {\n\t\tthis._event.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the loop at the given time.\n\t * @param  time  When to stop the Loop.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._event.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime): this {\n\t\tthis._event.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t * @param time  The time the event occurs\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tthis.callback(time);\n\t}\n\n\t/**\n\t * The state of the Loop, either started or stopped.\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._event.state;\n\t}\n\n\t/**\n\t * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating. \n\t */\n\tget progress(): NormalRange {\n\t\treturn this._event.progress;\n\t}\n\n\t/**\n\t * The time between successive callbacks. \n\t * @example\n\t * const loop = new Tone.Loop();\n\t * loop.interval = \"8n\"; // loop every 8n\n\t */\n\tget interval(): Time {\n\t\treturn this._event.loopEnd;\n\t}\n\tset interval(interval) {\n\t\tthis._event.loopEnd = interval;\n\t}\n\n\t/**\n\t * The playback rate of the loop. The normal playback rate is 1 (no change). \n\t * A `playbackRate` of 2 would be twice as fast. \n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._event.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._event.playbackRate = rate;\n\t}\n\n\t/**\n\t * Random variation +/-0.01s to the scheduled time. \n\t * Or give it a time value which it will randomize by.\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._event.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._event.humanize = variation;\n\t}\n\n\t/**\n\t * The probably of the callback being invoked.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._event.probability;\n\t}\n\n\tset probability(prob) {\n\t\tthis._event.probability = prob;\n\t}\n\n\t/**\n\t * Muting the Loop means that no callbacks are invoked.\n\t */\n\tget mute(): boolean {\n\t\treturn this._event.mute;\n\t}\n\n\tset mute(mute) {\n\t\tthis._event.mute = mute;\n\t}\n\n\t/**\n\t * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n\t */\n\tget iterations(): number {\n\t\tif (this._event.loop === true) {\n\t\t\treturn Infinity;\n\t\t} else {\n\t\t\treturn this._event.loop as number;\n\t\t}\n\t}\n\tset iterations(iters) {\n\t\tif (iters === Infinity) {\n\t\t\tthis._event.loop = true;\n\t\t} else {\n\t\t\tthis._event.loop = iters;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._event.dispose();\n\t\treturn this;\n\t}\n}\n", "import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t} ? T :\n\t\tT extends ArrayLike<any> ? T[1] :\n\t\t\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// make sure things are assigned in the right order\n\t\tthis._state.increasing = true;\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.at(\"1m\"); // returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n\t * // if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.add(\"1m\", \"C#+11\");\n\t */\n\tadd(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * const part = new Tone.Part();\n\t * // loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n", "import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName = \"up\" | \"down\" | \"upDown\" | \"downUp\" | \"alternateUp\" | \"alternateDown\" | \"random\" | \"randomOnce\" | \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(values: T[], gen: typeof upPatternGen): IterableIterator<T> {\n\twhile (true) {\n\t\tyield* gen(values);\n\t}\n}\n\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index: number, values: any[]): number {\n\treturn clamp(index, 0, values.length - 1);\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(values: T[], directionUp: boolean): IterableIterator<T> {\n\tlet index = directionUp ? 0 : values.length - 1;\n\twhile (true) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= values.length - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? 2 : -1);\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? -2 : 1);\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(values: T[]): IterableIterator<T> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * values.length);\n\t\tyield values[randomIndex];\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(values: T[]): IterableIterator<T> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < values.length; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clampToArraySize(randVal[0], values);\n\t\tyield values[index];\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk<T>(values: T[]): IterableIterator<T> {\n\t// randomly choose a starting index in the values array\n\tlet index = Math.floor(Math.random() * values.length);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom of array, so force upward step\n\t\t} else if (index === values.length - 1) {\n\t\t\tindex--; // at top of array, so force downward step\n\t\t} else if (Math.random() < 0.5) { // else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield values[index];\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator<T>(values: T[], pattern: PatternName = \"up\", index = 0): Iterator<T> {\n\t// safeguards\n\tassert(values.length > 0, \"The array must have more than one value in it\");\n\tswitch (pattern) {\n\t\tcase \"up\" :\n\t\t\tyield* infiniteGen(values, upPatternGen);\n\t\tcase \"down\" :\n\t\t\tyield* infiniteGen(values, downPatternGen);\n\t\tcase \"upDown\" :\n\t\t\tyield* alternatingGenerator(values, true);\n\t\tcase \"downUp\" :\n\t\t\tyield* alternatingGenerator(values, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(values, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(values, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(values);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(values, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(values);\n\t}\n}\n", "import { Loop, LoopOptions } from \"./Loop\";\nimport { PatternGenerator, PatternName } from \"./PatternGenerator\";\nimport { ToneEventCallback } from \"./ToneEvent\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Seconds } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\n\nexport interface PatternOptions<ValueType> extends LoopOptions {\n\tpattern: PatternName;\n\tvalues: ValueType[];\n\tcallback: (time: Seconds, value?: ValueType) => void;\n}\n\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns. \n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport class Pattern<ValueType> extends Loop<PatternOptions<ValueType>> {\n\n\treadonly name: string = \"Pattern\";\n\n\t/**\n\t * The pattern generator function\n\t */\n\tprivate _pattern: Iterator<ValueType>;\n\n\t/**\n\t * The current value\n\t */\n\tprivate _value?: ValueType;\n\n\t/**\n\t * Hold the pattern type\n\t */\n\tprivate _type: PatternName;\n\n\t/**\n\t * Hold the values\n\t */\n\tprivate _values: ValueType[];\n\n\t/**\n\t * The callback to be invoked at a regular interval\n\t */\n\tcallback: (time: Seconds, value?: ValueType) => void;\n\n\t/**\n\t * @param  callback The callback to invoke with the event.\n\t * @param  values The values to arpeggiate over.\n\t * @param  pattern  The name of the pattern\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tvalues?: ValueType[],\n\t\tpattern?: PatternName,\n\t);\n\tconstructor(options?: Partial<PatternOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n\t\tconst options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._values = options.values;\n\t\tthis._pattern = PatternGenerator(options.values, options.pattern);\n\t\tthis._type = options.pattern;\n\t}\n\n\tstatic getDefaults(): PatternOptions<any> {\n\t\treturn Object.assign(Loop.getDefaults(), {\n\t\t\tpattern: \"up\" as \"up\",\n\t\t\tvalues: [],\n\t\t\tcallback: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst value = this._pattern.next() as IteratorResult<ValueType>;\n\t\tthis._value = value.value;\n\t\tthis.callback(time, this._value);\n\t}\n\n\t/**\n\t * The array of events.\n\t */\n\tget values(): ValueType[] {\n\t\treturn this._values;\n\t}\n\tset values(val) {\n\t\tthis._values = val;\n\t\t// reset the pattern\n\t\tthis.pattern = this._type;\n\t}\n\n\t/**\n\t * The current value of the pattern.\n\t */\n\tget value(): ValueType | undefined {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t */\n\tget pattern(): PatternName {\n\t\treturn this._type;\n\t}\n\tset pattern(pattern) {\n\t\tthis._type = pattern;\n\t\tthis._pattern = PatternGenerator(this._values, this._type);\n\t}\n}\n\n", "import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | Array<T | Array<T | Array<T | Array<T | T[]>>>>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { connect, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { GainToAudio } from \"../../signal/GainToAudio\";\nimport { Signal } from \"../../signal/Signal\";\n\ninterface CrossFadeOptions extends ToneAudioNodeOptions {\n\tfade: NormalRange;\n}\n\n/**\n * Tone.Crossfade provides equal power fading between two inputs.\n * More on crossfading technique [here](https://en.wikipedia.org/wiki/Fade_(audio_engineering)#Crossfading).\n * ```\n *                                             +---------+\n *                                            +> input a +>--+\n * +-----------+   +---------------------+     |         |   |\n * | 1s signal +>--> stereoPannerNode  L +>----> gain    |   |\n * +-----------+   |                     |     +---------+   |\n *               +-> pan               R +>-+                |   +--------+\n *               | +---------------------+  |                +---> output +>\n *  +------+     |                          |  +---------+   |   +--------+\n *  | fade +>----+                          | +> input b +>--+\n *  +------+                                |  |         |\n *                                          +--> gain    |\n *                                             +---------+\n * ```\n * @example\n * const crossFade = new Tone.CrossFade().toDestination();\n * // connect two inputs Tone.to a/b\n * const inputA = new Tone.Oscillator(440, \"square\").connect(crossFade.a).start();\n * const inputB = new Tone.Oscillator(440, \"sine\").connect(crossFade.b).start();\n * // use the fade to control the mix between the two\n * crossFade.fade.value = 0.5;\n * @category Component\n */\nexport class CrossFade extends ToneAudioNode<CrossFadeOptions> {\n\n\treadonly name: string = \"CrossFade\";\n\n\t/**\n\t * The crossfading is done by a StereoPannerNode\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\n\t/**\n\t * Split the output of the panner node into two values used to control the gains.\n\t */\n\tprivate _split: ChannelSplitterNode = this.context.createChannelSplitter(2);\n\n\t/**\n\t * Convert the fade value into an audio range value so it can be connected\n\t * to the panner.pan AudioParam\n\t */\n\tprivate _g2a: GainToAudio = new GainToAudio({ context: this.context });\n\n\t/**\n\t * The input which is at full level when fade = 0\n\t */\n\treadonly a: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The input which is at full level when fade = 1\n\t */\n\treadonly b: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * The output is a mix between `a` and `b` at the ratio of `fade`\n\t */\n\treadonly output: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * CrossFade has no input, you must choose either `a` or `b`\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The mix between the two inputs. A fade value of 0\n\t * will output 100% crossFade.a and\n\t * a value of 1 will output 100% crossFade.b.\n\t */\n\treadonly fade: Signal<\"normalRange\">;\n\n\tprotected _internalChannels = [this.a, this.b];\n\n\t/**\n\t * @param fade The initial fade value [0, 1].\n\t */\n\tconstructor(fade?: NormalRange);\n\tconstructor(options?: Partial<CrossFadeOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"])));\n\t\tconst options = optionsFromArguments(CrossFade.getDefaults(), arguments, [\"fade\"]);\n\n\t\tthis.fade = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"normalRange\",\n\t\t\tvalue: options.fade,\n\t\t});\n\t\treadOnly(this, \"fade\");\n\n\t\tthis.context.getConstant(1).connect(this._panner);\n\t\tthis._panner.connect(this._split);\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = 1;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\t\tconnect(this._split, this.a.gain, 0);\n\t\tconnect(this._split, this.b.gain, 1);\n\n\t\tthis.fade.chain(this._g2a, this._panner.pan);\n\n\t\tthis.a.connect(this.output);\n\t\tthis.b.connect(this.output);\n\t}\n\n\tstatic getDefaults(): CrossFadeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tfade: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.a.dispose();\n\t\tthis.b.dispose();\n\t\tthis.output.dispose();\n\t\tthis.fade.dispose();\n\t\tthis._g2a.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis._split.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { CrossFade } from \"../component/channel/CrossFade\";\nimport { Gain } from \"../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\n\nexport interface EffectOptions extends ToneAudioNodeOptions {\n\twet: NormalRange;\n}\n/**\n * Effect is the base class for effects. Connect the effect between\n * the effectSend and effectReturn GainNodes, then control the amount of\n * effect which goes to the output using the wet control.\n */\nexport abstract class Effect<Options extends EffectOptions>\n\textends ToneAudioNode<Options> {\n\n\treadonly name: string = \"Effect\";\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade = new CrossFade({ context: this.context });\n\n\t/**\n\t * The wet control is how much of the effected\n\t * will pass through to the output. 1 = 100% effected\n\t * signal, 0 = 100% dry signal.\n\t */\n\twet: Signal<\"normalRange\"> = this._dryWet.fade;\n\n\t/**\n\t * connect the effectSend to the input of hte effect\n\t */\n\tprotected effectSend: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * connect the output of the effect to the effectReturn\n\t */\n\tprotected effectReturn: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect input node\n\t */\n\tinput: Gain = new Gain({ context: this.context });\n\n\t/**\n\t * The effect output\n\t */\n\toutput = this._dryWet;\n\n\tconstructor(options: EffectOptions) {\n\t\tsuper(options);\n\n\t\t// connections\n\t\tthis.input.fan(this._dryWet.a, this.effectSend);\n\t\tthis.effectReturn.connect(this._dryWet.b);\n\t\tthis.wet.setValueAtTime(options.wet, 0);\n\t\tthis._internalChannels = [this.effectReturn, this.effectSend];\n\t\treadOnly(this, \"wet\");\n\t}\n\n\tstatic getDefaults(): EffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\t/**\n\t * chains the effect in between the effectSend and effectReturn\n\t */\n\tprotected connectEffect(effect: ToneAudioNode | AudioNode): this {\n\t\t// add it to the internal channels\n\t\tthis._internalChannels.push(effect);\n\t\tthis.effectSend.chain(effect, this.effectReturn);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis.effectSend.dispose();\n\t\tthis.effectReturn.dispose();\n\t\tthis.wet.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\n\nexport interface LFOEffectOptions extends EffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n}\n\n/**\n * Base class for LFO-based effects.\n */\nexport abstract class LFOEffect<Options extends LFOEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"LFOEffect\";\n\n\t/**\n\t * the lfo which drives the filter cutoff\n\t */\n\tprotected _lfo: LFO;\n\n\t/**\n\t * The range of the filter modulating between the min and max frequency. \n\t * 0 = no modulation. 1 = full modulation.\n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * How fast the filter modulates between min and max. \n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\tconstructor(options: LFOEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tamplitude: options.depth,\n\t\t});\n\t\tthis.depth = this._lfo.amplitude;\n\t\tthis.frequency = this._lfo.frequency;\n\n\t\tthis.type = options.type;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t}\n\n\tstatic getDefaults(): LFOEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 1,\n\t\t\ttype: \"sine\" as ToneOscillatorType,\n\t\t\tdepth: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfo.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfo.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport. See [[LFO.sync]]\n\t */\n\tsync(): this {\n\t\tthis._lfo.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfo.unsync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the LFO's oscillator: See [[Oscillator.type]]\n\t * @example\n\t * const autoFilter = new Tone.AutoFilter().start().toDestination();\n\t * const noise = new Tone.Noise().start().connect(autoFilter);\n\t * autoFilter.type = \"square\";\n\t */\n\tget type() {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Frequency, Positive } from \"../core/type/Units\";\nimport { Filter, FilterOptions } from \"../component/filter/Filter\";\nimport { SourceOptions } from \"../source/Source\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect\";\n\nexport interface AutoFilterOptions extends LFOEffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tfilter: Omit<FilterOptions, keyof SourceOptions | \"frequency\" | \"detune\" | \"gain\">;\n}\n\n/**\n * AutoFilter is a Tone.Filter with a Tone.LFO connected to the filter cutoff frequency.\n * Setting the LFO rate and depth allows for control over the filter modulation rate \n * and depth.\n *\n * @example\n * // create an autofilter and start it's LFO\n * const autoFilter = new Tone.AutoFilter(\"4n\").toDestination().start();\n * // route an oscillator through the filter and start it\n * const oscillator = new Tone.Oscillator().connect(autoFilter).start();\n * @category Effect\n */\nexport class AutoFilter extends LFOEffect<AutoFilterOptions> {\n\n\treadonly name: string = \"AutoFilter\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly filter: Filter;\n\n\t/**\n\t * The octaves placeholder\n\t */\n\tprivate _octaves!: Positive;\n\n\t/**\n\t * @param frequency The rate of the LFO.\n\t * @param baseFrequency The lower value of the LFOs oscillation\n\t * @param octaves The number of octaves above the baseFrequency\n\t */\n\tconstructor(frequency?: Frequency, baseFrequency?: Frequency, octaves?: Positive);\n\tconstructor(options?: Partial<AutoFilterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]));\n\t\tconst options = optionsFromArguments(AutoFilter.getDefaults(), arguments, [\"frequency\", \"baseFrequency\", \"octaves\"]);\n\n\t\tthis.filter = new Filter(Object.assign(options.filter, {\n\t\t\tcontext: this.context,\n\t\t}));\n\n\t\t// connections\n\t\tthis.connectEffect(this.filter);\n\t\tthis._lfo.connect(this.filter.frequency);\n\t\tthis.octaves = options.octaves;\n\t\tthis.baseFrequency = options.baseFrequency;\n\t}\n\n\tstatic getDefaults(): AutoFilterOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tbaseFrequency: 200,\n\t\t\toctaves: 2.6,\n\t\t\tfilter: {\n\t\t\t\ttype: \"lowpass\" as \"lowpass\",\n\t\t\t\trolloff: -12 as -12,\n\t\t\t\tQ: 1,\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The minimum value of the filter's cutoff frequency.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._lfo.min;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._lfo.min = this.toFrequency(freq);\n\t\t// and set the max\n\t\tthis.octaves = this._octaves;\n\t}\n\n\t/**\n\t * The maximum value of the filter's cutoff frequency. \n\t */\n\tget octaves(): Positive {\n\t\treturn this._octaves;\n\t}\n\tset octaves(oct) {\n\t\tthis._octaves = oct;\n\t\tthis._lfo.max = this._lfo.min * Math.pow(2, oct);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.filter.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\ninterface TonePannerOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tchannelCount: number;\n}\n\n/**\n * Panner is an equal power Left/Right Panner. It is a wrapper around the StereoPannerNode.\n * @example\n * return Tone.Offline(() => {\n * // move the input signal from right to left\n * \tconst panner = new Tone.Panner(1).toDestination();\n * \tpanner.pan.rampTo(-1, 0.5);\n * \tconst osc = new Tone.Oscillator(100).connect(panner).start();\n * }, 0.5, 2);\n * @category Component\n */\nexport class Panner extends ToneAudioNode<TonePannerOptions> {\n\n\treadonly name: string = \"Panner\";\n\n\t/**\n\t * the panner node\n\t */\n\tprivate _panner: StereoPannerNode = this.context.createStereoPanner();\n\treadonly input: StereoPannerNode = this._panner;\n\treadonly output: StereoPannerNode = this._panner;\n\n\t/**\n\t * The pan control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \t// pan hard right\n\t * \tconst panner = new Tone.Panner(1).toDestination();\n\t * \t// pan hard left\n\t * \tpanner.pan.setValueAtTime(-1, 0.25);\n\t * \tconst osc = new Tone.Oscillator(50, \"triangle\").connect(panner).start();\n\t * }, 0.5, 2);\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\tconstructor(options?: Partial<TonePannerOptions>);\n\t/**\n\t * @param pan The initial panner value (Defaults to 0 = \"center\").\n\t */\n\tconstructor(pan?: AudioRange);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"])));\n\t\tconst options = optionsFromArguments(Panner.getDefaults(), arguments, [\"pan\"]);\n\n\t\tthis.pan = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.pan,\n\t\t\tvalue: options.pan,\n\t\t\tminValue: -1,\n\t\t\tmaxValue: 1,\n\t\t});\n\n\t\t// this is necessary for standardized-audio-context\n\t\t// doesn't make any difference for the native AudioContext\n\t\t// https://github.com/chrisguttandin/standardized-audio-context/issues/647\n\t\tthis._panner.channelCount = options.channelCount;\n\t\tthis._panner.channelCountMode = \"explicit\";\n\n\t\t// initial value\n\t\treadOnly(this, \"pan\");\n\t}\n\n\tstatic getDefaults(): TonePannerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.pan.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Panner } from \"../component/channel/Panner\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFOEffect, LFOEffectOptions } from \"./LFOEffect\";\nimport { Frequency } from \"../core/type/Units\";\n\nexport interface AutoPannerOptions extends LFOEffectOptions {\n\tchannelCount: number;\n}\n\n/**\n * AutoPanner is a [[Panner]] with an [[LFO]] connected to the pan amount. \n * [Related Reading](https://www.ableton.com/en/blog/autopan-chopper-effect-and-more-liveschool/).\n *\n * @example\n * // create an autopanner and start it\n * const autoPanner = new Tone.AutoPanner(\"4n\").toDestination().start();\n * // route an oscillator through the panner and start it\n * const oscillator = new Tone.Oscillator().connect(autoPanner).start();\n * @category Effect\n */\nexport class AutoPanner extends LFOEffect<AutoPannerOptions> {\n\n\treadonly name: string = \"AutoPanner\";\n\n\t/**\n\t * The filter node\n\t */\n\treadonly _panner: Panner;\n\n\t/**\n\t * @param frequency Rate of left-right oscillation. \n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<AutoPannerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(AutoPanner.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis._panner = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tchannelCount: options.channelCount\n\t\t});\n\t\t// connections\n\t\tthis.connectEffect(this._panner);\n\t\tthis._lfo.connect(this._panner.pan);\n\t\tthis._lfo.min = -1;\n\t\tthis._lfo.max = 1;\n\t}\n\n\tstatic getDefaults(): AutoPannerOptions {\n\t\treturn Object.assign(LFOEffect.getDefaults(), {\n\t\t\tchannelCount: 1\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\treturn this;\n\t}\n}\n\n", "import { Time } from \"../../core/type/Units\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { OnePoleFilter } from \"../filter/OnePoleFilter\";\nimport { Abs } from \"../../signal/Abs\";\n\nexport interface FollowerOptions extends ToneAudioNodeOptions {\n\tsmoothing: Time;\n}\n\n/**\n * Follower is a simple envelope follower. \n * It's implemented by applying a lowpass filter to the absolute value of the incoming signal. \n * ```\n *          +-----+    +---------------+\n * Input +--> Abs +----> OnePoleFilter +--> Output\n *          +-----+    +---------------+\n * ```\n * @category Component\n */\nexport class Follower extends ToneAudioNode<FollowerOptions> {\n\n\treadonly name: string = \"Follower\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Private reference to the smoothing parameter\n\t */\n\tprivate _smoothing: Time;\n\n\t/**\n\t * The lowpass filter\n\t */\n\tprivate _lowpass: OnePoleFilter;\n\n\t/**\n\t * The absolute value\n\t */\n\tprivate _abs: Abs;\n\n\t/**\n\t * @param smoothing The rate of change of the follower.\n\t */\n\tconstructor(smoothing?: Time);\n\tconstructor(options?: Partial<FollowerOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]));\n\t\tconst options = optionsFromArguments(Follower.getDefaults(), arguments, [\"smoothing\"]);\n\n\t\tthis._abs = this.input = new Abs({ context: this.context });\n\t\tthis._lowpass = this.output = new OnePoleFilter({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 1 / this.toSeconds(options.smoothing),\n\t\t\ttype: \"lowpass\"\n\t\t});\n\t\tthis._abs.connect(this._lowpass);\n\t\tthis._smoothing = options.smoothing;\n\t}\n\n\tstatic getDefaults(): FollowerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.05\n\t\t});\n\t}\n\n\t/**\n\t * The amount of time it takes a value change to arrive at the updated value. \n\t */\n\tget smoothing(): Time {\n\t\treturn this._smoothing;\n\t}\n\tset smoothing(smoothing) {\n\t\tthis._smoothing = smoothing;\n\t\tthis._lowpass.frequency = 1 / this.toSeconds(this.smoothing);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._abs.dispose();\n\t\tthis._lowpass.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Effect, EffectOptions } from \"./Effect\";\nimport { Filter } from \"../component/filter/Filter\";\nimport { Follower } from \"../component/analysis/Follower\";\nimport { Decibels, Frequency, GainFactor, Hertz, Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Gain } from \"../core/context/Gain\";\nimport { dbToGain, gainToDb } from \"../core/type/Conversions\";\nimport { ScaleExp } from \"../signal/ScaleExp\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface AutoWahOptions extends EffectOptions {\n\tbaseFrequency: Frequency;\n\toctaves: Positive;\n\tsensitivity: Decibels;\n\tQ: Positive;\n\tgain: GainFactor;\n\tfollower: Time;\n}\n\n/**\n * AutoWah connects a [[Follower]] to a [[Filter]]. \n * The frequency of the filter, follows the input amplitude curve. \n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna).\n * \n * @example\n * const autoWah = new Tone.AutoWah(50, 6, -30).toDestination();\n * // initialize the synth and connect to autowah\n * const synth = new Tone.Synth().connect(autoWah);\n * // Q value influences the effect of the wah - default is 2\n * autoWah.Q.value = 6;\n * // more audible on higher notes\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Effect\n */\nexport class AutoWah extends Effect<AutoWahOptions> {\n\n\treadonly name: string = \"AutoWah\";\n\n\t/**\n\t * The envelope follower. Set the attack/release\n\t * timing to adjust how the envelope is followed.\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * scales the follower value to the frequency domain\n\t */\n\tprivate _sweepRange: ScaleExp;\n\n\t/**\n\t * Hold the base frequency value\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * Private holder for the octave count\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * the input gain to adjust the sensitivity\n\t */\n\tprivate _inputBoost: Gain;\n\n\t/**\n\t * Private holder for the filter\n\t */\n\tprivate _bandpass: Filter;\n\n\t/**\n\t * The peaking fitler\n\t */\n\tprivate _peaking: Filter;\n\n\t/**\n\t * The gain of the filter.\n\t */\n\treadonly gain: Signal<\"decibels\">;\n\n\t/**\n\t * The quality of the filter.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param baseFrequency The frequency the filter is set to at the low point of the wah\n\t * @param octaves The number of octaves above the baseFrequency the filter will sweep to when fully open. \n\t * @param sensitivity The decibel threshold sensitivity for the incoming signal. Normal range of -40 to 0.\n\t */\n\tconstructor(baseFrequency?: Frequency, octaves?: Positive, sensitivity?: Decibels);\n\tconstructor(options?: Partial<AutoWahOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]));\n\t\tconst options = optionsFromArguments(AutoWah.getDefaults(), arguments, [\"baseFrequency\", \"octaves\", \"sensitivity\"]);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.follower,\n\t\t});\n\t\tthis._sweepRange = new ScaleExp({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\texponent: 0.5,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis._inputBoost = new Gain({ context: this.context });\n\t\tthis._bandpass = new Filter({\n\t\t\tcontext: this.context,\n\t\t\trolloff: -48,\n\t\t\tfrequency: 0,\n\t\t\tQ: options.Q,\n\t\t});\n\t\tthis._peaking = new Filter({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"peaking\"\n\t\t});\n\t\tthis._peaking.gain.value = options.gain;\n\t\tthis.gain = this._peaking.gain;\n\t\tthis.Q = this._bandpass.Q;\n\n\t\t// the control signal path\n\t\tthis.effectSend.chain(this._inputBoost, this._follower, this._sweepRange);\n\t\tthis._sweepRange.connect(this._bandpass.frequency);\n\t\tthis._sweepRange.connect(this._peaking.frequency);\n\t\t// the filtered path\n\t\tthis.effectSend.chain(this._bandpass, this._peaking, this.effectReturn);\n\t\t// set the initial value\n\t\tthis._setSweepRange();\n\t\tthis.sensitivity = options.sensitivity;\n\n\t\treadOnly(this, [\"gain\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): AutoWahOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbaseFrequency: 100,\n\t\t\toctaves: 6,\n\t\t\tsensitivity: 0,\n\t\t\tQ: 2,\n\t\t\tgain: 2,\n\t\t\tfollower: 0.2,\n\t\t});\n\t}\n\n\t/**\n\t * The number of octaves that the filter will sweep above the baseFrequency.\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The follower's smoothing time\n\t */\n\tget follower(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset follower(follower) {\n\t\tthis._follower.smoothing = follower;\n\t}\n\n\t/**\n\t * The base frequency from which the sweep will start from.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(baseFreq) {\n\t\tthis._baseFrequency = this.toFrequency(baseFreq);\n\t\tthis._setSweepRange();\n\t}\n\n\t/**\n\t * The sensitivity to control how responsive to the input signal the filter is.\n\t */\n\tget sensitivity(): Decibels {\n\t\treturn gainToDb(1 / this._inputBoost.gain.value);\n\t}\n\tset sensitivity(sensitivity) {\n\t\tthis._inputBoost.gain.value = 1 / dbToGain(sensitivity);\n\t}\n\n\t/**\n\t * sets the sweep range of the scaler\n\t */\n\tprivate _setSweepRange() {\n\t\tthis._sweepRange.min = this._baseFrequency;\n\t\tthis._sweepRange.max = Math.min(this._baseFrequency * Math.pow(2, this._octaves), this.context.sampleRate / 2);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._sweepRange.dispose();\n\t\tthis._bandpass.dispose();\n\t\tthis._peaking.dispose();\n\t\tthis._inputBoost.dispose();\n\t\treturn this;\n\t}\n}\n", "import \"../core/worklet/SingleIOProcessor.worklet\";\nimport { registerProcessor } from \"../core/worklet/WorkletGlobalScope\";\n\nexport const workletName = \"bit-crusher\";\n\nexport const bitCrusherWorklet = /* javascript */`\n\tclass BitCrusherWorklet extends SingleIOProcessor {\n\n\t\tstatic get parameterDescriptors() {\n\t\t\treturn [{\n\t\t\t\tname: \"bits\",\n\t\t\t\tdefaultValue: 12,\n\t\t\t\tminValue: 1,\n\t\t\t\tmaxValue: 16,\n\t\t\t\tautomationRate: 'k-rate'\n\t\t\t}];\n\t\t}\n\n\t\tgenerate(input, _channel, parameters) {\n\t\t\tconst step = Math.pow(0.5, parameters.bits - 1);\n\t\t\tconst val = step * Math.floor(input / step + 0.5);\n\t\t\treturn val;\n\t\t}\n\t}\n`;\n\nregisterProcessor(workletName, bitCrusherWorklet);\n", "import { ToneAudioWorklet, ToneAudioWorkletOptions } from \"../core/worklet/ToneAudioWorklet\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { connectSeries } from \"../core/context/ToneAudioNode\";\nimport { Param } from \"../core/context/Param\";\nimport { workletName } from \"./BitCrusher.worklet\";\n\nexport interface BitCrusherOptions extends EffectOptions {\n\tbits: Positive;\n}\n\n/**\n * BitCrusher down-samples the incoming signal to a different bit depth.\n * Lowering the bit depth of the signal creates distortion. Read more about BitCrushing\n * on [Wikipedia](https://en.wikipedia.org/wiki/Bitcrusher).\n * @example\n * // initialize crusher and route a synth through it\n * const crusher = new Tone.BitCrusher(4).toDestination();\n * const synth = new Tone.Synth().connect(crusher);\n * synth.triggerAttackRelease(\"C2\", 2);\n * \n * @category Effect\n */\nexport class BitCrusher extends Effect<BitCrusherOptions> {\n\n\treadonly name: string = \"BitCrusher\";\n\n\t/**\n\t * The bit depth of the effect\n\t * @min 1\n\t * @max 16\n\t */\n\treadonly bits: Param<\"positive\">;\n\n\t/**\n\t * The node which does the bit crushing effect. Runs in an AudioWorklet when possible.\n\t */\n\tprivate _bitCrusherWorklet: BitCrusherWorklet;\n\n\tconstructor(bits?: Positive);\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]));\n\t\tconst options = optionsFromArguments(BitCrusher.getDefaults(), arguments, [\"bits\"]);\n\n\t\tthis._bitCrusherWorklet = new BitCrusherWorklet({\n\t\t\tcontext: this.context,\n\t\t\tbits: options.bits,\n\t\t});\n\t\t// connect it up\n\t\tthis.connectEffect(this._bitCrusherWorklet);\n\n\t\tthis.bits = this._bitCrusherWorklet.bits;\n\t}\n\n\tstatic getDefaults(): BitCrusherOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tbits: 4,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._bitCrusherWorklet.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface BitCrusherWorkletOptions extends ToneAudioWorkletOptions {\n\tbits: number;\n}\n\n/**\n * Internal class which creates an AudioWorklet to do the bit crushing\n */\nclass BitCrusherWorklet extends ToneAudioWorklet<BitCrusherWorkletOptions> {\n\n\treadonly name: string = \"BitCrusherWorklet\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\treadonly bits: Param<\"positive\">;\n\n\tconstructor(options?: Partial<BitCrusherWorkletOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(BitCrusherWorklet.getDefaults(), arguments);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\tthis.bits = new Param<\"positive\">({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.bits,\n\t\t\tunits: \"positive\",\n\t\t\tminValue: 1,\n\t\t\tmaxValue: 16,\n\t\t\tparam: this._dummyParam,\n\t\t\tswappable: true,\n\t\t});\n\t}\n\n\tstatic getDefaults(): BitCrusherWorkletOptions {\n\t\treturn Object.assign(ToneAudioWorklet.getDefaults(), {\n\t\t\tbits: 12,\n\t\t});\n\t}\n\n\tprotected _audioWorkletName(): string {\n\t\treturn workletName;\n\t}\n\n\tonReady(node: AudioWorkletNode) {\n\t\tconnectSeries(this.input, node, this.output);\n\t\tconst bits = node.parameters.get(\"bits\") as AudioParam;\n\t\tthis.bits.setParam(bits);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.bits.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Effect, EffectOptions } from \"./Effect\";\nimport { Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\n\nexport interface ChebyshevOptions extends EffectOptions {\n\torder: Positive;\n\toversample: OverSampleType;\n}\n\n/**\n * Chebyshev is a waveshaper which is good \n * for making different types of distortion sounds.\n * Note that odd orders sound very different from even ones, \n * and order = 1 is no change. \n * Read more at [music.columbia.edu](http://music.columbia.edu/cmc/musicandcomputers/chapter4/04_06.php).\n * @example\n * // create a new cheby\n * const cheby = new Tone.Chebyshev(50).toDestination();\n * // create a monosynth connected to our cheby\n * const synth = new Tone.MonoSynth().connect(cheby);\n * synth.triggerAttackRelease(\"C2\", 0.4);\n * @category Effect\n */\nexport class Chebyshev extends Effect<ChebyshevOptions> {\n\n\treadonly name: string = \"Chebyshev\";\n\n\t/**\n\t * The private waveshaper node\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * holds onto the order of the filter\n\t */\n\tprivate _order: number;\n\n\t/**\n\t * @param order The order of the chebyshev polynomial. Normal range between 1-100. \n\t */\n\tconstructor(order?: Positive);\n\tconstructor(options?: Partial<ChebyshevOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]));\n\t\tconst options = optionsFromArguments(Chebyshev.getDefaults(), arguments, [\"order\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096\n\t\t});\n\t\tthis._order = options.order;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.order = options.order;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): ChebyshevOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\torder: 1,\n\t\t\toversample: \"none\" as \"none\"\n\t\t});\n\t}\n\n\t/**\n\t * get the coefficient for that degree\n\t * @param  x the x value\n\t * @param  degree \n\t * @param  memo memoize the computed value. this speeds up computation greatly. \n\t */\n\tprivate _getCoefficient(x: number, degree: number, memo: Map<number, number>): number {\n\t\tif (memo.has(degree)) {\n\t\t\treturn memo.get(degree) as number;\n\t\t} else if (degree === 0) {\n\t\t\tmemo.set(degree, 0);\n\t\t} else if (degree === 1) {\n\t\t\tmemo.set(degree, x);\n\t\t} else {\n\t\t\tmemo.set(degree, 2 * x * this._getCoefficient(x, degree - 1, memo) - this._getCoefficient(x, degree - 2, memo));\n\t\t}\n\t\treturn memo.get(degree) as number;\n\t}\n\n\t/**\n\t * The order of the Chebyshev polynomial which creates the equation which is applied to the incoming \n\t * signal through a Tone.WaveShaper. The equations are in the form:\n\t * ```\n\t * order 2: 2x^2 + 1\n\t * order 3: 4x^3 + 3x \n\t * ```\n\t * @min 1\n\t * @max 100\n\t */\n\tget order(): Positive {\n\t\treturn this._order;\n\t}\n\tset order(order) {\n\t\tthis._order = order;\n\t\tthis._shaper.setMap((x => {\n\t\t\treturn this._getCoefficient(x, order, new Map());\n\t\t}));\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface SplitOptions extends ToneAudioNodeOptions {\n\tchannels: number;\n}\n\n/**\n * Split splits an incoming signal into the number of given channels.\n *\n * @example\n * const split = new Tone.Split();\n * // stereoSignal.connect(split);\n * @category Component\n */\nexport class Split extends ToneAudioNode<SplitOptions> {\n\treadonly name: string = \"Split\";\n\n\t/**\n\t * The splitting node\n\t */\n\tprivate _splitter: ChannelSplitterNode;\n\n\treadonly input: ChannelSplitterNode;\n\treadonly output: ChannelSplitterNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: number);\n\tconstructor(options?: Partial<SplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Split.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._splitter = this.input = this.output = this.context.createChannelSplitter(options.channels);\n\t\tthis._internalChannels = [this._splitter];\n\t}\n\n\tstatic getDefaults(): SplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\ninterface MergeOptions extends ToneAudioNodeOptions {\n\tchannels: Positive;\n}\n\n/**\n * Merge brings multiple mono input channels into a single multichannel output channel.\n *\n * @example\n * const merge = new Tone.Merge().toDestination();\n * // routing a sine tone in the left channel\n * const osc = new Tone.Oscillator().connect(merge, 0, 0).start();\n * // and noise in the right channel\n * const noise = new Tone.Noise().connect(merge, 0, 1).start();;\n * @category Component\n */\nexport class Merge extends ToneAudioNode<MergeOptions> {\n\n\treadonly name: string = \"Merge\";\n\n\t/**\n\t * The merger node for the channels.\n\t */\n\tprivate _merger: ChannelMergerNode;\n\n\t/**\n\t * The output is the input channels combined into a single (multichannel) output\n\t */\n\treadonly output: ChannelMergerNode;\n\n\t/**\n\t * Multiple input connections combine into a single output.\n\t */\n\treadonly input: ChannelMergerNode;\n\n\t/**\n\t * @param channels The number of channels to merge.\n\t */\n\tconstructor(channels?: Positive);\n\tconstructor(options?: Partial<MergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]));\n\t\tconst options = optionsFromArguments(Merge.getDefaults(), arguments, [\"channels\"]);\n\n\t\tthis._merger = this.output = this.input = this.context.createChannelMerger(options.channels);\n\t}\n\n\tstatic getDefaults(): MergeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tchannels: 2,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merger.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { EffectOptions } from \"./Effect\";\nimport { connect, connectSeries, OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { Split } from \"../component/channel/Split\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport type StereoEffectOptions = EffectOptions;\n\n/**\n * Base class for Stereo effects.\n */\nexport class StereoEffect<Options extends StereoEffectOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"StereoEffect\";\n\n\treadonly input: Gain;\n\treadonly output: CrossFade;\n\n\t/**\n\t * the drywet knob to control the amount of effect\n\t */\n\tprivate _dryWet: CrossFade;\n\t\n\t/**\n\t * The wet control, i.e. how much of the effected\n\t * will pass through to the output.\n\t */\n\treadonly wet: Signal<\"normalRange\">;\n\t\n\t/**\n\t * Split it\n\t */\n\tprotected _split: Split;\n\t\n\t/**\n\t * the stereo effect merger\n\t */\n\tprotected _merge: Merge;\n\n\tconstructor(options: StereoEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\t// force mono sources to be stereo\n\t\tthis.input.channelCount = 2;\n\t\tthis.input.channelCountMode = \"explicit\";\n\n\t\tthis._dryWet = this.output = new CrossFade({\n\t\t\tcontext: this.context,\n\t\t\tfade: options.wet\n\t\t});\n\t\tthis.wet = this._dryWet.fade;\n\t\tthis._split = new Split({ context: this.context, channels: 2 });\n\t\tthis._merge = new Merge({ context: this.context, channels: 2 });\n\n\t\t// connections\n\t\tthis.input.connect(this._split);\n\t\t// dry wet connections\n\t\tthis.input.connect(this._dryWet.a);\n\t\tthis._merge.connect(this._dryWet.b);\n\t\treadOnly(this, [\"wet\"]);\n\t}\n\t\n\t/**\n\t * Connect the left part of the effect\n\t */\n\tprotected connectEffectLeft(...nodes: OutputNode[]): void{\n\t\tthis._split.connect(nodes[0], 0, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length-1], this._merge, 0, 0);\n\t}\n\t\n\t/**\n\t * Connect the right part of the effect\n\t */\n\tprotected connectEffectRight(...nodes: OutputNode[]): void{\n\t\tthis._split.connect(nodes[0], 1, 0);\n\t\tconnectSeries(...nodes);\n\t\tconnect(nodes[nodes.length-1], this._merge, 0, 1);\n\t}\n\n\tstatic getDefaults(): StereoEffectOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\twet: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dryWet.dispose();\n\t\tthis._split.dispose();\n\t\tthis._merge.dispose();\n\t\treturn this;\n\t}\n}\n", "import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { Signal } from \"../signal/Signal\";\nimport { Gain } from \"../core/context/Gain\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Split } from \"../component/channel/Split\";\nimport { Merge } from \"../component/channel/Merge\";\n\nexport interface StereoFeedbackEffectOptions extends StereoEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Base class for stereo feedback effects where the effectReturn is fed back into the same channel.\n */\nexport class StereoFeedbackEffect<Options extends StereoFeedbackEffectOptions> extends StereoEffect<Options> {\n\t\n\t/**\n\t * The amount of feedback from the output\n\t * back into the input of the effect (routed\n\t * across left and right channels).\n\t */\n\treadonly feedback: Signal<\"normalRange\">;\n\n\t/**\n\t * the left side feedback\n\t */\n\tprotected _feedbackL: Gain;\n\n\t/**\n\t * the right side feedback\n\t */\n\tprotected _feedbackR: Gain;\n\n\t/**\n\t * Split the channels for feedback\n\t */\n\tprotected _feedbackSplit: Split;\n\n\t/**\n\t * Merge the channels for feedback\n\t */\n\tprotected _feedbackMerge: Merge;\n\n\tconstructor(options: StereoFeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis.feedback = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.feedback, \n\t\t\tunits: \"normalRange\"\n\t\t});\n\t\tthis._feedbackL = new Gain({ context: this.context });\n\t\tthis._feedbackR = new Gain({ context: this.context });\n\n\t\tthis._feedbackSplit = new Split({ context: this.context, channels: 2 });\n\t\tthis._feedbackMerge = new Merge({ context: this.context, channels: 2 });\n\n\t\tthis._merge.connect(this._feedbackSplit);\n\t\tthis._feedbackMerge.connect(this._split);\n\t\t\n\t\t// the left output connected to the left input\n\t\tthis._feedbackSplit.connect(this._feedbackL, 0, 0);\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 0);\n\n\t\t// the right output connected to the right input\n\t\tthis._feedbackSplit.connect(this._feedbackR, 1, 0);\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 1);\n\t\t\n\t\t// the feedback control\n\t\tthis.feedback.fan(this._feedbackL.gain, this._feedbackR.gain);\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n\n\tstatic getDefaults(): StereoFeedbackEffectOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfeedback: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.feedback.dispose();\n\t\tthis._feedbackL.dispose();\n\t\tthis._feedbackR.dispose();\n\t\tthis._feedbackSplit.dispose();\n\t\tthis._feedbackMerge.dispose();\n\t\treturn this;\n\t}\n}\n", "import { StereoFeedbackEffect, StereoFeedbackEffectOptions } from \"../effect/StereoFeedbackEffect\";\nimport { Degrees, Frequency, Milliseconds, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface ChorusOptions extends StereoFeedbackEffectOptions {\n\tfrequency: Frequency;\n\tdelayTime: Milliseconds;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n\tspread: Degrees;\n}\n\n/**\n * Chorus is a stereo chorus effect composed of a left and right delay with an [[LFO]] applied to the delayTime of each channel.\n * When [[feedback]] is set to a value larger than 0, you also get Flanger-type effects. \n * Inspiration from [Tuna.js](https://github.com/Dinahmoe/tuna/blob/master/tuna.js).\n * Read more on the chorus effect on [SoundOnSound](http://www.soundonsound.com/sos/jun04/articles/synthsecrets.htm).\n *\n * @example\n * const chorus = new Tone.Chorus(4, 2.5, 0.5).toDestination().start();\n * const synth = new Tone.PolySynth().connect(chorus);\n * synth.triggerAttackRelease([\"C3\", \"E3\", \"G3\"], \"8n\");\n * \n * @category Effect\n */\nexport class Chorus extends StereoFeedbackEffect<ChorusOptions> {\n\n\treadonly name: string = \"Chorus\";\n\n\t/**\n\t * the depth of the chorus\n\t */\n\tprivate _depth: NormalRange;\n\n\t/**\n\t * the delayTime in seconds.\n\t */\n\tprivate _delayTime: Seconds;\n\n\t/**\n\t * the lfo which controls the delayTime\n\t */\n\tprivate _lfoL: LFO\n\n\t/**\n\t * another LFO for the right side with a 180 degree phase diff\n\t */\n\tprivate _lfoR: LFO\n\n\t/**\n\t * delay for left\n\t */\n\tprivate _delayNodeL: Delay;\n\n\t/**\n\t * delay for right\n\t */\n\tprivate _delayNodeR: Delay;\n\n\t/**\n\t * The frequency of the LFO which modulates the delayTime.\n\t */\n\treadonly frequency: Signal<\"frequency\">\n\n\t/**\n\t * @param frequency The frequency of the LFO.\n\t * @param delayTime The delay of the chorus effect in ms.\n\t * @param depth The depth of the chorus.\n\t */\n\tconstructor(frequency?: Frequency, delayTime?: Milliseconds, depth?: NormalRange);\n\tconstructor(options?: Partial<ChorusOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Chorus.getDefaults(), arguments, [\"frequency\", \"delayTime\", \"depth\"]);\n\n\t\tthis._depth = options.depth;\n\t\tthis._delayTime = options.delayTime / 1000;\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180\n\t\t});\n\t\tthis._delayNodeL = new Delay({ context: this.context });\n\t\tthis._delayNodeR = new Delay({ context: this.context });\n\t\tthis.frequency = this._lfoL.frequency;\n\t\treadOnly(this, [\"frequency\"]);\n\t\t// have one LFO frequency control the other\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\n\t\t// connections\n\t\tthis.connectEffectLeft(this._delayNodeL);\n\t\tthis.connectEffectRight(this._delayNodeR);\n\t\t// lfo setup\n\t\tthis._lfoL.connect(this._delayNodeL.delayTime);\n\t\tthis._lfoR.connect(this._delayNodeR.delayTime);\n\t\t// set the initial values\n\t\tthis.depth = this._depth;\n\t\tthis.type = options.type;\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): ChorusOptions {\n\t\treturn Object.assign(StereoFeedbackEffect.getDefaults(), {\n\t\t\tfrequency: 1.5,\n\t\t\tdelayTime: 3.5,\n\t\t\tdepth: 0.7,\n\t\t\ttype: \"sine\" as \"sine\",\n\t\t\tspread: 180,\n\t\t\tfeedback: 0,\n\t\t\twet: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * The depth of the effect. A depth of 1 makes the delayTime\n\t * modulate between 0 and 2*delayTime (centered around the delayTime).\n\t */\n\tget depth(): NormalRange {\n\t\treturn this._depth;\n\t}\n\tset depth(depth) {\n\t\tthis._depth = depth;\n\t\tconst deviation = this._delayTime * depth;\n\t\tthis._lfoL.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoL.max = this._delayTime + deviation;\n\t\tthis._lfoR.min = Math.max(this._delayTime - deviation, 0);\n\t\tthis._lfoR.max = this._delayTime + deviation;\n\t}\n\n\t/**\n\t * The delayTime in milliseconds of the chorus. A larger delayTime\n\t * will give a more pronounced effect. Nominal range a delayTime\n\t * is between 2 and 20ms.\n\t */\n\tget delayTime(): Milliseconds {\n\t\treturn this._delayTime * 1000;\n\t}\n\tset delayTime(delayTime) {\n\t\tthis._delayTime = delayTime / 1000;\n\t\tthis.depth = this._depth;\n\t}\n\n\t/**\n\t * The oscillator type of the LFO.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase;\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - (spread / 2);\n\t\tthis._lfoR.phase = (spread / 2) + 90;\n\t}\n\n\t/**\n\t * Start the effect.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the lfo\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the filter to the transport. See [[LFO.sync]]\n\t */\n\tsync(): this {\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport.\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._delayNodeL.dispose();\n\t\tthis._delayNodeR.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n", "import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface DistortionOptions extends EffectOptions {\n\tdistortion: number;\n\toversample: OverSampleType;\n}\n\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport class Distortion extends Effect<DistortionOptions> {\n\n\treadonly name: string = \"Distortion\";\n\n\t/**\n\t * The waveshaper which does the distortion\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * Stores the distortion value\n\t */\n\tprivate _distortion: number;\n\n\t/**\n\t * @param distortion The amount of distortion (nominal range of 0-1)\n\t */\n\tconstructor(distortion?: number);\n\tconstructor(options?: Partial<DistortionOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n\t\tconst options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\n\t\tthis._distortion = options.distortion;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.distortion = options.distortion;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): DistortionOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdistortion: 0.4,\n\t\t\toversample: \"none\" as OverSampleType,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of distortion. Nominal range is between 0 and 1.\n\t */\n\tget distortion(): number {\n\t\treturn this._distortion;\n\t}\n\tset distortion(amount) {\n\t\tthis._distortion = amount;\n\t\tconst k = amount * 100;\n\t\tconst deg = Math.PI / 180;\n\t\tthis._shaper.setMap((x) => {\n\t\t\tif (Math.abs(x) < 0.001) {\n\t\t\t\t// should output 0 when input is 0\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../core/context/Gain\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface FeedbackEffectOptions extends EffectOptions {\n\t/**\n\t * The feedback from the output back to the input\n\t * ```\n\t * +---<--------<---+\n\t * |                |\n\t * |  +----------+  |\n\t * +--> feedback +>-+\n\t *    +----------+\n\t * ```\n\t */\n\tfeedback: NormalRange;\n}\n\n/**\n * FeedbackEffect provides a loop between an audio source and its own output.\n * This is a base-class for feedback effects.\n */\nexport abstract class FeedbackEffect<Options extends FeedbackEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"FeedbackEffect\";\n\n\t/**\n\t * the gain which controls the feedback\n\t */\n\tprivate _feedbackGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amount of signal which is fed back into the effect input.\n\t */\n\tfeedback: Param<\"normalRange\">;\n\n\tconstructor(options: FeedbackEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._feedbackGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.feedback,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\tthis.feedback = this._feedbackGain.gain;\n\t\treadOnly(this, \"feedback\");\n\n\t\t// the feedback loop\n\t\tthis.effectReturn.chain(this._feedbackGain, this.effectSend);\n\t}\n\n\tstatic getDefaults(): FeedbackEffectOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfeedback: 0.125,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._feedbackGain.dispose();\n\t\tthis.feedback.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Delay } from \"../core/context/Delay\";\nimport { Param } from \"../core/context/Param\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\n\ninterface FeedbackDelayOptions extends FeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Time;\n}\n\n/**\n * FeedbackDelay is a DelayNode in which part of output signal is fed back into the delay.\n *\n * @param delayTime The delay applied to the incoming signal.\n * @param feedback The amount of the effected signal which is fed back through the delay.\n * @example\n * const feedbackDelay = new Tone.FeedbackDelay(\"8n\", 0.5).toDestination();\n * const tom = new Tone.MembraneSynth({\n * \toctaves: 4,\n * \tpitchDecay: 0.1\n * }).connect(feedbackDelay);\n * tom.triggerAttackRelease(\"A2\", \"32n\");\n * @category Effect\n */\nexport class FeedbackDelay extends FeedbackEffect<FeedbackDelayOptions> {\n\n\treadonly name: string = \"FeedbackDelay\";\n\n\t/**\n\t * the delay node\n\t */\n\tprivate _delayNode: Delay;\n\n\t/**\n\t * The delayTime of the FeedbackDelay.\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<FeedbackDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(FeedbackDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: options.delayTime,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis.delayTime = this._delayNode.delayTime;\n\n\t\t// connect it up\n\t\tthis.connectEffect(this._delayNode);\n\t\treadOnly(this, \"delayTime\");\n\t}\n\n\tstatic getDefaults(): FeedbackDelayOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90°.\n * Here the `offset90` phase is offset by +90° in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n\t\tconst allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map(value => {\n\t\t\tconst coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n\t\t\treturn this.context.createIIRFilter(coefficients[0], coefficients[1]);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach(f => f.disconnect());\n\t\tthis._bank1.forEach(f => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { Frequency } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n\ninterface FrequencyShifterOptions extends EffectOptions {\n\tfrequency: Frequency;\n}\n\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport class FrequencyShifter extends Effect<FrequencyShifterOptions> {\n\n\treadonly name: string = \"FrequencyShifter\";\n\n\t/**\n\t * The ring modulators carrier frequency. This frequency determines\n\t * by how many Hertz the input signal will be shifted up or down. Default is 0.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The ring modulators sine carrier\n\t */\n\tprivate _sine: ToneOscillatorNode;\n\n\t/**\n\t * The ring modulators cosine carrier\n\t */\n\tprivate _cosine: Oscillator;\n\n\t/**\n\t * The sine multiply operator\n\t */\n\tprivate _sineMultiply: Multiply;\n\n\t/**\n\t * The cosine multiply operator\n\t */\n\tprivate _cosineMultiply: Multiply;\n\n\t/**\n\t * The negate operator\n\t */\n\tprivate _negate: Negate;\n\n\t/**\n\t * The final add operator\n\t */\n\tprivate _add: Add;\n\n\t/**\n\t * The phase shifter to create the initial 90° phase offset\n\t */\n\tprivate _phaseShifter: PhaseShiftAllpass;\n\n\t/**\n\t * @param frequency The incoming signal is shifted by this frequency value.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<FrequencyShifterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tminValue: -this.context.sampleRate / 2,\n\t\t\tmaxValue: this.context.sampleRate / 2,\n\t\t});\n\n\t\tthis._sine = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._cosine = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: -90,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._sineMultiply = new Multiply({ context: this.context });\n\t\tthis._cosineMultiply = new Multiply({ context: this.context });\n\t\tthis._negate = new Negate({ context: this.context });\n\t\tthis._add = new Add({ context: this.context });\n\n\t\tthis._phaseShifter = new PhaseShiftAllpass({ context: this.context });\n\t\tthis.effectSend.connect(this._phaseShifter);\n\n\t\t// connect the carrier frequency signal to the two oscillators\n\t\tthis.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n\t\tthis._phaseShifter.offset90.connect(this._cosineMultiply);\n\t\tthis._cosine.connect(this._cosineMultiply.factor);\n\n\t\tthis._phaseShifter.connect(this._sineMultiply);\n\t\tthis._sine.connect(this._sineMultiply.factor);\n\t\tthis._sineMultiply.connect(this._negate);\n\n\t\tthis._cosineMultiply.connect(this._add);\n\t\tthis._negate.connect(this._add.addend);\n\n\t\tthis._add.connect(this.effectReturn);\n\n\t\t// start the oscillators at the same time\n\t\tconst now = this.immediate();\n\t\tthis._sine.start(now);\n\t\tthis._cosine.start(now);\n\t}\n\n\tstatic getDefaults(): FrequencyShifterOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._add.dispose();\n\t\tthis._cosine.dispose();\n\t\tthis._cosineMultiply.dispose();\n\t\tthis._negate.dispose();\n\t\tthis._phaseShifter.dispose();\n\t\tthis._sine.dispose();\n\t\tthis._sineMultiply.dispose();\n\t\treturn this;\n\t}\n}\n", "import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, NormalRange } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { LowpassCombFilter } from \"../component/filter/LowpassCombFilter\";\n\nexport interface FreeverbOptions extends StereoEffectOptions {\n\tdampening: Frequency;\n\troomSize: NormalRange;\n}\n\n/**\n * An array of comb filter delay values from Freeverb implementation\n */\nconst combFilterTunings = [1557 / 44100, 1617 / 44100, 1491 / 44100, 1422 / 44100, 1277 / 44100, 1356 / 44100, 1188 / 44100, 1116 / 44100];\n\n/**\n * An array of allpass filter frequency values from Freeverb implementation\n */\nconst allpassFilterFrequencies = [225, 556, 441, 341];\n\n/**\n * Freeverb is a reverb based on [Freeverb](https://ccrma.stanford.edu/~jos/pasp/Freeverb.html).\n * Read more on reverb on [Sound On Sound](https://web.archive.org/web/20160404083902/http://www.soundonsound.com:80/sos/feb01/articles/synthsecrets.asp).\n * Freeverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].\n * @example\n * const freeverb = new Tone.Freeverb().toDestination();\n * freeverb.dampening = 1000;\n * // routing synth through the reverb\n * const synth = new Tone.NoiseSynth().connect(freeverb);\n * synth.triggerAttackRelease(0.05);\n * @category Effect\n */\nexport class Freeverb extends StereoEffect<FreeverbOptions> {\n\n\treadonly name: string = \"Freeverb\";\n\n\t/**\n\t * The roomSize value between 0 and 1. A larger roomSize will result in a longer decay.\n\t */\n\treadonly roomSize: Signal<\"normalRange\">;\n\n\t/**\n\t * the comb filters\n\t */\n\tprivate _combFilters: LowpassCombFilter[] = [];\n\n\t/**\n\t * the allpass filters on the left\n\t */\n\tprivate _allpassFiltersL: BiquadFilterNode[] = [];\n\n\t/**\n\t * the allpass filters on the right\n\t */\n\tprivate _allpassFiltersR: BiquadFilterNode[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t * @param dampening The cutoff frequency of a lowpass filter as part of the reverb.\n\t */\n\tconstructor(roomSize?: NormalRange, dampening?: Frequency);\n\tconstructor(options?: Partial<FreeverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]));\n\t\tconst options = optionsFromArguments(Freeverb.getDefaults(), arguments, [\"roomSize\", \"dampening\"]);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\t// make the allpass filters on the right\n\t\tthis._allpassFiltersL = allpassFilterFrequencies.map(freq => {\n\t\t\tconst allpassL = this.context.createBiquadFilter();\n\t\t\tallpassL.type = \"allpass\";\n\t\t\tallpassL.frequency.value = freq;\n\t\t\treturn allpassL;\n\t\t});\n\n\t\t// make the allpass filters on the left\n\t\tthis._allpassFiltersR = allpassFilterFrequencies.map(freq => {\n\t\t\tconst allpassR = this.context.createBiquadFilter();\n\t\t\tallpassR.type = \"allpass\";\n\t\t\tallpassR.frequency.value = freq;\n\t\t\treturn allpassR;\n\t\t});\n\n\t\t// make the comb filters\n\t\tthis._combFilters = combFilterTunings.map((delayTime, index) => {\n\t\t\tconst lfpf = new LowpassCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdampening: options.dampening,\n\t\t\t\tdelayTime,\n\t\t\t});\n\t\t\tif (index < combFilterTunings.length / 2) {\n\t\t\t\tthis.connectEffectLeft(lfpf, ...this._allpassFiltersL);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(lfpf, ...this._allpassFiltersR);\n\t\t\t}\n\t\t\tthis.roomSize.connect(lfpf.resonance);\n\t\t\treturn lfpf;\n\t\t});\n\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): FreeverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.7,\n\t\t\tdampening: 3000\n\t\t});\n\t}\n\n\t/**\n\t * The amount of dampening of the reverberant signal.\n\t */\n\n\tget dampening(): Frequency {\n\t\treturn this._combFilters[0].dampening;\n\t}\n\tset dampening(d) {\n\t\tthis._combFilters.forEach(c => c.dampening = d);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFiltersL.forEach(al => al.disconnect());\n\t\tthis._allpassFiltersR.forEach(ar => ar.disconnect());\n\t\tthis._combFilters.forEach(cf => cf.dispose());\n\t\tthis.roomSize.dispose();\n\t\treturn this;\n\t}\n}\n", "import { NormalRange } from \"../core/type/Units\";\nimport { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Scale } from \"../signal/Scale\";\nimport { Signal } from \"../signal/Signal\";\nimport { FeedbackCombFilter } from \"../component/filter/FeedbackCombFilter\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface JCReverbOptions extends StereoEffectOptions {\n\troomSize: NormalRange;\n}\n\n/**\n * an array of the comb filter delay time values\n */\nconst combFilterDelayTimes = [1687 / 25000, 1601 / 25000, 2053 / 25000, 2251 / 25000];\n\n/**\n * the resonances of each of the comb filters\n */\nconst combFilterResonances = [0.773, 0.802, 0.753, 0.733];\n\n/**\n * the allpass filter frequencies\n */\nconst allpassFilterFreqs = [347, 113, 37];\n\n/**\n * JCReverb is a simple [Schroeder Reverberator](https://ccrma.stanford.edu/~jos/pasp/Schroeder_Reverberators.html)\n * tuned by John Chowning in 1970.\n * It is made up of three allpass filters and four [[FeedbackCombFilter]].\n * JCReverb is now implemented with an AudioWorkletNode which may result on performance degradation on some platforms. Consider using [[Reverb]].\n * @example\n * const reverb = new Tone.JCReverb(0.4).toDestination();\n * const delay = new Tone.FeedbackDelay(0.5);\n * // connecting the synth to reverb through delay\n * const synth = new Tone.DuoSynth().chain(delay, reverb);\n * synth.triggerAttackRelease(\"A4\", \"8n\");\n * \n * @category Effect\n */\nexport class JCReverb extends StereoEffect<JCReverbOptions> {\n\n\treadonly name: string = \"JCReverb\";\n\n\t/**\n\t * Room size control values. \n\t */\n\treadonly roomSize: Signal<\"normalRange\">\n\n\t/**\n\t * Scale the room size\n\t */\n\tprivate _scaleRoomSize: Scale;\n\n\t/**\n\t * a series of allpass filters\n\t */\n\tprivate _allpassFilters: BiquadFilterNode[] = [];\n\n\t/**\n\t * parallel feedback comb filters\n\t */\n\tprivate _feedbackCombFilters: FeedbackCombFilter[] = [];\n\n\t/**\n\t * @param roomSize Correlated to the decay time.\n\t */\n\tconstructor(roomSize?: NormalRange);\n\tconstructor(options?: Partial<JCReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]));\n\t\tconst options = optionsFromArguments(JCReverb.getDefaults(), arguments, [\"roomSize\"]);\n\n\t\tthis.roomSize = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.roomSize,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis._scaleRoomSize = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmin: -0.733,\n\t\t\tmax: 0.197,\n\t\t});\n\n\t\t// make the allpass filters\n\t\tthis._allpassFilters = allpassFilterFreqs.map(freq => {\n\t\t\tconst allpass = this.context.createBiquadFilter();\n\t\t\tallpass.type = \"allpass\";\n\t\t\tallpass.frequency.value = freq;\n\t\t\treturn allpass;\n\t\t});\n\n\t\t// and the comb filters\n\t\tthis._feedbackCombFilters = combFilterDelayTimes.map((delayTime, index) => {\n\t\t\tconst fbcf = new FeedbackCombFilter({\n\t\t\t\tcontext: this.context,\n\t\t\t\tdelayTime,\n\t\t\t});\n\t\t\tthis._scaleRoomSize.connect(fbcf.resonance);\n\t\t\tfbcf.resonance.value = combFilterResonances[index];\n\t\t\tif (index < combFilterDelayTimes.length / 2) {\n\t\t\t\tthis.connectEffectLeft(...this._allpassFilters, fbcf);\n\t\t\t} else {\n\t\t\t\tthis.connectEffectRight(...this._allpassFilters, fbcf);\n\t\t\t}\n\t\t\treturn fbcf;\n\t\t});\n\n\t\t// chain the allpass filters together\n\t\tthis.roomSize.connect(this._scaleRoomSize);\n\t\treadOnly(this, [\"roomSize\"]);\n\t}\n\n\tstatic getDefaults(): JCReverbOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\troomSize: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._allpassFilters.forEach(apf => apf.disconnect());\n\t\tthis._feedbackCombFilters.forEach(fbcf => fbcf.dispose());\n\t\tthis.roomSize.dispose();\n\t\tthis._scaleRoomSize.dispose();\n\t\treturn this;\n\t}\n}\n", "import { StereoFeedbackEffect, StereoFeedbackEffectOptions } from \"./StereoFeedbackEffect\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface StereoXFeedbackEffectOptions extends StereoFeedbackEffectOptions {\n\tfeedback: NormalRange;\n}\n\n/**\n * Just like a [[StereoFeedbackEffect]], but the feedback is routed from left to right\n * and right to left instead of on the same channel.\n * ```\n * +--------------------------------+ feedbackL <-----------------------------------+\n * |                                                                                |\n * +-->                          +----->        +---->                          +-----+\n *      feedbackMerge +--> split        (EFFECT)       merge +--> feedbackSplit     | |\n * +-->                          +----->        +---->                          +---+ |\n * |                                                                                  |\n * +--------------------------------+ feedbackR <-------------------------------------+\n * ```\n */\nexport class StereoXFeedbackEffect<Options extends StereoXFeedbackEffectOptions> extends StereoFeedbackEffect<Options> {\n\t\n\tconstructor(options: StereoXFeedbackEffectOptions) {\n\n\t\tsuper(options);\n\t\t// the left output connected to the right input\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._feedbackMerge, 0, 1);\n\n\t\t// the left output connected to the right input\n\t\tthis._feedbackR.disconnect();\n\t\tthis._feedbackR.connect(this._feedbackMerge, 0, 0);\n\t\t\n\t\treadOnly(this, [\"feedback\"]);\n\t}\n}\n", "import { StereoXFeedbackEffect, StereoXFeedbackEffectOptions } from \"./StereoXFeedbackEffect\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PingPongDelayOptions extends StereoXFeedbackEffectOptions {\n\tdelayTime: Time;\n\tmaxDelay: Seconds;\n}\n\n/**\n * PingPongDelay is a feedback delay effect where the echo is heard\n * first in one channel and next in the opposite channel. In a stereo\n * system these are the right and left channels.\n * PingPongDelay in more simplified terms is two Tone.FeedbackDelays\n * with independent delay values. Each delay is routed to one channel\n * (left or right), and the channel triggered second will always\n * trigger at the same interval after the first.\n * @example\n * const pingPong = new Tone.PingPongDelay(\"4n\", 0.2).toDestination();\n * const drum = new Tone.MembraneSynth().connect(pingPong);\n * drum.triggerAttackRelease(\"C4\", \"32n\");\n * @category Effect\n */\nexport class PingPongDelay extends StereoXFeedbackEffect<PingPongDelayOptions> {\n\n\treadonly name: string = \"PingPongDelay\";\n\n\t/**\n\t * the delay node on the left side\n\t */\n\tprivate _leftDelay: Delay;\n\n\t/**\n\t * the delay node on the right side\n\t */\n\tprivate _rightDelay: Delay;\n\n\t/**\n\t * the predelay on the right side\n\t */\n\tprivate _rightPreDelay: Delay;\n\n\t/**\n\t * the delay time signal\n\t */\n\treadonly delayTime: Signal<\"time\">;\n\n\t/**\n\t * @param delayTime The delayTime between consecutive echos.\n\t * @param feedback The amount of the effected signal which is fed back through the delay.\n\t */\n\tconstructor(delayTime?: Time, feedback?: NormalRange);\n\tconstructor(options?: Partial<PingPongDelayOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]));\n\t\tconst options = optionsFromArguments(PingPongDelay.getDefaults(), arguments, [\"delayTime\", \"feedback\"]);\n\n\t\tthis._leftDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._rightDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay\n\t\t});\n\t\tthis._rightPreDelay = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tmaxDelay: options.maxDelay\n\t\t});\n\t\tthis.delayTime = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.delayTime,\n\t\t});\n\n\t\t// connect it up\n\t\tthis.connectEffectLeft(this._leftDelay);\n\t\tthis.connectEffectRight(this._rightPreDelay, this._rightDelay);\n\t\tthis.delayTime.fan(this._leftDelay.delayTime, this._rightDelay.delayTime, this._rightPreDelay.delayTime);\n\t\t// rearranged the feedback to be after the rightPreDelay\n\t\tthis._feedbackL.disconnect();\n\t\tthis._feedbackL.connect(this._rightDelay);\n\t\treadOnly(this, [\"delayTime\"]);\n\t}\n\n\tstatic getDefaults(): PingPongDelayOptions {\n\t\treturn Object.assign(StereoXFeedbackEffect.getDefaults(), {\n\t\t\tdelayTime: 0.25,\n\t\t\tmaxDelay: 1\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._leftDelay.dispose();\n\t\tthis._rightDelay.dispose();\n\t\tthis._rightPreDelay.dispose();\n\t\tthis.delayTime.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Interval, Seconds, Time } from \"../core/type/Units\";\nimport { FeedbackEffect, FeedbackEffectOptions } from \"./FeedbackEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { CrossFade } from \"../component/channel/CrossFade\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { Param } from \"../core/context/Param\";\nimport { intervalToFrequencyRatio } from \"../core/type/Conversions\";\n\nexport interface PitchShiftOptions extends FeedbackEffectOptions {\n\tpitch: Interval;\n\twindowSize: Seconds;\n\tdelayTime: Time;\n}\n\n/**\n * PitchShift does near-realtime pitch shifting to the incoming signal.\n * The effect is achieved by speeding up or slowing down the delayTime\n * of a DelayNode using a sawtooth wave.\n * Algorithm found in [this pdf](http://dsp-book.narod.ru/soundproc.pdf).\n * Additional reference by [Miller Pucket](http://msp.ucsd.edu/techniques/v0.11/book-html/node115.html).\n * @category Effect\n */\nexport class PitchShift extends FeedbackEffect<PitchShiftOptions> {\n\n\treadonly name: string = \"PitchShift\";\n\n\t/**\n\t * The pitch signal\n\t */\n\tprivate _frequency: Signal<\"frequency\">;\n\n\t/**\n\t * Uses two DelayNodes to cover up the jump in the sawtooth wave.\n\t */\n\tprivate _delayA: Delay;\n\n\t/**\n\t * The first LFO.\n\t */\n\tprivate _lfoA: LFO;\n\n\t/**\n\t * The second DelayNode\n\t */\n\tprivate _delayB: Delay;\n\n\t/**\n\t * The second LFO.\n\t */\n\tprivate _lfoB: LFO;\n\n\t/**\n\t * Cross fade quickly between the two delay lines to cover up the jump in the sawtooth wave\n\t */\n\tprivate _crossFade: CrossFade;\n\n\t/**\n\t * LFO which alternates between the two delay lines to cover up the disparity in the\n\t * sawtooth wave.\n\t */\n\tprivate _crossFadeLFO: LFO;\n\n\t/**\n\t * The delay node\n\t */\n\tprivate _feedbackDelay: Delay;\n\n\t/**\n\t * The amount of delay on the input signal\n\t */\n\treadonly delayTime: Param<\"time\">;\n\n\t/**\n\t * Hold the current pitch\n\t */\n\tprivate _pitch: Interval;\n\n\t/**\n\t * Hold the current windowSize\n\t */\n\tprivate _windowSize;\n\n\t/**\n\t * @param pitch The interval to transpose the incoming signal by.\n\t */\n\tconstructor(pitch?: Interval);\n\tconstructor(options?: Partial<PitchShiftOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]));\n\t\tconst options = optionsFromArguments(PitchShift.getDefaults(), arguments, [\"pitch\"]);\n\n\t\tthis._frequency = new Signal({ context: this.context });\n\t\tthis._delayA = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._lfoA = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\"\n\t\t}).connect(this._delayA.delayTime);\n\t\tthis._delayB = new Delay({\n\t\t\tmaxDelay: 1,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._lfoB = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 0.1,\n\t\t\ttype: \"sawtooth\",\n\t\t\tphase: 180\n\t\t}).connect(this._delayB.delayTime);\n\t\tthis._crossFade = new CrossFade({ context: this.context });\n\t\tthis._crossFadeLFO = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\ttype: \"triangle\",\n\t\t\tphase: 90\n\t\t}).connect(this._crossFade.fade);\n\t\tthis._feedbackDelay = new Delay({\n\t\t\tdelayTime: options.delayTime,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis.delayTime = this._feedbackDelay.delayTime;\n\t\treadOnly(this, \"delayTime\");\n\t\tthis._pitch = options.pitch;\n\n\t\tthis._windowSize = options.windowSize;\n\n\t\t// connect the two delay lines up\n\t\tthis._delayA.connect(this._crossFade.a);\n\t\tthis._delayB.connect(this._crossFade.b);\n\t\t// connect the frequency\n\t\tthis._frequency.fan(this._lfoA.frequency, this._lfoB.frequency, this._crossFadeLFO.frequency);\n\t\t// route the input\n\t\tthis.effectSend.fan(this._delayA, this._delayB);\n\t\tthis._crossFade.chain(this._feedbackDelay, this.effectReturn);\n\t\t// start the LFOs at the same time\n\t\tconst now = this.now();\n\t\tthis._lfoA.start(now);\n\t\tthis._lfoB.start(now);\n\t\tthis._crossFadeLFO.start(now);\n\t\t// set the initial value\n\t\tthis.windowSize = this._windowSize;\n\t}\n\n\tstatic getDefaults(): PitchShiftOptions {\n\t\treturn Object.assign(FeedbackEffect.getDefaults(), {\n\t\t\tpitch: 0,\n\t\t\twindowSize: 0.1,\n\t\t\tdelayTime: 0,\n\t\t\tfeedback: 0\n\t\t});\n\t}\n\n\t/**\n\t * Repitch the incoming signal by some interval (measured in semi-tones).\n\t * @example\n\t * const pitchShift = new Tone.PitchShift().toDestination();\n\t * const osc = new Tone.Oscillator().connect(pitchShift).start().toDestination();\n\t * pitchShift.pitch = -12; // down one octave\n\t * pitchShift.pitch = 7; // up a fifth\n\t */\n\tget pitch() {\n\t\treturn this._pitch;\n\t}\n\tset pitch(interval) {\n\t\tthis._pitch = interval;\n\t\tlet factor = 0;\n\t\tif (interval < 0) {\n\t\t\tthis._lfoA.min = 0;\n\t\t\tthis._lfoA.max = this._windowSize;\n\t\t\tthis._lfoB.min = 0;\n\t\t\tthis._lfoB.max = this._windowSize;\n\t\t\tfactor = intervalToFrequencyRatio(interval - 1) + 1;\n\t\t} else {\n\t\t\tthis._lfoA.min = this._windowSize;\n\t\t\tthis._lfoA.max = 0;\n\t\t\tthis._lfoB.min = this._windowSize;\n\t\t\tthis._lfoB.max = 0;\n\t\t\tfactor = intervalToFrequencyRatio(interval) - 1;\n\t\t}\n\t\tthis._frequency.value = factor * (1.2 / this._windowSize);\n\t}\n\n\t/**\n\t * The window size corresponds roughly to the sample length in a looping sampler.\n\t * Smaller values are desirable for a less noticeable delay time of the pitch shifted\n\t * signal, but larger values will result in smoother pitch shifting for larger intervals.\n\t * A nominal range of 0.03 to 0.1 is recommended.\n\t */\n\tget windowSize(): Seconds {\n\t\treturn this._windowSize;\n\t}\n\tset windowSize(size) {\n\t\tthis._windowSize = this.toSeconds(size);\n\t\tthis.pitch = this._pitch;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._frequency.dispose();\n\t\tthis._delayA.dispose();\n\t\tthis._delayB.dispose();\n\t\tthis._lfoA.dispose();\n\t\tthis._lfoB.dispose();\n\t\tthis._crossFade.dispose();\n\t\tthis._crossFadeLFO.dispose();\n\t\tthis._feedbackDelay.dispose();\n\t\treturn this;\n\t}\n}\n", "import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, Hertz, Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PhaserOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\toctaves: Positive;\n\tstages: Positive;\n\tQ: Positive;\n\tbaseFrequency: Frequency;\n}\n\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport class Phaser extends StereoEffect<PhaserOptions> {\n\n\treadonly name: string = \"Phaser\";\n\n\t/**\n\t * the lfo which controls the frequency on the left side\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * the lfo which controls the frequency on the right side\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * the base modulation frequency\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * the octaves of the phasing\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * The quality factor of the filters\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersL: BiquadFilterNode[];\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersR: BiquadFilterNode[];\n\n\t/**\n\t * the frequency of the effect\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The speed of the phasing.\n\t * @param octaves The octaves of the effect.\n\t * @param baseFrequency The base frequency of the filters.\n\t */\n\tconstructor(frequency?: Frequency, octaves?: Positive, baseFrequency?: Frequency);\n\tconstructor(options?: Partial<PhaserOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n\t\tconst options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.Q,\n\t\t\tunits: \"positive\",\n\t\t});\n\t\tthis._filtersL = this._makeFilters(options.stages, this._lfoL);\n\t\tthis._filtersR = this._makeFilters(options.stages, this._lfoR);\n\n\t\tthis.frequency = this._lfoL.frequency;\n\t\tthis.frequency.value = options.frequency;\n\n\t\t// connect them up\n\t\tthis.connectEffectLeft(...this._filtersL);\n\t\tthis.connectEffectRight(...this._filtersR);\n\t\t// control the frequency with one LFO\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\t\t// set the options\n\t\tthis.baseFrequency = options.baseFrequency;\n\t\tthis.octaves = options.octaves;\n\t\t// start the lfo\n\t\tthis._lfoL.start();\n\t\tthis._lfoR.start();\n\t\treadOnly(this, [\"frequency\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): PhaserOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 0.5,\n\t\t\toctaves: 3,\n\t\t\tstages: 10,\n\t\t\tQ: 10,\n\t\t\tbaseFrequency: 350,\n\t\t});\n\t}\n\n\tprivate _makeFilters(stages: number, connectToFreq: LFO): BiquadFilterNode[] {\n\t\tconst filters: BiquadFilterNode[] = [];\n\t\t// make all the filters\n\t\tfor (let i = 0; i < stages; i++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = \"allpass\";\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tconnectToFreq.connect(filter.frequency);\n\t\t\tfilters.push(filter);\n\t\t}\n\t\treturn filters;\n\t}\n\n\t/**\n\t * The number of octaves the phase goes above the baseFrequency\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tconst max = this._baseFrequency * Math.pow(2, octaves);\n\t\tthis._lfoL.max = max;\n\t\tthis._lfoR.max = max;\n\t}\n\n\t/**\n\t * The the base frequency of the filters.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._baseFrequency = this.toFrequency(freq);\n\t\tthis._lfoL.min = this._baseFrequency;\n\t\tthis._lfoR.min = this._baseFrequency;\n\t\tthis.octaves = this._octaves;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.Q.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._filtersL.forEach(f => f.disconnect());\n\t\tthis._filtersR.forEach(f => f.disconnect());\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n\n", "import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound. \n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n\t * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n\t * before the IR is generated with the latest values. \n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis._decay = options.decay;\n\t\tthis._preDelay = options.preDelay;\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n\t\t\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\t\t\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Split } from \"./Split\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type MidSideSplitOptions = ToneAudioNodeOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels).\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n * @category Component\n */\nexport class MidSideSplit extends ToneAudioNode<MidSideSplitOptions> {\n\t\n\treadonly name: string = \"MidSideSplit\";\n\n\treadonly input: Split;\n\n\t/**\n\t * There is no output node, use either [[mid]] or [[side]] outputs.\n\t */\n\treadonly output: undefined;\n\t/**\n\t * Split the incoming signal into left and right channels\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * Sums the left and right channels\n\t */\n\tprivate _midAdd: Add;\n\n\t/**\n\t * Subtract left and right channels. \n\t */\n\tprivate _sideSubtract: Subtract;\n\n\t/**\n\t * The \"mid\" output. `(Left+Right)/sqrt(2)`\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" output. `(Left-Right)/sqrt(2)`\n\t */\n\treadonly side: ToneAudioNode;\n\t\n\tconstructor(options?: Partial<MidSideSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideSplit.getDefaults(), arguments));\n\n\t\tthis._split = this.input = new Split({\n\t\t\tchannels: 2,\n\t\t\tcontext: this.context\n\t\t});\n\t\tthis._midAdd = new Add({ context: this.context });\n\t\tthis.mid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\t\tthis._sideSubtract = new Subtract({ context: this.context });\n\t\tthis.side = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: Math.SQRT1_2,\n\t\t});\n\n\t\tthis._split.connect(this._midAdd, 0);\n\t\tthis._split.connect(this._midAdd.addend, 1);\n\t\tthis._split.connect(this._sideSubtract, 0);\n\t\tthis._split.connect(this._sideSubtract.subtrahend, 1);\n\t\tthis._midAdd.connect(this.mid);\n\t\tthis._sideSubtract.connect(this.side);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midAdd.dispose();\n\t\tthis._sideSubtract.dispose();\n\t\tthis._split.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Merge } from \"./Merge\";\nimport { Add } from \"../../signal/Add\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Subtract } from \"../../signal/Subtract\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport type MidSideMergeOptions = ToneAudioNodeOptions;\n\n/**\n * MidSideMerge merges the mid and side signal after they've been separated by [[MidSideSplit]]\n * ```\n * Mid = (Left+Right)/sqrt(2);   // obtain mid-signal from left and right\n * Side = (Left-Right)/sqrt(2);   // obtain side-signal from left and right\n * ```\n * @category Component\n */\nexport class MidSideMerge extends ToneAudioNode<MidSideMergeOptions> {\n\t\n\treadonly name: string = \"MidSideMerge\";\n\n\t/**\n\t * There is no input, connect sources to either [[mid]] or [[side]] inputs.\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * The merged signal\n\t */\n\treadonly output: Merge;\n\n\t/**\n\t * Merge the incoming signal into left and right channels\n\t */\n\tprivate _merge: Merge;\n\n\t/**\n\t * The \"mid\" input.\n\t */\n\treadonly mid: ToneAudioNode;\n\n\t/**\n\t * The \"side\" input.\n\t */\n\treadonly side: ToneAudioNode;\n\n\t/**\n\t * Recombine the mid/side into Left\n\t */\n\tprivate _left: Add;\n\n\t/**\n\t * Recombine the mid/side into Right\n\t */\n\tprivate _right: Subtract;\n\n\t/**\n\t * Multiply the right by sqrt(1/2)\n\t */\n\tprivate _leftMult: Multiply;\n\n\t/**\n\t * Multiply the left by sqrt(1/2)\n\t */\n\tprivate _rightMult: Multiply;\n\t\n\tconstructor(options?: Partial<MidSideMergeOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MidSideMerge.getDefaults(), arguments));\n\t\tthis.mid = new Gain({ context: this.context });\n\t\tthis.side = new Gain({ context: this.context });\n\t\tthis._left = new Add({ context: this.context });\n\t\tthis._leftMult = new Multiply({\n\t\t\tcontext: this.context, \n\t\t\tvalue: Math.SQRT1_2\n\t\t});\n\t\tthis._right = new Subtract({ context: this.context });\n\t\tthis._rightMult = new Multiply({\n\t\t\tcontext: this.context, \n\t\t\tvalue: Math.SQRT1_2\n\t\t});\n\t\tthis._merge = this.output = new Merge({ context: this.context });\n\n\t\tthis.mid.fan(this._left);\n\t\tthis.side.connect(this._left.addend);\n\t\tthis.mid.connect(this._right);\n\t\tthis.side.connect(this._right.subtrahend);\n\t\tthis._left.connect(this._leftMult);\n\t\tthis._right.connect(this._rightMult);\n\t\tthis._leftMult.connect(this._merge, 0, 0);\n\t\tthis._rightMult.connect(this._merge, 0, 1);\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._leftMult.dispose();\n\t\tthis._rightMult.dispose();\n\t\tthis._left.dispose();\n\t\tthis._right.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Effect, EffectOptions } from \"./Effect\";\nimport { MidSideSplit } from \"../component/channel/MidSideSplit\";\nimport { MidSideMerge } from \"../component/channel/MidSideMerge\";\nimport { OutputNode, ToneAudioNode } from \"../core/context/ToneAudioNode\";\n\nexport type MidSideEffectOptions = EffectOptions;\n\n/**\n * Mid/Side processing separates the the 'mid' signal\n * (which comes out of both the left and the right channel)\n * and the 'side' (which only comes out of the the side channels)\n * and effects them separately before being recombined.\n * Applies a Mid/Side seperation and recombination.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * This is a base-class for Mid/Side Effects.\n * @category Effect\n */\nexport abstract class MidSideEffect<Options extends MidSideEffectOptions> extends Effect<Options> {\n\n\treadonly name: string = \"MidSideEffect\";\n\n\t/**\n\t * The mid/side split\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\t\n\t/**\n\t * The mid/side merge\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\t\n\t/**\n\t * The mid send. Connect to mid processing\n\t */\n\tprotected _midSend: ToneAudioNode;\n\t\n\t/**\n\t * The side send. Connect to side processing\n\t */\n\tprotected _sideSend: ToneAudioNode;\n\t\n\t/**\n\t * The mid return connection\n\t */\n\tprotected _midReturn: ToneAudioNode;\n\t\n\t/**\n\t * The side return connection\n\t */\n\tprotected _sideReturn: ToneAudioNode;\n\n\tconstructor(options: MidSideEffectOptions) {\n\n\t\tsuper(options);\n\n\t\tthis._midSideMerge = new MidSideMerge({ context: this.context });\n\t\tthis._midSideSplit = new MidSideSplit({ context: this.context });\n\t\tthis._midSend = this._midSideSplit.mid;\n\t\tthis._sideSend = this._midSideSplit.side;\n\t\tthis._midReturn = this._midSideMerge.mid;\n\t\tthis._sideReturn = this._midSideMerge.side;\n\n\t\t// the connections\n\t\tthis.effectSend.connect(this._midSideSplit);\n\t\tthis._midSideMerge.connect(this.effectReturn);\n\t}\n\n\t/**\n\t * Connect the mid chain of the effect\n\t */\n\tprotected connectEffectMid(...nodes: OutputNode[]): void{\n\t\tthis._midSend.chain(...nodes, this._midReturn);\n\t}\n\t\n\t/**\n\t * Connect the side chain of the effect\n\t */\n\tprotected connectEffectSide(...nodes: OutputNode[]): void{\n\t\tthis._sideSend.chain(...nodes, this._sideReturn);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\tthis._midSend.dispose();\n\t\tthis._sideSend.dispose();\n\t\tthis._midReturn.dispose();\n\t\tthis._sideReturn.dispose();\n\t\treturn this;\n\t}\n}\n\n", "import { MidSideEffect, MidSideEffectOptions } from \"../effect/MidSideEffect\";\nimport { Signal } from \"../signal/Signal\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Subtract } from \"../signal/Subtract\";\nimport { NormalRange } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { connect } from \"../core/context/ToneAudioNode\";\n\nexport interface StereoWidenerOptions extends MidSideEffectOptions {\n\twidth: NormalRange;\n}\n\n/**\n * Applies a width factor to the mid/side seperation.\n * 0 is all mid and 1 is all side.\n * Algorithm found in [kvraudio forums](http://www.kvraudio.com/forum/viewtopic.php?t=212587).\n * ```\n * Mid *= 2*(1-width)<br>\n * Side *= 2*width\n * ```\n * @category Effect\n */\nexport class StereoWidener extends MidSideEffect<StereoWidenerOptions> {\n\n\treadonly name: string = \"StereoWidener\";\n\n\t/**\n\t * The width control. 0 = 100% mid. 1 = 100% side. 0.5 = no change.\n\t */\n\treadonly width: Signal<\"normalRange\">;\n\t\n\t/**\n\t * Two times the (1-width) for the mid channel\n\t */\n\tprivate _twoTimesWidthMid: Multiply;\n\t\n\t/**\n\t * Two times the width for the side channel\n\t */\n\tprivate _twoTimesWidthSide: Multiply;\n\t\n\t/**\n\t * Mid multiplier\n\t */\n\tprivate _midMult: Multiply;\n\t\n\t/**\n\t * 1 - width\n\t */\n\tprivate _oneMinusWidth: Subtract;\n\t\n\t/**\n\t * Side multiplier\n\t */\n\tprivate _sideMult: Multiply;\n\n\t/**\n\t * @param width The stereo width. A width of 0 is mono and 1 is stereo. 0.5 is no change.\n\t */\n\tconstructor(width?: NormalRange);\n\tconstructor(options?: Partial<StereoWidenerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]));\n\t\tconst options = optionsFromArguments(StereoWidener.getDefaults(), arguments, [\"width\"]);\n\t\tthis.width = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.width,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\treadOnly(this, [\"width\"]);\n\t\tthis._twoTimesWidthMid = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._twoTimesWidthSide = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tvalue: 2,\n\t\t});\n\t\tthis._midMult = new Multiply({ context: this.context });\n\t\tthis._twoTimesWidthMid.connect(this._midMult.factor);\n\t\tthis.connectEffectMid(this._midMult);\n\n\t\tthis._oneMinusWidth = new Subtract({ context: this.context });\n\t\tthis._oneMinusWidth.connect(this._twoTimesWidthMid);\n\t\tconnect(this.context.getConstant(1), this._oneMinusWidth);\n\t\tthis.width.connect(this._oneMinusWidth.subtrahend);\n\n\t\tthis._sideMult = new Multiply({ context: this.context });\n\t\tthis.width.connect(this._twoTimesWidthSide);\n\t\tthis._twoTimesWidthSide.connect(this._sideMult.factor);\n\t\tthis.connectEffectSide(this._sideMult);\n\t}\n\n\tstatic getDefaults(): StereoWidenerOptions {\n\t\treturn Object.assign(MidSideEffect.getDefaults(), {\n\t\t\twidth: 0.5,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.width.dispose();\n\t\tthis._midMult.dispose();\n\t\tthis._sideMult.dispose();\n\t\tthis._twoTimesWidthMid.dispose();\n\t\tthis._twoTimesWidthSide.dispose();\n\t\tthis._oneMinusWidth.dispose();\n\t\treturn this;\n\t}\n}\n", "import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Signal } from \"../signal/Signal\";\nimport { Degrees, Frequency, NormalRange, Time } from \"../core/type/Units\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface TremoloOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\ttype: ToneOscillatorType;\n\tdepth: NormalRange;\n\tspread: Degrees;\n}\n\n/**\n * Tremolo modulates the amplitude of an incoming signal using an [[LFO]].\n * The effect is a stereo effect where the modulation phase is inverted in each channel.\n *\n * @example\n * // create a tremolo and start it's LFO\n * const tremolo = new Tone.Tremolo(9, 0.75).toDestination().start();\n * // route an oscillator through the tremolo and start it\n * const oscillator = new Tone.Oscillator().connect(tremolo).start();\n * \n * @category Effect\n */\nexport class Tremolo extends StereoEffect<TremoloOptions> {\n\n\treadonly name: string = \"Tremolo\";\n\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * The tremolo LFO in the left channel\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeL: Gain;\n\n\t/**\n\t * Where the gain is multiplied\n\t */\n\tprivate _amplitudeR: Gain;\n\n\t/**\n\t * The frequency of the tremolo.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The depth of the effect. A depth of 0, has no effect\n\t * on the amplitude, and a depth of 1 makes the amplitude\n\t * modulate fully between 0 and 1.\n\t */\n\treadonly depth: Signal<\"normalRange\">;\n\n\t/**\n\t * @param frequency The rate of the effect.\n\t * @param depth The depth of the effect.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<TremoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Tremolo.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 1,\n\t\t\tmax: 0,\n\t\t});\n\t\tthis._amplitudeL = new Gain({ context: this.context });\n\t\tthis._amplitudeR = new Gain({ context: this.context });\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.frequency,\n\t\t\tunits: \"frequency\",\n\t\t});\n\t\tthis.depth = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.depth,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.connectEffectLeft(this._amplitudeL);\n\t\tthis.connectEffectRight(this._amplitudeR);\n\t\tthis._lfoL.connect(this._amplitudeL.gain);\n\t\tthis._lfoR.connect(this._amplitudeR.gain);\n\t\tthis.frequency.fan(this._lfoL.frequency, this._lfoR.frequency);\n\t\tthis.depth.fan(this._lfoR.amplitude, this._lfoL.amplitude);\n\t\tthis.spread = options.spread;\n\t}\n\n\tstatic getDefaults(): TremoloOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 10,\n\t\t\ttype: \"sine\" as \"sine\",\n\t\t\tdepth: 0.5,\n\t\t\tspread: 180,\n\t\t});\n\t}\n\n\t/**\n\t * Start the tremolo.\n\t */\n\tstart(time?: Time): this {\n\t\tthis._lfoL.start(time);\n\t\tthis._lfoR.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the tremolo.\n\t */\n\tstop(time?: Time): this {\n\t\tthis._lfoL.stop(time);\n\t\tthis._lfoR.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the effect to the transport.\n\t */\n\tsync(): this {\n\t\tthis._lfoL.sync();\n\t\tthis._lfoR.sync();\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the filter from the transport\n\t */\n\tunsync(): this {\n\t\tthis._lfoL.unsync();\n\t\tthis._lfoR.unsync();\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The oscillator type.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfoL.type;\n\t}\n\tset type(type) {\n\t\tthis._lfoL.type = type;\n\t\tthis._lfoR.type = type;\n\t}\n\n\t/**\n\t * Amount of stereo spread. When set to 0, both LFO's will be panned centrally.\n\t * When set to 180, LFO's will be panned hard left and right respectively.\n\t */\n\tget spread(): Degrees {\n\t\treturn this._lfoR.phase - this._lfoL.phase; // 180\n\t}\n\tset spread(spread) {\n\t\tthis._lfoL.phase = 90 - (spread / 2);\n\t\tthis._lfoR.phase = (spread / 2) + 90;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._amplitudeL.dispose();\n\t\tthis._amplitudeR.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Effect, EffectOptions } from \"./Effect\";\nimport { ToneOscillatorType } from \"../source/oscillator/OscillatorInterface\";\nimport { Frequency, NormalRange, Seconds } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Delay } from \"../core/context/Delay\";\nimport { Signal } from \"../signal/Signal\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface VibratoOptions extends EffectOptions {\n\tmaxDelay: Seconds;\n\tfrequency: Frequency;\n\tdepth: NormalRange;\n\ttype: ToneOscillatorType;\n}\n/**\n * A Vibrato effect composed of a Tone.Delay and a Tone.LFO. The LFO\n * modulates the delayTime of the delay, causing the pitch to rise and fall. \n * @category Effect\n */\nexport class Vibrato extends Effect<VibratoOptions> {\n\n\treadonly name: string = \"Vibrato\";\n\t/**\n\t * The delay node used for the vibrato effect\n\t */\n\tprivate _delayNode: Delay;\n\t\n\t/**\n\t * The LFO used to control the vibrato\n\t */\n\tprivate _lfo: LFO;\n\t\n\t/**\n\t * The frequency of the vibrato\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\t\n\t/**\n\t * The depth of the vibrato. \n\t */\n\treadonly depth: Param<\"normalRange\">;\n\n\t/**\n\t * @param frequency The frequency of the vibrato.\n\t * @param depth The amount the pitch is modulated.\n\t */\n\tconstructor(frequency?: Frequency, depth?: NormalRange);\n\tconstructor(options?: Partial<VibratoOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]));\n\t\tconst options = optionsFromArguments(Vibrato.getDefaults(), arguments, [\"frequency\", \"depth\"]);\n\n\t\tthis._delayNode = new Delay({\n\t\t\tcontext: this.context,\n\t\t\tdelayTime: 0,\n\t\t\tmaxDelay: options.maxDelay,\n\t\t});\n\t\tthis._lfo = new LFO({\n\t\t\tcontext: this.context,\n\t\t\ttype: options.type,\n\t\t\tmin: 0,\n\t\t\tmax: options.maxDelay, \n\t\t\tfrequency: options.frequency,\n\t\t\tphase: -90 // offse the phase so the resting position is in the center\n\t\t}).start().connect(this._delayNode.delayTime);\n\t\tthis.frequency = this._lfo.frequency;\n\t\tthis.depth = this._lfo.amplitude;\n\n\t\tthis.depth.value = options.depth;\n\t\treadOnly(this, [\"frequency\", \"depth\"]);\n\t\tthis.effectSend.chain(this._delayNode, this.effectReturn);\n\t}\n\n\tstatic getDefaults(): VibratoOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tmaxDelay: 0.005,\n\t\t\tfrequency: 5,\n\t\t\tdepth: 0.1,\n\t\t\ttype: \"sine\" as \"sine\"\n\t\t});\n\t}\n\n\t/**\n\t * Type of oscillator attached to the Vibrato.\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._lfo.type;\n\t}\n\tset type(type) {\n\t\tthis._lfo.type = type;\n\t}\n\t\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._delayNode.dispose();\n\t\tthis._lfo.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.depth.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Split } from \"../channel/Split\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert, assertRange } from \"../../core/util/Debug\";\n\nexport type AnalyserType = \"fft\" | \"waveform\";\n\nexport interface AnalyserOptions extends ToneAudioNodeOptions {\n\tsize: PowerOfTwo;\n\ttype: AnalyserType;\n\tsmoothing: NormalRange;\n\tchannels: number;\n}\n\n/**\n * Wrapper around the native Web Audio's [AnalyserNode](http://webaudio.github.io/web-audio-api/#idl-def-AnalyserNode).\n * Extracts FFT or Waveform data from the incoming signal.\n * @category Component\n */\nexport class Analyser extends ToneAudioNode<AnalyserOptions> {\n\n\treadonly name: string = \"Analyser\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The analyser node.\n\t */\n\tprivate _analysers: AnalyserNode[] = [];\n\n\t/**\n\t * Input and output are a gain node\n\t */\n\tprivate _gain: Gain;\n\n\t/**\n\t * The channel splitter node\n\t */\n\tprivate _split: Split;\n\n\t/**\n\t * The analysis type\n\t */\n\tprivate _type!: AnalyserType;\n\n\t/**\n\t * The buffer that the FFT data is written to\n\t */\n\tprivate _buffers: Float32Array[] = [];\n\n\t/**\n\t * @param type The return type of the analysis, either \"fft\", or \"waveform\".\n\t * @param size The size of the FFT. This must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(type?: AnalyserType, size?: number);\n\tconstructor(options?: Partial<AnalyserOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]));\n\t\tconst options = optionsFromArguments(Analyser.getDefaults(), arguments, [\"type\", \"size\"]);\n\n\t\tthis.input = this.output = this._gain = new Gain({ context: this.context });\n\t\tthis._split = new Split({\n\t\t\tcontext: this.context,\n\t\t\tchannels: options.channels,\n\t\t});\n\t\tthis.input.connect(this._split);\n\t\t\n\t\tassertRange(options.channels, 1);\n\t\t\n\t\t// create the analysers\n\t\tfor (let channel = 0; channel < options.channels; channel++) {\n\t\t\tthis._analysers[channel] = this.context.createAnalyser();\n\t\t\tthis._split.connect(this._analysers[channel], channel, 0);\n\t\t}\n\n\t\t// set the values initially\n\t\tthis.size = options.size;\n\t\tthis.type = options.type;\n\t}\n\n\tstatic getDefaults(): AnalyserOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t\ttype: \"fft\" as AnalyserType,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Run the analysis given the current settings. If [[channels]] = 1,\n\t * it will return a Float32Array. If [[channels]] > 1, it will\n\t * return an array of Float32Arrays where each index in the array\n\t * represents the analysis done on a channel.\n\t */\n\tgetValue(): Float32Array | Float32Array[] {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tconst buffer = this._buffers[index];\n\t\t\tif (this._type === \"fft\") {\n\t\t\t\tanalyser.getFloatFrequencyData(buffer);\n\t\t\t} else if (this._type === \"waveform\") {\n\t\t\t\tanalyser.getFloatTimeDomainData(buffer);\n\t\t\t}\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn this._buffers[0];\n\t\t} else {\n\t\t\treturn this._buffers;\n\t\t}\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analysers[0].frequencyBinCount;\n\t}\n\tset size(size: PowerOfTwo) {\n\t\tthis._analysers.forEach((analyser, index) => {\n\t\t\tanalyser.fftSize = size * 2;\n\t\t\tthis._buffers[index] = new Float32Array(size);\n\t\t});\n\t}\n\n\t/**\n\t * The number of channels the analyser does the analysis on. Channel\n\t * separation is done using [[Split]]\n\t */\n\tget channels(): number {\n\t\treturn this._analysers.length;\n\t}\n\n\t/**\n\t * The analysis function returned by analyser.getValue(), either \"fft\" or \"waveform\".\n\t */\n\tget type(): AnalyserType {\n\t\treturn this._type;\n\t}\n\tset type(type: AnalyserType) {\n\t\tassert(type === \"waveform\" || type === \"fft\", `Analyser: invalid type: ${type}`);\n\t\tthis._type = type;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analysers[0].smoothingTimeConstant;\n\t}\n\tset smoothing(val: NormalRange) {\n\t\tthis._analysers.forEach(a => a.smoothingTimeConstant = val);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analysers.forEach(a => a.disconnect());\n\t\tthis._split.dispose();\n\t\tthis._gain.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Analyser } from \"./Analyser\";\n\nexport type MeterBaseOptions = ToneAudioNodeOptions;\n\n/**\n * The base class for Metering classes.\n */\nexport class MeterBase<Options extends MeterBaseOptions> extends ToneAudioNode<Options> {\n\n\treadonly name: string = \"MeterBase\";\n\n\t/**\n\t * The signal to be analysed\n\t */\n\tinput: InputNode;\n\n\t/**\n\t * The output is just a pass through of the input\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * The analyser node for the incoming signal\n\t */\n\tprotected _analyser: Analyser;\n\n\tconstructor(options?: Partial<MeterBaseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MeterBase.getDefaults(), arguments));\n\n\t\tthis.input = this.output = this._analyser = new Analyser({\n\t\t\tcontext: this.context,\n\t\t\tsize: 256,\n\t\t\ttype: \"waveform\",\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n", "import { gainToDb } from \"../../core/type/Conversions\";\nimport { NormalRange } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\nimport { warn } from \"../../core/util/Debug\";\nimport { Analyser } from \"./Analyser\";\n\nexport interface MeterOptions extends MeterBaseOptions {\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n\tchannels: number;\n}\n\n/**\n * Meter gets the [RMS](https://en.wikipedia.org/wiki/Root_mean_square)\n * of an input signal. It can also get the raw value of the input signal.\n *\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * setInterval(() => console.log(meter.getValue()), 100);\n * @category Component\n */\nexport class Meter extends MeterBase<MeterOptions> {\n\n\treadonly name: string = \"Meter\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * A value from between 0 and 1 where 0 represents no time averaging with the last analysis frame.\n\t */\n\tsmoothing: number;\n\n\t/**\n\t * The previous frame's value\n\t */\n\tprivate _rms = 0;\n\n\t/**\n\t * @param smoothing The amount of smoothing applied between frames.\n\t */\n\tconstructor(smoothing?: NormalRange);\n\tconstructor(options?: Partial<MeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]));\n\t\tconst options = optionsFromArguments(Meter.getDefaults(), arguments, [\"smoothing\"]);\n\n\t\tthis.input = this.output = this._analyser = new Analyser({\n\t\t\tcontext: this.context,\n\t\t\tsize: 256,\n\t\t\ttype: \"waveform\",\n\t\t\tchannels: options.channels,\n\t\t});\n\n\t\tthis.smoothing = options.smoothing,\n\t\tthis.normalRange = options.normalRange;\n\t}\n\n\tstatic getDefaults(): MeterOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsmoothing: 0.8,\n\t\t\tnormalRange: false,\n\t\t\tchannels: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Use [[getValue]] instead. For the previous getValue behavior, use DCMeter.\n\t * @deprecated\n\t */\n\tgetLevel(): number | number[] {\n\t\twarn(\"'getLevel' has been changed to 'getValue'\");\n\t\treturn this.getValue();\n\t}\n\n\t/**\n\t * Get the current value of the incoming signal. \n\t * Output is in decibels when [[normalRange]] is `false`.\n\t * If [[channels]] = 1, then the output is a single number\n\t * representing the value of the input signal. When [[channels]] > 1,\n\t * then each channel is returned as a value in a number array. \n\t */\n\tgetValue(): number | number[] {\n\t\tconst aValues = this._analyser.getValue();\n\t\tconst channelValues = this.channels === 1 ? [aValues as Float32Array] : aValues as Float32Array[];\n\t\tconst vals = channelValues.map(values => {\n\t\t\tconst totalSquared = values.reduce((total, current) => total + current * current, 0);\n\t\t\tconst rms = Math.sqrt(totalSquared / values.length);\n\t\t\t// the rms can only fall at the rate of the smoothing\n\t\t\t// but can jump up instantly\n\t\t\tthis._rms = Math.max(rms, this._rms * this.smoothing);\n\t\t\treturn this.normalRange ? this._rms : gainToDb(this._rms);\n\t\t});\n\t\tif (this.channels === 1) {\n\t\t\treturn vals[0];\n\t\t} else {\n\t\t\treturn vals;\n\t\t}\n\t}\n\n\t/**\n\t * The number of channels of analysis.\n\t */\n\tget channels(): number {\n\t\treturn this._analyser.channels;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._analyser.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { dbToGain } from \"../../core/type/Conversions\";\nimport { Hertz, NormalRange, PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\nimport { assert } from \"../../core/util/Debug\";\n\nexport interface FFTOptions extends MeterBaseOptions {\n\tsize: PowerOfTwo;\n\tsmoothing: NormalRange;\n\tnormalRange: boolean;\n}\n\n/**\n * Get the current frequency data of the connected audio source using a fast Fourier transform.\n * @category Component\n */\nexport class FFT extends MeterBase<FFTOptions> {\n\n\treadonly name: string = \"FFT\";\n\n\t/**\n\t * If the output should be in decibels or normal range between 0-1. If `normalRange` is false,\n\t * the output range will be the measured decibel value, otherwise the decibel value will be converted to\n\t * the range of 0-1\n\t */\n\tnormalRange: boolean;\n\n\t/**\n\t * @param size The size of the FFT. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<FFTOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(FFT.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis.normalRange = options.normalRange;\n\t\tthis._analyser.type = \"fft\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): FFTOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalRange: false,\n\t\t\tsize: 1024,\n\t\t\tsmoothing: 0.8,\n\t\t});\n\t}\n\n\t/**\n\t * Gets the current frequency data from the connected audio source.\n\t * Returns the frequency data of length [[size]] as a Float32Array of decibel values.\n\t */\n\tgetValue(): Float32Array {\n\t\tconst values = this._analyser.getValue() as Float32Array;\n\t\treturn values.map(v => this.normalRange ? dbToGain(v) : v);\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]] (i.e. the number of\n\t * frequency bins). Large FFT sizes may be costly to compute.\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n\n\t/**\n\t * 0 represents no time averaging with the last analysis frame.\n\t */\n\tget smoothing(): NormalRange {\n\t\treturn this._analyser.smoothing;\n\t}\n\tset smoothing(val) {\n\t\tthis._analyser.smoothing = val;\n\t}\n\n\t/**\n\t * Returns the frequency value in hertz of each of the indices of the FFT's [[getValue]] response.\n\t * @example\n\t * const fft = new Tone.FFT(32);\n\t * console.log([0, 1, 2, 3, 4].map(index => fft.getFrequencyOfIndex(index)));\n\t */\n\tgetFrequencyOfIndex(index: number): Hertz {\n\t\tassert(0 <= index && index < this.size, `index must be greater than or equal to 0 and less than ${this.size}`);\n\t\treturn index * this.context.sampleRate / (this.size * 2);\n\t}\n}\n", "import { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport type DCMeterOptions = MeterBaseOptions;\n\n/**\n * DCMeter gets the raw value of the input signal at the current time.\n *\n * @example\n * const meter = new Tone.DCMeter();\n * const mic = new Tone.UserMedia();\n * mic.open();\n * // connect mic to the meter\n * mic.connect(meter);\n * // the current level of the mic\n * const level = meter.getValue();\n * @category Component\n */\nexport class DCMeter extends MeterBase<DCMeterOptions> {\n\n\treadonly name: string = \"DCMeter\";\n\n\tconstructor(options?: Partial<DCMeterOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(DCMeter.getDefaults(), arguments));\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis._analyser.size = 256;\n\t}\n\n\t/**\n\t * Get the signal value of the incoming signal\n\t */\n\tgetValue(): number {\n\t\tconst value = this._analyser.getValue() as Float32Array;\n\t\treturn value[0];\n\t}\n}\n", "import { PowerOfTwo } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MeterBase, MeterBaseOptions } from \"./MeterBase\";\n\nexport interface WaveformOptions extends MeterBaseOptions {\n\t/**\n\t * The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tsize: PowerOfTwo;\n}\n\n/**\n * Get the current waveform data of the connected audio source.\n * @category Component\n */\nexport class Waveform extends MeterBase<WaveformOptions> {\n\n\treadonly name: string = \"Waveform\";\n\n\t/**\n\t * @param size The size of the Waveform. Value must be a power of two in the range 16 to 16384.\n\t */\n\tconstructor(size?: PowerOfTwo);\n\tconstructor(options?: Partial<WaveformOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]));\n\t\tconst options = optionsFromArguments(Waveform.getDefaults(), arguments, [\"size\"]);\n\n\t\tthis._analyser.type = \"waveform\";\n\t\tthis.size = options.size;\n\t}\n\n\tstatic getDefaults(): WaveformOptions {\n\t\treturn Object.assign(MeterBase.getDefaults(), {\n\t\t\tsize: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Return the waveform for the current time as a Float32Array where each value in the array\n\t * represents a sample in the waveform.\n\t */\n\tgetValue(): Float32Array {\n\t\treturn this._analyser.getValue() as Float32Array;\n\t}\n\n\t/**\n\t * The size of analysis. This must be a power of two in the range 16 to 16384.\n\t * Determines the size of the array returned by [[getValue]].\n\t */\n\tget size(): PowerOfTwo {\n\t\treturn this._analyser.size;\n\t}\n\tset size(size) {\n\t\tthis._analyser.size = size;\n\t}\n}\n", "import { BaseContext } from \"../../core/context/BaseContext\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\n\nexport interface SoloOptions extends ToneAudioNodeOptions {\n\tsolo: boolean;\n}\n\n/**\n * Solo lets you isolate a specific audio stream. When an instance is set to `solo=true`,\n * it will mute all other instances of Solo.\n * @example\n * const soloA = new Tone.Solo().toDestination();\n * const oscA = new Tone.Oscillator(\"C4\", \"sawtooth\").connect(soloA);\n * const soloB = new Tone.Solo().toDestination();\n * const oscB = new Tone.Oscillator(\"E4\", \"square\").connect(soloB);\n * soloA.solo = true;\n * // no audio will pass through soloB\n * @category Component\n */\nexport class Solo extends ToneAudioNode<SoloOptions> {\n\n\treadonly name: string = \"Solo\";\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param solo If the connection should be initially solo'ed.\n\t */\n\tconstructor(solo?: boolean);\n\tconstructor(options?: Partial<SoloOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]));\n\t\tconst options = optionsFromArguments(Solo.getDefaults(), arguments, [\"solo\"]);\n\n\t\tthis.input = this.output = new Gain({\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tif (!Solo._allSolos.has(this.context)) {\n\t\t\tSolo._allSolos.set(this.context, new Set());\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).add(this);\n\n\t\t// set initially\n\t\tthis.solo = options.solo;\n\t}\n\n\tstatic getDefaults(): SoloOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsolo: false,\n\t\t});\n\t}\n\n\t/**\n\t * Hold all of the solo'ed tracks belonging to a specific context\n\t */\n\tprivate static _allSolos: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Hold the currently solo'ed instance(s)\n\t */\n\tprivate static _soloed: Map<BaseContext, Set<Solo>> = new Map();\n\n\t/**\n\t * Isolates this instance and mutes all other instances of Solo.\n\t * Only one instance can be soloed at a time. A soloed\n\t * instance will report `solo=false` when another instance is soloed.\n\t */\n\tget solo(): boolean {\n\t\treturn this._isSoloed();\n\t}\n\tset solo(solo) {\n\t\tif (solo) {\n\t\t\tthis._addSolo();\n\t\t} else {\n\t\t\tthis._removeSolo();\n\t\t}\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).forEach(instance => instance._updateSolo());\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed\n\t */\n\tget muted(): boolean {\n\t\treturn this.input.gain.value === 0;\n\t}\n\n\t/**\n\t * Add this to the soloed array\n\t */\n\tprivate _addSolo(): void {\n\t\tif (!Solo._soloed.has(this.context)) {\n\t\t\tSolo._soloed.set(this.context, new Set());\n\t\t}\n\t\t(Solo._soloed.get(this.context) as Set<Solo>).add(this);\n\t}\n\n\t/**\n\t * Remove this from the soloed array\n\t */\n\tprivate _removeSolo(): void {\n\t\tif (Solo._soloed.has(this.context)) {\n\t\t\t(Solo._soloed.get(this.context) as Set<Solo>).delete(this);\n\t\t}\n\t}\n\n\t/**\n\t * Is this on the soloed array\n\t */\n\tprivate _isSoloed(): boolean {\n\t\treturn Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).has(this);\n\t}\n\n\t/**\n\t * Returns true if no one is soloed\n\t */\n\tprivate _noSolos(): boolean {\n\t\t// either does not have any soloed added\n\t\treturn !Solo._soloed.has(this.context) ||\n\t\t\t// or has a solo set but doesn't include any items\n\t\t\t(Solo._soloed.has(this.context) && (Solo._soloed.get(this.context) as Set<Solo>).size === 0);\n\t}\n\n\t/**\n\t * Solo the current instance and unsolo all other instances.\n\t */\n\tprivate _updateSolo(): void {\n\t\tif (this._isSoloed()) {\n\t\t\tthis.input.gain.value = 1;\n\t\t} else if (this._noSolos()) {\n\t\t\t// no one is soloed\n\t\t\tthis.input.gain.value = 1;\n\t\t} else {\n\t\t\tthis.input.gain.value = 0;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\t(Solo._allSolos.get(this.context) as Set<Solo>).delete(this);\n\t\tthis._removeSolo();\n\t\treturn this;\n\t}\n}\n", "import { readOnly } from \"../../core/util/Interface\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { AudioRange, Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Panner } from \"./Panner\";\nimport { Volume } from \"./Volume\";\n\nexport interface PanVolOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tmute: boolean;\n\tchannelCount: number;\n}\n\n/**\n * PanVol is a Tone.Panner and Tone.Volume in one.\n * @example\n * // pan the incoming signal left and drop the volume\n * const panVol = new Tone.PanVol(-0.25, -12).toDestination();\n * const osc = new Tone.Oscillator().connect(panVol).start();\n * @category Component\n */\nexport class PanVol extends ToneAudioNode<PanVolOptions> {\n\n\treadonly name: string = \"PanVol\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The panning node\n\t */\n\tprivate _panner: Panner;\n\n\t/**\n\t * The L/R panning control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param pan the initial pan\n\t * @param volume The output volume.\n\t */\n\tconstructor(pan?: AudioRange, volume?: Decibels);\n\tconstructor(options?: Partial<PanVolOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]));\n\t\tconst options = optionsFromArguments(PanVol.getDefaults(), arguments, [\"pan\", \"volume\"]);\n\n\t\tthis._panner = this.input = new Panner({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tchannelCount: options.channelCount,\n\t\t});\n\t\tthis.pan = this._panner.pan;\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\n\t\t// connections\n\t\tthis._panner.connect(this._volume);\n\t\tthis.mute = options.mute;\n\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): PanVolOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.dispose();\n\t\tthis.pan.dispose();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n}\n", "import { AudioRange, Decibels } from \"../../core/type/Units\";\nimport { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Solo } from \"./Solo\";\nimport { PanVol } from \"./PanVol\";\nimport { Param } from \"../../core/context/Param\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport interface ChannelOptions extends ToneAudioNodeOptions {\n\tpan: AudioRange;\n\tvolume: Decibels;\n\tsolo: boolean;\n\tmute: boolean;\n\tchannelCount: number;\n}\n\n/**\n * Channel provides a channel strip interface with volume, pan, solo and mute controls. \n * See [[PanVol]] and [[Solo]]\n * @example\n * // pan the incoming signal left and drop the volume 12db\n * const channel = new Tone.Channel(-0.25, -12);\n * @category Component\n */\nexport class Channel extends ToneAudioNode<ChannelOptions> {\n\n\treadonly name: string = \"Channel\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The soloing interface\n\t */\n\tprivate _solo: Solo;\n\n\t/**\n\t * The panning and volume node\n\t */\n\tprivate _panVol: PanVol;\n\n\t/**\n\t * The L/R panning control. -1 = hard left, 1 = hard right.\n\t * @min -1\n\t * @max 1\n\t */\n\treadonly pan: Param<\"audioRange\">;\n\n\t/**\n\t * The volume control in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The output volume.\n\t * @param pan the initial pan\n\t */\n\tconstructor(volume?: Decibels, pan?: AudioRange);\n\tconstructor(options?: Partial<ChannelOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]));\n\t\tconst options = optionsFromArguments(Channel.getDefaults(), arguments, [\"volume\", \"pan\"]);\n\n\t\tthis._solo = this.input = new Solo({\n\t\t\tsolo: options.solo,\n\t\t\tcontext: this.context,\n\t\t});\n\t\tthis._panVol = this.output = new PanVol({\n\t\t\tcontext: this.context,\n\t\t\tpan: options.pan,\n\t\t\tvolume: options.volume,\n\t\t\tmute: options.mute,\n\t\t\tchannelCount: options.channelCount\n\t\t});\n\t\tthis.pan = this._panVol.pan;\n\t\tthis.volume = this._panVol.volume;\n\n\t\tthis._solo.connect(this._panVol);\n\t\treadOnly(this, [\"pan\", \"volume\"]);\n\t}\n\n\tstatic getDefaults(): ChannelOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpan: 0,\n\t\t\tvolume: 0,\n\t\t\tmute: false,\n\t\t\tsolo: false,\n\t\t\tchannelCount: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Solo/unsolo the channel. Soloing is only relative to other [[Channels]] and [[Solo]] instances\n\t */\n\tget solo(): boolean {\n\t\treturn this._solo.solo;\n\t}\n\tset solo(solo) {\n\t\tthis._solo.solo = solo;\n\t}\n\n\t/**\n\t * If the current instance is muted, i.e. another instance is soloed,\n\t * or the channel is muted\n\t */\n\tget muted(): boolean {\n\t\treturn this._solo.muted || this.mute;\n\t}\n\n\t/**\n\t * Mute/unmute the volume\n\t */\n\tget mute(): boolean {\n\t\treturn this._panVol.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._panVol.mute = mute;\n\t}\n\n\t/**\n\t * Store the send/receive channels by name. \n\t */\n\tprivate static buses: Map<string, Gain> = new Map();\n\n\t/**\n\t * Get the gain node belonging to the bus name. Create it if\n\t * it doesn't exist\n\t * @param name The bus name\n\t */\n\tprivate _getBus(name: string): Gain {\n\t\tif (!Channel.buses.has(name)) {\n\t\t\tChannel.buses.set(name, new Gain({ context: this.context }));\n\t\t}\n\t\treturn Channel.buses.get(name) as Gain;\n\t}\n\n\t/**\n\t * Send audio to another channel using a string. `send` is a lot like\n\t * [[connect]], except it uses a string instead of an object. This can \n\t * be useful in large applications to decouple sections since [[send]]\n\t * and [[receive]] can be invoked separately in order to connect an object\n\t * @param name The channel name to send the audio\n\t * @param volume The amount of the signal to send. \n\t * \tDefaults to 0db, i.e. send the entire signal\n\t * @returns Returns the gain node of this connection.\n\t */\n\tsend(name: string, volume: Decibels = 0): Gain<\"decibels\"> {\n\t\tconst bus = this._getBus(name);\n\t\tconst sendKnob = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"decibels\",\n\t\t\tgain: volume,\n\t\t});\n\t\tthis.connect(sendKnob);\n\t\tsendKnob.connect(bus);\n\t\treturn sendKnob;\n\t}\n\n\t/**\n\t * Receive audio from a channel which was connected with [[send]]. \n\t * @param name The channel name to receive audio from.\n\t */\n\treceive(name: string): this {\n\t\tconst bus = this._getBus(name);\n\t\tbus.connect(this);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panVol.dispose();\n\t\tthis.pan.dispose();\n\t\tthis.volume.dispose();\n\t\tthis._solo.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Merge } from \"./Merge\";\n\nexport type MonoOptions = ToneAudioNodeOptions;\n\n/**\n * Mono coerces the incoming mono or stereo signal into a mono signal\n * where both left and right channels have the same value. This can be useful\n * for [stereo imaging](https://en.wikipedia.org/wiki/Stereo_imaging).\n * @category Component\n */\nexport class Mono extends ToneAudioNode<MonoOptions> {\n\n\treadonly name: string = \"Mono\";\n\n\t/**\n\t * merge the signal\n\t */\n\tprivate _merge: Merge;\n\n\t/**\n\t * The summed output of the multiple inputs\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * The stereo signal to sum to mono\n\t */\n\treadonly input: Gain;\n\n\tconstructor(options?: Partial<MonoOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Mono.getDefaults(), arguments));\n\n\t\tthis.input = new Gain({ context: this.context });\n\n\t\tthis._merge = this.output = new Merge({\n\t\t\tchannels: 2,\n\t\t\tcontext: this.context,\n\t\t});\n\n\t\tthis.input.connect(this._merge, 0, 0);\n\t\tthis.input.connect(this._merge, 0, 1);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._merge.dispose();\n\t\tthis.input.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Frequency, Positive } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Filter } from \"../filter/Filter\";\n\ninterface MultibandSplitOptions extends ToneAudioNodeOptions {\n\tQ: Positive;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * Split the incoming signal into three bands (low, mid, high)\n * with two crossover frequency controls.\n * ```\n *            +----------------------+\n *          +-> input < lowFrequency +------------------> low\n *          | +----------------------+\n *          |\n *          | +--------------------------------------+\n * input ---+-> lowFrequency < input < highFrequency +--> mid\n *          | +--------------------------------------+\n *          |\n *          | +-----------------------+\n *          +-> highFrequency < input +-----------------> high\n *            +-----------------------+\n * ```\n * @category Component\n */\nexport class MultibandSplit extends ToneAudioNode<MultibandSplitOptions> {\n\n\treadonly name: string = \"MultibandSplit\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * no output node, use either low, mid or high outputs\n\t */\n\treadonly output = undefined;\n\n\t/**\n\t * The low band.\n\t */\n\treadonly low = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * the lower filter of the mid band\n\t */\n\tprivate _lowMidFilter = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The mid band output.\n\t */\n\treadonly mid = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"lowpass\",\n\t});\n\n\t/**\n\t * The high band output.\n\t */\n\treadonly high = new Filter({\n\t\tcontext: this.context,\n\t\tfrequency: 0,\n\t\ttype: \"highpass\",\n\t});\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels = [this.low, this.mid, this.high];\n\n\t/**\n\t * The Q or Quality of the filter\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * @param lowFrequency the low/mid crossover frequency\n\t * @param highFrequency the mid/high crossover frequency\n\t */\n\tconstructor(lowFrequency?: Frequency, highFrequency?: Frequency);\n\tconstructor(options?: Partial<MultibandSplitOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]));\n\t\tconst options = optionsFromArguments(MultibandSplit.getDefaults(), arguments, [\"lowFrequency\", \"highFrequency\"]);\n\n\t\tthis.lowFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.lowFrequency,\n\t\t});\n\n\t\tthis.highFrequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.highFrequency,\n\t\t});\n\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.Q,\n\t\t});\n\n\t\tthis.input.fan(this.low, this.high);\n\t\tthis.input.chain(this._lowMidFilter, this.mid);\n\t\t// the frequency control signal\n\t\tthis.lowFrequency.fan(this.low.frequency, this._lowMidFilter.frequency);\n\t\tthis.highFrequency.fan(this.mid.frequency, this.high.frequency);\n\t\t// the Q value\n\t\tthis.Q.connect(this.low.Q);\n\t\tthis.Q.connect(this._lowMidFilter.Q);\n\t\tthis.Q.connect(this.mid.Q);\n\t\tthis.Q.connect(this.high.Q);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandSplitOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tQ: 1,\n\t\t\thighFrequency: 2500,\n\t\t\tlowFrequency: 400,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t\tthis.low.dispose();\n\t\tthis._lowMidFilter.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"./ToneAudioNode\";\nimport { Param } from \"./Param\";\nimport { onContextClose, onContextInit } from \"./ContextInitialization\";\n\nexport interface ListenerOptions extends ToneAudioNodeOptions{\n\tpositionX: number;\n\tpositionY: number;\n\tpositionZ: number;\n\tforwardX: number;\n\tforwardY: number;\n\tforwardZ: number;\n\tupX: number;\n\tupY: number;\n\tupZ: number;\n}\n\n/**\n * Tone.Listener is a thin wrapper around the AudioListener. Listener combined\n * with [[Panner3D]] makes up the Web Audio API's 3D panning system. Panner3D allows you \n * to place sounds in 3D and Listener allows you to navigate the 3D sound environment from\n * a first-person perspective. There is only one listener per audio context. \n */\nexport class Listener extends ToneAudioNode<ListenerOptions> {\n\n\treadonly name: string = \"Listener\";\n\n\t/**\n\t * The listener has no inputs or outputs. \n\t */\n\toutput: undefined; \n\tinput: undefined; \n\n\treadonly positionX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionX,\n\t})\n\n\treadonly positionY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionY,\n\t})\n\n\treadonly positionZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.positionZ,\n\t})\n\n\treadonly forwardX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardX,\n\t})\n\n\treadonly forwardY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardY,\n\t})\n\n\treadonly forwardZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.forwardZ,\n\t})\n\n\treadonly upX: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upX,\n\t})\n\n\treadonly upY: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upY,\n\t})\n\n\treadonly upZ: Param = new Param({\n\t\tcontext: this.context,\n\t\tparam: this.context.rawContext.listener.upZ,\n\t})\n\n\tstatic getDefaults(): ListenerOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tpositionX: 0,\n\t\t\tpositionY: 0,\n\t\t\tpositionZ: 0,\n\t\t\tforwardX: 0,\n\t\t\tforwardY: 0,\n\t\t\tforwardZ: -1,\n\t\t\tupX: 0,\n\t\t\tupY: 1,\n\t\t\tupZ: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.positionX.dispose();\n\t\tthis.positionY.dispose();\n\t\tthis.positionZ.dispose();\n\t\tthis.forwardX.dispose();\n\t\tthis.forwardY.dispose();\n\t\tthis.forwardZ.dispose();\n\t\tthis.upX.dispose();\n\t\tthis.upY.dispose();\n\t\tthis.upZ.dispose();\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.listener = new Listener({ context });\n});\n\nonContextClose(context => {\n\tcontext.listener.dispose();\n});\n", "import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, GainFactor } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport \"../../core/context/Listener\";\n\nexport interface Panner3DOptions extends ToneAudioNodeOptions {\n\tconeInnerAngle: Degrees;\n\tconeOuterAngle: Degrees;\n\tconeOuterGain: GainFactor;\n\tdistanceModel: DistanceModelType;\n\tmaxDistance: number;\n\torientationX: number;\n\torientationY: number;\n\torientationZ: number;\n\tpanningModel: PanningModelType;\n\tpositionX: number;\n\tpositionY: number;\n\tpositionZ: number;\n\trefDistance: number;\n\trolloffFactor: number;\n}\n\n/**\n * A spatialized panner node which supports equalpower or HRTF panning.\n * @category Component\n */\nexport class Panner3D extends ToneAudioNode<Panner3DOptions> {\n\n\treadonly name: string = \"Panner3D\";\n\n\t/**\n\t * The panning object\n\t */\n\tprivate _panner: PannerNode;\n\treadonly input: PannerNode;\n\treadonly output: PannerNode;\n\n\treadonly positionX: Param<\"number\">;\n\treadonly positionY: Param<\"number\">;\n\treadonly positionZ: Param<\"number\">;\n\n\treadonly orientationX: Param<\"number\">;\n\treadonly orientationY: Param<\"number\">;\n\treadonly orientationZ: Param<\"number\">;\n\n\t/**\n\t * @param positionX The initial x position.\n\t * @param positionY The initial y position.\n\t * @param positionZ The initial z position.\n\t */\n\tconstructor(positionX: number, positionY: number, positionZ: number);\n\tconstructor(options?: Partial<Panner3DOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Panner3D.getDefaults(), arguments, [\"positionX\", \"positionY\", \"positionZ\"]));\n\t\tconst options = optionsFromArguments(Panner3D.getDefaults(), arguments, [\"positionX\", \"positionY\", \"positionZ\"]);\n\n\t\tthis._panner = this.input = this.output = this.context.createPanner();\n\t\t// set some values\n\t\tthis.panningModel = options.panningModel;\n\t\tthis.maxDistance = options.maxDistance;\n\t\tthis.distanceModel = options.distanceModel;\n\t\tthis.coneOuterGain = options.coneOuterGain;\n\t\tthis.coneOuterAngle = options.coneOuterAngle;\n\t\tthis.coneInnerAngle = options.coneInnerAngle;\n\t\tthis.refDistance = options.refDistance;\n\t\tthis.rolloffFactor = options.rolloffFactor;\n\n\t\tthis.positionX = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionX,\n\t\t\tvalue: options.positionX,\n\t\t});\n\t\tthis.positionY = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionY,\n\t\t\tvalue: options.positionY,\n\t\t});\n\t\tthis.positionZ = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.positionZ,\n\t\t\tvalue: options.positionZ,\n\t\t});\n\t\tthis.orientationX = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationX,\n\t\t\tvalue: options.orientationX,\n\t\t});\n\t\tthis.orientationY = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationY,\n\t\t\tvalue: options.orientationY,\n\t\t});\n\t\tthis.orientationZ = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._panner.orientationZ,\n\t\t\tvalue: options.orientationZ,\n\t\t});\n\t}\n\n\tstatic getDefaults(): Panner3DOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tconeInnerAngle: 360,\n\t\t\tconeOuterAngle: 360,\n\t\t\tconeOuterGain: 0,\n\t\t\tdistanceModel: \"inverse\" as DistanceModelType,\n\t\t\tmaxDistance: 10000,\n\t\t\torientationX: 0,\n\t\t\torientationY: 0,\n\t\t\torientationZ: 0,\n\t\t\tpanningModel: \"equalpower\" as PanningModelType,\n\t\t\tpositionX: 0,\n\t\t\tpositionY: 0,\n\t\t\tpositionZ: 0,\n\t\t\trefDistance: 1,\n\t\t\trolloffFactor: 1,\n\t\t});\n\t}\n\n\t/**\n\t * Sets the position of the source in 3d space.\n\t */\n\tsetPosition(x: number, y: number, z: number): this {\n\t\tthis.positionX.value = x;\n\t\tthis.positionY.value = y;\n\t\tthis.positionZ.value = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sets the orientation of the source in 3d space.\n\t */\n\tsetOrientation(x: number, y: number, z: number): this {\n\t\tthis.orientationX.value = x;\n\t\tthis.orientationY.value = y;\n\t\tthis.orientationZ.value = z;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The panning model. Either \"equalpower\" or \"HRTF\".\n\t */\n\tget panningModel(): PanningModelType {\n\t\treturn this._panner.panningModel;\n\t}\n\tset panningModel(val) {\n\t\tthis._panner.panningModel = val;\n\t}\n\n\t/**\n\t * A reference distance for reducing volume as source move further from the listener\n\t */\n\tget refDistance(): number {\n\t\treturn this._panner.refDistance;\n\t}\n\tset refDistance(val) {\n\t\tthis._panner.refDistance = val;\n\t}\n\n\t/**\n\t * Describes how quickly the volume is reduced as source moves away from listener.\n\t */\n\tget rolloffFactor(): number {\n\t\treturn this._panner.rolloffFactor;\n\t}\n\tset rolloffFactor(val) {\n\t\tthis._panner.rolloffFactor = val;\n\t}\n\n\t/**\n\t * The distance model used by,  \"linear\", \"inverse\", or \"exponential\".\n\t */\n\tget distanceModel(): DistanceModelType {\n\t\treturn this._panner.distanceModel;\n\t}\n\tset distanceModel(val) {\n\t\tthis._panner.distanceModel = val;\n\t}\n\n\t/**\n\t * The angle, in degrees, inside of which there will be no volume reduction\n\t */\n\tget coneInnerAngle(): Degrees {\n\t\treturn this._panner.coneInnerAngle;\n\t}\n\tset coneInnerAngle(val) {\n\t\tthis._panner.coneInnerAngle = val;\n\t}\n\n\t/**\n\t * The angle, in degrees, outside of which the volume will be reduced\n\t * to a constant value of coneOuterGain\n\t */\n\tget coneOuterAngle(): Degrees {\n\t\treturn this._panner.coneOuterAngle;\n\t}\n\tset coneOuterAngle(val) {\n\t\tthis._panner.coneOuterAngle = val;\n\t}\n\n\t/**\n\t * The gain outside of the coneOuterAngle\n\t */\n\tget coneOuterGain(): GainFactor {\n\t\treturn this._panner.coneOuterGain;\n\t}\n\tset coneOuterGain(val) {\n\t\tthis._panner.coneOuterGain = val;\n\t}\n\n\t/**\n\t * The maximum distance between source and listener,\n\t * after which the volume will not be reduced any further.\n\t */\n\tget maxDistance(): number {\n\t\treturn this._panner.maxDistance;\n\t}\n\tset maxDistance(val) {\n\t\tthis._panner.maxDistance = val;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._panner.disconnect();\n\t\tthis.orientationX.dispose();\n\t\tthis.orientationY.dispose();\n\t\tthis.orientationZ.dispose();\n\t\tthis.positionX.dispose();\n\t\tthis.positionY.dispose();\n\t\tthis.positionZ.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { assert } from \"../../core/util/Debug\";\nimport { theWindow } from \"../../core/context/AudioContext\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\n\nexport interface RecorderOptions extends ToneAudioNodeOptions {\n\tmimeType?: string;\n}\n\n/**\n * A wrapper around the MediaRecorder API. Unlike the rest of Tone.js, this module does not offer\n * any sample-accurate scheduling because it is not a feature of the MediaRecorder API.\n * This is only natively supported in Chrome and Firefox. \n * For a cross-browser shim, install (audio-recorder-polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill]. \n * @example\n * const recorder = new Tone.Recorder();\n * const synth = new Tone.Synth().connect(recorder);\n * // start recording\n * recorder.start();\n * // generate a few notes\n * synth.triggerAttackRelease(\"C3\", 0.5);\n * synth.triggerAttackRelease(\"C4\", 0.5, \"+1\");\n * synth.triggerAttackRelease(\"C5\", 0.5, \"+2\");\n * // wait for the notes to end and stop the recording\n * setTimeout(async () => {\n * \t// the recorded audio is returned as a blob\n * \tconst recording = await recorder.stop();\n * \t// download the recording by creating an anchor element and blob url\n * \tconst url = URL.createObjectURL(recording);\n * \tconst anchor = document.createElement(\"a\");\n * \tanchor.download = \"recording.webm\";\n * \tanchor.href = url;\n * \tanchor.click();\n * }, 4000);\n * @category Component\n */\nexport class Recorder extends ToneAudioNode<RecorderOptions> {\n\n\treadonly name = \"Recorder\";\n\n\t/**\n\t * Recorder uses the Media Recorder API\n\t */\n\tprivate _recorder: MediaRecorder;\n\n\t/**\n\t * MediaRecorder requires \n\t */\n\tprivate _stream: MediaStreamAudioDestinationNode;\n\n\treadonly input: Gain;\n\treadonly output: undefined;\n\n\tconstructor(options?: Partial<RecorderOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Recorder.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Recorder.getDefaults(), arguments);\n\n\t\tthis.input = new Gain({\n\t\t\tcontext: this.context\n\t\t});\n\n\t\tassert(Recorder.supported, \"Media Recorder API is not available\");\n\n\t\tthis._stream = this.context.createMediaStreamDestination();\n\t\tthis.input.connect(this._stream);\n\t\tthis._recorder = new MediaRecorder(this._stream.stream, {\n\t\t\tmimeType: options.mimeType\n\t\t});\n\t}\n\n\tstatic getDefaults(): RecorderOptions {\n\t\treturn ToneAudioNode.getDefaults();\n\t}\n\n\t/**\n\t * The mime type is the format that the audio is encoded in. For Chrome \n\t * that is typically webm encoded as \"vorbis\". \n\t */\n\tget mimeType(): string {\n\t\treturn this._recorder.mimeType;\n\t}\n\n\t/**\n\t * Test if your platform supports the Media Recorder API. If it's not available, \n\t * try installing this (polyfill)[https://www.npmjs.com/package/audio-recorder-polyfill].\n\t */\n\tstatic get supported(): boolean {\n\t\treturn theWindow !== null && Reflect.has(theWindow, \"MediaRecorder\");\n\t}\n\n\t/**\n\t * Get the playback state of the Recorder, either \"started\", \"stopped\" or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\tif (this._recorder.state === \"inactive\") {\n\t\t\treturn \"stopped\";\n\t\t} else if (this._recorder.state === \"paused\") {\n\t\t\treturn \"paused\";\n\t\t} else {\n\t\t\treturn \"started\";\n\t\t}\n\t}\n\n\t/**\n\t * Start the Recorder. Returns a promise which resolves\n\t * when the recorder has started.\n\t */\n\tasync start() {\n\t\tassert(this.state !== \"started\", \"Recorder is already started\");\n\t\tconst startPromise = new Promise(done => {\n\t\t\tconst handleStart = () => {\n\t\t\t\tthis._recorder.removeEventListener(\"start\", handleStart, false);\n\n\t\t\t\tdone();\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"start\", handleStart, false);\n\t\t});\n\n\t\tthis._recorder.start();\n\t\treturn await startPromise;\n\t}\n\n\t/**\n\t * Stop the recorder. Returns a promise with the recorded content until this point\n\t * encoded as [[mimeType]]\n\t */\n\tasync stop(): Promise<Blob> {\n\t\tassert(this.state !== \"stopped\", \"Recorder is not started\");\n\t\tconst dataPromise: Promise<Blob> = new Promise(done => {\n\t\t\tconst handleData = (e: BlobEvent) => {\n\t\t\t\tthis._recorder.removeEventListener(\"dataavailable\", handleData, false);\n\n\t\t\t\tdone(e.data);\n\t\t\t};\n\n\t\t\tthis._recorder.addEventListener(\"dataavailable\", handleData, false);\n\t\t});\n\t\tthis._recorder.stop();\n\t\treturn await dataPromise;\n\t}\n\n\t/**\n\t * Pause the recorder\n\t */\n\tpause(): this {\n\t\tassert(this.state === \"started\", \"Recorder must be started\");\n\t\tthis._recorder.pause();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._stream.disconnect();\n\t\treturn this;\n\t}\n}\n", "import { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Positive, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface CompressorOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tknee: Decibels;\n\tratio: Positive;\n\trelease: Time;\n\tthreshold: Decibels;\n}\n\n/**\n * Compressor is a thin wrapper around the Web Audio\n * [DynamicsCompressorNode](http://webaudio.github.io/web-audio-api/#the-dynamicscompressornode-interface).\n * Compression reduces the volume of loud sounds or amplifies quiet sounds\n * by narrowing or \"compressing\" an audio signal's dynamic range.\n * Read more on [Wikipedia](https://en.wikipedia.org/wiki/Dynamic_range_compression).\n * @example\n * const comp = new Tone.Compressor(-30, 3);\n * @category Component\n */\nexport class Compressor extends ToneAudioNode<CompressorOptions> {\n\n\treadonly name: string = \"Compressor\";\n\n\t/**\n\t * the compressor node\n\t */\n\tprivate _compressor: DynamicsCompressorNode = this.context.createDynamicsCompressor();\n\treadonly input = this._compressor;\n\treadonly output = this._compressor;\n\n\t/**\n\t * The decibel value above which the compression will start taking effect.\n\t * @min -100\n\t * @max 0\n\t */\n\treadonly threshold: Param<\"decibels\">;\n\n\t/**\n\t * The amount of time (in seconds) to reduce the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly attack: Param<\"time\">;\n\n\t/**\n\t * The amount of time (in seconds) to increase the gain by 10dB.\n\t * @min 0\n\t * @max 1\n\t */\n\treadonly release: Param<\"time\">;\n\n\t/**\n\t * A decibel value representing the range above the threshold where the\n\t * curve smoothly transitions to the \"ratio\" portion.\n\t * @min 0\n\t * @max 40\n\t */\n\treadonly knee: Param<\"decibels\">;\n\n\t/**\n\t * The amount of dB change in input for a 1 dB change in output.\n\t * @min 1\n\t * @max 20\n\t */\n\treadonly ratio: Param<\"positive\">;\n\n\t/**\n\t * @param threshold The value above which the compression starts to be applied.\n\t * @param ratio The gain reduction ratio.\n\t */\n\tconstructor(threshold?: Decibels, ratio?: Positive);\n\tconstructor(options?: Partial<CompressorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]));\n\t\tconst options = optionsFromArguments(Compressor.getDefaults(), arguments, [\"threshold\", \"ratio\"]);\n\n\t\tthis.threshold = new Param({\n\t\t\tminValue: this._compressor.threshold.minValue,\n\t\t\tmaxValue: this._compressor.threshold.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.threshold,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.threshold,\n\t\t});\n\n\t\tthis.attack = new Param({\n\t\t\tminValue: this._compressor.attack.minValue,\n\t\t\tmaxValue: this._compressor.attack.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.attack,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.attack,\n\t\t});\n\n\t\tthis.release = new Param({\n\t\t\tminValue: this._compressor.release.minValue,\n\t\t\tmaxValue: this._compressor.release.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tparam: this._compressor.release,\n\t\t\tunits: \"time\",\n\t\t\tvalue: options.release,\n\t\t});\n\n\t\tthis.knee = new Param({\n\t\t\tminValue: this._compressor.knee.minValue,\n\t\t\tmaxValue: this._compressor.knee.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.knee,\n\t\t\tunits: \"decibels\",\n\t\t\tvalue: options.knee,\n\t\t});\n\n\t\tthis.ratio = new Param({\n\t\t\tminValue: this._compressor.ratio.minValue,\n\t\t\tmaxValue: this._compressor.ratio.maxValue,\n\t\t\tcontext: this.context,\n\t\t\tconvert: false,\n\t\t\tparam: this._compressor.ratio,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.ratio,\n\t\t});\n\n\t\t// set the defaults\n\t\treadOnly(this, [\"knee\", \"release\", \"attack\", \"ratio\", \"threshold\"]);\n\t}\n\n\tstatic getDefaults(): CompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.003,\n\t\t\tknee: 30,\n\t\t\tratio: 12,\n\t\t\trelease: 0.25,\n\t\t\tthreshold: -24,\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. If fed no signal the value will be 0 (no gain reduction).\n\t */\n\tget reduction(): Decibels {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.disconnect();\n\t\tthis.attack.dispose();\n\t\tthis.release.dispose();\n\t\tthis.threshold.dispose();\n\t\tthis.ratio.dispose();\n\t\tthis.knee.dispose();\n\t\treturn this;\n\t}\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Time } from \"../../core/type/Units\";\nimport { GreaterThan } from \"../../signal/GreaterThan\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { Follower } from \"../analysis/Follower\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { dbToGain, gainToDb } from \"../../core/type/Conversions\";\n\nexport interface GateOptions extends ToneAudioNodeOptions {\n\tthreshold: Decibels;\n\tsmoothing: Time;\n}\n\n/**\n * Gate only passes a signal through when the incoming\n * signal exceeds a specified threshold. It uses [[Follower]] to follow the ampltiude\n * of the incoming signal and compares it to the [[threshold]] value using [[GreaterThan]].\n *\n * @example\n * const gate = new Tone.Gate(-30, 0.2).toDestination();\n * const mic = new Tone.UserMedia().connect(gate);\n * // the gate will only pass through the incoming\n * // signal when it's louder than -30db\n * @category Component\n */\nexport class Gate extends ToneAudioNode<GateOptions> {\n\n\treadonly name: string = \"Gate\";\n\n\treadonly input: ToneAudioNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * Follow the incoming signal\n\t */\n\tprivate _follower: Follower;\n\n\t/**\n\t * Test if it's greater than the threshold\n\t */\n\tprivate _gt: GreaterThan;\n\n\t/**\n\t * Gate the incoming signal when it does not exceed the threshold\n\t */\n\tprivate _gate: Gain;\n\n\t/**\n\t * @param threshold The threshold above which the gate will open.\n\t * @param smoothing The follower's smoothing time\n\t */\n\tconstructor(threshold?: Decibels, smoothing?: Time);\n\tconstructor(options?: Partial<GateOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Gate.getDefaults(), arguments, [\"threshold\", \"smoothing\"])));\n\t\tconst options = optionsFromArguments(Gate.getDefaults(), arguments, [\"threshold\", \"smoothing\"]);\n\n\t\tthis._follower = new Follower({\n\t\t\tcontext: this.context,\n\t\t\tsmoothing: options.smoothing,\n\t\t});\n\t\tthis._gt = new GreaterThan({\n\t\t\tcontext: this.context,\n\t\t\tvalue: dbToGain(options.threshold),\n\t\t});\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis._gate = this.output = new Gain({ context: this.context });\n\n\t\t// connections\n\t\tthis.input.connect(this._gate);\n\t\t// the control signal\n\t\tthis.input.chain(this._follower, this._gt, this._gate.gain);\n\t}\n\n\tstatic getDefaults(): GateOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tsmoothing: 0.1,\n\t\t\tthreshold: -40\n\t\t});\n\t}\n\n\t/**\n\t * The threshold of the gate in decibels\n\t */\n\tget threshold(): Decibels {\n\t\treturn gainToDb(this._gt.value);\n\t}\n\tset threshold(thresh) {\n\t\tthis._gt.value = dbToGain(thresh);\n\t}\n\n\t/**\n\t * The attack/decay speed of the gate. See [[Follower.smoothing]]\n\t */\n\tget smoothing(): Time {\n\t\treturn this._follower.smoothing;\n\t}\n\tset smoothing(smoothingTime) {\n\t\tthis._follower.smoothing = smoothingTime;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis._follower.dispose();\n\t\tthis._gt.dispose();\n\t\tthis._gate.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Compressor } from \"./Compressor\";\nimport { Param } from \"../../core/context/Param\";\nimport { readOnly } from \"../../core/util/Interface\";\n\nexport interface LimiterOptions extends ToneAudioNodeOptions {\n\tthreshold: Decibels;\n};\n\n/**\n * Limiter will limit the loudness of an incoming signal.\n * Under the hood it's composed of a [[Compressor]] with a fast attack\n * and release and max compression ratio. \n *\n * @example\n * const limiter = new Tone.Limiter(-20).toDestination();\n * const oscillator = new Tone.Oscillator().connect(limiter);\n * oscillator.start();\n * @category Component\n */\nexport class Limiter extends ToneAudioNode<LimiterOptions> {\n\n\treadonly name: string = \"Limiter\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The compressor which does the limiting\n\t */\n\tprivate _compressor: Compressor;\n\n\treadonly threshold: Param<\"decibels\">\n\n\t/**\n\t * @param threshold The threshold above which the gain reduction is applied.\n\t */\n\tconstructor(threshold?: Decibels);\n\tconstructor(options?: Partial<LimiterOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(Limiter.getDefaults(), arguments, [\"threshold\"])));\n\t\tconst options = optionsFromArguments(Limiter.getDefaults(), arguments, [\"threshold\"]);\n\n\t\tthis._compressor = this.input = this.output = new Compressor({\n\t\t\tcontext: this.context,\n\t\t\tratio: 20,\n\t\t\tattack: 0.003,\n\t\t\trelease: 0.01,\n\t\t\tthreshold: options.threshold\n\t\t});\n\n\t\tthis.threshold = this._compressor.threshold;\n\t\treadOnly(this, \"threshold\");\n\t}\n\n\tstatic getDefaults(): LimiterOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tthreshold: -12\n\t\t});\n\t}\n\n\t/**\n\t * A read-only decibel value for metering purposes, representing the current amount of gain\n\t * reduction that the compressor is applying to the signal. \n\t */\n\tget reduction(): Decibels {\n\t\treturn this._compressor.reduction;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._compressor.dispose();\n\t\tthis.threshold.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Compressor, CompressorOptions } from \"./Compressor\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { MidSideSplit } from \"../channel/MidSideSplit\";\nimport { MidSideMerge } from \"../channel/MidSideMerge\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\n\nexport interface MidSideCompressorOptions extends ToneAudioNodeOptions {\n\tmid: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tside: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * MidSideCompressor applies two different compressors to the [[mid]]\n * and [[side]] signal components of the input. See [[MidSideSplit]] and [[MidSideMerge]].\n * @category Component\n */\nexport class MidSideCompressor extends ToneAudioNode<MidSideCompressorOptions> {\n\n\treadonly name: string = \"MidSideCompressor\";\n\n\treadonly input: InputNode;\n\treadonly output: OutputNode;\n\n\t/**\n\t * Split the incoming signal into Mid/Side\n\t */\n\tprivate _midSideSplit: MidSideSplit;\n\n\t/**\n\t * Merge the compressed signal back into a single stream\n\t */\n\tprivate _midSideMerge: MidSideMerge;\n\n\t/**\n\t * The compression applied to the mid signal\n\t */\n\treadonly mid: Compressor;\n\n\t/**\n\t * The compression applied to the side signal\n\t */\n\treadonly side: Compressor;\n\n\tconstructor(options?: RecursivePartial<MidSideCompressorOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(MidSideCompressor.getDefaults(), arguments)));\n\t\tconst options = optionsFromArguments(MidSideCompressor.getDefaults(), arguments);\n\n\t\tthis._midSideSplit = this.input = new MidSideSplit({ context: this.context });\n\t\tthis._midSideMerge = this.output = new MidSideMerge({ context: this.context });\n\t\tthis.mid = new Compressor(Object.assign(options.mid, { context: this.context }));\n\t\tthis.side = new Compressor(Object.assign(options.side, { context: this.context }));\n\n\t\tthis._midSideSplit.mid.chain(this.mid, this._midSideMerge.mid);\n\t\tthis._midSideSplit.side.chain(this.side, this._midSideMerge.side);\n\t\treadOnly(this, [\"mid\", \"side\"]);\n\t}\n\n\tstatic getDefaults(): MidSideCompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmid: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16\n\t\t\t},\n\t\t\tside: {\n\t\t\t\tratio: 6,\n\t\t\t\tthreshold: -30,\n\t\t\t\trelease: 0.25,\n\t\t\t\tattack: 0.03,\n\t\t\t\tknee: 10\n\t\t\t}\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.side.dispose();\n\t\tthis._midSideSplit.dispose();\n\t\tthis._midSideMerge.dispose();\n\t\treturn this;\n\t}\n}\n", "import { InputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Compressor, CompressorOptions } from \"./Compressor\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, RecursivePartial } from \"../../core/util/Interface\";\nimport { Frequency } from \"../../core/type/Units\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Gain } from \"../../core/context/Gain\";\n\nexport interface MultibandCompressorOptions extends ToneAudioNodeOptions {\n\tmid: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tlow: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\thigh: Omit<CompressorOptions, keyof ToneAudioNodeOptions>;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * A compressor with separate controls over low/mid/high dynamics. See [[Compressor]] and [[MultibandSplit]]\n *\n * @example\n * const multiband = new Tone.MultibandCompressor({\n * \tlowFrequency: 200,\n * \thighFrequency: 1300,\n * \tlow: {\n * \t\tthreshold: -12\n * \t}\n * });\n * @category Component\n */\nexport class MultibandCompressor extends ToneAudioNode<MultibandCompressorOptions> {\n\n\treadonly name: string = \"MultibandCompressor\";\n\n\treadonly input: InputNode;\n\treadonly output: ToneAudioNode;\n\n\t/**\n\t * Split the incoming signal into high/mid/low\n\t */\n\tprivate _splitter: MultibandSplit;\n\n\t/**\n\t * low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The compressor applied to the low frequencies\n\t */\n\treadonly low: Compressor;\n\n\t/**\n\t * The compressor applied to the mid frequencies\n\t */\n\treadonly mid: Compressor;\n\n\t/**\n\t * The compressor applied to the high frequencies\n\t */\n\treadonly high: Compressor;\n\n\tconstructor(options?: RecursivePartial<MultibandCompressorOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(MultibandCompressor.getDefaults(), arguments)));\n\t\tconst options = optionsFromArguments(MultibandCompressor.getDefaults(), arguments);\n\n\t\tthis._splitter = this.input = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t\thighFrequency: options.highFrequency\n\t\t});\n\t\tthis.lowFrequency = this._splitter.lowFrequency;\n\t\tthis.highFrequency = this._splitter.highFrequency;\n\t\tthis.output = new Gain({ context: this.context });\n\t\tthis.low = new Compressor(Object.assign(options.low, { context: this.context }));\n\t\tthis.mid = new Compressor(Object.assign(options.mid, { context: this.context }));\n\t\tthis.high = new Compressor(Object.assign(options.high, { context: this.context }));\n\n\t\t// connect the compressor\n\t\tthis._splitter.low.chain(this.low, this.output);\n\t\tthis._splitter.mid.chain(this.mid, this.output);\n\t\tthis._splitter.high.chain(this.high, this.output);\n\n\t\treadOnly(this, [\"high\", \"mid\", \"low\", \"highFrequency\", \"lowFrequency\"]);\n\t}\n\n\tstatic getDefaults(): MultibandCompressorOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tlowFrequency: 250,\n\t\t\thighFrequency: 2000,\n\t\t\tlow: {\n\t\t\t\tratio: 6,\n\t\t\t\tthreshold: -30,\n\t\t\t\trelease: 0.25,\n\t\t\t\tattack: 0.03,\n\t\t\t\tknee: 10\n\t\t\t},\n\t\t\tmid: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16\n\t\t\t},\n\t\t\thigh: {\n\t\t\t\tratio: 3,\n\t\t\t\tthreshold: -24,\n\t\t\t\trelease: 0.03,\n\t\t\t\tattack: 0.02,\n\t\t\t\tknee: 16\n\t\t\t},\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._splitter.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.output.dispose();\n\t\treturn this;\n\t}\n}\n", "import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { Decibels, Frequency } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly, writable } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { MultibandSplit } from \"../channel/MultibandSplit\";\n\ninterface EQ3Options extends ToneAudioNodeOptions {\n\tlow: Decibels;\n\tmid: Decibels;\n\thigh: Decibels;\n\tlowFrequency: Frequency;\n\thighFrequency: Frequency;\n}\n\n/**\n * EQ3 provides 3 equalizer bins: Low/Mid/High. \n * @category Component\n */\nexport class EQ3 extends ToneAudioNode<EQ3Options> {\n\n\treadonly name: string = \"EQ3\";\n\n\t/**\n\t * the input\n\t */\n\treadonly input: MultibandSplit;\n\n\t/**\n\t * the output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * Splits the input into three outputs\n\t */\n\tprivate _multibandSplit: MultibandSplit;\n\n\t/**\n\t * The gain for the lower signals\n\t */\n\tprivate _lowGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the mid signals\n\t */\n\tprivate _midGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain for the high signals\n\t */\n\tprivate _highGain: Gain<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the low part\n\t */\n\treadonly low: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the mid part\n\t */\n\treadonly mid: Param<\"decibels\">;\n\n\t/**\n\t * The gain in decibels of the high part\n\t */\n\treadonly high: Param<\"decibels\">;\n\n\t/**\n\t * The Q value for all of the filters.\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * The low/mid crossover frequency.\n\t */\n\treadonly lowFrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The mid/high crossover frequency.\n\t */\n\treadonly highFrequency: Signal<\"frequency\">;\n\n\tprotected _internalChannels: ToneAudioNode[] = [];\n\n\tconstructor(lowLevel?: Decibels, midLevel?: Decibels, highLevel?: Decibels);\n\tconstructor(options: Partial<EQ3Options>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]));\n\t\tconst options = optionsFromArguments(EQ3.getDefaults(), arguments, [\"low\", \"mid\", \"high\"]);\n\n\t\tthis.input = this._multibandSplit = new MultibandSplit({\n\t\t\tcontext: this.context,\n\t\t\thighFrequency: options.highFrequency,\n\t\t\tlowFrequency: options.lowFrequency,\n\t\t});\n\n\t\tthis._lowGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.low,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._midGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.mid,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis._highGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.high,\n\t\t\tunits: \"decibels\",\n\t\t});\n\n\t\tthis.low = this._lowGain.gain;\n\t\tthis.mid = this._midGain.gain;\n\t\tthis.high = this._highGain.gain;\n\t\tthis.Q = this._multibandSplit.Q;\n\t\tthis.lowFrequency = this._multibandSplit.lowFrequency;\n\t\tthis.highFrequency\t= this._multibandSplit.highFrequency;\n\n\t\t// the frequency bands\n\t\tthis._multibandSplit.low.chain(this._lowGain, this.output);\n\t\tthis._multibandSplit.mid.chain(this._midGain, this.output);\n\t\tthis._multibandSplit.high.chain(this._highGain, this.output);\n\n\t\treadOnly(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._internalChannels = [this._multibandSplit];\n\t}\n\n\tstatic getDefaults(): EQ3Options {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\thigh: 0,\n\t\t\thighFrequency: 2500,\n\t\t\tlow: 0,\n\t\t\tlowFrequency: 400,\n\t\t\tmid: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\twritable(this, [\"low\", \"mid\", \"high\", \"lowFrequency\", \"highFrequency\"]);\n\t\tthis._multibandSplit.dispose();\n\t\tthis.lowFrequency.dispose();\n\t\tthis.highFrequency.dispose();\n\t\tthis._lowGain.dispose();\n\t\tthis._midGain.dispose();\n\t\tthis._highGain.dispose();\n\t\tthis.low.dispose();\n\t\tthis.mid.dispose();\n\t\tthis.high.dispose();\n\t\tthis.Q.dispose();\n\t\treturn this;\n\t}\n\n}\n", "import { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { noOp } from \"../../core/util/Interface\";\n\nexport interface ConvolverOptions extends ToneAudioNodeOptions {\n\tonload: () => void;\n\tnormalize: boolean;\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n}\n\n/**\n * Convolver is a wrapper around the Native Web Audio\n * [ConvolverNode](http://webaudio.github.io/web-audio-api/#the-convolvernode-interface).\n * Convolution is useful for reverb and filter emulation. Read more about convolution reverb on\n * [Wikipedia](https://en.wikipedia.org/wiki/Convolution_reverb).\n *\n * @example\n * // initializing the convolver with an impulse response\n * const convolver = new Tone.Convolver(\"./path/to/ir.wav\").toDestination();\n * @category Component\n */\nexport class Convolver extends ToneAudioNode<ConvolverOptions> {\n\n\treadonly name: string = \"Convolver\";\n\n\t/**\n\t * The native ConvolverNode\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The Buffer belonging to the convolver\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\treadonly input: Gain;\n\treadonly output: Gain;\n\n\t/**\n\t * @param url The URL of the impulse response or the ToneAudioBuffer containing the impulse response.\n\t * @param onload The callback to invoke when the url is loaded.\n\t */\n\tconstructor(url?: string | AudioBuffer | ToneAudioBuffer, onload?: () => void);\n\tconstructor(options?: Partial<ConvolverOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(Convolver.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tthis._buffer = new ToneAudioBuffer(options.url, buffer => {\n\t\t\tthis.buffer = buffer;\n\t\t\toptions.onload();\n\t\t});\n\n\t\tthis.input = new Gain({ context: this.context });\n\t\tthis.output = new Gain({ context: this.context });\n\n\t\t// set if it's already loaded, set it immediately\n\t\tif (this._buffer.loaded) {\n\t\t\tthis.buffer = this._buffer;\n\t\t}\n\n\t\t// initially set normalization\n\t\tthis.normalize = options.normalize;\n\n\t\t// connect it up\n\t\tthis.input.chain(this._convolver, this.output);\n\t}\n\n\tstatic getDefaults(): ConvolverOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tnormalize: true,\n\t\t\tonload: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Load an impulse response url as an audio buffer.\n\t * Decodes the audio asynchronously and invokes\n\t * the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t */\n\tasync load(url: string): Promise<void> {\n\t\tthis.buffer = await this._buffer.load(url);\n\t}\n\n\t/**\n\t * The convolver's buffer\n\t */\n\tget buffer(): ToneAudioBuffer | null {\n\t\tif (this._buffer.length) {\n\t\t\treturn this._buffer;\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\tset buffer(buffer) {\n\t\tif (buffer) {\n\t\t\tthis._buffer.set(buffer);\n\t\t}\n\t\t// if it's already got a buffer, create a new one\n\t\tif (this._convolver.buffer) {\n\t\t\t// disconnect the old one\n\t\t\tthis.input.disconnect();\n\t\t\tthis._convolver.disconnect();\n\t\t\t// create and connect a new one\n\t\t\tthis._convolver = this.context.createConvolver();\n\t\t\tthis.input.chain(this._convolver, this.output);\n\t\t}\n\t\tconst buff = this._buffer.get();\n\t\tthis._convolver.buffer = buff ? buff : null;\n\t}\n\n\t/**\n\t * The normalize property of the ConvolverNode interface is a boolean that\n\t * controls whether the impulse response from the buffer will be scaled by\n\t * an equal-power normalization when the buffer attribute is set, or not.\n\t */\n\tget normalize(): boolean {\n\t\treturn this._convolver.normalize;\n\t}\n\tset normalize(norm) {\n\t\tthis._convolver.normalize = norm;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n", "export { getContext, setContext } from \"./core/Global\";\nexport * from \"./classes\";\nexport * from \"./version\";\nimport { getContext } from \"./core/Global\";\nimport { ToneAudioBuffer } from \"./core/context/ToneAudioBuffer\";\nexport { start } from \"./core/Global\";\nimport { Seconds } from \"./core/type/Units\";\nexport { supported } from \"./core/context/AudioContext\";\n\n/**\n * The current audio context time of the global [[Context]]. \n * See [[Context.now]]\n * @category Core\n */\nexport function now(): Seconds {\n\treturn getContext().now();\n}\n\n/**\n * The current audio context time of the global [[Context]] without the [[Context.lookAhead]]\n * See [[Context.immediate]]\n * @category Core\n */\nexport function immediate(): Seconds {\n\treturn getContext().immediate();\n}\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\nexport const Transport = getContext().transport;\n\n/**\n * The Transport object belonging to the global Tone.js Context.\n * See [[Transport]]\n * @category Core\n */\nexport function getTransport(): import(\"./core/clock/Transport\").Transport {\n\treturn getContext().transport;\n}\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\nexport const Destination = getContext().destination;\n\n/**\n * @deprecated Use [[Destination]]\n */\nexport const Master = getContext().destination;\n\n/**\n * The Destination (output) belonging to the global Tone.js Context.\n * See [[Destination]]\n * @category Core\n */\nexport function getDestination(): import(\"./core/context/Destination\").Destination {\n\treturn getContext().destination;\n}\n\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\nexport const Listener = getContext().listener;\n\n/**\n * The [[Listener]] belonging to the global Tone.js Context.\n * @category Core\n */\nexport function getListener(): import(\"./core/context/Listener\").Listener {\n\treturn getContext().listener;\n}\n\n/**\n * Draw is used to synchronize the draw frame with the Transport's callbacks. \n * See [[Draw]]\n * @category Core\n */\nexport const Draw = getContext().draw;\n\n/**\n * Get the singleton attached to the global context. \n * Draw is used to synchronize the draw frame with the Transport's callbacks. \n * See [[Draw]]\n * @category Core\n */\nexport function getDraw(): import(\"./core/util/Draw\").Draw {\n\treturn getContext().draw;\n}\n\n/**\n * A reference to the global context\n * See [[Context]]\n */\nexport const context = getContext();\n\n/**\n * Promise which resolves when all of the loading promises are resolved. \n * Alias for static [[ToneAudioBuffer.loaded]] method.\n * @category Core\n */\nexport function loaded() {\n\treturn ToneAudioBuffer.loaded();\n}\n\n// this fills in name changes from 13.x to 14.x\nimport { ToneAudioBuffers } from \"./core/context/ToneAudioBuffers\";\nimport { ToneBufferSource } from \"./source/buffer/ToneBufferSource\";\nexport const Buffer: typeof ToneAudioBuffer = ToneAudioBuffer;\nexport const Buffers: typeof ToneAudioBuffers = ToneAudioBuffers;\nexport const BufferSource: typeof ToneBufferSource = ToneBufferSource;\n"],
  "mappings": ";;;;;;;;;AAAO,IAAM,UAAkB;;;ACExB,IAAM,sDAAsD,CAC/D,OACA,SACA,eACgD;AAChD,SAAO,EAAE,SAAS,YAAY,MAAM,0BAA0B,MAAK;AACvE;;;ACNO,IAAM,iDAAiD,CAC1D,OACA,SACA,eAC2C;AAC3C,SAAO,EAAE,SAAS,YAAY,MAAM,qBAAqB,MAAK;AAClE;;;ACNO,IAAM,gCAAgC,CAAC,OAAe,cAA+C;AACxG,SAAO,EAAE,WAAW,MAAM,YAAY,MAAK;AAC/C;;;ACFO,IAAM,qCAAqC,CAC9C,QACA,WACA,aAC+B;AAC/B,SAAO,EAAE,UAAU,WAAW,MAAM,iBAAiB,OAAM;AAC/D;;;ACNO,IAAM,uBAAuB,CAChC,MACA,kBACA,EAAE,WAAW,QAAQ,aAAY,MACzB;AACR,SAAO,UAAU,mBAAmB,UAAU,KAAK,KAAK,YAAY,QAAQ,YAAY;AAC5F;;;ACLO,IAAM,0CAA0C,CACnD,oBAC2D;AAC3D,SAAO,gBAAgB,SAAS;AACpC;;;ACJO,IAAM,qCAAqC,CAC9C,oBACsD;AACtD,SAAO,gBAAgB,SAAS;AACpC;;;ACFO,IAAM,kCAAkC,CAC3C,oBAC+F;AAC/F,SAAO,wCAAwC,eAAe,KAAK,mCAAmC,eAAe;AACzH;;;ACNO,IAAM,4BAA4B,CAAC,oBAAkF;AACxH,SAAO,gBAAgB,SAAS;AACpC;;;ACFO,IAAM,iCAAiC,CAAC,oBAAuF;AAClI,SAAO,gBAAgB,SAAS;AACpC;;;ACCO,IAAM,yCAAyC,CAClD,kBACA,OACA,MACA,iBACQ;AACR,QAAM,kBAAkB,iBAAiB,KAAK;AAE9C,SAAO,oBAAoB,SACrB,eACA,gCAAgC,eAAe,KAAK,0BAA0B,eAAe,IAC7F,gBAAgB,QAChB,+BAA+B,eAAe,IAC9C,gBAAgB,OAAO,gBAAgB,OAAO,SAAS,CAAC,IACxD,qBACI,MACA,uCAAuC,kBAAkB,QAAQ,GAAG,gBAAgB,WAAW,YAAY,GAC3G,eAAe;AAE7B;;;AClBO,IAAM,8CAA8C,CACvD,kBACA,OACA,wBACA,qBACA,iBACkB;AAClB,SAAO,2BAA2B,SAC5B,CAAC,oBAAoB,YAAY,YAAY,IAC7C,gCAAgC,sBAAsB,IACtD,CAAC,uBAAuB,SAAS,uBAAuB,KAAK,IAC7D,0BAA0B,sBAAsB,IAChD,CAAC,uBAAuB,WAAW,uBAAuB,KAAK,IAC/D,+BAA+B,sBAAsB,IACrD;IACI,uBAAuB,YAAY,uBAAuB;IAC1D,uBAAuB,OAAO,uBAAuB,OAAO,SAAS,CAAC;MAE1E;IACI,uBAAuB;IACvB,uCAAuC,kBAAkB,QAAQ,GAAG,uBAAuB,WAAW,YAAY;;AAEhI;;;AC1BO,IAAM,iCAAiC,CAAC,oBAAuF;AAClI,SAAO,gBAAgB,SAAS;AACpC;;;ACFO,IAAM,yCAAyC,CAClD,oBAC0D;AAC1D,SAAO,gBAAgB,SAAS;AACpC;;;ACDO,IAAM,eAAe,CAAC,oBAA6C;AACtE,MAAI,+BAA+B,eAAe,KAAK,uCAAuC,eAAe,GAAG;AAC5G,WAAO,gBAAgB;;AAG3B,MAAI,wCAAwC,eAAe,KAAK,mCAAmC,eAAe,GAAG;AACjH,WAAO,gBAAgB;;AAG3B,SAAO,gBAAgB;AAC3B;;;ACdO,IAAM,gCAAgC,CACzC,MACA,WACA,kBACA,EAAE,SAAS,MAAK,MAChB;AACA,MAAI,qBAAqB,OAAO;AAC5B,WAAO;;AAGX,MAAK,IAAI,oBAAoB,IAAI,SAAW,mBAAmB,KAAK,QAAQ,GAAI;AAC5E,WAAO,oBAAoB,QAAQ,uBAAuB,OAAO,cAAc,UAAU;;AAG7F,SAAO;AACX;;;ACfO,IAAM,2BAA2B,CACpC,MACA,WACA,kBACA,EAAE,SAAS,MAAK,MAChB;AACA,SAAO,oBAAqB,OAAO,cAAc,UAAU,cAAe,QAAQ;AACtF;;;ACTO,IAAM,mBAAmB,CAAC,QAAsB,mBAA0B;AAC7E,QAAM,aAAa,KAAK,MAAM,cAAc;AAC5C,QAAM,aAAa,KAAK,KAAK,cAAc;AAE3C,MAAI,eAAe,YAAY;AAC3B,WAAO,OAAO,UAAU;;AAG5B,UAAQ,KAAK,iBAAiB,eAAe,OAAO,UAAU,KAAK,KAAK,aAAa,mBAAmB,OAAO,UAAU;AAC7H;;;ACNO,IAAM,2BAA2B,CAAC,MAAc,EAAE,UAAU,WAAW,OAAM,MAA6C;AAC7H,QAAM,kBAAmB,OAAO,aAAa,YAAa,OAAO,SAAS;AAE1E,SAAO,iBAAiB,QAAQ,cAAc;AAClD;;;ACJO,IAAM,6BAA6B,CAAC,oBAAmF;AAC1H,SAAO,gBAAgB,SAAS;AACpC;;;ACgBM,IAAO,sBAAP,MAA0B;EAO5B,YAAY,cAAoB;AAC5B,SAAK,oBAAoB,CAAA;AACzB,SAAK,cAAc;AACnB,SAAK,gBAAgB;EACzB;EAEO,CAAC,OAAO,QAAQ,IAAC;AACpB,WAAO,KAAK,kBAAkB,OAAO,QAAQ,EAAC;EAClD;EAEO,IAAI,iBAAiC;AACxC,UAAM,YAAY,aAAa,eAAe;AAE9C,QAAI,+BAA+B,eAAe,KAAK,uCAAuC,eAAe,GAAG;AAC5G,YAAM,QAAQ,KAAK,kBAAkB,UAAU,CAAC,2BAA0B;AACtE,YAAI,uCAAuC,eAAe,KAAK,+BAA+B,sBAAsB,GAAG;AACnH,iBAAO,uBAAuB,YAAY,uBAAuB,YAAY;;AAGjF,eAAO,aAAa,sBAAsB,KAAK;MACnD,CAAC;AACD,YAAM,yBAAyB,KAAK,kBAAkB,KAAK;AAE3D,UAAI,UAAU,IAAI;AACd,aAAK,oBAAoB,KAAK,kBAAkB,MAAM,GAAG,KAAK;;AAGlE,UAAI,+BAA+B,eAAe,GAAG;AACjD,cAAM,sBAAsB,KAAK,kBAAkB,KAAK,kBAAkB,SAAS,CAAC;AAEpF,YAAI,2BAA2B,UAAa,gCAAgC,sBAAsB,GAAG;AACjG,cAAI,wBAAwB,UAAa,2BAA2B,mBAAmB,GAAG;AACtF,kBAAM,IAAI,MAAM,iCAAiC;;AAGrD,gBAAM,YACF,wBAAwB,SAClB,uBAAuB,aACvB,+BAA+B,mBAAmB,IAClD,oBAAoB,YAAY,oBAAoB,WACpD,aAAa,mBAAmB;AAC1C,gBAAM,aACF,wBAAwB,SAClB,KAAK,gBACL,+BAA+B,mBAAmB,IAClD,oBAAoB,OAAO,oBAAoB,OAAO,SAAS,CAAC,IAChE,oBAAoB;AAC9B,gBAAM,QAAQ,wCAAwC,sBAAsB,IACtE,8BAA8B,WAAW,WAAW,YAAY,sBAAsB,IACtF,yBAAyB,WAAW,WAAW,YAAY,sBAAsB;AACvF,gBAAM,2BAA2B,wCAAwC,sBAAsB,IACzF,oDAAoD,OAAO,WAAW,KAAK,WAAW,IACtF,+CAA+C,OAAO,WAAW,KAAK,WAAW;AAEvF,eAAK,kBAAkB,KAAK,wBAAwB;;AAGxD,YAAI,wBAAwB,UAAa,2BAA2B,mBAAmB,GAAG;AACtF,eAAK,kBAAkB,KAAK,8BAA8B,KAAK,SAAS,SAAS,GAAG,SAAS,CAAC;;AAGlG,YACI,wBAAwB,UACxB,+BAA+B,mBAAmB,KAClD,oBAAoB,YAAY,oBAAoB,WAAW,WACjE;AACE,gBAAM,WAAW,YAAY,oBAAoB;AACjD,gBAAM,SAAS,oBAAoB,OAAO,SAAS,KAAK,oBAAoB;AAC5E,gBAAM,SAAS,KAAK,IAAI,GAAG,IAAI,KAAK,KAAK,WAAW,KAAK,CAAC;AAC1D,gBAAM,WAAY,YAAY,SAAS,KAAM;AAC7C,gBAAM,SAAS,oBAAoB,OAAO,MAAM,GAAG,MAAM;AAEzD,cAAI,WAAW,GAAG;AACd,qBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,oBAAM,SAAU,WAAW,IAAK;AAEhC,qBAAO,CAAC,IAAI,oBAAoB,OAAO,IAAI,CAAC,KAAK,IAAI,UAAU,oBAAoB,OAAO,CAAC,IAAI;;;AAIvG,eAAK,kBAAkB,KAAK,kBAAkB,SAAS,CAAC,IAAI,mCACxD,QACA,oBAAoB,WACpB,QAAQ;;;WAIjB;AACH,YAAM,QAAQ,KAAK,kBAAkB,UAAU,CAAC,2BAA2B,aAAa,sBAAsB,IAAI,SAAS;AAE3H,YAAM,0BACF,UAAU,KAAK,KAAK,kBAAkB,KAAK,kBAAkB,SAAS,CAAC,IAAI,KAAK,kBAAkB,QAAQ,CAAC;AAE/G,UACI,4BAA4B,UAC5B,+BAA+B,uBAAuB,KACtD,aAAa,uBAAuB,IAAI,wBAAwB,WAAW,WAC7E;AACE,eAAO;;AAGX,YAAM,4BAA4B,wCAAwC,eAAe,IACnF,oDAAoD,gBAAgB,OAAO,gBAAgB,SAAS,KAAK,WAAW,IACpH,mCAAmC,eAAe,IAClD,+CAA+C,gBAAgB,OAAO,WAAW,KAAK,WAAW,IACjG;AAEN,UAAI,UAAU,IAAI;AACd,aAAK,kBAAkB,KAAK,yBAAyB;aAClD;AACH,YACI,+BAA+B,eAAe,KAC9C,YAAY,gBAAgB,WAAW,aAAa,KAAK,kBAAkB,KAAK,CAAC,GACnF;AACE,iBAAO;;AAGX,aAAK,kBAAkB,OAAO,OAAO,GAAG,yBAAyB;;;AAIzE,WAAO;EACX;EAEO,MAAM,MAAY;AACrB,UAAM,QAAQ,KAAK,kBAAkB,UAAU,CAAC,2BAA2B,aAAa,sBAAsB,IAAI,IAAI;AAEtH,QAAI,QAAQ,GAAG;AACX,YAAM,4BAA4B,KAAK,kBAAkB,MAAM,QAAQ,CAAC;AACxE,YAAM,gCAAgC,0BAA0B,CAAC;AAEjE,UAAI,2BAA2B,6BAA6B,GAAG;AAC3D,kCAA0B,QACtB,8BACI,uCACI,KAAK,mBACL,QAAQ,GACR,8BAA8B,WAC9B,KAAK,aAAa,GAEtB,8BAA8B,SAAS,CAC1C;;AAIT,WAAK,oBAAoB;;EAEjC;EAEO,SAAS,MAAY;AACxB,QAAI,KAAK,kBAAkB,WAAW,GAAG;AACrC,aAAO,KAAK;;AAGhB,UAAM,mBAAmB,KAAK,kBAAkB,UAAU,CAAC,oBAAoB,aAAa,eAAe,IAAI,IAAI;AACnH,UAAM,sBAAsB,KAAK,kBAAkB,gBAAgB;AACnE,UAAM,uBAAuB,qBAAqB,KAAK,KAAK,kBAAkB,SAAS,oBAAoB;AAC3G,UAAM,yBAAyB,KAAK,kBAAkB,mBAAmB;AAEzE,QACI,2BAA2B,UAC3B,2BAA2B,sBAAsB,MAChD,wBAAwB,UACrB,CAAC,gCAAgC,mBAAmB,KACpD,oBAAoB,aAAa,OACvC;AACE,aAAO,qBACH,MACA,uCACI,KAAK,mBACL,sBAAsB,GACtB,uBAAuB,WACvB,KAAK,aAAa,GAEtB,sBAAsB;;AAI9B,QACI,2BAA2B,UAC3B,0BAA0B,sBAAsB,MAC/C,wBAAwB,UAAa,CAAC,gCAAgC,mBAAmB,IAC5F;AACE,aAAO,uBAAuB;;AAGlC,QACI,2BAA2B,UAC3B,+BAA+B,sBAAsB,MACpD,wBAAwB,UACrB,CAAC,gCAAgC,mBAAmB,KACpD,uBAAuB,YAAY,uBAAuB,WAAW,OAC3E;AACE,UAAI,OAAO,uBAAuB,YAAY,uBAAuB,UAAU;AAC3E,eAAO,yBAAyB,MAAM,sBAAsB;;AAGhE,aAAO,uBAAuB,OAAO,uBAAuB,OAAO,SAAS,CAAC;;AAGjF,QACI,2BAA2B,UAC3B,gCAAgC,sBAAsB,MACrD,wBAAwB,UAAa,CAAC,gCAAgC,mBAAmB,IAC5F;AACE,aAAO,uBAAuB;;AAGlC,QAAI,wBAAwB,UAAa,wCAAwC,mBAAmB,GAAG;AACnG,YAAM,CAAC,WAAW,KAAK,IAAI,4CACvB,KAAK,mBACL,qBACA,wBACA,qBACA,KAAK,aAAa;AAGtB,aAAO,8BAA8B,MAAM,WAAW,OAAO,mBAAmB;;AAGpF,QAAI,wBAAwB,UAAa,mCAAmC,mBAAmB,GAAG;AAC9F,YAAM,CAAC,WAAW,KAAK,IAAI,4CACvB,KAAK,mBACL,qBACA,wBACA,qBACA,KAAK,aAAa;AAGtB,aAAO,yBAAyB,MAAM,WAAW,OAAO,mBAAmB;;AAG/E,WAAO,KAAK;EAChB;;;;ACnQG,IAAM,qCAAqC,CAAC,eAAqD;AACpG,SAAO,EAAE,YAAY,MAAM,gBAAe;AAC9C;;;ACFO,IAAM,6CAA6C,CAAC,eAA6D;AACpH,SAAO,EAAE,YAAY,MAAM,wBAAuB;AACtD;;;ACFO,IAAM,8CAA8C,CAAC,OAAe,YAA2D;AAClI,SAAO,EAAE,SAAS,MAAM,0BAA0B,MAAK;AAC3D;;;ACFO,IAAM,yCAAyC,CAAC,OAAe,YAAsD;AACxH,SAAO,EAAE,SAAS,MAAM,qBAAqB,MAAK;AACtD;;;ACFO,IAAM,iCAAiC,CAAC,QAAgB,WAAmB,iBAAmD;AACjI,SAAO,EAAE,WAAW,QAAQ,cAAc,MAAM,YAAW;AAC/D;;;ACFO,IAAM,mBAAuC,MAAM,IAAI,aAAa,IAAI,YAAY;;;ACApF,IAAM,4CAAyF,CAACA,wBAAsB;AACzH,SAAO,CAAC,cAAc,QAAQ,CAAC,QAAQ,OAAO,aAAa,GAAG,qBAAoB;AAC9E,IAAAA,oBACI,aAAa,KAAK,GAClB,CAAC,QAAQ,QAAQ,aAAa,GAC9B,CAAC,0BAA0B,sBAAsB,CAAC,MAAM,UAAU,sBAAsB,CAAC,MAAM,QAC/F,gBAAgB;EAExB;AACJ;;;ACRO,IAAM,gCAAiE,CAAC,8BAA6B;AACxG,SAAO,CACH,WACA,mBACA,oBACA;AACA,UAAM,eAAe,CAAA;AAErB,aAAS,IAAI,GAAG,IAAI,gBAAgB,gBAAgB,KAAK,GAAG;AACxD,mBAAa,KAAK,oBAAI,IAAG,CAA6B;;AAG1D,8BAA0B,IAAI,WAAW;MACrC;MACA,SAAS,oBAAI,IAAG;MAChB,eAAe,oBAAI,QAAO;MAC1B,UAAU;KACb;EACL;AACJ;;;ACnBO,IAAM,iCAAmE,CAAC,+BAA8B;AAC3G,SAAO,CACH,YACA,uBACA;AACA,+BAA2B,IAAI,YAAY,EAAE,cAAc,oBAAI,IAAG,GAAI,eAAe,oBAAI,QAAO,GAAI,UAAU,mBAAkB,CAAE;EACtI;AACJ;;;ACIO,IAAM,0BAAyD,oBAAI,QAAO;AAE1E,IAAM,+BAA2D,oBAAI,QAAO;AAE5E,IAAM,mBAAoC,oBAAI,QAAO;AAErD,IAAM,gCAA6D,oBAAI,QAAO;AAE9E,IAAM,oBAAsC,oBAAI,QAAO;AAEvD,IAAM,gBAA+B,oBAAI,QAAO;AAEhD,IAAM,kBAAmF,oBAAI,QAAO;AAEpG,IAAM,iBAAiC,oBAAI,QAAO;AAGlD,IAAM,0CAGT,oBAAI,QAAO;AAER,IAAM,yBAGT,oBAAI,QAAO;;;ACrCf,IAAM,UAAU;EACZ,YAAS;AACL,WAAO;EACX;;AAGG,IAAM,kBAAkB,CAAC,kBAAwC;AACpE,MAAI;AACA,UAAM,QAAQ,IAAI,MAAM,eAAe,OAAO;AAE9C,QAAI,MAAK;UACL;AACJ,WAAO;;AAGX,SAAO;AACX;;;ACNA,IAAM,yBAAyB;AAExB,IAAM,wBAAwB,CAAC,QAAgB,QAAiC;AACnF,QAAM,mBAAmB,CAAA;AAEzB,MAAI,gCAAgC,OAAO,QAAQ,UAAU,EAAE;AAC/D,MAAI,SAAS,8BAA8B,MAAM,sBAAsB;AAEvE,SAAO,WAAW,MAAM;AACpB,UAAM,gBAAgB,OAAO,CAAC,EAAE,MAAM,GAAG,EAAE;AAE3C,UAAM,iCAAiC,OAAO,CAAC,EAC1C,QAAQ,eAAe,EAAE,EACzB,QAAQ,eAAe,IAAI,IAAI,eAAe,GAAG,EAAE,SAAQ,CAAE;AAClE,qBAAiB,KAAK,8BAA8B;AAEpD,oCAAgC,8BAA8B,MAAM,OAAO,CAAC,EAAE,MAAM,EAAE,QAAQ,UAAU,EAAE;AAC1G,aAAS,8BAA8B,MAAM,sBAAsB;;AAGvE,SAAO,CAAC,iBAAiB,KAAK,GAAG,GAAG,6BAA6B;AACrE;;;AC3BA,IAAM,6BAA6B,CAAC,yBAAmF;AACnH,MAAI,yBAAyB,UAAa,CAAC,MAAM,QAAQ,oBAAoB,GAAG;AAC5E,UAAM,IAAI,UAAU,qFAAqF;;AAEjH;AAEA,IAAM,sBAAsB,CAA8C,kBAAoB;AAC1F,MAAI,CAAC,gBAAgB,aAAa,GAAG;AACjC,UAAM,IAAI,UAAU,4DAA4D;;AAGpF,MAAI,cAAc,cAAc,QAAQ,OAAO,cAAc,cAAc,UAAU;AACjF,UAAM,IAAI,UAAU,4DAA4D;;AAExF;AAEO,IAAM,8BAA6D,CACtEC,kBACAC,0BACA,gBACAC,mCACA,aACAC,mBACAC,uCACAC,8BACAC,oCACA,iBACA,kBACA,6CACAC,YACA;AACA,MAAI,QAAQ;AAEZ,SAAO,CAACC,UAAS,WAAW,UAAU,EAAE,aAAa,OAAM,MAAM;AAC7D,UAAM,4BAA4B,iBAAiB,IAAIA,QAAO;AAE9D,QAAI,8BAA8B,UAAa,0BAA0B,IAAI,SAAS,GAAG;AACrF,aAAO,QAAQ,QAAO;;AAG1B,UAAM,2BAA2B,gBAAgB,IAAIA,QAAO;AAE5D,QAAI,6BAA6B,QAAW;AACxC,YAAM,0BAA0B,yBAAyB,IAAI,SAAS;AAEtE,UAAI,4BAA4B,QAAW;AACvC,eAAO;;;AAIf,UAAM,gBAAgBL,kBAAiBK,QAAO;AAG9C,UAAM,UACF,cAAc,iBAAiB,SACzB,YAAY,SAAS,EAChB,KAAK,CAAC,CAAC,QAAQ,WAAW,MAAK;AAC5B,YAAM,CAAC,kBAAkB,6BAA6B,IAAI,sBAAsB,QAAQ,WAAW;AAiBnG,YAAM,gBAAgB,GAAG,gBAAgB,4GAA4G,6BAA6B;;AAIlL,aAAO,eAAe,aAAa;IACvC,CAAC,EACA,KAAK,MAAK;AACP,YAAM,kCAAqFD,QAAQ,MAAO,IAAG;AAE7G,UAAI,oCAAoC,QAAW;AAE/C,cAAM,IAAI,YAAW;;AAGzB,MAAAL,kCAAiC,cAAc,aAAa,cAAc,YAAY,MAClF,gCACI,MAAM,sBAAqB;SAC3B,QACA,CAAC,MAAM,kBAAiB;AACpB,YAAI,KAAK,KAAI,MAAO,IAAI;AACpB,gBAAMD,yBAAuB;;AAGjC,cAAM,oCAAoC,wCAAwC,IAAI,aAAa;AAEnG,YAAI,sCAAsC,QAAW;AACjD,cAAI,kCAAkC,IAAI,IAAI,GAAG;AAC7C,kBAAMA,yBAAuB;;AAGjC,8BAAoB,aAAa;AACjC,qCAA2B,cAAc,oBAAoB;AAE7D,4CAAkC,IAAI,MAAM,aAAa;eACtD;AACH,8BAAoB,aAAa;AACjC,qCAA2B,cAAc,oBAAoB;AAE7D,kDAAwC,IAAI,eAAe,oBAAI,IAAI,CAAC,CAAC,MAAM,aAAa,CAAC,CAAC,CAAC;;MAEnG,GACA,cAAc,YACd,QACA,MAAS,CACZ;IAET,CAAC,IACL,QAAQ,IAAI;MACR,YAAY,SAAS;MACrB,QAAQ,QACJD,iBAAgB,6CAA6C,2CAA2C,CAAC;KAEhH,EAAE,KAAK,CAAC,CAAC,CAAC,QAAQ,WAAW,GAAG,uBAAuB,MAAK;AACzD,YAAM,eAAe,QAAQ;AAE7B,cAAQ;AAER,YAAM,CAAC,kBAAkB,6BAA6B,IAAI,sBAAsB,QAAQ,WAAW;AA2BnG,YAAM,+BAA+B,0BAC/B,0BACA;AA6CN,YAAM,mBAAmB,0BAA0B,KAAK;AACxD,YAAM,qBAAqB,0BACrB,KACA;AACN,YAAM,gBAAgB,GAAG,gBAAgB,iDAAiD,6BAA6B;KACxI,4BAA4B,+CAA+C,gBAAgB,kBAAkB,kBAAkB,gGAAgG,YAAY;AAC1N,YAAM,OAAO,IAAI,KAAK,CAAC,aAAa,GAAG,EAAE,MAAM,wCAAuC,CAAE;AACxF,YAAM,MAAM,IAAI,gBAAgB,IAAI;AAEpC,aAAO,cAAc,aAChB,UAAU,KAAK,OAAO,EACtB,KAAK,MAAK;AACP,YAAIK,6BAA4B,aAAa,GAAG;AAC5C,iBAAO;;AAIX,cAAM,4BAA4BD,sCAAqC,aAAa;AAEpF,eAAO,0BAA0B,aAAa,UAAU,KAAK,OAAO,EAAE,KAAK,MAAM,yBAAyB;MAC9G,CAAC,EACA,KAAK,CAAC,6CAA4C;AAC/C,YAAIE,uCAAsC,MAAM;AAC5C,gBAAM,IAAI,YAAW;;AAGzB,YAAI;AAEA,cAAIA,mCAAkC,0CAA0C,QAAQ,YAAY,EAAE;gBAClG;AACJ,gBAAM,IAAI,YAAW;;MAE7B,CAAC,EACA,QAAQ,MAAM,IAAI,gBAAgB,GAAG,CAAC;IAC/C,CAAC;AAEX,QAAI,6BAA6B,QAAW;AACxC,sBAAgB,IAAIE,UAAS,oBAAI,IAAI,CAAC,CAAC,WAAW,OAAO,CAAC,CAAC,CAAC;WACzD;AACH,+BAAyB,IAAI,WAAW,OAAO;;AAGnD,YACK,KAAK,MAAK;AACP,YAAM,mCAAmC,iBAAiB,IAAIA,QAAO;AAErE,UAAI,qCAAqC,QAAW;AAChD,yBAAiB,IAAIA,UAAS,oBAAI,IAAI,CAAC,SAAS,CAAC,CAAC;aAC/C;AACH,yCAAiC,IAAI,SAAS;;IAEtD,CAAC,EACA,QAAQ,MAAK;AACV,YAAM,kCAAkC,gBAAgB,IAAIA,QAAO;AAEnE,UAAI,oCAAoC,QAAW;AAC/C,wCAAgC,OAAO,SAAS;;IAExD,CAAC;AAEL,WAAO;EACX;AACJ;;;AC/QO,IAAM,iBAA0C,CAAC,KAAK,QAAO;AAChE,QAAM,QAAQ,IAAI,IAAI,GAAG;AAEzB,MAAI,UAAU,QAAW;AACrB,UAAM,IAAI,MAAM,gDAAgD;;AAGpE,SAAO;AACX;;;ACRO,IAAM,qBAAkD,CAAC,KAAK,cAAa;AAC9E,QAAM,mBAAmB,MAAM,KAAK,GAAG,EAAE,OAAO,SAAS;AAEzD,MAAI,iBAAiB,SAAS,GAAG;AAC7B,UAAM,MAAM,kCAAkC;;AAGlD,MAAI,iBAAiB,WAAW,GAAG;AAC/B,UAAM,MAAM,uBAAuB;;AAGvC,QAAM,CAAC,eAAe,IAAI;AAE1B,MAAI,OAAO,eAAe;AAE1B,SAAO;AACX;;;ACbO,IAAM,0CAA0C,CACnD,eACA,QACA,QACA,UACA;AACA,QAAM,0BAA0B,eAAe,eAAe,MAAM;AACpE,QAAM,qBAAqB,mBACvB,yBACA,CAAC,2BAA2B,uBAAuB,CAAC,MAAM,UAAU,uBAAuB,CAAC,MAAM,KAAK;AAG3G,MAAI,wBAAwB,SAAS,GAAG;AACpC,kBAAc,OAAO,MAAM;;AAG/B,SAAO;AACX;;;AClBO,IAAM,+BAAsE,CAAC,cAAa;AAC7F,SAAO,eAAe,iBAAiB,SAAS;AACpD;;;ACDO,IAAM,2BAA2B,CAAqB,cAA4B;AACrF,MAAI,wBAAwB,IAAI,SAAS,GAAG;AACxC,UAAM,IAAI,MAAM,kCAAkC;;AAGtD,0BAAwB,IAAI,SAAS;AAErC,+BAA6B,SAAS,EAAE,QAAQ,CAAC,kBAAkB,cAAc,IAAI,CAAC;AAC1F;;;ACVO,IAAM,qBAAqB,CAAqB,cAA+D;AAClH,SAAO,UAAU;AACrB;;;ACAO,IAAM,4BAA4B,CAAqB,cAA4B;AACtF,MAAI,CAAC,wBAAwB,IAAI,SAAS,GAAG;AACzC,UAAM,IAAI,MAAM,8BAA8B;;AAGlD,0BAAwB,OAAO,SAAS;AAExC,+BAA6B,SAAS,EAAE,QAAQ,CAAC,kBAAkB,cAAc,KAAK,CAAC;AAC3F;;;ACPO,IAAM,yCAAyC,CAClD,WACA,iBACA;AACA,MAAI,CAAC,mBAAmB,SAAS,KAAK,aAAa,MAAM,CAAC,gBAAgB,YAAY,SAAS,CAAC,GAAG;AAC/F,8BAA0B,SAAS;;AAE3C;;;ACPO,IAAM,iCAAmE,CAC5EC,sCACAC,uCACAC,0CACAC,yCACAC,+CACAC,0BACAC,uBACAC,+BACAC,qBACAC,qBACAC,oBACAC,iBACAC,wBACA;AACA,QAAM,qBAAqB,oBAAI,QAAO;AAEtC,SAAO,CAAC,QAAQ,aAAa,QAAQ,OAAO,cAAa;AACrD,UAAM,EAAE,cAAc,cAAa,IAAKP,yBAAwB,WAAW;AAC3E,UAAM,EAAE,QAAO,IAAKA,yBAAwB,MAAM;AAClD,UAAM,iBAAiBE,8BAA6B,MAAM;AAE1D,UAAM,gBAA6C,CAAC,aAAY;AAC5D,YAAM,6BAA6BC,oBAAmB,WAAW;AACjE,YAAM,wBAAwBA,oBAAmB,MAAM;AAEvD,UAAI,UAAU;AACV,cAAM,oBAAoB,wCAAwC,eAAe,QAAQ,QAAQ,KAAK;AAEtG,QAAAR,qCAAoC,cAAc,QAAQ,mBAAmB,KAAK;AAElF,YAAI,CAAC,aAAa,CAACW,gBAAe,MAAM,GAAG;AACvC,UAAAT,yCAAwC,uBAAuB,4BAA4B,QAAQ,KAAK;;AAG5G,YAAIU,oBAAmB,WAAW,GAAG;AACjC,mCAAyB,WAAW;;aAErC;AACH,cAAM,oBAAoBT,wCAAuC,cAAc,QAAQ,QAAQ,KAAK;AAEpG,QAAAF,sCAAqC,eAAe,OAAO,mBAAmB,KAAK;AAEnF,YAAI,CAAC,aAAa,CAACU,gBAAe,MAAM,GAAG;AACvC,UAAAP,8CAA6C,uBAAuB,4BAA4B,QAAQ,KAAK;;AAGjH,cAAM,WAAWE,sBAAqB,WAAW;AAEjD,YAAI,aAAa,GAAG;AAChB,cAAII,mBAAkB,WAAW,GAAG;AAChC,mDAAuC,aAAa,YAAY;;eAEjE;AACH,gBAAM,oBAAoB,mBAAmB,IAAI,WAAW;AAE5D,cAAI,sBAAsB,QAAW;AACjC,yBAAa,iBAAiB;;AAGlC,6BAAmB,IACf,aACA,WAAW,MAAK;AACZ,gBAAIA,mBAAkB,WAAW,GAAG;AAChC,qDAAuC,aAAa,YAAY;;UAExE,GAAG,WAAW,GAAI,CAAC;;;IAInC;AAEA,QACID,oBACI,SACA,CAAC,aAAa,QAAQ,KAAK,GAC3B,CAAC,qBACG,iBAAiB,CAAC,MAAM,eAAe,iBAAiB,CAAC,MAAM,UAAU,iBAAiB,CAAC,MAAM,OACrG,IAAI,GAEV;AACE,qBAAe,IAAI,aAAa;AAEhC,UAAIC,mBAAkB,MAAM,GAAG;AAC3B,QAAAV,qCAAoC,cAAc,QAAQ,CAAC,QAAQ,OAAO,aAAa,GAAG,IAAI;aAC3F;AACH,QAAAC,sCAAqC,eAAe,OAAO,CAAC,QAAQ,QAAQ,aAAa,GAAG,IAAI;;AAGpG,aAAO;;AAGX,WAAO;EACX;AACJ;;;AClGO,IAAM,6CAA2F,CAACY,wBAAsB;AAC3H,SAAO,CAAC,eAAe,OAAO,CAAC,QAAQ,QAAQ,aAAa,GAAG,qBAAoB;AAC/E,UAAM,0BAA0B,cAAc,IAAI,MAAM;AAExD,QAAI,4BAA4B,QAAW;AACvC,oBAAc,IAAI,QAAQ,oBAAI,IAAI,CAAC,CAAC,QAAQ,OAAO,aAAa,CAAC,CAAC,CAAC;WAChE;AACH,MAAAA,oBACI,yBACA,CAAC,QAAQ,OAAO,aAAa,GAC7B,CAAC,2BAA2B,uBAAuB,CAAC,MAAM,UAAU,uBAAuB,CAAC,MAAM,OAClG,gBAAgB;;EAG5B;AACJ;;;ACfO,IAAM,4BAAyD,CAACC,0BAAwB;AAC3F,SAAO,CAAC,eAAe,mCAAkC;AACrD,UAAM,iBAAiBA,sBAAqB,eAAe;MACvD,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,MAAM;KACT;AAED,mCAA+B,QAAQ,cAAc,EAAE,QAAQ,cAAc,WAAW;AAExF,UAAMC,cAAa,MAAK;AACpB,qCAA+B,oBAAoB,SAASA,WAAU;AACtE,qCAA+B,WAAW,cAAc;AACxD,qBAAe,WAAU;IAC7B;AAEA,mCAA+B,iBAAiB,SAASA,WAAU;EACvE;AACJ;;;ACnBO,IAAM,sCAA6E,CAACC,oCAAkC;AACzH,SAAO,CAAC,eAAe,qBAAoB;AACvC,IAAAA,gCAA+B,aAAa,EAAE,IAAI,gBAAgB;EACtE;AACJ;;;ACHA,IAAM,kBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,SAAS;EACT,aAAa;EACb,aAAa;EACb,uBAAuB;;AAGpB,IAAM,gCAAiE,CAC1E,uBACAC,6BACAC,uBACAC,2BACAC,mBACAC,iCACA;AACA,SAAO,MAAM,qBAAyC,sBAAwB;IAG1E,YAAYC,UAAY,SAAmC;AACvD,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAG,iBAAiB,GAAG,QAAO;AACtD,YAAM,qBAAqBH,0BAAyB,eAAe,aAAa;AAChF,YAAM,uBACDE,6BAA4B,aAAa,IAAIJ,4BAA0B,IAAK;AAGjF,YAAMK,UAAS,OAAO,oBAAoB,oBAAoB;AAE9D,WAAK,sBAAsB;IAC/B;IAEA,IAAI,UAAO;AACP,aAAO,KAAK,oBAAoB;IACpC;IAEA,IAAI,QAAQ,OAAK;AACb,WAAK,oBAAoB,UAAU;IACvC;IAEA,IAAI,oBAAiB;AACjB,aAAO,KAAK,oBAAoB;IACpC;IAEA,IAAI,cAAW;AACX,aAAO,KAAK,oBAAoB;IACpC;IAEA,IAAI,YAAY,OAAK;AAEjB,YAAM,cAAc,KAAK,oBAAoB;AAE7C,WAAK,oBAAoB,cAAc;AAEvC,UAAI,EAAE,QAAQ,KAAK,oBAAoB,cAAc;AACjD,aAAK,oBAAoB,cAAc;AAEvC,cAAMJ,sBAAoB;;IAElC;IAEA,IAAI,cAAW;AACX,aAAO,KAAK,oBAAoB;IACpC;IAEA,IAAI,YAAY,OAAK;AAEjB,YAAM,cAAc,KAAK,oBAAoB;AAE7C,WAAK,oBAAoB,cAAc;AAEvC,UAAI,EAAE,KAAK,oBAAoB,cAAc,QAAQ;AACjD,aAAK,oBAAoB,cAAc;AAEvC,cAAMA,sBAAoB;;IAElC;IAEA,IAAI,wBAAqB;AACrB,aAAO,KAAK,oBAAoB;IACpC;IAEA,IAAI,sBAAsB,OAAK;AAC3B,WAAK,oBAAoB,wBAAwB;IACrD;IAEO,qBAAqB,OAAiB;AACzC,WAAK,oBAAoB,qBAAqB,KAAK;IACvD;IAEO,sBAAsB,OAAiB;AAC1C,WAAK,oBAAoB,sBAAsB,KAAK;IACxD;IAEO,sBAAsB,OAAmB;AAC5C,WAAK,oBAAoB,sBAAsB,KAAK;IACxD;IAEO,uBAAuB,OAAmB;AAC7C,WAAK,oBAAoB,uBAAuB,KAAK;IACzD;;AAER;;;ACzGO,IAAM,mBAAmB,CAAC,iBAAmC,kBAA0C;AAC1G,SAAO,gBAAgB,YAAY;AACvC;;;ACAO,IAAM,oCAAyE,CAClFK,2BACAC,qBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,8BAA8B,oBAAI,QAAO;AAE/C,UAAM,qBAAqB,OAAO,OAAyB,8BAAyD;AAChH,UAAI,qBAAqBD,oBAA2C,KAAK;AAGzE,YAAM,qCAAqC,iBAAiB,oBAAoB,yBAAyB;AAEzG,UAAI,CAAC,oCAAoC;AACrC,cAAM,UAAU;UACZ,cAAc,mBAAmB;UACjC,kBAAkB,mBAAmB;UACrC,uBAAuB,mBAAmB;UAC1C,SAAS,mBAAmB;UAC5B,aAAa,mBAAmB;UAChC,aAAa,mBAAmB;UAChC,uBAAuB,mBAAmB;;AAG9C,6BAAqBD,0BAAyB,2BAA2B,OAAO;;AAGpF,kCAA4B,IAAI,2BAA2B,kBAAkB;AAE7E,YAAME,yBAAwB,OAAO,2BAA2B,kBAAkB;AAElF,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAAyB,2BAAqD;AACjF,cAAM,6BAA6B,4BAA4B,IAAI,yBAAyB;AAE5F,YAAI,+BAA+B,QAAW;AAC1C,iBAAO,QAAQ,QAAQ,0BAA0B;;AAGrD,eAAO,mBAAmB,OAAO,yBAAyB;MAC9D;;EAER;AACJ;;;ACjDO,IAAM,sDAAsD,CAAC,sBAAkD;AAClH,MAAI;AACA,sBAAkB,cAAc,IAAI,aAAa,CAAC,GAAG,GAAG,EAAE;UACtD;AACJ,WAAO;;AAGX,SAAO;AACX;;;ACRO,IAAM,uBAA+C,MAAM,IAAI,aAAa,IAAI,gBAAgB;;;ACChG,IAAM,sCAAsC,CAAC,gBAAyC;AACzF,cAAY,kBAAkB,CAAC,mBAAkB;AAC7C,WAAO,CAAC,YAAmB;AACvB,UAAI;AACA,eAAO,eAAe,KAAK,aAAa,OAAO;eAC1C,KAAK;AACV,YAAI,IAAI,SAAS,IAAI;AACjB,gBAAM,qBAAoB;;AAG9B,cAAM;;IAEd;EACJ,GAAG,YAAY,cAAc;AACjC;;;ACZA,IAAMC,mBAAkB;EACpB,kBAAkB;;AAGf,IAAM,+BAA+D,CACxEC,mBACAC,kBACAC,0BACAC,+BACAC,uCACA,yCACAC,oCACAC,kDACA;AACA,MAAI,4BAA+D;AAEnE,SAAO,MAAMC,aAAW;IAsBpB,YAAY,SAA4B;AACpC,UAAIH,0CAAyC,MAAM;AAC/C,cAAM,IAAI,MAAM,qDAAqD;;AAGzE,YAAM,EAAE,QAAQ,kBAAkB,WAAU,IAAK,EAAE,GAAGL,kBAAiB,GAAG,QAAO;AAEjF,UAAI,8BAA8B,MAAM;AACpC,oCAA4B,IAAIK,sCAAqC,GAAG,GAAG,KAAK;;AAOpF,YAAM,cACFD,kCAAiC,QACjCF,iBAAgB,yCAAyC,uCAAuC,IAC1F,IAAIE,8BAA6B,EAAE,QAAQ,kBAAkB,WAAU,CAAE,IACzE,0BAA0B,aAAa,kBAAkB,QAAQ,UAAU;AAGrF,UAAI,YAAY,qBAAqB,GAAG;AACpC,cAAMD,yBAAuB;;AAKjC,UAAI,OAAO,YAAY,oBAAoB,YAAY;AACnD,QAAAG,mCAAkC,WAAW;AAC7C,4CAAoC,WAAW;iBAG/C,CAACJ,iBAAgB,qDAAqD,MAClE,oDAAoD,WAAW,CAAC,GAEtE;AACE,QAAAK,8CAA6C,WAAW;;AAG5D,MAAAN,kBAAiB,IAAI,WAAW;AAMhC,aAAO;IACX;IAEO,QAAQ,OAAO,WAAW,EAAE,UAAiB;AAChD,aACK,aAAa,QAAQ,OAAO,aAAa,YAAY,OAAO,eAAe,QAAQ,MAAMO,aAAY,aACtGP,kBAAiB,IAAS,QAAQ;IAE1C;;AAER;;;ACnGO,IAAM,6BAA6B;AAEnC,IAAM,6BAA6B,CAAC;;;ACCpC,IAAM,oBAAgD,CAAC,cAAc,wBAAwB,IAAI,SAAS;;;ACWjH,IAAMQ,mBAAkB;EACpB,QAAQ;EACR,cAAc;EACd,kBAAkB;EAClB,uBAAuB;;EAEvB,MAAM;EACN,SAAS;EACT,WAAW;EACX,cAAc;;AAGX,IAAM,yCAAmF,CAC5FC,uBACAC,sCACAC,mBACAC,0BACAC,oCACAC,mBACAC,8BACAC,uBACA;AACA,SAAO,MAAM,8BACDP,sBAA0D;IAelE,YAAYQ,UAAY,SAA4C;AAChE,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGT,kBAAiB,GAAG,QAAO;AACtD,YAAM,8BAA8BK,mCAAkC,eAAe,aAAa;AAClG,YAAM,YAAYE,6BAA4B,aAAa;AAC3D,YAAM,gCACD,YAAYL,qCAAmC,IAAK;AAGzD,YAAMO,UAAS,OAAO,6BAA6B,6BAA6B;AAEhF,WAAK,iCAAiC;AACtC,WAAK,qBAAqB;AAC1B,WAAK,eAAe,cAAc,WAAW;AAC7C,WAAK,+BAA+B;AACpC,WAAK,WAAW;AAEhB,WAAK,gBAAgBN,kBACjB,MACA,WACA,4BAA4B,cAC5B,4BACA,0BAA0B;IAElC;IAEA,IAAI,SAAM;AACN,UAAI,KAAK,oBAAoB;AACzB,eAAO;;AAGX,aAAO,KAAK,6BAA6B;IAC7C;IAEA,IAAI,OAAO,OAAK;AACZ,WAAK,6BAA6B,SAAS;AAG3C,UAAI,UAAU,MAAM;AAChB,YAAI,KAAK,cAAc;AACnB,gBAAMC,yBAAuB;;AAGjC,aAAK,eAAe;;IAE5B;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK,6BAA6B;IAC7C;IAEA,IAAI,KAAK,OAAK;AACV,WAAK,6BAA6B,OAAO;IAC7C;IAEA,IAAI,UAAO;AACP,aAAO,KAAK,6BAA6B;IAC7C;IAEA,IAAI,QAAQ,OAAK;AACb,WAAK,6BAA6B,UAAU;IAChD;IAEA,IAAI,YAAS;AACT,aAAO,KAAK,6BAA6B;IAC7C;IAEA,IAAI,UAAU,OAAK;AACf,WAAK,6BAA6B,YAAY;IAClD;IAEA,IAAI,UAAO;AACP,aAAO,KAAK;IAChB;IAEA,IAAI,QAAQ,OAAK;AACb,YAAM,kBAAkB,OAAO,UAAU,aAAaI,mBAAkB,MAAM,KAAK,IAAI;AAEvF,WAAK,6BAA6B,UAAU;AAE5C,YAAM,gBAAgB,KAAK,6BAA6B;AAExD,WAAK,WAAW,kBAAkB,QAAQ,kBAAkB,kBAAkB,QAAQ;IAC1F;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK;IAChB;IAEO,MAAM,OAAO,GAAG,SAAS,GAAG,UAAiB;AAChD,WAAK,6BAA6B,MAAM,MAAM,QAAQ,QAAQ;AAE9D,UAAI,KAAK,mCAAmC,MAAM;AAC9C,aAAK,+BAA+B,QAAQ,aAAa,SAAY,CAAC,MAAM,MAAM,IAAI,CAAC,MAAM,QAAQ,QAAQ;;AAGjH,UAAI,KAAK,QAAQ,UAAU,UAAU;AACjC,iCAAyB,IAAI;AAE7B,cAAM,8BAA8B,MAAK;AACrC,eAAK,6BAA6B,oBAAoB,SAAS,2BAA2B;AAE1F,cAAI,kBAAkB,IAAI,GAAG;AACzB,sCAA0B,IAAI;;QAEtC;AAEA,aAAK,6BAA6B,iBAAiB,SAAS,2BAA2B;;IAE/F;IAEO,KAAK,OAAO,GAAC;AAChB,WAAK,6BAA6B,KAAK,IAAI;AAE3C,UAAI,KAAK,mCAAmC,MAAM;AAC9C,aAAK,+BAA+B,OAAO;;IAEnD;;AAER;;;ACvKO,IAAM,6CAA2F,CACpGE,oBACAC,oCACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,uCAAuC,oBAAI,QAAO;AAExD,QAAIC,SAA4D;AAChE,QAAI,OAAsB;AAE1B,UAAM,8BAA8B,OAChC,OACA,8BACA;AACA,UAAI,8BAA8BH,oBAAoD,KAAK;AAM3F,YAAM,8CAA8C,iBAAiB,6BAA6B,yBAAyB;AAE3H,UAAI,CAAC,6CAA6C;AAC9C,cAAM,UAAU;UACZ,QAAQ,4BAA4B;UACpC,cAAc,4BAA4B;UAC1C,kBAAkB,4BAA4B;UAC9C,uBAAuB,4BAA4B;;UAEnD,MAAM,4BAA4B;UAClC,SAAS,4BAA4B;UACrC,WAAW,4BAA4B;UACvC,cAAc,4BAA4B,aAAa;;AAG3D,sCAA8BD,mCAAkC,2BAA2B,OAAO;AAElG,YAAII,WAAU,MAAM;AAChB,sCAA4B,MAAM,GAAGA,MAAK;;AAG9C,YAAI,SAAS,MAAM;AACf,sCAA4B,KAAK,IAAI;;;AAI7C,2CAAqC,IAAI,2BAA2B,2BAA2B;AAE/F,UAAI,CAAC,6CAA6C;AAE9C,cAAMF,kBAAiB,2BAA2B,MAAM,cAAc,4BAA4B,YAAY;aAC3G;AAEH,cAAMH,mBAAkB,2BAA2B,MAAM,cAAc,4BAA4B,YAAY;;AAGnH,YAAMI,yBAAwB,OAAO,2BAA2B,2BAA2B;AAE3F,aAAO;IACX;AAEA,WAAO;MACH,IAAI,MAAM,OAAkD;AACxD,QAAAC,SAAQ;MACZ;MACA,IAAI,KAAK,OAAa;AAClB,eAAO;MACX;MACA,OACI,OACA,2BAAqD;AAErD,cAAM,sCAAsC,qCAAqC,IAAI,yBAAyB;AAE9G,YAAI,wCAAwC,QAAW;AACnD,iBAAO,QAAQ,QAAQ,mCAAmC;;AAG9D,eAAO,4BAA4B,OAAO,yBAAyB;MACvE;;EAER;AACJ;;;ACtFO,IAAM,0BAA0B,CAAqB,cAAoE;AAC5H,SAAO,kBAAkB;AAC7B;;;ACFO,IAAM,qBAAqB,CAAqB,cAA+D;AAClH,SAAO,eAAe,aAAa,UAAU;AACjD;;;ACFO,IAAM,uBAAuB,CAAqB,cAAiE;AACtH,SAAO,YAAY;AACvB;;;ACFO,IAAM,aAAa,CAAqB,cAAuD;AAClG,SAAO,EAAE,eAAe,cAAc,UAAU;AACpD;;;ACFO,IAAM,mBAAmB,CAAqB,cAA6D;AAC9G,SAAO,YAAY,aAAa,eAAe;AACnD;;;ACFO,IAAM,qBAAqB,CAAqB,cAA+D;AAClH,SAAO,SAAS;AACpB;;;ACAO,IAAM,0BAA4D,CACrE,cAC0B;AAC1B,SAAiC,eAAe,8BAA8B,SAAS;AAC3F;;;ACJO,IAAM,2BAA8D,CACvE,eAC2B;AAC3B,SAAkC,eAAe,+BAA+B,UAAU;AAC9F;;;ACKO,IAAM,4CAA4C,CACrD,WACA,UACA;AACA,QAAM,EAAE,aAAY,IAAK,wBAAwB,SAAS;AAE1D,eAAa,QAAQ,CAAC,gBAClB,YAAY,QAAQ,CAAC,CAAC,MAAM,MAAK;AAC7B,QAAI,CAAC,MAAM,SAAS,SAAS,GAAG;AAC5B,gDAA0C,QAAQ,CAAC,GAAG,OAAO,SAAS,CAAC;;EAE/E,CAAC,CAAC;AAGN,QAAM,cAAc,wBAAwB,SAAS,IAC/C;;IAEI,UAAU;MAEd,mBAAmB,SAAS,IAC5B,MAAM,KAAK,UAAU,WAAW,OAAM,CAAE,IACxC,mBAAmB,SAAS,IAC5B,CAAC,UAAU,GAAG,UAAU,QAAQ,UAAU,WAAW,UAAU,IAAI,IACnE,qBAAqB,SAAS,IAC9B,CAAC,UAAU,MAAM,IACjB,WAAW,SAAS,IACpB,CAAC,UAAU,IAAI,IACf,iBAAiB,SAAS,IAC1B,CAAC,UAAU,QAAQ,UAAU,SAAS,IACtC,mBAAmB,SAAS,IAC5B,CAAC,UAAU,GAAG,IACd,CAAA;AAEN,aAAW,cAAc,aAAa;AAClC,UAAM,wBAAwB,yBAA4B,UAAU;AAEpE,QAAI,0BAA0B,QAAW;AACrC,4BAAsB,aAAa,QAAQ,CAAC,CAAC,MAAM,MAAM,0CAA0C,QAAQ,KAAK,CAAC;;;AAIzH,MAAI,kBAAkB,SAAS,GAAG;AAC9B,8BAA0B,SAAS;;AAE3C;;;ACtDO,IAAM,uBAAuB,CAAqBC,aAAoB;AACzE,4CAAoEA,SAAQ,aAAa,CAAA,CAAE;AAC/F;;;ACJO,IAAM,qBAAqB,CAAC,gBAAoD;AACnF,SACI,gBAAgB,UAChB,OAAO,gBAAgB,YACtB,OAAO,gBAAgB,aAAa,gBAAgB,cAAc,gBAAgB,iBAAiB,gBAAgB;AAE5H;;;ACIO,IAAM,gCAAiE,CAC1EC,8BACAC,0BACAC,0BACAC,qBACAC,yCACAC,6CACAC,wCACAC,6CACAC,mCACA;AACA,SAAO,MAAM,qBAAqBR,6BAA0C;IAWxE,YAAY,UAAgC,CAAA,GAAE;AAC1C,UAAIQ,mCAAkC,MAAM;AACxC,cAAM,IAAI,MAAM,8CAA8C;;AAGlE,UAAI;AAEJ,UAAI;AACA,6BAAqB,IAAIA,+BAA8B,OAAO;eACzD,KAAK;AAEV,YAAI,IAAI,SAAS,MAAM,IAAI,YAAY,8BAA8B;AACjE,gBAAMN,yBAAuB;;AAGjC,cAAM;;AAIV,UAAI,uBAAuB,MAAM;AAC7B,cAAMC,oBAAkB;;AAI5B,UAAI,CAAC,mBAAmB,QAAQ,WAAW,GAAG;AAC1C,cAAM,IAAI,UACN,uBAAuB,QAAQ,WAAW,kEAAkE;;AAKpH,UAAI,QAAQ,eAAe,UAAa,mBAAmB,eAAe,QAAQ,YAAY;AAC1F,cAAMD,yBAAuB;;AAGjC,YAAM,oBAAoB,CAAC;AAE3B,YAAM,EAAE,YAAW,IAAK;AACxB,YAAM,EAAE,WAAU,IAAK;AAGvB,WAAK,eACD,OAAO,mBAAmB,gBAAgB,WACpC,mBAAmB,cACnB,gBAAgB,aAChB,MAAM,aACN,gBAAgB,iBAAiB,gBAAgB,SACjD,MAAM,aACN,gBAAgB,aAChB,OAAO;;;;;QAKN,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,MAAO,cAAc,aAAc,GAAG,CAAC,CAAC,IAAI,MAAO;;AAC7F,WAAK,sBAAsB;AAG3B,UAAIM,+BAA8B,SAAS,sBAAsB;AAC7D,aAAK,kBAAkB,mBAAmB,WAAU;AACpD,aAAK,wBAAwB,mBAAmB,iBAAgB;AAEhE,aAAK,gBAAgB,KAAK,QAAQ;AAElC,aAAK,sBAAsB,QAAQ,KAAK,eAAe,EAAE,QAAQ,mBAAmB,WAAW;AAC/F,aAAK,sBAAsB,MAAK;aAC7B;AACH,aAAK,kBAAkB;AACvB,aAAK,wBAAwB;;AAGjC,WAAK,SAAS;AAMd,UAAI,mBAAmB,UAAU,WAAW;AACxC,aAAK,SAAS;AAEd,cAAM,cAAc,MAAK;AACrB,cAAI,KAAK,WAAW,aAAa;AAC7B,iBAAK,SAAS;;AAGlB,6BAAmB,oBAAoB,eAAe,WAAW;QACrE;AAEA,2BAAmB,iBAAiB,eAAe,WAAW;;IAEtE;IAEA,IAAI,cAAW;AACX,aAAO,KAAK;IAChB;IAEA,IAAI,QAAK;AACL,aAAO,KAAK,WAAW,OAAO,KAAK,SAAS,KAAK,oBAAoB;IACzE;IAEO,QAAK;AAER,UAAI,KAAK,UAAU,UAAU;AACzB,eAAO,KAAK,oBAAoB,MAAK,EAAG,KAAK,MAAK;AAC9C,gBAAMP,yBAAuB;QACjC,CAAC;;AAIL,UAAI,KAAK,WAAW,aAAa;AAC7B,aAAK,SAAS;;AAGlB,aAAO,KAAK,oBAAoB,MAAK,EAAG,KAAK,MAAK;AAC9C,YAAI,KAAK,oBAAoB,QAAQ,KAAK,0BAA0B,MAAM;AACtE,eAAK,sBAAsB,KAAI;AAE/B,eAAK,gBAAgB,WAAU;AAC/B,eAAK,sBAAsB,WAAU;;AAGzC,6BAAqB,IAAI;MAC7B,CAAC;IACL;IAEO,yBAAyB,cAA8B;AAC1D,aAAO,IAAIG,wCAAuC,MAAM,EAAE,aAAY,CAAE;IAC5E;IAEO,+BAA4B;AAC/B,aAAO,IAAIC,4CAA2C,IAAI;IAC9D;IAEO,wBAAwB,aAAwB;AACnD,aAAO,IAAIC,uCAAsC,MAAM,EAAE,YAAW,CAAE;IAC1E;IAEO,6BAA6B,kBAAkC;AAClE,aAAO,IAAIC,4CAA2C,MAAM,EAAE,iBAAgB,CAAE;IACpF;IAEO,SAAM;AACT,UAAI,KAAK,WAAW,aAAa;AAC7B,eAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,gBAAM,iBAAiB,MAAK;AACxB,iBAAK,oBAAoB,oBAAoB,eAAe,cAAc;AAE1E,gBAAI,KAAK,oBAAoB,UAAU,WAAW;AAC9C,sBAAO;mBACJ;AACH,mBAAK,OAAM,EAAG,KAAK,SAAS,MAAM;;UAE1C;AAEA,eAAK,oBAAoB,iBAAiB,eAAe,cAAc;QAC3E,CAAC;;AAGL,aAAO,KAAK,oBAAoB,OAAM,EAAG,MAAM,CAAC,QAAO;AAGnD,YAAI,QAAQ,UAAa,IAAI,SAAS,IAAI;AACtC,gBAAMN,yBAAuB;;AAGjC,cAAM;MACV,CAAC;IACL;IAEO,UAAO;AACV,aAAO,KAAK,oBAAoB,QAAO,EAAG,MAAM,CAAC,QAAO;AAEpD,YAAI,QAAQ,QAAW;AACnB,gBAAMA,yBAAuB;;AAGjC,cAAM;MACV,CAAC;IACL;;AAER;;;AC7MO,IAAM,wCAAiF,CAC1FQ,uBACAC,qCACAC,uBACAC,0BACA,kCACAC,mBACAC,8BACAC,6BACA;AACA,SAAO,MAAM,6BAAiDN,sBAAuB;IAKjF,YAAYO,UAAY,cAAoB;AACxC,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,YAAYF,6BAA4B,aAAa;AAC3D,YAAM,6BAA6B,iCAAiC,eAAe,cAAc,SAAS;AAC1G,YAAM,+BACD,YAAYJ,oCAAmCK,wBAAuB,IAAI;AAG/E,YAAMC,UAAS,OAAO,4BAA4B,4BAA4B;AAE9E,WAAK,qCAAqC;AAC1C,WAAK,8BAA8B;IACvC;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK,4BAA4B;IAC5C;IAEA,IAAI,aAAa,OAAK;AAGlB,UAAI,KAAK,oCAAoC;AACzC,cAAMJ,yBAAuB;;AAIjC,UAAI,QAAQ,KAAK,4BAA4B,iBAAiB;AAC1D,cAAMD,sBAAoB;;AAG9B,WAAK,4BAA4B,eAAe;IACpD;IAEA,IAAI,mBAAgB;AAChB,aAAO,KAAK,4BAA4B;IAC5C;IAEA,IAAI,iBAAiB,OAAK;AAEtB,UAAI,KAAK,oCAAoC;AACzC,cAAMC,yBAAuB;;AAGjC,WAAK,4BAA4B,mBAAmB;IACxD;IAEA,IAAI,kBAAe;AACf,aAAO,KAAK,4BAA4B;IAC5C;;AAER;;;AClEO,IAAM,qCAA2E,CAGpFK,6BACA;AACA,QAAM,sCAAsC,oBAAI,QAAO;AAEvD,QAAM,6BAA6B,OAAO,OAAiC,8BAAyD;AAChI,UAAM,6BAA6B,0BAA0B;AAE7D,wCAAoC,IAAI,2BAA2B,0BAA0B;AAE7F,UAAMA,yBAAwB,OAAO,2BAA2B,0BAA0B;AAE1F,WAAO;EACX;AAEA,SAAO;IACH,OACI,OACA,2BAAqD;AAErD,YAAM,qCAAqC,oCAAoC,IAAI,yBAAyB;AAE5G,UAAI,uCAAuC,QAAW;AAClD,eAAO,QAAQ,QAAQ,kCAAkC;;AAG7D,aAAO,2BAA2B,OAAO,yBAAyB;IACtE;;AAER;;;ACnCO,IAAM,6BAA2D,CACpEC,mBACAC,gCACAC,iCACAC,kCACAC,0BACAC,iBACAC,8BACAC,wBACA;AACA,SAAO,CAACC,UAAS,kBAAiB;AAC9B,UAAM,iBAAiB,cAAc;AAGrC,UAAM,wBAAwB,MAAK;AAC/B,YAAM,SAAS,IAAI,aAAa,CAAC;AACjC,YAAM,oBAAoBP,+BAA8B,eAAe;QACnE,cAAc;QACd,kBAAkB;QAClB,uBAAuB;QACvB,gBAAgB;OACnB;AACD,YAAM,YAAYK,6BAA4B,aAAa;AAE3D,UAAI,+BAA+B;AACnC,UAAI,kBAAoE,CAAC,GAAG,GAAG,IAAI,GAAG,GAAG,CAAC;AAC1F,UAAI,eAAyC,CAAC,GAAG,GAAG,CAAC;AAErD,YAAM,4BAA4B,MAAK;AACnC,YAAI,8BAA8B;AAC9B;;AAGJ,uCAA+B;AAE/B,cAAM,sBAAsBH,iCAAgC,eAAe,KAAK,GAAG,CAAC;AAGpF,4BAAoB,iBAAiB,CAAC,EAAE,YAAW,MAAM;AACrD,gBAAM,cAAgE;YAClEE,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;;AAGzC,cAAI,YAAY,KAAK,CAAC,OAAO,UAAU,UAAU,gBAAgB,KAAK,CAAC,GAAG;AACtE,2BAAe,eAAe,GAAG,WAAW;AAE5C,8BAAkB;;AAGtB,gBAAM,UAAoC;YACtCA,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;YACrCA,gBAAe,aAAa,QAAQ,CAAC;;AAGzC,cAAI,QAAQ,KAAK,CAAC,OAAO,UAAU,UAAU,aAAa,KAAK,CAAC,GAAG;AAC/D,2BAAe,YAAY,GAAG,OAAO;AAErC,2BAAe;;QAEvB;AAEA,0BAAkB,QAAQ,mBAAmB;MACjD;AACA,YAAM,uBAAuB,CAAC,UAAkB,CAAC,UAAiB;AAC9D,YAAI,UAAU,gBAAgB,KAAK,GAAG;AAClC,0BAAgB,KAAK,IAAI;AAEzB,yBAAe,eAAe,GAAG,eAAe;;MAExD;AACA,YAAM,oBAAoB,CAAC,UAAkB,CAAC,UAAiB;AAC3D,YAAI,UAAU,aAAa,KAAK,GAAG;AAC/B,uBAAa,KAAK,IAAI;AAEtB,yBAAe,YAAY,GAAG,YAAY;;MAElD;AACA,YAAM,uBAAuB,CAAC,OAAe,cAAsB,aAAqC;AACpG,cAAM,qBAAqBH,gCAA+B,eAAe;UACrE,cAAc;UACd,kBAAkB;UAClB,uBAAuB;UACvB,QAAQ;SACX;AAED,2BAAmB,QAAQ,mBAAmB,GAAG,KAAK;AAGtD,2BAAmB,MAAK;AAExB,eAAO,eAAe,mBAAmB,QAAQ,gBAAgB;UAC7D,MAAG;AACC,mBAAO;UACX;SACH;AAMD,cAAM,aAAaF,kBACV,EAAE,SAAAQ,SAAO,GACd,WACA,mBAAmB,QACnB,4BACA,0BAA0B;AAG9B,QAAAD,oBACI,YACA,SACA,CAAC,QAAQ,MAAM,IAAI,KAAK,UAAU,GAClC,CAAC,QAAQ,CAAC,UAAS;AACf,cAAI;AACA,gBAAI,KAAK,YAAY,KAAK;mBACrB,KAAK;AACV,gBAAI,IAAI,SAAS,GAAG;AAChB,oBAAM;;;AAId,oCAAyB;AAEzB,cAAI,WAAW;AAEX,qBAAS,KAAK;;QAEtB,CAAC;AAGL,mBAAW,uBAAuB,CAAC,wBAAuB;AACtD,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMH,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAAwD;AAC/D,kBAAM,QAAQ,oBAAoB,MAAM,YAAY,IAAI;AAExD,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,mBAAmB;AACjC,mBAAW,yBAAyB,CAAC,0BAAyB;AAC1D,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMA,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAA0D;AACjE,kBAAM,QAAQ,sBAAsB,MAAM,YAAY,IAAI;AAE1D,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,qBAAqB;AACnC,mBAAW,gCAAgC,CAAC,iCAAgC;AACxE,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMA,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAAiE;AACxE,kBAAM,QAAQ,6BAA6B,MAAM,YAAY,IAAI;AAEjE,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,4BAA4B;AAC1C,mBAAW,2BAA2B,CAAC,4BAA2B;AAC9D,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMA,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAA4D;AACnE,kBAAM,QAAQ,wBAAwB,MAAM,YAAY,IAAI;AAE5D,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,uBAAuB;AACrC,mBAAW,mBAAmB,CAAC,oBAAmB;AAC9C,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMA,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAAoD;AAC3D,kBAAM,QAAQ,gBAAgB,MAAM,YAAY,IAAI;AAEpD,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,eAAe;AAC7B,mBAAW,kBAAkB,CAAC,mBAAkB;AAC5C,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMA,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAAmD;AAC1D,kBAAM,QAAQ,eAAe,MAAM,YAAY,IAAI;AAEnD,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,cAAc;AAC5B,mBAAW,uBAAuB,CAAC,wBAAuB;AACtD,cAAI,WAAW;AACX,mBAAO,MAAK;AACR,oBAAMA,yBAAuB;YACjC;;AAGJ,iBAAO,IAAI,SAAwD;AAC/D,kBAAM,QAAQ,oBAAoB,MAAM,YAAY,IAAI;AAExD,sCAAyB;AAEzB,mBAAO;UACX;QACJ,GAAG,WAAW,mBAAmB;AAEjC,eAAO;MACX;AAEA,aAAO;QACH,UAAU,qBAAqB,GAAG,GAAG,qBAAqB,CAAC,CAAC;QAC5D,UAAU,qBAAqB,GAAG,GAAG,qBAAqB,CAAC,CAAC;QAC5D,UAAU,qBAAqB,GAAG,IAAI,qBAAqB,CAAC,CAAC;QAC7D,WAAW,qBAAqB,GAAG,GAAG,kBAAkB,CAAC,CAAC;QAC1D,WAAW,qBAAqB,GAAG,GAAG,kBAAkB,CAAC,CAAC;QAC1D,WAAW,qBAAqB,GAAG,GAAG,kBAAkB,CAAC,CAAC;QAC1D,KAAK,qBAAqB,GAAG,GAAG,qBAAqB,CAAC,CAAC;QACvD,KAAK,qBAAqB,GAAG,GAAG,qBAAqB,CAAC,CAAC;QACvD,KAAK,qBAAqB,GAAG,GAAG,qBAAqB,CAAC,CAAC;;IAE/D;AAEA,UAAM,EAAE,UAAU,UAAU,UAAU,WAAW,WAAW,WAAW,KAAK,KAAK,IAAG,IAChF,eAAe,aAAa,SAAY,sBAAqB,IAAK;AAEtE,WAAO;MACH,IAAI,WAAQ;AACR,eAAO;MACX;MACA,IAAI,WAAQ;AACR,eAAO;MACX;MACA,IAAI,WAAQ;AACR,eAAO;MACX;MACA,IAAI,YAAS;AACT,eAAO;MACX;MACA,IAAI,YAAS;AACT,eAAO;MACX;MACA,IAAI,YAAS;AACT,eAAO;MACX;MACA,IAAI,MAAG;AACH,eAAO;MACX;MACA,IAAI,MAAG;AACH,eAAO;MACX;MACA,IAAI,MAAG;AACH,eAAO;MACX;;EAER;AACJ;;;ACpSO,IAAM,cAAc,CACvB,0BACwC;AACxC,SAAO,aAAa;AACxB;;;ACJO,IAAM,8BAA8B,CACvC,qBACmD;AACnD,SAAO,YAAY,iBAAiB,CAAC,CAAC;AAC1C;;;ACLO,IAAM,qBAAkD,CAAC,KAAK,SAAS,WAAW,qBAAoB;AACzG,aAAW,QAAQ,KAAK;AACpB,QAAI,UAAU,IAAI,GAAG;AACjB,UAAI,kBAAkB;AAClB,eAAO;;AAGX,YAAM,MAAM,gDAAgD;;;AAIpE,MAAI,IAAI,OAAO;AAEf,SAAO;AACX;;;ACZO,IAAM,uCAAuC,CAChD,cACA,QACA,CAAC,QAAQ,aAAa,GACtB,qBACA;AACA,qBACI,cACA,CAAC,QAAQ,QAAQ,aAAa,GAC9B,CAAC,0BAA0B,sBAAsB,CAAC,MAAM,UAAU,sBAAsB,CAAC,MAAM,QAC/F,gBAAgB;AAExB;;;ACZO,IAAM,wCAAwC,CACjD,eACA,CAAC,QAAQ,QAAQ,aAAa,GAC9B,qBACA;AACA,QAAM,0BAA0B,cAAc,IAAI,MAAM;AAExD,MAAI,4BAA4B,QAAW;AACvC,kBAAc,IAAI,QAAQ,oBAAI,IAAI,CAAC,CAAC,QAAQ,aAAa,CAAC,CAAC,CAAC;SACzD;AACH,uBACI,yBACA,CAAC,QAAQ,aAAa,GACtB,CAAC,2BAA2B,uBAAuB,CAAC,MAAM,QAC1D,gBAAgB;;AAG5B;;;AClBO,IAAM,yBAAyB,CAClC,0CACgE;AAChE,SAAO,YAAY;AACvB;;;ACHO,IAAM,0CAA4F,CACrG,uBACA,4BACA,QACA,UACoC;AACpC,MAAI,uBAAuB,0BAA0B,GAAG;AACpD,UAAM,iCAAiC,2BAA2B,OAAO,KAAK;AAE9E,0BAAsB,QAAQ,gCAAgC,QAAQ,CAAC;AAEvE,WAAO,CAAC,gCAAgC,QAAQ,CAAC;;AAGrD,wBAAsB,QAAQ,4BAA4B,QAAQ,KAAK;AAEvE,SAAO,CAAC,4BAA4B,QAAQ,KAAK;AACrD;;;AClBO,IAAM,8BAA8B,CACvC,wBACA,QACA,WACkC;AAClC,aAAW,yBAAyB,wBAAwB;AACxD,QAAI,sBAAsB,CAAC,MAAM,UAAU,sBAAsB,CAAC,MAAM,QAAQ;AAC5E,6BAAuB,OAAO,qBAAqB;AAEnD,aAAO;;;AAIf,SAAO;AACX;;;ACbO,IAAM,0CAA0C,CACnD,cACA,QACA,WACA;AACA,SAAO,mBACH,cACA,CAAC,0BAA0B,sBAAsB,CAAC,MAAM,UAAU,sBAAsB,CAAC,MAAM,MAAM;AAE7G;;;ACTO,IAAM,iCAAiC,CAC1C,WACA,kBACA;AACA,QAAM,iBAAiB,6BAA6B,SAAS;AAE7D,MAAI,CAAC,eAAe,OAAO,aAAa,GAAG;AACvC,UAAM,IAAI,MAAM,sCAAsC;;AAE9D;;;ACRO,IAAM,2CAA2C,CACpD,eACA,QACA,WACA;AACA,QAAM,0BAA0B,eAAe,eAAe,MAAM;AACpE,QAAM,qBAAqB,mBACvB,yBACA,CAAC,2BAA2B,uBAAuB,CAAC,MAAM,MAAM;AAGpE,MAAI,wBAAwB,SAAS,GAAG;AACpC,kBAAc,OAAO,MAAM;;AAG/B,SAAO;AACX;;;AClBO,IAAM,+CAAsG,CAC/G,uBACA,4BACA,QACA,UACA;AACA,MAAI,uBAAuB,0BAA0B,GAAG;AACpD,0BAAsB,WAAW,2BAA2B,OAAO,KAAK,GAAG,QAAQ,CAAC;SACjF;AACH,0BAAsB,WAAW,4BAA4B,QAAQ,KAAK;;AAElF;;;ACTO,IAAM,qBAAkD,CAC3D,cACG;AACH,SAAU,eAAe,kBAAkB,SAAS;AACxD;;;ACJO,IAAM,sBAAsB,CAAC,eAA8C;AAC9E,SAAO,eAAe,mBAAmB,UAAU;AACvD;;;ACJO,IAAM,iBAA0C,CAAC,cAAa;AACjE,SAAO,eAAe,IAAI,SAAS;AACvC;;;ACFO,IAAM,qBAAkD,CAAC,cAAa;AACzE,SAAO,CAAC,wBAAwB,IAAI,SAAS;AACjD;;;ACHO,IAAM,uCAAuC,CAChD,oBACAK,uCACkB;AAClB,SAAO,IAAI,QAAQ,CAAC,YAAW;AAK3B,QAAIA,uCAAsC,MAAM;AAC5C,cAAQ,IAAI;WACT;AACH,YAAM,WAAW,mBAAmB,sBAAsB,KAAK,GAAG,CAAC;AACnE,YAAM,QAAQ,mBAAmB,WAAU;AAE3C,YAAM,OAAO,mBAAmB,aAAa,GAAG,GAAG,KAAK;AACxD,YAAM,cAAc,KAAK,eAAe,CAAC;AAEzC,kBAAY,CAAC,IAAI;AACjB,kBAAY,CAAC,IAAI;AAEjB,YAAM,SAAS,mBAAmB,mBAAkB;AAEpD,aAAO,SAAS;AAChB,aAAO,OAAO;AAEd,aAAO,QAAQ,QAAQ,EAAE,QAAQ,mBAAmB,WAAW;AAC/D,aAAO,QAAQ,KAAK;AACpB,aAAO,WAAW,KAAK;AAGvB,eAAS,iBAAiB,CAAC,UAAS;AAChC,cAAM,UAAU,MAAM,YAAY,eAAe,CAAC;AAElD,YAAI,MAAM,UAAU,KAAK,KAAK,SAAS,CAAC,WAAmB,WAAW,CAAC,GAAG;AACtE,kBAAQ,IAAI;eACT;AACH,kBAAQ,KAAK;;AAGjB,eAAO,KAAI;AAEX,iBAAS,iBAAiB;AAE1B,eAAO,WAAW,QAAQ;AAC1B,iBAAS,WAAW,mBAAmB,WAAW;MACtD;AAEA,aAAO,MAAK;;EAEpB,CAAC;AACL;;;AClDO,IAAM,yBAAyB,CAClC,QACA,YACM;AACN,QAAM,SAAS,oBAAI,IAAG;AAEtB,aAAW,SAAS,QAAQ;AACxB,eAAW,aAAa,OAAO;AAC3B,YAAM,QAAQ,OAAO,IAAI,SAAS;AAElC,aAAO,IAAI,WAAW,UAAU,SAAY,IAAI,QAAQ,CAAC;;;AAIjE,SAAO,QAAQ,CAAC,OAAO,cAAc,QAAQ,WAAW,KAAK,CAAC;AAClE;;;AChBO,IAAM,oBAAoB,CAC7B,gCACiD;AACjD,SAAO,aAAa;AACxB;;;ACHO,IAAM,gCAAgC,CAAC,oBAA2C;AACrF,QAAM,cAAc,oBAAI,IAAG;AAE3B,kBAAgB,WAAwC,CAACC,aAAW;AAEhE,WAAO,CAAC,aAAmD,SAAS,GAAG,QAAgB,MAA8B;AACjH,YAAM,cAAc,kBAAkB,WAAW,IAAIA,SAAQ,aAAa,QAAQ,KAAK,IAAIA,SAAQ,aAAa,MAAM;AAGtH,YAAM,2BAA2B,YAAY,IAAI,WAAW;AAE5D,UAAI,6BAA6B,QAAW;AACxC,oBAAY,IAAI,aAAa,CAAC,EAAE,OAAO,OAAM,CAAE,CAAC;aAC7C;AACH,YAAI,yBAAyB,MAAM,CAAC,eAAe,WAAW,UAAU,SAAS,WAAW,WAAW,MAAM,GAAG;AAC5G,mCAAyB,KAAK,EAAE,OAAO,OAAM,CAAE;;;AAIvD,aAAO;IACX;EACJ,GAAG,gBAAgB,QAAQ,KAAK,eAAe,CAAC;AAEhD,kBAAgB,cAAc,CAACC,gBAAc;AACzC,WAAO,CAAC,qBAAqE,QAAiB,UAAwB;AAClH,MAAAA,YAAW,MAAM,eAAe;AAEhC,UAAI,wBAAwB,QAAW;AACnC,oBAAY,MAAK;iBACV,OAAO,wBAAwB,UAAU;AAChD,mBAAW,CAAC,aAAa,wBAAwB,KAAK,aAAa;AAC/D,gBAAM,sBAAsB,yBAAyB,OAAO,CAAC,eAAe,WAAW,WAAW,mBAAmB;AAErH,cAAI,oBAAoB,WAAW,GAAG;AAClC,wBAAY,OAAO,WAAW;iBAC3B;AACH,wBAAY,IAAI,aAAa,mBAAmB;;;iBAGjD,YAAY,IAAI,mBAAmB,GAAG;AAC7C,YAAI,WAAW,QAAW;AACtB,sBAAY,OAAO,mBAAmB;eACnC;AACH,gBAAM,2BAA2B,YAAY,IAAI,mBAAmB;AAEpE,cAAI,6BAA6B,QAAW;AACxC,kBAAM,sBAAsB,yBAAyB,OACjD,CAAC,eAAe,WAAW,WAAW,WAAW,WAAW,UAAU,SAAS,UAAU,OAAU;AAGvG,gBAAI,oBAAoB,WAAW,GAAG;AAClC,0BAAY,OAAO,mBAAmB;mBACnC;AACH,0BAAY,IAAI,qBAAqB,mBAAmB;;;;;AAMxE,iBAAW,CAAC,aAAa,wBAAwB,KAAK,aAAa;AAC/D,iCAAyB,QAAQ,CAAC,eAAc;AAC5C,cAAI,kBAAkB,WAAW,GAAG;AAChC,4BAAgB,QAAQ,aAAa,WAAW,QAAQ,WAAW,KAAK;iBACrE;AACH,4BAAgB,QAAQ,aAAa,WAAW,MAAM;;QAE9D,CAAC;;IAET;EACJ,GAAG,gBAAgB,UAAU;AACjC;;;AC7BA,IAAM,0CAA0C,CAC5C,QACA,aACA,QACA,cACS;AACT,QAAM,EAAE,cAAc,cAAa,IAAK,yBAA4B,WAAW;AAC/E,QAAM,EAAE,QAAO,IAAK,wBAAwB,MAAM;AAClD,QAAM,iBAAiB,6BAA6B,MAAM;AAE1D,QAAM,gBAA6C,CAAC,aAAY;AAC5D,UAAM,kBAAkB,mBAAmB,MAAM;AACjD,UAAM,mBAAmB,oBAAoB,WAAW;AAExD,QAAI,UAAU;AACV,YAAM,oBAAoB,yCAAyC,eAAe,QAAQ,MAAM;AAEhG,2CAAqC,cAAc,QAAQ,mBAAmB,KAAK;AAEnF,UAAI,CAAC,aAAa,CAAC,eAAe,MAAM,GAAG;AACvC,wBAAgB,QAAQ,kBAAkB,MAAM;;WAEjD;AACH,YAAM,oBAAoB,wCAAwC,cAAc,QAAQ,MAAM;AAE9F,4CAAsC,eAAe,mBAAmB,KAAK;AAE7E,UAAI,CAAC,aAAa,CAAC,eAAe,MAAM,GAAG;AACvC,wBAAgB,WAAW,kBAAkB,MAAM;;;EAG/D;AAEA,MACI,mBACI,SACA,CAAC,aAAa,MAAM,GACpB,CAAC,qBAAqB,iBAAiB,CAAC,MAAM,eAAe,iBAAiB,CAAC,MAAM,QACrF,IAAI,GAEV;AACE,mBAAe,IAAI,aAAa;AAEhC,QAAI,kBAAkB,MAAM,GAAG;AAC3B,2CAAqC,cAAc,QAAQ,CAAC,QAAQ,aAAa,GAAG,IAAI;WACrF;AACH,4CAAsC,eAAe,CAAC,QAAQ,QAAQ,aAAa,GAAG,IAAI;;AAG9F,WAAO;;AAGX,SAAO;AACX;AAEA,IAAM,mCAAmC,CACrC,QACA,aACA,QACA,UAC+C;AAC/C,QAAM,EAAE,cAAc,cAAa,IAAK,wBAAwB,WAAW;AAE3E,QAAM,wBAAwB,4BAA4B,aAAa,KAAK,GAAG,QAAQ,MAAM;AAE7F,MAAI,0BAA0B,MAAM;AAChC,UAAM,yBAAyB,wCAAwC,eAAe,QAAQ,QAAQ,KAAK;AAE3G,WAAO,CAAC,uBAAuB,CAAC,GAAG,KAAK;;AAG5C,SAAO,CAAC,sBAAsB,CAAC,GAAG,IAAI;AAC1C;AAEA,IAAM,oCAAoC,CACtC,QACA,aACA,WAC+C;AAC/C,QAAM,EAAE,cAAc,cAAa,IAAK,yBAA4B,WAAW;AAE/E,QAAM,wBAAwB,4BAA4B,cAAc,QAAQ,MAAM;AAEtF,MAAI,0BAA0B,MAAM;AAChC,UAAM,yBAAyB,yCAAyC,eAAe,QAAQ,MAAM;AAErG,WAAO,CAAC,uBAAuB,CAAC,GAAG,KAAK;;AAG5C,SAAO,CAAC,sBAAsB,CAAC,GAAG,IAAI;AAC1C;AAEA,IAAM,0BAA0B,CAC5B,QACA,WACA,aACA,QACA,UACA;AACA,QAAM,CAAC,UAAU,QAAQ,IAAI,iCAAiC,QAAQ,aAAa,QAAQ,KAAK;AAEhG,MAAI,aAAa,MAAM;AACnB,mCAA+B,QAAQ,QAAQ;AAE/C,QAAI,YAAY,CAAC,aAAa,CAAC,eAAe,MAAM,GAAG;AACnD,mDAA6C,mBAAmB,MAAM,GAAG,mBAAmB,WAAW,GAAG,QAAQ,KAAK;;;AAI/H,MAAI,kBAAkB,WAAW,GAAG;AAChC,UAAM,EAAE,aAAY,IAAK,wBAAwB,WAAW;AAE5D,2CAAuC,aAAa,YAAY;;AAExE;AAEA,IAAM,2BAA2B,CAC7B,QACA,WACA,aACA,WACA;AACA,QAAM,CAAC,UAAU,QAAQ,IAAI,kCAAkC,QAAQ,aAAa,MAAM;AAE1F,MAAI,aAAa,MAAM;AACnB,mCAA+B,QAAQ,QAAQ;AAE/C,QAAI,YAAY,CAAC,aAAa,CAAC,eAAe,MAAM,GAAG;AACnD,yBAAmB,MAAM,EAAE,WAAW,oBAAoB,WAAW,GAAG,MAAM;;;AAG1F;AAEA,IAAM,sBAAsB,CAAqB,QAAuB,cAAuD;AAC3H,QAAM,+BAA+B,wBAAwB,MAAM;AACnE,QAAM,eAAe,CAAA;AAErB,aAAW,oBAAoB,6BAA6B,SAAS;AACjE,QAAI,4BAA4B,gBAAgB,GAAG;AAC/C,8BAAwB,QAAQ,WAAW,GAAG,gBAAgB;WAC3D;AACH,+BAAyB,QAAQ,WAAW,GAAG,gBAAgB;;AAGnE,iBAAa,KAAK,iBAAiB,CAAC,CAAC;;AAGzC,+BAA6B,QAAQ,MAAK;AAE1C,SAAO;AACX;AAEA,IAAM,2BAA2B,CAC7B,QACA,WACA,WACiC;AACjC,QAAM,+BAA+B,wBAAwB,MAAM;AACnE,QAAM,eAAe,CAAA;AAErB,aAAW,oBAAoB,6BAA6B,SAAS;AACjE,QAAI,iBAAiB,CAAC,MAAM,QAAQ;AAChC,UAAI,4BAA4B,gBAAgB,GAAG;AAC/C,gCAAwB,QAAQ,WAAW,GAAG,gBAAgB;aAC3D;AACH,iCAAyB,QAAQ,WAAW,GAAG,gBAAgB;;AAGnE,mBAAa,KAAK,iBAAiB,CAAC,CAAC;AACrC,mCAA6B,QAAQ,OAAO,gBAAgB;;;AAIpE,SAAO;AACX;AAEA,IAAM,gCAAgC,CAClC,QACA,WACA,aACA,QACA,UACiC;AACjC,QAAM,+BAA+B,wBAAwB,MAAM;AAEnE,SAAO,MAAM,KAAK,6BAA6B,OAAO,EACjD,OACG,CAAC,qBACG,iBAAiB,CAAC,MAAM,gBACvB,WAAW,UAAa,iBAAiB,CAAC,MAAM,YAChD,UAAU,UAAa,iBAAiB,CAAC,MAAM,MAAM,EAE7D,IAAI,CAAC,qBAAoB;AACtB,QAAI,4BAA4B,gBAAgB,GAAG;AAC/C,8BAAwB,QAAQ,WAAW,GAAG,gBAAgB;WAC3D;AACH,+BAAyB,QAAQ,WAAW,GAAG,gBAAgB;;AAGnE,iCAA6B,QAAQ,OAAO,gBAAgB;AAE5D,WAAO,iBAAiB,CAAC;EAC7B,CAAC;AACT;AAEO,IAAM,6BAA2D,CACpE,yBACA,0BACAC,kBACA,6BACAC,uBACAC,2BACAC,0BACA,uBACA,cACAC,yBACAC,mBACAC,uBACAC,oBACAC,qBACAC,8BACAC,uCACA;AACA,SAAO,MAAM,kBACDN,wBAAgC;IAOxC,YACIO,UACA,UACA,iBACA,mBAA6H;AAE7H,YAAM,eAAe;AAErB,WAAK,WAAWA;AAChB,WAAK,mBAAmB;AAExB,YAAM,gBAAgBN,kBAAiBM,QAAO;AAG9C,UACIL,sBAAqB,aAAa,KAClC,SACIN,iBAAgB,sCAAsC,MAAK;AACvD,eAAO,qCAAqC,eAAeU,kCAAiC;MAChG,CAAC,GACP;AACE,sCAA8B,eAAe;;AAGjD,uBAAiB,IAAI,MAAM,eAAe;AAC1C,sBAAgB,IAAI,MAAM,oBAAI,IAAG,CAAE;AAEnC,UAAIC,SAAQ,UAAU,YAAY,UAAU;AACxC,iCAAyB,IAAI;;AAGjC,8BAAwB,MAAM,mBAAmB,eAAe;IACpE;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK,iBAAiB;IACjC;IAEA,IAAI,aAAa,OAAK;AAClB,WAAK,iBAAiB,eAAe;IACzC;IAEA,IAAI,mBAAgB;AAChB,aAAO,KAAK,iBAAiB;IACjC;IAEA,IAAI,iBAAiB,OAAK;AACtB,WAAK,iBAAiB,mBAAmB;IAC7C;IAEA,IAAI,wBAAqB;AACrB,aAAO,KAAK,iBAAiB;IACjC;IAEA,IAAI,sBAAsB,OAAK;AAC3B,WAAK,iBAAiB,wBAAwB;IAClD;IAEA,IAAI,UAAO;AACP,aAAO,KAAK;IAChB;IAEA,IAAI,iBAAc;AACd,aAAO,KAAK,iBAAiB;IACjC;IAEA,IAAI,kBAAe;AACf,aAAO,KAAK,iBAAiB;IACjC;;IAKO,QAAqD,aAA8B,SAAS,GAAG,QAAQ,GAAC;AAE3G,UAAI,SAAS,KAAK,UAAU,KAAK,iBAAiB,iBAAiB;AAC/D,cAAMV,sBAAoB;;AAG9B,YAAM,gBAAgBI,kBAAiB,KAAK,QAAQ;AACpD,YAAM,YAAYI,6BAA4B,aAAa;AAE3D,UAAIF,mBAAkB,WAAW,KAAKC,oBAAmB,WAAW,GAAG;AACnE,cAAMN,0BAAwB;;AAGlC,UAAI,YAAY,WAAW,GAAG;AAC1B,cAAM,6BAA6B,mBAAmB,WAAW;AAEjE,YAAI;AACA,gBAAM,aAAa,wCACf,KAAK,kBACL,4BACA,QACA,KAAK;AAGT,gBAAM,YAAY,mBAAmB,IAAI;AAEzC,cAAI,aAAa,WAAW;AACxB,iBAAK,iBAAiB,WAAW,GAAG,UAAU;;AAGlD,cAAI,KAAK,QAAQ,UAAU,YAAY,CAAC,aAAa,mBAAmB,WAAW,GAAG;AAClF,qCAAyB,WAAW;;iBAEnC,KAAK;AAEV,cAAI,IAAI,SAAS,IAAI;AACjB,kBAAMA,0BAAwB;;AAGlC,gBAAM;;AAGV,cAAM,6BAA6B,yBAC/B,MACsB,aACtB,QACA,OACA,SAAS;AAIb,YAAI,4BAA4B;AAC5B,gBAAM,SAAS,aAAa,CAAC,IAAI,GAA4B,WAAY;AAEzE,iCAAuB,QAAQ,4BAA4B,SAAS,CAAC;;AAGzE,eAAO;;AAGX,YAAM,mBAAmB,oBAAoB,WAAW;AAOxD,UAA2C,iBAAkB,SAAS,kBAAkB,iBAAiB,aAAa,MAAM;AACxH,cAAMC,yBAAuB;;AAGjC,UAAI;AACA,aAAK,iBAAiB,QAAQ,kBAAkB,MAAM;AAEtD,YAAI,aAAa,mBAAmB,IAAI,GAAG;AACvC,eAAK,iBAAiB,WAAW,kBAAkB,MAAM;;eAExD,KAAK;AAEV,YAAI,IAAI,SAAS,IAAI;AACjB,gBAAMD,0BAAwB;;AAGlC,cAAM;;AAGV,YAAM,8BAA8B,wCAAwC,MAAM,aAAa,QAAQ,SAAS;AAGhH,UAAI,6BAA6B;AAC7B,cAAM,SAAS,aAAa,CAAC,IAAI,GAAG,WAAW;AAE/C,+BAAuB,QAAQ,4BAA4B,SAAS,CAAC;;IAE7E;IAKO,WACH,qBACA,QACA,OAAc;AAEd,UAAI;AAEJ,YAAM,gBAAgBG,kBAAiB,KAAK,QAAQ;AACpD,YAAM,YAAYI,6BAA4B,aAAa;AAE3D,UAAI,wBAAwB,QAAW;AACnC,uBAAe,oBAAoB,MAAM,SAAS;iBAC3C,OAAO,wBAAwB,UAAU;AAChD,YAAI,sBAAsB,KAAK,uBAAuB,KAAK,iBAAiB;AACxE,gBAAMR,sBAAoB;;AAG9B,uBAAe,yBAAyB,MAAM,WAAW,mBAAmB;aACzE;AACH,YAAI,WAAW,WAAc,SAAS,KAAK,UAAU,KAAK,kBAAkB;AACxE,gBAAMA,sBAAoB;;AAG9B,YAAI,YAAY,mBAAmB,KAAK,UAAU,WAAc,QAAQ,KAAK,SAAS,oBAAoB,iBAAiB;AACvH,gBAAMA,sBAAoB;;AAG9B,uBAAe,8BAA8B,MAAM,WAAW,qBAAqB,QAAQ,KAAK;AAEhG,YAAI,aAAa,WAAW,GAAG;AAC3B,gBAAMC,0BAAwB;;;AAKtC,iBAAW,eAAe,cAAc;AACpC,cAAM,SAAS,aAAa,CAAC,IAAI,GAAG,WAAW;AAE/C,+BAAuB,QAAQ,qBAAqB;;IAE5D;;AAER;;;ACreO,IAAM,0BAAqD,CAC9D,0BACAU,2BACA,iBACAC,2BACAC,qCACAC,6CACAC,8CACAC,yCACAC,iCACAC,gCACAC,qCACAC,gCACAC,iCACA;AACA,SAAO,CACH,WACA,mCACA,kBACA,WAA0B,MAC1B,WAA0B,SACb;AAEb,UAAM,eAAe,iBAAiB;AACtC,UAAM,sBAAsB,IAAI,oBAAoB,YAAY;AAChE,UAAM,qBAAqB,oCAAoCT,0BAAyB,mBAAmB,IAAI;AAC/G,UAAM,aAAa;MACf,IAAI,eAAY;AACZ,eAAO;MACX;MACA,IAAI,WAAQ;AACR,eAAO,aAAa,OAAO,iBAAiB,WAAW;MAC3D;MACA,IAAI,WAAQ;AACR,eAAO,aAAa,OAAO,iBAAiB,WAAW;MAC3D;MACA,IAAI,QAAK;AACL,eAAO,iBAAiB;MAC5B;MACA,IAAI,MAAM,OAAK;AACX,yBAAiB,QAAQ;AAGzB,mBAAW,eAAe,OAAO,UAAU,QAAQ,WAAW;MAClE;MACA,oBAAoB,YAAkB;AAElC,YAAI,OAAO,iBAAiB,wBAAwB,YAAY;AAC5D,cAAI,uBAAuB,MAAM;AAC7B,gCAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,8BAAoB,IAAIC,oCAAmC,UAAU,CAAC;AACtE,2BAAiB,oBAAoB,UAAU;eAC5C;AACH,gBAAM,oBAAoB,MAAM,KAAK,mBAAmB,EAAE,IAAG;AAE7D,cAAI,uBAAuB,MAAM;AAC7B,gCAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,8BAAoB,IAAIA,oCAAmC,UAAU,CAAC;AAEtE,gBAAM,mBAAmB,MAAM,KAAK,mBAAmB,EAAE,IAAG;AAE5D,2BAAiB,sBAAsB,UAAU;AAEjD,cAAI,sBAAsB,oBAAoB,qBAAqB,QAAW;AAC1E,gBAAI,iBAAiB,SAAS,0BAA0B;AACpD,+BAAiB,6BAA6B,iBAAiB,OAAO,iBAAiB,OAAO;uBACvF,iBAAiB,SAAS,qBAAqB;AACtD,+BAAiB,wBAAwB,iBAAiB,OAAO,iBAAiB,OAAO;uBAClF,iBAAiB,SAAS,YAAY;AAC7C,+BAAiB,eAAe,iBAAiB,OAAO,iBAAiB,SAAS;uBAC3E,iBAAiB,SAAS,iBAAiB;AAClD,+BAAiB,oBACb,iBAAiB,QACjB,iBAAiB,WACjB,iBAAiB,QAAQ;;;;AAMzC,eAAO;MACX;MACA,sBAAsB,YAAkB;AACpC,YAAI,uBAAuB,MAAM;AAC7B,8BAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,4BAAoB,IAAIC,4CAA2C,UAAU,CAAC;AAC9E,yBAAiB,sBAAsB,UAAU;AAEjD,eAAO;MACX;MACA,6BAA6B,OAAe,SAAe;AAEvD,YAAI,UAAU,GAAG;AACb,gBAAM,IAAI,WAAU;;AAIxB,YAAI,CAAC,OAAO,SAAS,OAAO,KAAK,UAAU,GAAG;AAC1C,gBAAM,IAAI,WAAU;;AAGxB,cAAM,cAAc,UAAU,QAAQ;AAEtC,YAAI,uBAAuB,MAAM;AAC7B,8BAAoB,MAAM,WAAW;;AAIzC,YAAI,MAAM,KAAK,mBAAmB,EAAE,WAAW,GAAG;AAC9C,8BAAoB,IAAII,+BAA8B,cAAc,WAAW,CAAC;AAChF,2BAAiB,eAAe,cAAc,WAAW;;AAG7D,4BAAoB,IAAIH,6CAA4C,OAAO,OAAO,CAAC;AACnF,yBAAiB,6BAA6B,OAAO,OAAO;AAE5D,eAAO;MACX;MACA,wBAAwB,OAAe,SAAe;AAClD,cAAM,cAAc,UAAU,QAAQ;AAEtC,YAAI,uBAAuB,MAAM;AAC7B,8BAAoB,MAAM,WAAW;;AAIzC,YAAI,MAAM,KAAK,mBAAmB,EAAE,WAAW,GAAG;AAC9C,8BAAoB,IAAIG,+BAA8B,cAAc,WAAW,CAAC;AAChF,2BAAiB,eAAe,cAAc,WAAW;;AAG7D,4BAAoB,IAAIF,wCAAuC,OAAO,OAAO,CAAC;AAC9E,yBAAiB,wBAAwB,OAAO,OAAO;AAEvD,eAAO;MACX;MACA,gBAAgB,QAAgB,WAAmB,cAAoB;AACnE,YAAI,uBAAuB,MAAM;AAC7B,8BAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,4BAAoB,IAAIC,gCAA+B,QAAQ,WAAW,YAAY,CAAC;AACvF,yBAAiB,gBAAgB,QAAQ,WAAW,YAAY;AAEhE,eAAO;MACX;MACA,eAAe,OAAe,WAAiB;AAC3C,YAAI,uBAAuB,MAAM;AAC7B,8BAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,4BAAoB,IAAIC,+BAA8B,OAAO,SAAS,CAAC;AACvE,yBAAiB,eAAe,OAAO,SAAS;AAEhD,eAAO;MACX;MACA,oBAAoB,QAA0B,WAAmB,UAAgB;AAE7E,cAAM,kBAAkB,kBAAkB,eAAe,SAAS,IAAI,aAAa,MAAM;AAMzF,YAAIE,mCAAkC,QAAQA,+BAA8B,SAAS,sBAAsB;AACvG,gBAAM,UAAU,YAAY;AAC5B,gBAAM,aAAa,UAAU,QAAQ;AACrC,gBAAM,cAAc,KAAK,KAAK,YAAY,UAAU;AACpD,gBAAM,aAAa,KAAK,MAAM,UAAU,UAAU;AAClD,gBAAM,6BAA6B,aAAa;AAChD,gBAAM,qBAAqB,IAAI,aAAa,0BAA0B;AAEtE,mBAAS,IAAI,GAAG,IAAI,4BAA4B,KAAK,GAAG;AACpD,kBAAM,kBAAmB,gBAAgB,SAAS,KAAK,aAAc,cAAc,KAAK,aAAa;AACrG,kBAAM,aAAa,KAAK,MAAM,cAAc;AAC5C,kBAAM,aAAa,KAAK,KAAK,cAAc;AAE3C,+BAAmB,CAAC,IAChB,eAAe,aACT,gBAAgB,UAAU,KACzB,KAAK,iBAAiB,eAAe,gBAAgB,UAAU,KAC/D,KAAK,aAAa,mBAAmB,gBAAgB,UAAU;;AAG9E,cAAI,uBAAuB,MAAM;AAC7B,gCAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,8BAAoB,IAAID,oCAAmC,oBAAoB,WAAW,QAAQ,CAAC;AACnG,2BAAiB,oBAAoB,oBAAoB,WAAW,QAAQ;AAE5E,gBAAM,mBAAmB,aAAa;AAEtC,cAAI,mBAAmB,SAAS;AAC5B,YAAAE,6BAA4B,YAAY,mBAAmB,mBAAmB,SAAS,CAAC,GAAG,gBAAgB;;AAG/G,UAAAA,6BAA4B,YAAY,gBAAgB,gBAAgB,SAAS,CAAC,GAAG,OAAO;eACzF;AACH,cAAI,uBAAuB,MAAM;AAC7B,gCAAoB,MAAM,UAAU,QAAQ,WAAW;;AAG3D,8BAAoB,IAAIF,oCAAmC,iBAAiB,WAAW,QAAQ,CAAC;AAChG,2BAAiB,oBAAoB,iBAAiB,WAAW,QAAQ;;AAG7E,eAAO;MACX;;AAGJ,oBAAgB,IAAI,YAAY,gBAAgB;AAChD,IAAAR,0BAAyB,IAAI,YAAY,SAAS;AAElD,6BACI,YAC2F,kBAAkB;AAGjH,WAAO;EACX;AACJ;;;ACrOO,IAAM,2BAAuD,CAAC,wBAAuB;AACxF,SAAO;IACH,OAAO,YAA6B;AAChC,iBAAW,mBAAmB,qBAAqB;AAC/C,YAAI,gBAAgB,SAAS,0BAA0B;AACnD,gBAAM,EAAE,SAAS,MAAK,IAAK;AAE3B,qBAAW,6BAA6B,OAAO,OAAO;mBAC/C,gBAAgB,SAAS,qBAAqB;AACrD,gBAAM,EAAE,SAAS,MAAK,IAAK;AAE3B,qBAAW,wBAAwB,OAAO,OAAO;mBAC1C,gBAAgB,SAAS,aAAa;AAC7C,gBAAM,EAAE,WAAW,QAAQ,aAAY,IAAK;AAE5C,qBAAW,gBAAgB,QAAQ,WAAW,YAAY;mBACnD,gBAAgB,SAAS,YAAY;AAC5C,gBAAM,EAAE,WAAW,MAAK,IAAK;AAE7B,qBAAW,eAAe,OAAO,SAAS;mBACnC,gBAAgB,SAAS,iBAAiB;AACjD,gBAAM,EAAE,UAAU,WAAW,OAAM,IAAK;AAExC,qBAAW,oBAAoB,QAAQ,WAAW,QAAQ;eACvD;AACH,gBAAM,IAAI,MAAM,oCAAoC;;;IAGhE;;AAER;;;AC9BM,IAAO,cAAP,MAAkB;EAGpB,YAAY,YAAoB;AAC5B,SAAK,OAAO,IAAI,IAAI,UAAU;EAClC;EAEA,IAAI,OAAI;AACJ,WAAO,KAAK,KAAK;EACrB;EAEO,UAAO;AACV,WAAO,KAAK,KAAK,QAAO;EAC5B;EAEO,QAAQ,UAAoE,UAAe,MAAI;AAClG,WAAO,KAAK,KAAK,QAAQ,CAAC,OAAU,QAAW,SAAS,KAAK,SAAS,OAAO,KAAK,IAAI,CAAC;EAC3F;EAEO,IAAI,MAAO;AACd,WAAO,KAAK,KAAK,IAAI,IAAI;EAC7B;EAEO,IAAI,MAAO;AACd,WAAO,KAAK,KAAK,IAAI,IAAI;EAC7B;EAEO,OAAI;AACP,WAAO,KAAK,KAAK,KAAI;EACzB;EAEO,SAAM;AACT,WAAO,KAAK,KAAK,OAAM;EAC3B;;;;ACZJ,IAAMW,mBAAkB;EACpB,cAAc;;EAEd,kBAAkB;EAClB,uBAAuB;EACvB,gBAAgB;EAChB,iBAAiB;EACjB,eAAe,CAAA;EACf,kBAAkB,CAAA;;AAGf,IAAM,oCAAyE,CAClFC,gCACAC,uBACAC,mBACAC,iCACAC,+BACAC,0BACAC,+BACAC,mBACAC,8BACAC,oCACAC,kCACAC,kCACAC,yCACAC,uBACA;AACA,SAAO,MAAM,yBACDZ,sBAAkD;IAS1D,YAAYa,UAAY,MAAc,SAA2C;;AAC7E,YAAM,gBAAgBP,kBAAiBO,QAAO;AAC9C,YAAM,YAAYN,6BAA4B,aAAa;AAC3D,YAAM,gBAAgBE,iCAAgC,EAAE,GAAGX,kBAAiB,GAAG,QAAO,CAAE;AAGxF,MAAAa,wCAAuC,aAAa;AAEpD,YAAM,oCAAoC,wCAAwC,IAAI,aAAa;AACnG,YAAM,uBAAuB,sCAAiC,QAAjC,sCAAiC,SAAA,SAAjC,kCAAmC,IAAI,IAAI;AAExE,YAAM,2CACF,aAAa,cAAc,UAAU,WAC/B,iBACA,KAAAN,8BAAkD,aAAa,OAAC,QAAA,OAAA,SAAA,KAAI;AAC9E,YAAM,yBAAyBF,8BAC3B,0CACA,YAAY,OAAoCU,SAAU,aAC1DL,oCACA,MACA,sBACA,aAAa;AAEjB,YAAM,2BACD,YAAYN,gCAA+B,MAAM,eAAe,oBAAoB,IAAI;AAO7F,YAAMW,UAAS,MAAM,wBAAwB,wBAAwB;AAErE,YAAM,aAAsC,CAAA;AAE5C,6BAAuB,WAAW,QAAQ,CAAC,kBAAkB,OAAM;AAC/D,cAAM,aAAaZ,kBAAiB,MAAM,WAAW,gBAAgB;AAErE,mBAAW,KAAK,CAAC,IAAI,UAAU,CAAC;MACpC,CAAC;AAED,WAAK,0BAA0B;AAC/B,WAAK,oBAAoB;AACzB,WAAK,cAAc,IAAI,YAAY,UAAU;AAM7C,UAAI,WAAW;AACX,QAAAF,+BAA8B,eAAsF,IAAI;;AAG5H,YAAM,EAAE,aAAY,IAAKK,yBAAwB,IAAI;AAErD,MAAAM,iCAAgC,wBAAwB,YAAY;IACxE;IAEA,IAAI,mBAAgB;AAChB,aAAO,KAAK;IAChB;IAEA,IAAI,iBAAiB,OAAK;AACtB,YAAM,kBAAkB,OAAO,UAAU,aAAaE,mBAAkB,MAA0C,KAAK,IAAI;AAE3H,WAAK,wBAAwB,mBAAmB;AAEhD,YAAM,yBAAyB,KAAK,wBAAwB;AAE5D,WAAK,oBACD,2BAA2B,QAAQ,2BAA2B,kBACxD,QACiC;IAC/C;IAEA,IAAI,aAAU;AACV,UAAI,KAAK,gBAAgB,MAAM;AAE3B,eAAgD,KAAK,wBAAwB;;AAGjF,aAAO,KAAK;IAChB;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK,wBAAwB;IACxC;;AAER;;;ACpIM,SAAU,gBACZ,aAEA,QACA,KACA,eACA,cAAoB;AAEpB,MAAI,OAAO,YAAY,oBAAoB,YAAY;AAEnD,QAAI,OAAO,GAAG,EAAE,eAAe,GAAG;AAC9B,aAAO,GAAG,IAAI,IAAI,aAAa,GAAG;;AAGtC,gBAAY,gBAAgB,OAAO,GAAG,GAAG,eAAe,YAAY;SAGjE;AACH,UAAM,cAAc,YAAY,eAAe,aAAa;AAG5D,QAAI,OAAO,GAAG,EAAE,eAAe,GAAG;AAC9B,aAAO,GAAG,IAAI,YAAY,MAAM,cAAc,eAAe,GAAG;WAC7D;AACH,YAAM,cAAc,IAAI,aAAa,YAAY,QAAQ,eAAe,aAAa,mBAAmB,GAAG;AAE3G,aAAO,GAAG,EAAE,IAAI,WAAW;;;AAGvC;;;AC3CO,IAAM,gBAAgB,CACzB,aACA,QACA,KACA,eACA,iBACM;AACN,MAAI,OAAO,YAAY,kBAAkB,YAAY;AAEjD,QAAI,OAAO,GAAG,EAAE,eAAe,GAAG;AAC9B,kBAAY,cAAc,OAAO,GAAG,GAAG,eAAe,YAAY;;SAInE;AAEH,QAAI,OAAO,GAAG,EAAE,eAAe,GAAG;AAC9B,kBAAY,eAAe,aAAa,EAAE,IAAI,OAAO,GAAG,GAAG,YAAY;;;AAGnF;;;ACtBO,IAAM,qBAAqB,CAAC,GAAW,MAA0C;AACpF,QAAM,SAA2B,CAAA;AAEjC,WAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC3B,UAAM,QAAQ,CAAA;AAEd,UAAM,SAAS,OAAO,MAAM,WAAW,IAAI,EAAE,CAAC;AAE9C,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,YAAM,KAAK,IAAI,aAAa,GAAG,CAAC;;AAGpC,WAAO,KAAK,KAAK;;AAGrB,SAAO;AACX;;;ACVO,IAAM,2BAA2B,CACpC,2BACA,UACiC;AACjC,QAAM,qBAAqB,eAAe,wBAAwB,yBAAyB;AAC3F,QAAM,yBAAyB,mBAA+C,KAAK;AAEnF,SAAO,eAAe,oBAAoB,sBAAsB;AACpE;;;ACaA,IAAM,gBAAgB,OAClB,OACA,gBACA,2BACA,SACA,oBACA,sBACAE,sCACoC;AAGpC,QAAM,SAAS,mBAAmB,OAAO,KAAK,KAAK,MAAM,QAAQ,SAAS,GAAG,IAAI,MAAM,eAAe;AACtG,QAAM,wBAAwB,QAAQ,eAAe,QAAQ;AAC7D,QAAM,yBAAyB,mBAAmB,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC;AACvF,QAAM,kBACF,2BAA2B,IACrB,OACA,0BAA0B,aAAa,wBAAwB,QAAQ,0BAA0B,UAAU;AAErH,MAAI,yBAAyB,QAAW;AACpC,UAAM,IAAI,MAAM,oCAAoC;;AAGxD,QAAM,uBAAuB,wBAAwB,KAAK;AAC1D,QAAM,wBAAwB,MAAM,yBAAyB,2BAA2B,KAAK;AAC7F,QAAM,SAAS,mBAAmB,QAAQ,gBAAgB,QAAQ,YAAY;AAC9E,QAAM,UAAU,mBAAmB,QAAQ,iBAAiB,kBAAkB;AAC9E,QAAM,aAA+C,MAAM,KAAK,MAAM,WAAW,KAAI,CAAE,EAAE,OACrF,CAAC,QAAQ,UAAU,EAAE,GAAG,QAAQ,CAAC,IAAI,GAAG,IAAI,aAAa,GAAG,EAAC,IAC7D,CAAA,CAAE;AAGN,WAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,KAAK;AAClC,QAAI,QAAQ,iBAAiB,KAAK,mBAAmB,MAAM;AACvD,eAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,iBAAS,IAAI,GAAG,IAAI,QAAQ,cAAc,KAAK,GAAG;AAC9C,0BAAgB,gBAAgB,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC;;;;AAK9D,QAAI,qBAAqB,yBAAyB,UAAa,mBAAmB,MAAM;AACpF,2BAAqB,qBAAqB,QAAQ,CAAC,EAAE,KAAI,GAAI,UAAS;AAClE,wBAAgB,gBAAgB,YAAY,MAAM,wBAAwB,OAAO,CAAC;MACtF,CAAC;;AAGL,aAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,eAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAE/C,YAAI,QAAQ,CAAC,EAAE,CAAC,EAAE,eAAe,GAAG;AAChC,kBAAQ,CAAC,EAAE,CAAC,IAAI,IAAI,aAAa,GAAG;;;;AAKhD,QAAI;AACA,YAAM,yBAAyB,OAAO,IAAI,CAAC,OAAO,UAAS;AACvD,YAAI,qBAAqB,aAAa,KAAK,EAAE,SAAS,GAAG;AACrD,iBAAO,CAAA;;AAGX,eAAO;MACX,CAAC;AACD,YAAM,mBAAmBA,kCACrB,IAAI,0BAA0B,YAC9B,0BAA0B,YAC1B,MAAM,sBAAsB,QAAQ,wBAAwB,SAAS,UAAU,CAAC;AAGpF,UAAI,oBAAoB,MAAM;AAC1B,iBAAS,IAAI,GAAG,kCAAkC,GAAG,IAAI,QAAQ,iBAAiB,KAAK,GAAG;AACtF,mBAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAC/C,0BAAc,iBAAiB,QAAQ,CAAC,GAAG,GAAG,kCAAkC,GAAG,CAAC;;AAGxF,6CAAmC,mBAAmB,CAAC;;;AAI/D,UAAI,CAAC,kBAAkB;AACnB;;aAEC,OAAO;AACZ,YAAM,cACF,IAAI,WAAW,kBAAkB;QAC7B,OAAO,MAAM;QACb,UAAU,MAAM;QAChB,QAAQ,MAAM;QACd,SAAS,MAAM;OAClB,CAAC;AAGN;;;AAIR,SAAO;AACX;AAEO,IAAM,wCAAiF,CAC1FC,oBACAC,yBACAC,oCACAC,gCACAC,kCACAC,iCACAC,uBACAC,mCACAC,4BACAT,mCACAU,qBACAC,oCACAC,uCACAC,mBACAC,0BACAC,qCACA;AACA,SAAO,CACH,MACA,SACA,yBACA;AACA,UAAM,2BAA2B,oBAAI,QAAO;AAE5C,QAAI,yBAAoE;AAExE,UAAM,kBAAkB,OAAO,OAA6B,8BAAyD;AACjH,UAAI,yBAAyBL,oBAA+C,KAAK;AACjF,UAAI,oBAAsG;AAE1G,YAAM,yCAAyC,iBAAiB,wBAAwB,yBAAyB;AACjH,YAAM,qBAAqB,MAAM,QAAQ,QAAQ,kBAAkB,IAC7D,QAAQ,qBACR,MAAM,KAAK,QAAQ,kBAAkB;AAG3C,UAAIC,uCAAsC,MAAM;AAC5C,cAAM,yBAAyB,mBAAmB,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC;AACvF,cAAM,4BAA4BN,iCAAgC,2BAA2B;UACzF,cAAc,KAAK,IAAI,GAAG,sBAAsB;UAChD,kBAAkB;UAClB,uBAAuB;UACvB,iBAAiB,KAAK,IAAI,GAAG,sBAAsB;SACtD;AACD,cAAM,2BAAuD,CAAA;AAE7D,iBAAS,IAAI,GAAG,IAAI,MAAM,iBAAiB,KAAK,GAAG;AAC/C,mCAAyB,KACrBD,+BAA8B,2BAA2B;YACrD,cAAc;YACd,kBAAkB;YAClB,uBAAuB;YACvB,gBAAgB,mBAAmB,CAAC;WACvC,CAAC;;AAIV,cAAM,iBAAiBG,sBAAqB,2BAA2B;UACnE,cAAc,QAAQ;UACtB,kBAAkB,QAAQ;UAC1B,uBAAuB,QAAQ;UAC/B,MAAM;SACT;AAED,uBAAe,UAAuCL,wBAAuB,KAAK,MAAM,wBAAwB;AAChH,uBAAe,aAA6CO,2BAA0B,KAAK,MAAM,wBAAwB;AAEzH,4BAAoB,CAAC,2BAA2B,0BAA0B,cAAc;iBACjF,CAAC,wCAAwC;AAChD,iCAAyB,IAAIE,mCAAkC,2BAA2B,IAAI;;AAGlG,+BAAyB,IACrB,2BACA,sBAAsB,OAAO,yBAAyB,kBAAkB,CAAC,CAAC;AAG9E,UAAI,sBAAsB,MAAM;AAC5B,YAAI,2BAA2B,MAAM;AACjC,cAAI,yBAAyB,QAAW;AACpC,kBAAM,IAAI,MAAM,oCAAoC;;AAGxD,cAAIC,0CAAyC,MAAM;AAC/C,kBAAM,IAAI,MAAM,qDAAqD;;AAIzE,gBAAM,wBAAwB,MAAM,eAAe,MAAM;AACzD,gBAAM,qBACF,qBAAqB,yBAAyB,SAAY,IAAI,qBAAqB,qBAAqB;AAC5G,gBAAM,mBAAmB,wBAAwB;AAEjD,gBAAM,eAAe,YAAW;AAC5B,kBAAM,6BAA6B,IAAIA;cACnC;;;cAGA,KAAK,KAAK,MAAM,QAAQ,SAAS,GAAG,IAAI;cACxC,0BAA0B;YAAU;AAExC,kBAAM,YAA+B,CAAA;AACrC,kBAAM,4BAA4B,CAAA;AAElC,qBAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,wBAAU,KACNL,sBAAqB,4BAA4B;gBAC7C,cAAc,QAAQ;gBACtB,kBAAkB,QAAQ;gBAC1B,uBAAuB,QAAQ;gBAC/B,MAAM;eACT,CAAC;AAEN,wCAA0B,KACtBF,iCAAgC,4BAA4B;gBACxD,cAAc,QAAQ;gBACtB,kBAAkB;gBAClB,uBAAuB;gBACvB,iBAAiB,QAAQ;eAC5B,CAAC;;AAIV,kBAAM,sBAAsB,MAAM,QAAQ,IACtC,MAAM,KAAK,MAAM,WAAW,OAAM,CAAE,EAAE,IAAI,OAAO,eAAc;AAC3D,oBAAM,qBAAqBC,gCAA+B,4BAA4B;gBAClF,cAAc;gBACd,kBAAkB;gBAClB,uBAAuB;gBACvB,QAAQ,WAAW;eACtB;AAED,oBAAMO,kBAAiB,4BAA4B,YAAY,mBAAmB,MAAM;AAExF,qBAAO;YACX,CAAC,CAAC;AAGN,kBAAM,yBAAyBT,+BAA8B,4BAA4B;cACrF,cAAc;cACd,kBAAkB;cAClB,uBAAuB;cACvB,gBAAgB,KAAK,IAAI,GAAG,wBAAwB,kBAAkB;aACzE;AAED,qBAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,wBAAU,CAAC,EAAE,QAAQ,0BAA0B,CAAC,CAAC;AAEjD,uBAAS,IAAI,GAAG,IAAI,QAAQ,cAAc,KAAK,GAAG;AAC9C,0CAA0B,CAAC,EAAE,QAAQ,wBAAwB,GAAG,IAAI,QAAQ,eAAe,CAAC;;;AAIpG,uBAAW,CAAC,OAAO,kBAAkB,KAAK,oBAAoB,QAAO,GAAI;AACrE,iCAAmB,QAAQ,wBAAwB,GAAG,wBAAwB,KAAK;AACnF,iCAAmB,MAAM,CAAC;;AAG9B,mCAAuB,QAAQ,2BAA2B,WAAW;AAErE,kBAAM,QAAQ,IACV,UAAU,IAAI,CAAC,aAAaU,yBAAwB,OAAO,4BAA4B,QAAQ,CAAC,CAAC;AAGrG,mBAAOC,iCAAgC,0BAA0B;UACrE;AAEA,mCAAyB,cACrB,OACA,qBAAqB,IAAI,OAAO,MAAM,aAAY,GAClD,2BACA,SACA,oBACA,sBACAf,iCAAgC;;AAIxC,cAAM,kBAAkB,MAAM;AAC9B,cAAM,wBAAwBG,mCAAkC,2BAA2B;UACvF,QAAQ;UACR,cAAc;UACd,kBAAkB;UAClB,uBAAuB;UACvB,MAAM;UACN,SAAS;UACT,WAAW;UACX,cAAc;SACjB;AACD,cAAM,CAAC,2BAA2B,0BAA0B,cAAc,IAAI;AAE9E,YAAI,oBAAoB,MAAM;AAC1B,gCAAsB,SAAS;AAC/B,gCAAsB,MAAM,CAAC;;AAGjC,8BAAsB,QAAQ,yBAAyB;AAEvD,iBAAS,IAAI,GAAG,kCAAkC,GAAG,IAAI,MAAM,iBAAiB,KAAK,GAAG;AACpF,gBAAM,0BAA0B,yBAAyB,CAAC;AAE1D,mBAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAC/C,sCAA0B,QAAQ,yBAAyB,kCAAkC,GAAG,CAAC;;AAGrG,6CAAmC,mBAAmB,CAAC;;AAG3D,eAAO;;AAGX,UAAI,CAAC,wCAAwC;AACzC,mBAAW,CAAC,IAAI,UAAU,KAAK,MAAM,WAAW,QAAO,GAAI;AACvD,gBAAMU;YACF;YACA;;YAE6D,uBAAuB,WAAY,IAAI,EAAE;UAAC;;aAG5G;AACH,mBAAW,CAAC,IAAI,UAAU,KAAK,MAAM,WAAW,QAAO,GAAI;AACvD,gBAAMZ;YACF;YACA;;YAE6D,uBAAuB,WAAY,IAAI,EAAE;UAAC;;;AAKnH,YAAMa,yBAAwB,OAAO,2BAA2B,sBAAsB;AAEtF,aAAO;IACX;AAEA,WAAO;MACH,OACI,OACA,2BAAqD;AAErD,QAAAN,kCAAiC,2BAA2B,KAAK;AAEjE,cAAM,2CAA2C,yBAAyB,IAAI,yBAAyB;AAEvG,YAAI,6CAA6C,QAAW;AACxD,iBAAO,QAAQ,QAAQ,wCAAwC;;AAGnE,eAAO,gBAAgB,OAAO,yBAAyB;MAC3D;;EAER;AACJ;;;ACrWO,IAAM,oCAAyE,CAClFQ,wBACAC,0BACAC,yBACAC,mCACAC,8BACAC,+BACAC,iCACAC,gCACAC,2BACAC,kBACAC,uBACAC,oCACAC,sBACAC,2BACAC,qCACAC,4BACAC,wBACAC,0BACAC,8BACAC,+BACA;AACA,SAAO,MAAM,yBAA6CL,oCAAqC;IAG3F,YAAoB,gBAAgC,kBAAwB;AACxE,YAAM,gBAAgB,gBAAgB;AADtB,WAAA,iBAAA;AAGhB,WAAK,gBACDd,2BAA0B,SACpB,SACA;QACI,WAAW,CAAC,WAAmB,YAA6B;AACxD,iBAAOA,uBAAmC,MAAO,WAAW,OAAO;QACvE;;IAElB;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK;IAChB;IAEO,iBAAc;AACjB,aAAO,IAAIC,yBAAqC,IAAK;IACzD;IAEO,qBAAkB;AACrB,aAAO,IAAIG,6BAAyC,IAAK;IAC7D;IAEO,aAAa,kBAA0B,QAAgB,YAAkB;AAC5E,aAAO,IAAIF,wBAAuB,EAAE,QAAQ,kBAAkB,WAAU,CAAE;IAC9E;IAEO,qBAAkB;AACrB,aAAO,IAAIC,kCAA8C,IAAK;IAClE;IAEO,oBAAoB,iBAAiB,GAAC;AACzC,aAAO,IAAIE,8BAA0C,MAAO,EAAE,eAAc,CAAE;IAClF;IAEO,sBAAsB,kBAAkB,GAAC;AAC5C,aAAO,IAAIC,gCAA4C,MAAO,EAAE,gBAAe,CAAE;IACrF;IAEO,uBAAoB;AACvB,aAAO,IAAIC,+BAA2C,IAAK;IAC/D;IAEO,kBAAe;AAClB,aAAO,IAAIC,0BAAsC,IAAK;IAC1D;IAEO,YAAY,eAAe,GAAC;AAC/B,aAAO,IAAIE,sBAAkC,MAAO,EAAE,aAAY,CAAE;IACxE;IAEO,2BAAwB;AAC3B,aAAO,IAAIC,mCAA+C,IAAK;IACnE;IAEO,aAAU;AACb,aAAO,IAAIC,qBAAiC,IAAK;IACrD;IAEO,gBAAgB,aAA+B,UAA0B;AAC5E,aAAO,IAAIC,0BAAsC,MAAO,EAAE,UAAU,YAAW,CAAE;IACrF;IAEO,mBAAgB;AACnB,aAAO,IAAIE,2BAAuC,IAAK;IAC3D;IAEO,eAAY;AACf,aAAO,IAAIC,uBAAmC,IAAK;IACvD;IAEO,mBACH,MACA,MACA,cAAiD,EAAE,sBAAsB,MAAK,GAAE;AAEhF,aAAO,IAAIC,yBAAqC,MAAO,EAAE,GAAG,aAAa,MAAM,KAAI,CAAE;IACzF;IAEO,qBAAkB;AACrB,aAAO,IAAIC,6BAAyC,IAAK;IAC7D;IAEO,mBAAgB;AACnB,aAAO,IAAIC,2BAAuC,IAAK;IAC3D;IAEO,gBACH,WACA,iBACA,eAAoC;AAEpC,aAAOV,iBAAgB,KAAK,gBAAgB,SAAS,EAAE,KACnD,CAAC,gBAAe;AACZ,YAAI,OAAO,oBAAoB,YAAY;AACvC,0BAAgB,WAAW;;AAG/B,eAAO;MACX,GACA,CAAC,QAAO;AACJ,YAAI,OAAO,kBAAkB,YAAY;AACrC,wBAAc,GAAG;;AAGrB,cAAM;MACV,CAAC;IAET;;AAER;;;AC7JA,IAAMW,mBAAkB;EACpB,GAAG;EACH,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,QAAQ;EACR,WAAW;EACX,MAAM;EACN,MAAM;;AAGH,IAAM,oCAAyE,CAClFC,uBACAC,mBACAC,iCACAC,2BACAC,+BACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,yBAA6CP,sBAAuB;IAW7E,YAAYQ,UAAY,SAAuC;AAC3D,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGT,kBAAiB,GAAG,QAAO;AACtD,YAAM,yBAAyBK,8BAA6B,eAAe,aAAa;AACxF,YAAM,YAAYE,6BAA4B,aAAa;AAC3D,YAAM,2BAAyD,YAAYJ,gCAA8B,IAAK;AAE9G,YAAMM,UAAS,OAAO,wBAAwB,wBAAwB;AAGtE,WAAK,KAAKP,kBAAiB,MAAM,WAAW,uBAAuB,GAAG,4BAA4B,0BAA0B;AAE5H,WAAK,UAAUA,kBACX,MACA,WACA,uBAAuB,QACvB,OAAO,KAAK,KAAK,0BAA0B,GAC3C,QAAQ,KAAK,KAAK,0BAA0B,CAAC;AAGjD,WAAK,aAAaA,kBAAiB,MAAM,WAAW,uBAAuB,WAAWO,SAAQ,aAAa,GAAG,CAAC;AAE/G,WAAK,QAAQP,kBACT,MACA,WACA,uBAAuB,MACvB,KAAK,KAAK,MAAM,0BAA0B,GAC1C,0BAA0B;AAE9B,WAAK,0BAA0B;AAG/B,MAAAM,sBAAqB,MAAM,CAAC;IAChC;IAEA,IAAI,SAAM;AACN,aAAO,KAAK;IAChB;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK;IAChB;IAEA,IAAI,IAAC;AACD,aAAO,KAAK;IAChB;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK,wBAAwB;IACxC;IAEA,IAAI,KAAK,OAAK;AACV,WAAK,wBAAwB,OAAO;IACxC;IAEO,qBAAqB,aAA2B,aAA2B,eAA2B;AAEzG,UAAI;AACA,aAAK,wBAAwB,qBAAqB,aAAa,aAAa,aAAa;eACpF,KAAK;AACV,YAAI,IAAI,SAAS,IAAI;AACjB,gBAAMJ,0BAAwB;;AAGlC,cAAM;;AAIV,UAAI,YAAY,WAAW,YAAY,UAAU,YAAY,WAAW,cAAc,QAAQ;AAC1F,cAAMA,0BAAwB;;IAEtC;;AAER;;;AC7GO,IAAM,wCAAiF,CAC1FM,oBACAC,+BACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,kCAAkC,oBAAI,QAAO;AAEnD,UAAM,yBAAyB,OAAO,OAA6B,8BAAyD;AACxH,UAAI,yBAAyBF,oBAA+C,KAAK;AAMjF,YAAM,yCAAyC,iBAAiB,wBAAwB,yBAAyB;AAEjH,UAAI,CAAC,wCAAwC;AACzC,cAAM,UAAU;UACZ,GAAG,uBAAuB,EAAE;UAC5B,cAAc,uBAAuB;UACrC,kBAAkB,uBAAuB;UACzC,uBAAuB,uBAAuB;UAC9C,QAAQ,uBAAuB,OAAO;UACtC,WAAW,uBAAuB,UAAU;UAC5C,MAAM,uBAAuB,KAAK;UAClC,MAAM,uBAAuB;;AAGjC,iCAAyBD,8BAA6B,2BAA2B,OAAO;;AAG5F,sCAAgC,IAAI,2BAA2B,sBAAsB;AAErF,UAAI,CAAC,wCAAwC;AACzC,cAAME,kBAAiB,2BAA2B,MAAM,GAAG,uBAAuB,CAAC;AACnF,cAAMA,kBAAiB,2BAA2B,MAAM,QAAQ,uBAAuB,MAAM;AAC7F,cAAMA,kBAAiB,2BAA2B,MAAM,WAAW,uBAAuB,SAAS;AACnG,cAAMA,kBAAiB,2BAA2B,MAAM,MAAM,uBAAuB,IAAI;aACtF;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,GAAG,uBAAuB,CAAC;AACpF,cAAMA,mBAAkB,2BAA2B,MAAM,QAAQ,uBAAuB,MAAM;AAC9F,cAAMA,mBAAkB,2BAA2B,MAAM,WAAW,uBAAuB,SAAS;AACpG,cAAMA,mBAAkB,2BAA2B,MAAM,MAAM,uBAAuB,IAAI;;AAG9F,YAAMI,yBAAwB,OAAO,2BAA2B,sBAAsB;AAEtF,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAA6B,2BAAqD;AACrF,cAAM,iCAAiC,gCAAgC,IAAI,yBAAyB;AAEpG,YAAI,mCAAmC,QAAW;AAC9C,iBAAO,QAAQ,QAAQ,8BAA8B;;AAGzD,eAAO,uBAAuB,OAAO,yBAAyB;MAClE;;EAER;AACJ;;;ACnEO,IAAM,wBAAiD,CAAC,cAAc,gBAAe;AACxF,SAAO,CAAC,QAAQ,SAAQ;AACpB,UAAM,mBAAmB,YAAY,IAAI,MAAM;AAE/C,QAAI,qBAAqB,QAAW;AAChC,aAAO;;AAGX,UAAM,cAAc,aAAa,IAAI,MAAM;AAE3C,QAAI,gBAAgB,QAAW;AAC3B,aAAO;;AAGX,QAAI;AACA,YAAM,wBAAwB,KAAI;AAElC,UAAI,iCAAiC,SAAS;AAC1C,qBAAa,IAAI,QAAQ,qBAAqB;AAE9C,eAAO,sBACF,MAAM,MAAM,KAAK,EACjB,KAAK,CAAC,oBAAmB;AACtB,uBAAa,OAAO,MAAM;AAC1B,sBAAY,IAAI,QAAQ,eAAe;AAEvC,iBAAO;QACX,CAAC;;AAGT,kBAAY,IAAI,QAAQ,qBAAqB;AAE7C,aAAO;YACH;AACJ,kBAAY,IAAI,QAAQ,KAAK;AAE7B,aAAO;;EAEf;AACJ;;;ACtCA,IAAMC,mBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,gBAAgB;;AAGb,IAAM,qCAA2E,CACpFC,uBACAC,kCACAC,gCACAC,mBACAC,iCACA;AACA,SAAO,MAAM,0BAA8CJ,sBAAuB;IAC9E,YAAYK,UAAY,SAAwC;AAC5D,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGN,kBAAiB,GAAG,QAAO;AACtD,YAAM,0BAA0BG,+BAA8B,eAAe,aAAa;AAC1F,YAAM,4BACDE,6BAA4B,aAAa,IAAIH,iCAA+B,IAAK;AAGtF,YAAMI,UAAS,OAAO,yBAAyB,yBAAyB;IAC5E;;AAER;;;ACzBO,IAAM,yCAAmF,CAC5FC,gCACAC,qBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,2BAA2B,oBAAI,QAAO;AAE5C,UAAM,kBAAkB,OAAO,OAAsB,8BAAyD;AAC1G,UAAI,kBAAkBD,oBAAwC,KAAK;AAGnE,YAAM,kCAAkC,iBAAiB,iBAAiB,yBAAyB;AAEnG,UAAI,CAAC,iCAAiC;AAClC,cAAM,UAAU;UACZ,cAAc,gBAAgB;UAC9B,kBAAkB,gBAAgB;UAClC,uBAAuB,gBAAgB;UACvC,gBAAgB,gBAAgB;;AAGpC,0BAAkBD,+BAA8B,2BAA2B,OAAO;;AAGtF,+BAAyB,IAAI,2BAA2B,eAAe;AAEvE,YAAME,yBAAwB,OAAO,2BAA2B,eAAe;AAE/E,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAAsB,2BAAqD;AAC9E,cAAM,0BAA0B,yBAAyB,IAAI,yBAAyB;AAEtF,YAAI,4BAA4B,QAAW;AACvC,iBAAO,QAAQ,QAAQ,uBAAuB;;AAGlD,eAAO,gBAAgB,OAAO,yBAAyB;MAC3D;;EAER;AACJ;;;AC7CA,IAAMC,mBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,iBAAiB;;AAGd,IAAM,uCAA+E,CACxFC,uBACAC,oCACAC,kCACAC,mBACAC,8BACAC,oCACA;AACA,SAAO,MAAM,4BAAgDL,sBAAuB;IAChF,YAAYM,UAAY,SAA0C;AAC9D,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgBD,gCAA+B,EAAE,GAAGN,kBAAiB,GAAG,QAAO,CAAE;AACvF,YAAM,4BAA4BG,iCAAgC,eAAe,aAAa;AAC9F,YAAM,8BACDE,6BAA4B,aAAa,IAAIH,mCAAiC,IAAK;AAGxF,YAAMK,UAAS,OAAO,2BAA2B,2BAA2B;IAChF;;AAER;;;AC1BO,IAAM,2CAAuF,CAChGC,kCACAC,qBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,2BAA2B,oBAAI,QAAO;AAE5C,UAAM,kBAAkB,OAAO,OAAsB,8BAAyD;AAC1G,UAAI,kBAAkBD,oBAAwC,KAAK;AAGnE,YAAM,kCAAkC,iBAAiB,iBAAiB,yBAAyB;AAEnG,UAAI,CAAC,iCAAiC;AAClC,cAAM,UAAU;UACZ,cAAc,gBAAgB;UAC9B,kBAAkB,gBAAgB;UAClC,uBAAuB,gBAAgB;UACvC,iBAAiB,gBAAgB;;AAGrC,0BAAkBD,iCAAgC,2BAA2B,OAAO;;AAGxF,+BAAyB,IAAI,2BAA2B,eAAe;AAEvE,YAAME,yBAAwB,OAAO,2BAA2B,eAAe;AAE/E,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAAsB,2BAAqD;AAC9E,cAAM,0BAA0B,yBAAyB,IAAI,yBAAyB;AAEtF,YAAI,4BAA4B,QAAW;AACvC,iBAAO,QAAQ,QAAQ,uBAAuB;;AAGlD,eAAO,gBAAgB,OAAO,yBAAyB;MAC3D;;EAER;AACJ;;;AC9CO,IAAM,0BAAqD,CAACC,8BAA4B;AAC3F,SAAO,CAAC,2BAA2B,YAAY,qBAAoB;AAC/D,WAAOA,0BAAyB,YAAY,2BAA2B,gBAAgB;EAC3F;AACJ;;;ACHO,IAAM,+BAA+D,CAACC,0BAAwB;AACjG,SAAO,CAAC,kBAAkB,aAAa,SAAS,GAAG,QAAQ,MAAK;AAC5D,UAAM,kBAAkB,iBAAiB,MAAM;AAE/C,QAAI,oBAAoB,QAAW;AAC/B,YAAMA,sBAAoB;;AAG9B,QAAI,kBAAkB,WAAW,GAAG;AAChC,aAAO,gBAAgB,QAAQ,aAAa,GAAG,KAAK;;AAGxD,WAAO,gBAAgB,QAAQ,aAAa,CAAC;EACjD;AACJ;;;ACfO,IAAM,oDAAyG,CAClHC,uCACA;AACA,SAAO,CAAC,eAAe,oBAAmB;AACtC,UAAM,8BAA8BA,mCAAkC,eAAe;MACjF,QAAQ;MACR,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,MAAM;MACN,SAAS;MACT,WAAW;MACX,cAAc;KACjB;AACD,UAAM,oBAAoB,cAAc,aAAa,GAAG,GAAG,KAAK;AAEhE,gCAA4B,SAAS;AACrC,gCAA4B,OAAO;AAEnC,gCAA4B,QAAQ,eAAe;AACnD,gCAA4B,MAAK;AAEjC,WAAO,MAAK;AACR,kCAA4B,KAAI;AAChC,kCAA4B,WAAW,eAAe;IAC1D;EACJ;AACJ;;;AChBA,IAAMC,mBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,QAAQ;;AAGL,IAAM,sCAA6E,CACtFC,uBACAC,mBACAC,0CACAC,iCACAC,mBACAC,8BACAC,uBACA;AACA,SAAO,MAAM,2BACDN,sBAA0D;IAWlE,YAAYO,UAAY,SAAyC;AAC7D,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGR,kBAAiB,GAAG,QAAO;AACtD,YAAM,2BAA2BI,gCAA+B,eAAe,aAAa;AAC5F,YAAM,YAAYE,6BAA4B,aAAa;AAC3D,YAAM,6BACD,YAAYH,yCAAuC,IAAK;AAG7D,YAAMK,UAAS,OAAO,0BAA0B,0BAA0B;AAE1E,WAAK,8BAA8B;AACnC,WAAK,4BAA4B;AAKjC,WAAK,UAAUN,kBACX,MACA,WACA,yBAAyB,QACzB,4BACA,0BAA0B;AAE9B,WAAK,WAAW;IACpB;IAEA,IAAI,SAAM;AACN,aAAO,KAAK;IAChB;IAEA,IAAI,UAAO;AACP,aAAO,KAAK;IAChB;IAEA,IAAI,QAAQ,OAAK;AACb,YAAM,kBAAkB,OAAO,UAAU,aAAaK,mBAAkB,MAAM,KAAK,IAAI;AAEvF,WAAK,0BAA0B,UAAU;AAEzC,YAAM,gBAAgB,KAAK,0BAA0B;AAErD,WAAK,WAAW,kBAAkB,QAAQ,kBAAkB,kBAAkB,QAAQ;IAC1F;IAEO,MAAM,OAAO,GAAC;AACjB,WAAK,0BAA0B,MAAM,IAAI;AAEzC,UAAI,KAAK,gCAAgC,MAAM;AAC3C,aAAK,4BAA4B,QAAQ;;AAG7C,UAAI,KAAK,QAAQ,UAAU,UAAU;AACjC,iCAAyB,IAAI;AAE7B,cAAM,8BAA8B,MAAK;AACrC,eAAK,0BAA0B,oBAAoB,SAAS,2BAA2B;AAEvF,cAAI,kBAAkB,IAAI,GAAG;AACzB,sCAA0B,IAAI;;QAEtC;AAEA,aAAK,0BAA0B,iBAAiB,SAAS,2BAA2B;;IAE5F;IAEO,KAAK,OAAO,GAAC;AAChB,WAAK,0BAA0B,KAAK,IAAI;AAExC,UAAI,KAAK,gCAAgC,MAAM;AAC3C,aAAK,4BAA4B,OAAO;;IAEhD;;AAER;;;AChHO,IAAM,0CAAqF,CAC9FE,oBACAC,iCACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,oCAAoC,oBAAI,QAAO;AAErD,QAAIC,SAAuB;AAC3B,QAAI,OAAsB;AAE1B,UAAM,2BAA2B,OAAO,OAA+B,8BAAyD;AAC5H,UAAI,2BAA2BH,oBAAiD,KAAK;AAMrF,YAAM,2CAA2C,iBAAiB,0BAA0B,yBAAyB;AAErH,UAAI,CAAC,0CAA0C;AAC3C,cAAM,UAAU;UACZ,cAAc,yBAAyB;UACvC,kBAAkB,yBAAyB;UAC3C,uBAAuB,yBAAyB;UAChD,QAAQ,yBAAyB,OAAO;;AAG5C,mCAA2BD,gCAA+B,2BAA2B,OAAO;AAE5F,YAAII,WAAU,MAAM;AAChB,mCAAyB,MAAMA,MAAK;;AAGxC,YAAI,SAAS,MAAM;AACf,mCAAyB,KAAK,IAAI;;;AAI1C,wCAAkC,IAAI,2BAA2B,wBAAwB;AAEzF,UAAI,CAAC,0CAA0C;AAC3C,cAAMF,kBAAiB,2BAA2B,MAAM,QAAQ,yBAAyB,MAAM;aAC5F;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,QAAQ,yBAAyB,MAAM;;AAGpG,YAAMI,yBAAwB,OAAO,2BAA2B,wBAAwB;AAExF,aAAO;IACX;AAEA,WAAO;MACH,IAAI,MAAM,OAAa;AACnB,QAAAC,SAAQ;MACZ;MACA,IAAI,KAAK,OAAa;AAClB,eAAO;MACX;MACA,OACI,OACA,2BAAqD;AAErD,cAAM,mCAAmC,kCAAkC,IAAI,yBAAyB;AAExG,YAAI,qCAAqC,QAAW;AAChD,iBAAO,QAAQ,QAAQ,gCAAgC;;AAG3D,eAAO,yBAAyB,OAAO,yBAAyB;MACpE;;EAER;AACJ;;;AC7EO,IAAM,oCAAyE,CAAC,gBAAe;AAClG,SAAO,CAAC,UAAS;AACb,gBAAY,CAAC,IAAI;AAEjB,WAAO,YAAY,CAAC;EACxB;AACJ;;;ACLA,IAAMC,mBAAkB;EACpB,QAAQ;EACR,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,sBAAsB;;AAGnB,IAAM,iCAAmE,CAC5EC,uBACAC,8BACAC,4BACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,sBAA0CL,sBAAuB;IAK1E,YAAYM,UAAY,SAAoC;AACxD,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGP,kBAAiB,GAAG,QAAO;AACtD,YAAM,sBAAsBG,2BAA0B,eAAe,aAAa;AAClF,YAAM,YAAYE,6BAA4B,aAAa;AAC3D,YAAM,wBAAsD,YAAYH,6BAA2B,IAAK;AAExG,YAAMK,UAAS,OAAO,qBAAqB,qBAAqB;AAEhE,WAAK,qBAAqB;AAC1B,WAAK,uBAAuB;AAE5B,UAAI,cAAc,WAAW,MAAM;AAC/B,QAAAD,sBAAqB,MAAM,cAAc,OAAO,QAAQ;;IAEhE;IAEA,IAAI,SAAM;AACN,UAAI,KAAK,oBAAoB;AACzB,eAAO;;AAGX,aAAO,KAAK,qBAAqB;IACrC;IAEA,IAAI,OAAO,OAAK;AACZ,WAAK,qBAAqB,SAAS;AAGnC,UAAI,UAAU,QAAQ,KAAK,qBAAqB,WAAW,MAAM;AAC7D,cAAM,gBAAgB,KAAK,qBAAqB;AAEhD,aAAK,qBAAqB,SAAS,cAAc,aAAa,GAAG,GAAG,cAAc,UAAU;AAC5F,aAAK,qBAAqB;AAE1B,QAAAA,sBAAqB,MAAM,CAAC;aACzB;AACH,aAAK,qBAAqB;AAE1B,QAAAA,sBAAqB,MAAM,KAAK,qBAAqB,WAAW,OAAO,IAAI,KAAK,qBAAqB,OAAO,QAAQ;;IAE5H;IAEA,IAAI,YAAS;AACT,aAAO,KAAK,qBAAqB;IACrC;IAEA,IAAI,UAAU,OAAK;AACf,WAAK,qBAAqB,YAAY;IAC1C;;AAER;;;ACtEO,IAAM,qCAA2E,CACpFE,4BACAC,qBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,+BAA+B,oBAAI,QAAO;AAEhD,UAAM,sBAAsB,OAAO,OAA0B,8BAAyD;AAClH,UAAI,sBAAsBD,oBAA4C,KAAK;AAG3E,YAAM,sCAAsC,iBAAiB,qBAAqB,yBAAyB;AAE3G,UAAI,CAAC,qCAAqC;AACtC,cAAM,UAAU;UACZ,QAAQ,oBAAoB;UAC5B,cAAc,oBAAoB;UAClC,kBAAkB,oBAAoB;UACtC,uBAAuB,oBAAoB;UAC3C,sBAAsB,CAAC,oBAAoB;;AAG/C,8BAAsBD,2BAA0B,2BAA2B,OAAO;;AAGtF,mCAA6B,IAAI,2BAA2B,mBAAmB;AAE/E,UAAI,uBAAuB,mBAAmB,GAAG;AAC7C,cAAME,yBAAwB,OAAO,2BAA2B,oBAAoB,OAAO,CAAC,CAAC;aAC1F;AACH,cAAMA,yBAAwB,OAAO,2BAA2B,mBAAmB;;AAGvF,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAA0B,2BAAqD;AAClF,cAAM,8BAA8B,6BAA6B,IAAI,yBAAyB;AAE9F,YAAI,gCAAgC,QAAW;AAC3C,iBAAO,QAAQ,QAAQ,2BAA2B;;AAGtD,eAAO,oBAAoB,OAAO,yBAAyB;MAC/D;;EAER;AACJ;;;ACpDO,IAAM,wCAAiF,CAC1FC,0BACAC,0CACA;AACA,SAAO,CAAC,kBAAkB,QAAQ,eAAc;AAC5C,QAAIA,0CAAyC,MAAM;AAC/C,YAAM,IAAI,MAAM,qDAAqD;;AAGzE,QAAI;AACA,aAAO,IAAIA,sCAAqC,kBAAkB,QAAQ,UAAU;aAC/E,KAAK;AAEV,UAAI,IAAI,SAAS,eAAe;AAC5B,cAAMD,yBAAuB;;AAGjC,YAAM;;EAEd;AACJ;;;ACpBO,IAAM,uBAA+C,MAAM,IAAI,aAAa,IAAI,gBAAgB;;;ACFhG,IAAM,oBAAoB,CAAC,gBAA2C;AACzE,QAAM,EAAE,OAAO,MAAK,IAAK,IAAI,eAAc;AAE3C,SAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,UAAM,kBAAkB,MAAK;AACzB,YAAM,YAAY;AAElB,YAAM,MAAK;AACX,YAAM,MAAK;AAEX,cAAO;IACX;AAEA,UAAM,YAAY,MAAM,gBAAe;AAEvC,QAAI;AACA,YAAM,YAAY,aAAa,CAAC,WAAW,CAAC;YACxC;;AAGJ,sBAAe;;EAEvB,CAAC;AACL;;;ACnBO,IAAM,wBAAiD,CAC1DE,mBACAC,kBACAC,uBACAC,sBACA,sBACAC,mBACAC,kBACAC,sDACAC,qBACAC,oCACAC,kDACA;AACA,SAAO,CAAC,YAAY,cAAa;AAC7B,UAAM,gBAAgBJ,iBAAgB,UAAU,IAAI,aAAaD,kBAAiB,UAAU;AAG5F,QAAI,qBAAqB,IAAI,SAAS,GAAG;AACrC,YAAM,MAAMF,sBAAoB;AAEhC,aAAO,QAAQ,OAAO,GAAG;;AAI7B,QAAI;AACA,2BAAqB,IAAI,SAAS;YAC9B;;AAKR,QAAID,iBAAgBM,qBAAoB,MAAMA,oBAAmB,aAAa,CAAC,GAAG;AAC9E,aAAO,cAAc,gBAAgB,SAAS,EAAE,KAAK,CAAC,gBAAe;AAEjE,0BAAkB,SAAS,EAAE,MAAM,MAAK;QAExC,CAAC;AAGD,YACI,CAACN,iBAAgBK,sDAAqD,MAClEA,qDAAoD,WAAW,CAAC,GAEtE;AACE,UAAAG,8CAA6C,WAAW;;AAG5D,QAAAT,kBAAiB,IAAI,WAAW;AAEhC,eAAO;MACX,CAAC;;AAIL,WAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,YAAM,WAAW,YAAW;AAExB,YAAI;AACA,gBAAM,kBAAkB,SAAS;gBAC7B;;MAGZ;AAEA,YAAM,OAAO,CAAC,QAA6B;AACvC,eAAO,GAAG;AACV,iBAAQ;MACZ;AAGA,UAAI;AAEA,sBAAc,gBACV,WACA,CAAC,gBAAe;AAGZ,cAAI,OAAO,YAAY,oBAAoB,YAAY;AACnD,YAAAQ,mCAAkC,WAAW;AAC7C,gDAAoC,WAAW;;AAGnD,UAAAR,kBAAiB,IAAI,WAAW;AAEhC,mBAAQ,EAAG,KAAK,MAAM,QAAQ,WAAW,CAAC;QAC9C,GACA,CAAC,QAA6B;AAE1B,cAAI,QAAQ,MAAM;AACd,iBAAKG,qBAAmB,CAAE;iBACvB;AACH,iBAAK,GAAG;;QAEhB,CAAC;eAEA,KAAK;AACV,aAAK,GAAG;;IAEhB,CAAC;EACL;AACJ;;;ACrGO,IAAM,8BAA6D,CACtEO,0CACA,eACAC,0BACAC,qBACAC,sBACAC,mBACAC,oBACAC,iCACA;AACA,SAAO,CAAC,WAAW,UAAS;AACxB,UAAM,eAAe,cAAc,IAAI,SAAS;AAEhD,QAAI,iBAAiB,QAAW;AAC5B,YAAM,IAAI,MAAM,mCAAmC;;AAGvD,UAAM,gBAAgBF,kBAAiB,UAAU,OAAO;AACxD,UAAM,YAAYE,6BAA4B,aAAa;AAE3D,QAAI,iBAAiB,OAAO;AACxB,oBAAc,OAAO,SAAS;AAE9B,UAAI,CAAC,aAAaD,mBAAkB,SAAS,GAAG;AAC5C,cAAM,wBAAwBH,oBAAmB,SAAS;AAC1D,cAAM,EAAE,QAAO,IAAKD,yBAAwB,SAAS;AAErD,mBAAW,UAAU,SAAS;AAC1B,cAAI,4BAA4B,MAAM,GAAG;AACrC,kBAAM,6BAA6BC,oBAAmB,OAAO,CAAC,CAAC;AAE/D,YAAAF,yCAAwC,uBAAuB,4BAA4B,OAAO,CAAC,GAAG,OAAO,CAAC,CAAC;iBAC5G;AACH,kBAAM,8BAA8BG,qBAAoB,OAAO,CAAC,CAAC;AAEjE,kCAAsB,QAAQ,6BAA6B,OAAO,CAAC,CAAC;;;;WAI7E;AACH,oBAAc,IAAI,WAAW,eAAe,KAAK;;EAEzD;AACJ;;;AC3CA,IAAMI,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,WAAW;EACX,cAAc;;AAGX,IAAM,6BAA2D,CACpEC,uBACAC,mBACAC,0BACAC,wBACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,kBAAsCN,sBAAuB;IAGtE,YAAYO,UAAY,SAAgC;AACpD,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGR,mBAAiB,GAAG,QAAO;AACtD,YAAM,kBAAkBI,uBAAsB,eAAe,aAAa;AAC1E,YAAM,YAAYE,6BAA4B,aAAa;AAC3D,YAAM,oBAAkD,YAAYH,yBAAwB,cAAc,YAAY,IAAI;AAE1H,YAAMK,UAAS,OAAO,iBAAiB,iBAAiB;AAExD,WAAK,aAAaN,kBAAiB,MAAM,WAAW,gBAAgB,SAAS;AAE7E,MAAAK,sBAAqB,MAAM,cAAc,YAAY;IACzD;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;;AAER;;;ACrCO,IAAM,iCAAmE,CAC5EE,oBACAC,wBACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,CAA+D,iBAAwB;AAC1F,UAAM,2BAA2B,oBAAI,QAAO;AAE5C,UAAM,kBAAkB,OAAO,OAAsB,8BAAyD;AAC1G,UAAI,kBAAkBF,oBAAwC,KAAK;AAGnE,YAAM,kCAAkC,iBAAiB,iBAAiB,yBAAyB;AAEnG,UAAI,CAAC,iCAAiC;AAClC,cAAM,UAAU;UACZ,cAAc,gBAAgB;UAC9B,kBAAkB,gBAAgB;UAClC,uBAAuB,gBAAgB;UACvC,WAAW,gBAAgB,UAAU;UACrC;;AAGJ,0BAAkBD,uBAAsB,2BAA2B,OAAO;;AAG9E,+BAAyB,IAAI,2BAA2B,eAAe;AAEvE,UAAI,CAAC,iCAAiC;AAClC,cAAME,kBAAiB,2BAA2B,MAAM,WAAW,gBAAgB,SAAS;aACzF;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,WAAW,gBAAgB,SAAS;;AAGjG,YAAMI,yBAAwB,OAAO,2BAA2B,eAAe;AAE/E,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAAsB,2BAAqD;AAC9E,cAAM,0BAA0B,yBAAyB,IAAI,yBAAyB;AAEtF,YAAI,4BAA4B,QAAW;AACvC,iBAAO,QAAQ,QAAQ,uBAAuB;;AAGlD,eAAO,gBAAgB,OAAO,yBAAyB;MAC3D;;EAER;AACJ;;;ACvDO,IAAM,+CAA+F,CAACC,wBAAsB;AAC/H,SAAO,CAAC,cAAc,QAAQ,QAAQ,UAAS;AAC3C,WAAOA,oBACH,aAAa,KAAK,GAClB,CAAC,0BAA0B,sBAAsB,CAAC,MAAM,UAAU,sBAAsB,CAAC,MAAM,MAAM;EAE7G;AACJ;;;ACPO,IAAM,yCAAmF,CAACC,oCAAkC;AAC/H,SAAO,CAAC,eAAe,qBAAoB;AACvC,IAAAA,gCAA+B,aAAa,EAAE,OAAO,gBAAgB;EACzE;AACJ;;;ACHO,IAAM,cAAc,CAAqB,cAAwD;AACpG,SAAO,eAAe;AAC1B;;;ACAO,IAAM,qBAA2C,CAACC,2BAA0BC,0BAAyBC,oBAAkB;AAC1H,SAAO,SAAS,aAAiC,OAAwB,UAAqC;AAC1G,UAAM,YAAY,YAAY,QAAQ,IAAI,WAA0BA,gBAAeF,2BAA0B,QAAQ;AAErH,QAAI,YAAY,SAAS,GAAG;AACxB,aAAO,CAAA;;AAGX,QAAI,MAAM,CAAC,MAAM,WAAW;AACxB,aAAO,CAAC,KAAK;;AAGjB,QAAI,MAAM,SAAS,SAAS,GAAG;AAC3B,aAAO,CAAA;;AAGX,UAAM,EAAE,QAAO,IAAKC,yBAAwB,SAAS;AAErD,WAAO,MAAM,KAAK,OAAO,EACpB,IAAI,CAAC,qBAAqB,aAAa,CAAC,GAAG,OAAO,SAAS,GAAG,iBAAiB,CAAC,CAAC,CAAC,EAClF,OAAO,CAAC,cAAc,iBAAiB,aAAa,OAAO,YAAY,GAAG,CAAA,CAAE;EACrF;AACJ;;;ACxBA,IAAM,4BAA4B,CAC9BE,uBACA,kBACA,WACkB;AAClB,QAAM,kBAAkB,iBAAiB,MAAM;AAE/C,MAAI,oBAAoB,QAAW;AAC/B,UAAMA,sBAAoB;;AAG9B,SAAO;AACX;AAEO,IAAM,kCAAqE,CAACA,0BAAwB;AACvG,SAAO,CAAC,kBAAkB,sBAAsB,QAAW,SAAS,QAAW,QAAQ,MAAK;AACxF,QAAI,wBAAwB,QAAW;AACnC,aAAO,iBAAiB,QAAQ,CAAC,oBAAoB,gBAAgB,WAAU,CAAE;;AAGrF,QAAI,OAAO,wBAAwB,UAAU;AACzC,aAAO,0BAA0BA,uBAAsB,kBAAkB,mBAAmB,EAAE,WAAU;;AAG5G,QAAI,kBAAkB,mBAAmB,GAAG;AACxC,UAAI,WAAW,QAAW;AACtB,eAAO,iBAAiB,QAAQ,CAAC,oBAAoB,gBAAgB,WAAW,mBAAmB,CAAC;;AAGxG,UAAI,UAAU,QAAW;AACrB,eAAO,0BAA0BA,uBAAsB,kBAAkB,MAAM,EAAE,WAAW,qBAAqB,CAAC;;AAGtH,aAAO,0BAA0BA,uBAAsB,kBAAkB,MAAM,EAAE,WAAW,qBAAqB,GAAG,KAAK;;AAG7H,QAAI,WAAW,QAAW;AACtB,aAAO,iBAAiB,QAAQ,CAAC,oBAAoB,gBAAgB,WAAW,mBAAmB,CAAC;;AAGxG,WAAO,0BAA0BA,uBAAsB,kBAAkB,MAAM,EAAE,WAAW,qBAAqB,CAAC;EACtH;AACJ;;;ACnCA,IAAMC,oBAAkB;EACpB,QAAQ;EACR,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,MAAM;EACN,OAAO;EACP,SAAS;EACT,WAAW;;AAGR,IAAM,0CAAqF,CAC9FC,uBACAC,mBACAC,uCACAC,qCACAC,0BACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,+BAAmDP,sBAAuB;IAanF,YAAYQ,UAAY,SAA6C;AACjE,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGT,mBAAiB,GAAG,QAAO;AACtD,YAAM,+BAA+BI,oCAAmC,eAAe,aAAa;AACpG,YAAM,YAAYG,6BAA4B,aAAa;AAC3D,YAAM,iCAA+D,YAAYJ,sCAAoC,IAAK;AAE1H,YAAMM,UAAS,OAAO,8BAA8B,8BAA8B;AAElF,WAAK,UAAUP,kBAAiB,MAAM,WAAW,6BAA6B,MAAM;AACpF,WAAK,QAAQA,kBAAiB,MAAM,WAAW,6BAA6B,IAAI;AAChF,WAAK,gCAAgC;AACrC,WAAK,SAASA,kBAAiB,MAAM,WAAW,6BAA6B,KAAK;AAClF,WAAK,WAAWA,kBAAiB,MAAM,WAAW,6BAA6B,OAAO;AACtF,WAAK,aAAaA,kBAAiB,MAAM,WAAW,6BAA6B,SAAS;AAE1F,MAAAM,sBAAqB,MAAM,IAAK;IACpC;IAEA,IAAI,SAAM;AACN,aAAO,KAAK;IAChB;;IAGA,IAAI,eAAY;AACZ,aAAO,KAAK,8BAA8B;IAC9C;IAEA,IAAI,aAAa,OAAK;AAClB,YAAM,uBAAuB,KAAK,8BAA8B;AAEhE,WAAK,8BAA8B,eAAe;AAElD,UAAI,QAAQ,GAAG;AACX,aAAK,8BAA8B,eAAe;AAElD,cAAMH,yBAAuB;;IAErC;;;;;IAMA,IAAI,mBAAgB;AAChB,aAAO,KAAK,8BAA8B;IAC9C;IAEA,IAAI,iBAAiB,OAAK;AACtB,YAAM,uBAAuB,KAAK,8BAA8B;AAEhE,WAAK,8BAA8B,mBAAmB;AAEtD,UAAI,UAAU,OAAO;AACjB,aAAK,8BAA8B,mBAAmB;AAEtD,cAAMA,yBAAuB;;IAErC;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK;IAChB;IAEA,IAAI,QAAK;AACL,aAAO,KAAK;IAChB;IAEA,IAAI,YAAS;AAET,UAAI,OAAiC,KAAK,8BAA8B,UAAY,UAAU,UAAU;AACpG,eAAiC,KAAK,8BAA8B,UAAY;;AAGpF,aAAO,KAAK,8BAA8B;IAC9C;IAEA,IAAI,UAAO;AACP,aAAO,KAAK;IAChB;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;;AAER;;;AC7HO,IAAM,8CAA6F,CACtGK,oBACAC,qCACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,wCAAwC,oBAAI,QAAO;AAEzD,UAAM,+BAA+B,OACjC,OACA,8BACA;AACA,UAAI,+BAA+BF,oBAAqD,KAAK;AAM7F,YAAM,+CAA+C,iBAAiB,8BAA8B,yBAAyB;AAE7H,UAAI,CAAC,8CAA8C;AAC/C,cAAM,UAAU;UACZ,QAAQ,6BAA6B,OAAO;UAC5C,cAAc,6BAA6B;UAC3C,kBAAkB,6BAA6B;UAC/C,uBAAuB,6BAA6B;UACpD,MAAM,6BAA6B,KAAK;UACxC,OAAO,6BAA6B,MAAM;UAC1C,SAAS,6BAA6B,QAAQ;UAC9C,WAAW,6BAA6B,UAAU;;AAGtD,uCAA+BD,oCAAmC,2BAA2B,OAAO;;AAGxG,4CAAsC,IAAI,2BAA2B,4BAA4B;AAEjG,UAAI,CAAC,8CAA8C;AAC/C,cAAME,kBAAiB,2BAA2B,MAAM,QAAQ,6BAA6B,MAAM;AACnG,cAAMA,kBAAiB,2BAA2B,MAAM,MAAM,6BAA6B,IAAI;AAC/F,cAAMA,kBAAiB,2BAA2B,MAAM,OAAO,6BAA6B,KAAK;AACjG,cAAMA,kBAAiB,2BAA2B,MAAM,SAAS,6BAA6B,OAAO;AACrG,cAAMA,kBAAiB,2BAA2B,MAAM,WAAW,6BAA6B,SAAS;aACtG;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,QAAQ,6BAA6B,MAAM;AACpG,cAAMA,mBAAkB,2BAA2B,MAAM,MAAM,6BAA6B,IAAI;AAChG,cAAMA,mBAAkB,2BAA2B,MAAM,OAAO,6BAA6B,KAAK;AAClG,cAAMA,mBAAkB,2BAA2B,MAAM,SAAS,6BAA6B,OAAO;AACtG,cAAMA,mBAAkB,2BAA2B,MAAM,WAAW,6BAA6B,SAAS;;AAG9G,YAAMI,yBAAwB,OAAO,2BAA2B,4BAA4B;AAE5F,aAAO;IACX;AAEA,WAAO;MACH,OACI,OACA,2BAAqD;AAErD,cAAM,uCAAuC,sCAAsC,IAAI,yBAAyB;AAEhH,YAAI,yCAAyC,QAAW;AACpD,iBAAO,QAAQ,QAAQ,oCAAoC;;AAG/D,eAAO,6BAA6B,OAAO,yBAAyB;MACxE;;EAER;AACJ;;;AC3EO,IAAM,sBAA6C,MAAM,IAAI,aAAa,IAAI,eAAe;;;ACA7F,IAAM,uBAA+C,CAACC,YAAU;AACnE,SAAO,CAAC,WACJ,IAAI,QAAQ,CAAC,SAAS,WAAU;AAC5B,QAAIA,YAAW,MAAM;AAEjB,aAAO,IAAI,YAAW,CAAE;AAExB;;AAGJ,UAAM,OAAOA,QAAO,SAAS;AAE7B,QAAI,SAAS,MAAM;AAEf,aAAO,IAAI,YAAW,CAAE;WACrB;AACH,YAAM,SAASA,QAAO,SAAS,cAAc,QAAQ;AAErD,YAAM,OAAO,IAAI,KAAK,CAAC,MAAM,GAAG,EAAE,MAAM,yBAAwB,CAAE;AAClE,YAAM,MAAM,IAAI,gBAAgB,IAAI;AAEpC,YAAM,yBAAyBA,QAAO;AAEtC,YAAM,uCAAuC,MAAK;AAC9C,QAAAA,QAAO,UAAU;AAEjB,YAAI,gBAAgB,GAAG;MAC3B;AAEA,MAAAA,QAAO,UAAU,CAAC,SAAS,KAAK,QAAQ,OAAO,UAAS;AAEpD,YAAI,QAAQ,OAAQ,QAAQA,QAAO,SAAS,QAAQ,WAAW,KAAK,UAAU,GAAI;AAC9E,+CAAoC;AACpC,iBAAO,KAAK;AAEZ,iBAAO;;AAGX,YAAI,2BAA2B,MAAM;AACjC,iBAAO,uBAAuB,SAAS,KAAK,QAAQ,OAAO,KAAK;;MAExE;AAEA,aAAO,UAAU,MAAK;AAClB,6CAAoC;AAEpC,eAAO,IAAI,YAAW,CAAE;MAC5B;AACA,aAAO,SAAS,MAAK;AACjB,6CAAoC;AACpC,gBAAO;MACX;AACA,aAAO,MAAM;AACb,aAAO,OAAO;AAEd,WAAK,YAAY,MAAM;;EAE/B,CAAC;AACT;;;ACzDO,IAAM,+BAA+D,CAACC,uBAAqB;AAC9F,SAAO,MAAM,YAAW;IAGpB,YAAoB,oBAAsC;AAAtC,WAAA,qBAAA;AAChB,WAAK,aAAa,oBAAI,QAAO;IACjC;IAEO,iBACH,MACA,UACA,SAA2C;AAE3C,UAAI,aAAa,MAAM;AACnB,YAAI,uBAAuB,KAAK,WAAW,IAAI,QAAQ;AAEvD,YAAI,yBAAyB,QAAW;AACpC,iCAAuBA,mBAAkB,MAAM,QAAQ;AAEvD,cAAI,OAAO,aAAa,YAAY;AAChC,iBAAK,WAAW,IAAI,UAAU,oBAAoB;;;AAI1D,aAAK,mBAAmB,iBAAiB,MAAM,sBAAsB,OAAO;;IAEpF;IAEO,cAAc,OAAY;AAC7B,aAAO,KAAK,mBAAmB,cAAc,KAAK;IACtD;IAEO,oBACH,MACA,UACA,SAAwC;AAExC,YAAM,uBAAuB,aAAa,OAAO,SAAY,KAAK,WAAW,IAAI,QAAQ;AAEzF,WAAK,mBAAmB,oBAAoB,MAAM,yBAAyB,SAAY,OAAO,sBAAsB,OAAO;IAC/H;;AAER;;;AC3CO,IAAM,yCAAmF,CAACC,YAAU;AACvG,SAAO,CAAC,aAAa,YAAY,OAAM;AACnC,WAAO,iBAAiBA,SAAQ;MAC5B,cAAc;QACV,cAAc;QACd,MAAG;AACC,iBAAO,KAAK,MAAM,cAAc,UAAU;QAC9C;;MAEJ,aAAa;QACT,cAAc;QACd,MAAG;AACC,iBAAO;QACX;;KAEP;AAED,QAAI;AACA,aAAO,GAAE;;AAET,UAAIA,YAAW,MAAM;AACjB,eAAaA,QAAQ;AACrB,eAAaA,QAAQ;;;EAGjC;AACJ;;;AC1BO,IAAM,oBAAyC,CAACC,sBAAoB;AACvE,SAAO,OAAO,QAAO;AACjB,QAAI;AACA,YAAM,WAAW,MAAM,MAAM,GAAG;AAEhC,UAAI,SAAS,IAAI;AACb,eAAO,CAAC,MAAM,SAAS,KAAI,GAAI,SAAS,GAAG;;YAE3C;;AAIR,UAAMA,kBAAgB;EAC1B;AACJ;;;ACZA,IAAMC,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,MAAM;;AAGH,IAAM,4BAAyD,CAClEC,uBACAC,mBACAC,yBACAC,uBACAC,mBACAC,iCACA;AACA,SAAO,MAAM,iBAAqCL,sBAAuB;IAGrE,YAAYM,UAAY,SAA+B;AACnD,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGP,mBAAiB,GAAG,QAAO;AACtD,YAAM,iBAAiBI,sBAAqB,eAAe,aAAa;AACxE,YAAM,YAAYE,6BAA4B,aAAa;AAC3D,YAAM,mBAAiD,YAAYH,wBAAsB,IAAK;AAE9F,YAAMI,UAAS,OAAO,gBAAgB,gBAAgB;AAGtD,WAAK,QAAQL,kBAAiB,MAAM,WAAW,eAAe,MAAM,4BAA4B,0BAA0B;IAC9H;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK;IAChB;;AAER;;;ACnCO,IAAM,gCAAiE,CAC1EM,oBACAC,uBACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,0BAA0B,oBAAI,QAAO;AAE3C,UAAM,iBAAiB,OAAO,OAAqB,8BAAyD;AACxG,UAAI,iBAAiBF,oBAAuC,KAAK;AAGjE,YAAM,iCAAiC,iBAAiB,gBAAgB,yBAAyB;AAEjG,UAAI,CAAC,gCAAgC;AACjC,cAAM,UAAU;UACZ,cAAc,eAAe;UAC7B,kBAAkB,eAAe;UACjC,uBAAuB,eAAe;UACtC,MAAM,eAAe,KAAK;;AAG9B,yBAAiBD,sBAAqB,2BAA2B,OAAO;;AAG5E,8BAAwB,IAAI,2BAA2B,cAAc;AAErE,UAAI,CAAC,gCAAgC;AACjC,cAAME,kBAAiB,2BAA2B,MAAM,MAAM,eAAe,IAAI;aAC9E;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,MAAM,eAAe,IAAI;;AAGtF,YAAMI,yBAAwB,OAAO,2BAA2B,cAAc;AAE9E,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAAqB,2BAAqD;AAC7E,cAAM,yBAAyB,wBAAwB,IAAI,yBAAyB;AAEpF,YAAI,2BAA2B,QAAW;AACtC,iBAAO,QAAQ,QAAQ,sBAAsB;;AAGjD,eAAO,eAAe,OAAO,yBAAyB;MAC1D;;EAER;AACJ;;;ACtDO,IAAM,wCAAiF,CAC1FC,oCACAC,oBACA;AACA,SAAO,CAAqB,2BACUA,gBAAeD,oCAAmC,sBAAsB;AAClH;;;ACLO,IAAM,6BAA2D,CAACE,6BAA2B;AAChG,SAAO,CACH,cACsC;AACtC,UAAM,uBAAuBA,yBAAwB,SAAS;AAE9D,QAAI,qBAAqB,aAAa,MAAM;AACxC,YAAM,IAAI,MAAM,iEAAiE;;AAGrF,WAA6C,qBAAqB;EACtE;AACJ;;;ACbO,IAAM,6BAA2D,CAACC,4BAA0B;AAC/F,SAAO,CAAC,cAAa;AAAA,QAAA;AAAC,YAAA,KAAAA,wBAAuB,IAAI,SAAS,OAAC,QAAA,OAAA,SAAA,KAAI;EAAC;AACpE;;;ACDO,IAAM,8BAA6D,CAACC,8BAA4B;AACnG,SAAO,CAAC,eAAc;AAClB,UAAM,wBAAwBA,0BAAsD,UAAU;AAE9F,QAAI,sBAAsB,aAAa,MAAM;AACzC,YAAM,IAAI,MAAM,kEAAkE;;AAGtF,WAAO,sBAAsB;EACjC;AACJ;;;ACXO,IAAM,qCAA2E,CAACC,oCAAkC;AACvH,SAAO,CAAC,kBAAiB;AACrB,WAAOA,gCAA+B,IAAI,aAAa;EAC3D;AACJ;;;ACJO,IAAM,0BAAqD,MAAM,IAAI,aAAa,IAAI,mBAAmB;;;ACEzG,IAAM,yBAAmD,CAAC,iBAAgB;AAC7E,SAAO,CACHC,aACiH;AACjH,UAAM,gBAAgB,aAAa,IAAIA,QAAO;AAE9C,QAAI,kBAAkB,QAAW;AAC7B,YAAM,wBAAuB;;AAGjC,WACI;EAER;AACJ;;;AChBO,IAAM,6CAA2F,CACpGC,iCACAC,0CACA;AACA,SAAO,CAAC,kBAAiB;AACrB,QAAI,4BAA4BD,gCAA+B,IAAI,aAAa;AAEhF,QAAI,8BAA8B,QAAW;AACzC,aAAO;;AAGX,QAAIC,0CAAyC,MAAM;AAC/C,YAAM,IAAI,MAAM,qDAAqD;;AAIzE,gCAA4B,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAEhF,IAAAD,gCAA+B,IAAI,eAAe,yBAAyB;AAE3E,WAAO;EACX;AACJ;;;ACtBO,IAAM,uCAA+E,CAACE,qCAAmC;AAC5H,SAAO,CAAC,kBAAiB;AACrB,UAAM,8BAA8BA,iCAAgC,IAAI,aAAa;AAErF,QAAI,gCAAgC,QAAW;AAC3C,YAAM,IAAI,MAAM,8CAA8C;;AAGlE,WAAO;EACX;AACJ;;;ACVO,IAAM,2BAAuD,MAAM,IAAI,aAAa,IAAI,oBAAoB;;;ACC5G,IAAM,8CAA8C,CAAC,wBAAmD;AAC3G,sBAAoB,wBAAwB,CAAC,yBAAwB;AACjE,WAAO,CAAC,aAA2B,aAA2B,kBAA+B;AACzF,UAAI,YAAY,WAAW,YAAY,UAAU,YAAY,WAAW,cAAc,QAAQ;AAC1F,cAAM,yBAAwB;;AAGlC,aAAO,qBAAqB,KAAK,qBAAqB,aAAa,aAAa,aAAa;IACjG;EACJ,GAAG,oBAAoB,oBAAoB;AAC/C;;;ACTA,IAAMC,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;;AAGpB,IAAM,iCAAmE,CAC5EC,uBACAC,4BACAC,8BACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,sBAA0CL,sBAAuB;IAG1E,YACIM,UACA,SAAgI;AAEhI,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,YAAYF,6BAA4B,aAAa;AAC3D,YAAM,gBAAgB,EAAE,GAAGL,mBAAiB,GAAG,QAAO;AACtD,YAAM,sBAAsBE,2BACxB,eACA,YAAY,OAAoCK,SAAU,aAC1D,aAAa;AAEjB,YAAM,wBACD,YAAYJ,6BAA4B,cAAc,UAAU,cAAc,WAAW,IAAI;AAGlG,YAAMI,UAAS,OAAO,qBAAqB,qBAAqB;AAIhE,kDAA4C,mBAAmB;AAE/D,WAAK,uBAAuB;AAG5B,MAAAD,sBAAqB,MAAM,CAAC;IAChC;IAEO,qBAAqB,aAA2B,aAA2B,eAA2B;AACzG,aAAO,KAAK,qBAAqB,qBAAqB,aAAa,aAAa,aAAa;IACjG;;AAER;;;AClDO,IAAM,eAAe,CACxB,UACA,gBACA,aACA,mBACA,WACA,SACA,SACA,aACA,cACA,OACA,WACA;AACA,QAAM,cAAc,MAAM;AAE1B,MAAI,IAAI;AAER,WAAS,IAAI,GAAG,IAAI,aAAa,KAAK,GAAG;AACrC,QAAI,IAAI,YAAY,CAAC,IAAI,MAAM,CAAC;AAEhC,aAAS,IAAI,GAAG,IAAI,WAAW,KAAK,GAAG;AACnC,YAAM,IAAK,IAAI,IAAM,eAAe;AAEpC,WAAK,YAAY,CAAC,IAAI,QAAQ,CAAC;AAC/B,WAAK,SAAS,CAAC,IAAI,QAAQ,CAAC;;AAGhC,aAAS,IAAI,WAAW,IAAI,mBAAmB,KAAK,GAAG;AACnD,WAAK,YAAY,CAAC,IAAI,QAAS,IAAI,IAAM,eAAe,CAAE;;AAG9D,aAAS,IAAI,WAAW,IAAI,gBAAgB,KAAK,GAAG;AAChD,WAAK,SAAS,CAAC,IAAI,QAAS,IAAI,IAAM,eAAe,CAAE;;AAG3D,YAAQ,CAAC,IAAI,MAAM,CAAC;AACpB,YAAQ,CAAC,IAAI;AAEb,QAAK,IAAI,IAAM,eAAe;AAE9B,WAAO,CAAC,IAAI;;AAGhB,SAAO;AACX;;;ACpCA,IAAM,mBAAmB,CACrB,gBACA,2BACA,UACA,gBACA;AACA,QAAM,oBAAoB,oBAAoB,eAAe,WAAW,IAAI,aAAa,QAAQ;AACjG,QAAM,uBAAuB,uBAAuB,eAAe,cAAc,IAAI,aAAa,WAAW;AAC7G,QAAM,iBAAiB,kBAAkB;AACzC,QAAM,oBAAoB,qBAAqB;AAC/C,QAAM,YAAY,KAAK,IAAI,gBAAgB,iBAAiB;AAE5D,MAAI,kBAAkB,CAAC,MAAM,GAAG;AAC5B,aAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK,GAAG;AACxC,2BAAqB,CAAC,KAAK,kBAAkB,CAAC;;AAGlD,aAAS,IAAI,GAAG,IAAI,mBAAmB,KAAK,GAAG;AAC3C,wBAAkB,CAAC,KAAK,kBAAkB,CAAC;;;AAInD,QAAM,eAAe;AACrB,QAAM,UAAU,IAAI,aAAa,YAAY;AAC7C,QAAM,UAAU,IAAI,aAAa,YAAY;AAE7C,QAAM,iBAAiB,0BAA0B,aAC7C,eAAe,kBACf,eAAe,QACf,eAAe,UAAU;AAG7B,QAAM,mBAAmB,eAAe;AAExC,WAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK,GAAG;AAC1C,UAAM,QAAQ,eAAe,eAAe,CAAC;AAC7C,UAAM,SAAS,eAAe,eAAe,CAAC;AAE9C,YAAQ,KAAK,CAAC;AACd,YAAQ,KAAK,CAAC;AAEd,iBACI,mBACA,gBACA,sBACA,mBACA,WACA,SACA,SACA,GACA,cACA,OACA,MAAM;;AAId,SAAO;AACX;AAEO,IAAM,qCAA2E,CACpFE,oCACAC,qBACAC,uCACAC,0BACAC,qCACA;AACA,SAAO,CAA+D,UAA4B,gBAAiC;AAC/H,UAAM,2BAA2B,oBAAI,QAAO;AAE5C,QAAI,wBAAmE;AAEvE,UAAM,kBAAkB,OAAO,OAA0B,8BAAyD;AAC9G,UAAI,8BAAmE;AACvE,UAAI,sBAAsBH,oBAA4C,KAAK;AAG3E,YAAM,sCAAsC,iBAAiB,qBAAqB,yBAAyB;AAG3G,UAAI,0BAA0B,oBAAoB,QAAW;AACzD,sCAA8BD,mCAAkC,2BAA2B;UACvF,QAAQ;UACR,cAAc;UACd,kBAAkB;UAClB,uBAAuB;UACvB,MAAM;UACN,SAAS;UACT,WAAW;UACX,cAAc;SACjB;iBACM,CAAC,qCAAqC;AAE7C,8BAAsB,0BAA0B,gBAA0B,aAAuB,QAAQ;;AAG7G,+BAAyB,IACrB,2BACA,gCAAgC,OAAO,sBAAsB,2BAA2B;AAG5F,UAAI,gCAAgC,MAAM;AACtC,YAAI,0BAA0B,MAAM;AAChC,cAAIE,0CAAyC,MAAM;AAC/C,kBAAM,IAAI,MAAM,qDAAqD;;AAGzE,gBAAM,6BAA6B,IAAIA;;YAEnC,MAAM,QAAQ,YAAY;;YAE1B,MAAM,QAAQ;YACd,0BAA0B;UAAU;AAGxC,mCAAyB,YAAW;AAChC,kBAAMC,yBAAwB,OAAO,4BAA4B,2BAA2B,WAAW;AAEvG,kBAAM,iBAAiB,MAAMC,iCAAgC,0BAA0B;AAEvF,mBAAO,iBAAiB,gBAAgB,2BAA2B,UAAU,WAAW;UAC5F,GAAE;;AAGN,cAAM,iBAAiB,MAAM;AAE7B,oCAA4B,SAAS;AACrC,oCAA4B,MAAM,CAAC;AAEnC,eAAO;;AAGX,YAAMD,yBAAwB,OAAO,2BAA2B,mBAAmB;AAEnF,aAAO;IACX;AAEA,WAAO;MACH,OACI,OACA,2BAAqD;AAErD,cAAM,0BAA0B,yBAAyB,IAAI,yBAAyB;AAEtF,YAAI,4BAA4B,QAAW;AACvC,iBAAO,QAAQ,QAAQ,uBAAuB;;AAGlD,eAAO,gBAAgB,OAAO,yBAAyB;MAC3D;;EAER;AACJ;;;AC/JO,IAAM,qCAA2E,CACpF,eACAE,+CACAC,0BACAC,qBACAC,sBACAC,uBACA;AACA,SAAO,CAAC,cAAa;AACjB,WAAO,CAAC,WAAW,UAAS;AACxB,YAAM,eAAe,cAAc,IAAI,SAAS;AAEhD,UAAI,iBAAiB,QAAW;AAC5B,YAAI,CAAC,aAAaA,mBAAkB,SAAS,GAAG;AAC5C,gBAAM,wBAAwBF,oBAAmB,SAAS;AAC1D,gBAAM,EAAE,QAAO,IAAKD,yBAAwB,SAAS;AAErD,qBAAW,UAAU,SAAS;AAC1B,gBAAI,4BAA4B,MAAM,GAAG;AACrC,oBAAM,6BAA6BC,oBAAmB,OAAO,CAAC,CAAC;AAE/D,cAAAF,8CACI,uBACA,4BACA,OAAO,CAAC,GACR,OAAO,CAAC,CAAC;mBAEV;AACH,oBAAM,8BAA8BG,qBAAoB,OAAO,CAAC,CAAC;AAEjE,oCAAsB,WAAW,6BAA6B,OAAO,CAAC,CAAC;;;;AAKnF,sBAAc,IAAI,WAAW,KAAK;aAC/B;AACH,sBAAc,IAAI,WAAW,eAAe,KAAK;;IAEzD;EACJ;AACJ;;;ACzCO,IAAM,0BAAqD,CAAC,cAAcE,0BAAwB;AACrG,SAAO,CAAC,aAAoF;AACxF,UAAM,gBAAgB,aAAa,IAAS,QAAQ;AAEpD,WAAOA,sBAAqB,aAAa,KAAKA,sBAAqB,QAAQ;EAC/E;AACJ;;;ACNO,IAAM,uBAA+C,CAAC,gBAAgBC,uBAAqB;AAC9F,SAAO,CAAC,aAA6D,eAAe,IAAS,QAAQ,KAAKA,mBAAkB,QAAQ;AACxI;;;ACFO,IAAM,wBAAiD,CAAC,iBAAiBC,wBAAsB;AAClG,SAAO,CAAC,aAA0D,gBAAgB,IAAS,QAAQ,KAAKA,oBAAmB,QAAQ;AACvI;;;ACFO,IAAM,iCAAmE,CAAC,cAAcC,iCAA+B;AAC1H,SAAO,CAAC,aAAyG;AAC7G,UAAM,gBAAgB,aAAa,IAAS,QAAQ;AAEpD,WAAOA,6BAA4B,aAAa,KAAKA,6BAA4B,QAAQ;EAC7F;AACJ;;;ACPO,IAAM,6BAA2D,CAACC,mCAAiC;AACtG,SAAO,CAAC,aAA6C;AACjD,WAAOA,mCAAkC,QAAQ,oBAAoBA;EACzE;AACJ;;;ACJO,IAAM,0BAAqD,CAACC,YAAU;AACzE,SAAO,CAAC,aAA0C;AAC9C,WAAOA,YAAW,QAAQ,OAAOA,QAAO,cAAc,cAAc,oBAAoBA,QAAO;EACnG;AACJ;;;ACJO,IAAM,2BAAuD,CAACC,YAAU;AAC3E,SAAO,CAAC,aAA2C;AAC/C,WAAOA,YAAW,QAAQ,OAAOA,QAAO,eAAe,cAAc,oBAAoBA,QAAO;EACpG;AACJ;;;ACJO,IAAM,wBAAiD,CAACC,uBAAsBC,iCAA+B;AAChH,SAAO,CAAC,aAA6C;AACjD,WAAOD,sBAAqB,QAAQ,KAAKC,6BAA4B,QAAQ;EACjF;AACJ;;;ACJO,IAAM,oCAAyE,CAACC,0CAAwC;AAC3H,SAAO,CAAC,aAAoD;AACxD,WAAOA,0CAAyC,QAAQ,oBAAoBA;EAChF;AACJ;;;ACJO,IAAM,wBAAiD,CAACC,YAAWA,YAAW,QAAQA,QAAO;;;ACA7F,IAAM,2BAAuD,OAChEC,kBACA,kDACA,oCACA,uDACA,gCACA,mCACA,2CACA,0CACA,iDACA,+CACA,sCACA,kCACA,4BACA,mEACA,yCACAC,8BACA;AACA,MACID,iBAAgB,kDAAkD,gDAAgD,KAClHA,iBAAgB,oCAAoC,kCAAkC,KACtFA,iBAAgB,gCAAgC,8BAA8B,KAC9EA,iBAAgB,mCAAmC,iCAAiC,KACpFA,iBAAgB,0CAA0C,wCAAwC,KAClGA,iBAAgB,iDAAiD,+CAA+C,KAChHA,iBAAgB,+CAA+C,6CAA6C,KAC5GA,iBAAgB,sCAAsC,oCAAoC,KAC1FA,iBAAgB,kCAAkC,gCAAgC,KAClFA,iBAAgB,4BAA4B,0BAA0B,KACtEA,iBACI,mEACA,iEAAiE,GAEvE;AACE,UAAM,UAAU,MAAM,QAAQ,IAAI;MAC9BA,iBAAgB,uDAAuD,qDAAqD;MAC5HA,iBAAgB,2CAA2C,yCAAyC;MACpGA,iBAAgB,yCAAyC,uCAAuC;MAChGA,iBAAgBC,2BAA0BA,yBAAwB;KACrE;AAED,WAAO,QAAQ,MAAM,CAAC,WAAW,MAAM;;AAG3C,SAAO;AACX;;;AC5CO,IAAM,+CAA+F,CACxGC,uBACAC,0CACAC,mBACAC,iCACA;AACA,SAAO,MAAM,oCAAoFH,sBAAuB;IAIpH,YAAYI,UAAY,SAAwC;AAC5D,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,oCAAoCH,yCAAwC,eAAe,OAAO;AAGxG,UAAIE,6BAA4B,aAAa,GAAG;AAC5C,cAAM,UAAS;;AAGnB,YAAMC,UAAS,MAAM,mCAA0D,IAAI;AAEnF,WAAK,qCAAqC;IAC9C;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK,mCAAmC;IACnD;;AAER;;;AC5BA,IAAMC,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;;AAGpB,IAAM,mDAAuG,CAChHC,uBACAC,8CACAC,mBACAC,iCACA;AACA,SAAO,MAAM,wCAAwFH,sBAAuB;IAIxH,YAAYI,UAAY,SAAoC;AACxD,YAAM,gBAAgBF,kBAAiBE,QAAO;AAG9C,UAAID,6BAA4B,aAAa,GAAG;AAC5C,cAAM,IAAI,UAAS;;AAGvB,YAAM,gBAAgB,EAAE,GAAGJ,mBAAiB,GAAG,QAAO;AACtD,YAAM,wCAAwCE,6CAA4C,eAAe,aAAa;AAEtH,YAAMG,UAAS,OAAO,uCAA8D,IAAI;AAExF,WAAK,yCAAyC;IAClD;IAEA,IAAI,SAAM;AACN,aAAO,KAAK,uCAAuC;IACvD;;AAER;;;ACpCO,IAAM,8CAA6F,CACtGC,uBACAC,yCACAC,mBACAC,iCACA;AACA,SAAO,MAAM,mCAAmFH,sBAAuB;IAInH,YAAYI,UAAY,SAAuC;AAC3D,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,mCAAmCH,wCAAuC,eAAe,OAAO;AAGtG,UAAIE,6BAA4B,aAAa,GAAG;AAC5C,cAAM,IAAI,UAAS;;AAGvB,YAAMC,UAAS,MAAM,kCAAyD,IAAI;AAElF,WAAK,oCAAoC;IAC7C;IAEA,IAAI,cAAW;AACX,aAAO,KAAK,kCAAkC;IAClD;;AAER;;;AC5BO,IAAM,mDAAuG,CAChHC,uBACAC,8CACAC,sBACA;AACA,SAAO,MAAM,wCAAwFF,sBAAuB;IAExH,YAAYG,UAAY,SAA4C;AAChE,YAAM,gBAAgBD,kBAAiBC,QAAO;AAC9C,YAAM,wCAAwCF,6CAA4C,eAAe,OAAO;AAEhH,YAAME,UAAS,MAAM,uCAA8D,IAAI;IAC3F;;AAER;;;ACNO,IAAM,uCAA+E,CACxFC,0BACAC,0BACAC,qBACAC,qCACAC,mCACA;AACA,SAAO,MAAM,4BAA4BD,oCAAwD;IAW7F,YAAY,UAAgC,CAAA,GAAE;AAC1C,UAAIC,mCAAkC,MAAM;AACxC,cAAM,IAAI,MAAM,8CAA8C;;AAGlE,UAAI;AAEJ,UAAI;AACA,6BAAqB,IAAIA,+BAA8B,OAAO;eACzD,KAAK;AAEV,YAAI,IAAI,SAAS,MAAM,IAAI,YAAY,8BAA8B;AACjE,gBAAMH,yBAAuB;;AAGjC,cAAM;;AAIV,UAAI,uBAAuB,MAAM;AAC7B,cAAMC,oBAAkB;;AAI5B,UAAI,CAAC,mBAAmB,QAAQ,WAAW,GAAG;AAC1C,cAAM,IAAI,UACN,uBAAuB,QAAQ,WAAW,kEAAkE;;AAKpH,UAAI,QAAQ,eAAe,UAAa,mBAAmB,eAAe,QAAQ,YAAY;AAC1F,cAAMD,yBAAuB;;AAGjC,YAAM,oBAAoB,CAAC;AAE3B,YAAM,EAAE,YAAW,IAAK;AACxB,YAAM,EAAE,WAAU,IAAK;AAGvB,WAAK,eACD,OAAO,mBAAmB,gBAAgB,WACpC,mBAAmB,cACnB,gBAAgB,aAChB,MAAM,aACN,gBAAgB,iBAAiB,gBAAgB,SACjD,MAAM,aACN,gBAAgB,aAChB,OAAO;;;;;QAKN,KAAK,IAAI,GAAG,KAAK,IAAI,KAAK,KAAK,MAAO,cAAc,aAAc,GAAG,CAAC,CAAC,IAAI,MAAO;;AAC7F,WAAK,sBAAsB;AAG3B,UAAIG,+BAA8B,SAAS,sBAAsB;AAC7D,aAAK,kBAAkB,mBAAmB,WAAU;AACpD,aAAK,wBAAwB,mBAAmB,iBAAgB;AAEhE,aAAK,gBAAgB,KAAK,QAAQ;AAElC,aAAK,sBAAsB,QAAQ,KAAK,eAAe,EAAE,QAAQ,mBAAmB,WAAW;AAC/F,aAAK,sBAAsB,MAAK;aAC7B;AACH,aAAK,kBAAkB;AACvB,aAAK,wBAAwB;;AAGjC,WAAK,SAAS;AAMd,UAAI,mBAAmB,UAAU,WAAW;AACxC,aAAK,SAAS;AAEd,cAAM,cAAc,MAAK;AACrB,cAAI,KAAK,WAAW,aAAa;AAC7B,iBAAK,SAAS;;AAGlB,6BAAmB,oBAAoB,eAAe,WAAW;QACrE;AAEA,2BAAmB,iBAAiB,eAAe,WAAW;;IAEtE;IAEA,IAAI,cAAW;AACX,aAAO,KAAK;IAChB;IAEA,IAAI,QAAK;AACL,aAAO,KAAK,WAAW,OAAO,KAAK,SAAS,KAAK,oBAAoB;IACzE;IAEO,QAAK;AAER,UAAI,KAAK,UAAU,UAAU;AACzB,eAAO,KAAK,oBAAoB,MAAK,EAAG,KAAK,MAAK;AAC9C,gBAAMJ,yBAAuB;QACjC,CAAC;;AAIL,UAAI,KAAK,WAAW,aAAa;AAC7B,aAAK,SAAS;;AAGlB,aAAO,KAAK,oBAAoB,MAAK,EAAG,KAAK,MAAK;AAC9C,YAAI,KAAK,oBAAoB,QAAQ,KAAK,0BAA0B,MAAM;AACtE,eAAK,sBAAsB,KAAI;AAE/B,eAAK,gBAAgB,WAAU;AAC/B,eAAK,sBAAsB,WAAU;;AAGzC,6BAAqB,IAAI;MAC7B,CAAC;IACL;IAEO,SAAM;AACT,UAAI,KAAK,WAAW,aAAa;AAC7B,eAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,gBAAM,iBAAiB,MAAK;AACxB,iBAAK,oBAAoB,oBAAoB,eAAe,cAAc;AAE1E,gBAAI,KAAK,oBAAoB,UAAU,WAAW;AAC9C,sBAAO;mBACJ;AACH,mBAAK,OAAM,EAAG,KAAK,SAAS,MAAM;;UAE1C;AAEA,eAAK,oBAAoB,iBAAiB,eAAe,cAAc;QAC3E,CAAC;;AAGL,aAAO,KAAK,oBAAoB,OAAM,EAAG,MAAM,CAAC,QAAO;AAGnD,YAAI,QAAQ,UAAa,IAAI,SAAS,IAAI;AACtC,gBAAMA,yBAAuB;;AAGjC,cAAM;MACV,CAAC;IACL;IAEO,UAAO;AACV,aAAO,KAAK,oBAAoB,QAAO,EAAG,MAAM,CAAC,QAAO;AAEpD,YAAI,QAAQ,QAAW;AACnB,gBAAMA,yBAAuB;;AAGjC,cAAM;MACV,CAAC;IACL;;AAER;;;AC7LO,IAAM,2CAAuF,CAChGK,kCACAC,sBACAC,yBACAC,8BACAC,kCACAC,uBACA;AACA,SAAO,MAAM,gCACDH,wBAAwD;IAShE,YAAoB,gBAAgC,kBAAwB;AACxE,YAAM,cAAc;AADJ,WAAA,iBAAA;AAGhB,oBAAc,IAAiB,MAAO,cAAc;AAEpD,UAAIC,6BAA4B,cAAc,GAAG;AAC7C,QAAAC,iCAAgC,IAAI,gBAAgB,oBAAI,IAAG,CAAE;;AAGjE,WAAK,eAAe,IAAIJ,iCAA6C,MAAO,gBAAgB;AAC5F,WAAK,YAAYC,qBAAiC,MAAO,cAAc;AACvE,WAAK,iBAAiB;IAC1B;IAEA,IAAI,cAAW;AACX,aAAO,KAAK,eAAe;IAC/B;IAEA,IAAI,cAAW;AACX,aAAO,KAAK;IAChB;IAEA,IAAI,WAAQ;AACR,aAAO,KAAK;IAChB;IAEA,IAAI,gBAAa;AACb,aAAO,KAAK;IAChB;IAEA,IAAI,cAAc,OAAK;AACnB,YAAM,kBAAkB,OAAO,UAAU,aAAaI,mBAAkB,MAAM,KAAK,IAAI;AAEvF,WAAK,eAAe,gBAAgB;AAEpC,YAAM,sBAAsB,KAAK,eAAe;AAEhD,WAAK,iBAAiB,wBAAwB,QAAQ,wBAAwB,kBAAkB,QAAQ;IAC5G;IAEA,IAAI,aAAU;AACV,aAAO,KAAK,eAAe;IAC/B;IAEA,IAAI,QAAK;AACL,aAAO,KAAK,eAAe;IAC/B;;AAER;;;ACpEO,IAAM,qBAAqB,CAAC,kBAA0C;AAEzE,QAAM,cAAc,IAAI,YAAY,CAAC,YAAY,IAAI,YAAY,WAAW,IAAI,QAAQ,OAAO,QAAQ,SAAS,YAAY,GAAG,CAAC,CAAC;AAEjI,MAAI;AAEA,UAAM,UAAU,cAAc,gBAA6B,YAAY,QAAQ,MAAK;IAEpF,CAAC;AAED,QAAI,YAAY,QAAW;AACvB,aAAO;;AAGX,YAAQ,MAAM,MAAK;IAEnB,CAAC;AAED,WAAO;UACH;;AAIR,SAAO;AACX;;;ACrBA,IAAMC,oBAAkB;EACpB,kBAAkB;;AAGf,IAAM,8CAA6F,CACtGC,kBACAC,0BACAC,kCACAC,qCACAC,oBACA;AACA,SAAO,MAAM,mCAAmCD,oCAA+D;IAQ3G,YAAY,SAAoC;AAC5C,YAAM,EAAE,QAAQ,kBAAkB,WAAU,IAAK,EAAE,GAAGJ,mBAAiB,GAAG,QAAO;AAEjF,YAAM,4BAA4BG,iCAAgC,kBAAkB,QAAQ,UAAU;AAGtG,UAAI,CAACF,iBAAgB,oBAAoB,MAAM,mBAAmB,yBAAyB,CAAC,GAAG;AAC3F,kCAA0B,iBACtB,gBACC,MAAK;AACF,cAAI,IAAI;AAER,gBAAM,wBAAwB,CAAC,UAAgB;AAC3C,gBAAI,KAAK,WAAW,WAAW;AAC3B,kBAAI,IAAI,GAAG;AACP,0CAA0B,oBAAoB,eAAe,qBAAqB;AAClF,sBAAM,yBAAwB;AAE9B,qBAAK,2BAA2B,KAAK;qBAClC;AACH,qBAAK;;;UAGjB;AAEA,iBAAO;QACX,GAAE,CAAE;;AAIZ,YAAM,2BAA2B,gBAAgB;AAEjD,WAAK,UAAU;AACf,WAAK,6BAA6B;AAClC,WAAK,SAAS;IAClB;IAEA,IAAI,SAAM;AAEN,UAAI,KAAK,2BAA2B,WAAW,QAAW;AACtD,eAAO,KAAK;;AAGhB,aAAO,KAAK,2BAA2B;IAC3C;IAEA,IAAI,QAAK;AACL,aAAO,KAAK,WAAW,OAAO,KAAK,2BAA2B,QAAQ,KAAK;IAC/E;IAEO,iBAAc;AAKjB,UAAI,KAAK,WAAW,WAAW;AAC3B,eAAO,QAAQ,OAAOC,yBAAuB,CAAE;;AAGnD,WAAK,SAAS;AAEd,aAAOG,gBAAe,KAAK,aAAa,KAAK,0BAA0B,EAAE,QAAQ,MAAK;AAClF,aAAK,SAAS;AAEd,6BAAqB,IAAI;MAC7B,CAAC;IACL;IAEQ,2BAA2B,OAAY;AAC3C,UAAI,KAAK,WAAW,MAAM;AACtB,aAAK,2BAA2B,cAAc,KAAK;aAChD;AACH,mBAAW,MAAM,KAAK,2BAA2B,KAAK,CAAC;;IAE/D;;AAER;;;AClGO,IAAM,2BAAuD,CAACC,qBAAoBC,uBAAqB;AAC1G,SAAO,CAAC,iBAAiB,eAAe,qBAAoB;AACxD,UAAM,cAAc,oBAAI,IAAG;AAE3B,oBAAgB,WAAwC,CAACC,aAAW;AAEhE,aAAO,CAAC,aAAmD,SAAS,GAAG,QAAgB,MAA8B;AACjH,cAAM,kBAAkB,YAAY,SAAS;AAE7C,YAAID,mBAAkB,WAAW,GAAG;AAEuD,UAAAC,SAAS,KAC5F,iBACA,aACA,QACA,KAAK;AAGT,UAAAF,oBACI,aACA,CAAC,aAAa,QAAQ,KAAK,GAC3B,CAAC,eAAe,WAAW,CAAC,MAAM,eAAe,WAAW,CAAC,MAAM,UAAU,WAAW,CAAC,MAAM,OAC/F,IAAI;AAGR,cAAI,iBAAiB;AACjB,0BAAa;;AAGjB,iBAAO;;AAGX,QAAAE,SAAQ,KAAK,iBAAiB,aAAa,MAAM;AAEjD,QAAAF,oBACI,aACA,CAAC,aAAa,MAAM,GACpB,CAAC,eAAe,WAAW,CAAC,MAAM,eAAe,WAAW,CAAC,MAAM,QACnE,IAAI;AAGR,YAAI,iBAAiB;AACjB,wBAAa;;AAGjB;MACJ;IACJ,GAAG,gBAAgB,OAAO;AAE1B,oBAAgB,cAAc,CAACG,gBAAc;AACzC,aAAO,CAAC,qBAAqE,QAAiB,UAAwB;AAClH,cAAM,eAAe,YAAY,OAAO;AAExC,YAAI,wBAAwB,QAAW;AACnC,UAAAA,YAAW,MAAM,eAAe;AAEhC,sBAAY,MAAK;mBACV,OAAO,wBAAwB,UAAU;AAErB,UAAAA,YAAY,KAAK,iBAAiB,mBAAmB;AAEhF,qBAAW,cAAc,aAAa;AAClC,gBAAI,WAAW,CAAC,MAAM,qBAAqB;AACvC,0BAAY,OAAO,UAAU;;;eAGlC;AACH,cAAIF,mBAAkB,mBAAmB,GAAG;AAEmC,YAAAE,YAAY,KACnF,iBACA,qBACA,QACA,KAAK;iBAEN;AAEyD,YAAAA,YAAY,KACpE,iBACA,qBACA,MAAM;;AAId,qBAAW,cAAc,aAAa;AAClC,gBACI,WAAW,CAAC,MAAM,wBACjB,WAAW,UAAa,WAAW,CAAC,MAAM,YAC1C,UAAU,UAAa,WAAW,CAAC,MAAM,QAC5C;AACE,0BAAY,OAAO,UAAU;;;;AAKzC,cAAM,iBAAiB,YAAY,SAAS;AAE5C,YAAI,gBAAgB,gBAAgB;AAChC,2BAAgB;;MAExB;IACJ,GAAG,gBAAgB,UAAU;AAE7B,WAAO;EACX;AACJ;;;AC3GO,IAAM,8BAA8B,CACvC,iBACA,SACA,WACA;AACA,QAAM,QAAQ,QAAQ,MAAM;AAE5B,MAAI,UAAU,UAAa,UAAU,gBAAgB,MAAM,GAAG;AAC1D,oBAAgB,MAAM,IAAI;;AAElC;;;ACNO,IAAM,+BAA+B,CAAC,iBAAmC,YAAoC;AAChH,8BAA4B,iBAAiB,SAAS,cAAc;AACpE,8BAA4B,iBAAiB,SAAS,kBAAkB;AACxE,8BAA4B,iBAAiB,SAAS,uBAAuB;AACjF;;;ACNO,IAAM,sDAAsD,CAAC,uBAAoD;AACpH,SAAO,OAAO,mBAAmB,2BAA2B;AAChE;;;ACFO,IAAM,+CAA+C,CAAC,uBAAiD;AAC1G,qBAAmB,yBAAyB,CAAC,UAAuB;AAChE,UAAM,qBAAqB,IAAI,WAAW,MAAM,MAAM;AAEtD,uBAAmB,sBAAsB,kBAAkB;AAE3D,UAAM,SAAS,KAAK,IAAI,mBAAmB,QAAQ,mBAAmB,OAAO;AAE7E,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,YAAM,CAAC,KAAK,mBAAmB,CAAC,IAAI,OAAO;;AAG/C,WAAO;EACX;AACJ;;;ACVO,IAAM,kCAAqE,CAACC,kBAAiBC,0BAAwB;AACxH,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,qBAAqB,cAAc,eAAc;AAGvD,iCAA6B,oBAAoB,OAAO;AAGxD,QAAI,EAAE,QAAQ,cAAc,QAAQ,cAAc;AAC9C,YAAMA,sBAAoB;;AAG9B,gCAA4B,oBAAoB,SAAS,SAAS;AAClE,gCAA4B,oBAAoB,SAAS,aAAa;AACtE,gCAA4B,oBAAoB,SAAS,aAAa;AACtE,gCAA4B,oBAAoB,SAAS,uBAAuB;AAGhF,QACI,CAACD,iBAAgB,qDAAqD,MAClE,oDAAoD,kBAAkB,CAAC,GAE7E;AACE,mDAA6C,kBAAkB;;AAGnE,WAAO;EACX;AACJ;;;AChCO,IAAM,qCAA2E,CAACE,YAAU;AAC/F,MAAIA,YAAW,MAAM;AACjB,WAAO;;AAGX,MAAIA,QAAO,eAAe,aAAa,GAAG;AACtC,WAAOA,QAAO;;AAGlB,SAAO;AACX;;;ACZO,IAAM,uCAAuC,CAChD,iBACA,SACA,eACA;AACA,QAAM,QAAQ,QAAQ,UAAU;AAEhC,MAAI,UAAU,UAAa,UAAU,gBAAgB,UAAU,EAAE,OAAO;AACpE,oBAAgB,UAAU,EAAE,QAAQ;;AAE5C;;;ACPO,IAAM,uDAAuD,CAAC,gCAAmE;AACpI,8BAA4B,SAAS,CAACC,WAAS;AAC3C,QAAI,cAAc;AAElB,WAAO,CAAC,OAAO,GAAG,SAAS,GAAG,aAAqB;AAC/C,UAAI,aAAa;AACb,cAAM,wBAAuB;;AAGjC,MAAAA,OAAM,KAAK,6BAA6B,MAAM,QAAQ,QAAQ;AAE9D,oBAAc;IAClB;EACJ,GAAG,4BAA4B,KAAK;AACxC;;;ACfO,IAAM,4DAA4D,CACrE,mCACM;AACN,iCAA+B,SAAS,CAACC,WAAS;AAC9C,WAAO,CAAC,OAAO,GAAG,SAAS,GAAG,aAAqB;AAC/C,UAAK,OAAO,aAAa,YAAY,WAAW,KAAM,SAAS,KAAK,OAAO,GAAG;AAC1E,cAAM,IAAI,WAAW,mCAAmC;;AAIA,MAAAA,OAAO,KAAK,gCAAgC,MAAM,QAAQ,QAAQ;IAClI;EACJ,GAAG,+BAA+B,KAAK;AAC3C;;;ACbO,IAAM,2DAA2D,CACpE,mCACM;AACN,iCAA+B,QAAQ,CAAC,SAAQ;AAC5C,WAAO,CAAC,OAAO,MAAK;AAChB,UAAI,OAAO,GAAG;AACV,cAAM,IAAI,WAAW,kCAAkC;;AAG3D,WAAK,KAAK,gCAAgC,IAAI;IAClD;EACJ,GAAG,+BAA+B,IAAI;AAC1C;;;ACNO,IAAM,2CAAuF,CAChGC,sBACAC,kBACAC,8DACAC,4DACAC,4DACAC,mEACAC,gEACAC,kEACA,qDACA,oDACAC,4DACA;AACA,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,8BAA8B,cAAc,mBAAkB;AAEpE,iCAA6B,6BAA6B,OAAO;AAEjE,yCAAqC,6BAA6B,SAAS,cAAc;AAEzF,gCAA4B,6BAA6B,SAAS,QAAQ;AAI1E,gCAA4B,6BAA6B,SAAS,MAAM;AACxE,gCAA4B,6BAA6B,SAAS,SAAS;AAC3E,gCAA4B,6BAA6B,SAAS,WAAW;AAG7E,QACI,CAACP,iBAAgBC,8DAA6D,MAC1EA,6DAA4D,aAAa,CAAC,GAEhF;AACE,2DAAqD,2BAA2B;;AAIpF,QACI,CAACD,iBAAgBE,4DAA2D,MACxEA,2DAA0D,aAAa,CAAC,GAE9E;AACE,0DAAoD,2BAA2B;;AAInF,QACI,CAACF,iBAAgBG,4DAA2D,MACxEA,2DAA0D,aAAa,CAAC,GAE9E;AACE,yDAAmD,6BAA6B,aAAa;;AAIjG,QACI,CAACH,iBAAgBI,mEAAkE,MAC/EA,kEAAiE,aAAa,CAAC,GAErF;AACE,gEAA0D,2BAA2B;;AAIzF,QACI,CAACJ,iBAAgBK,gEAA+D,MAC5EA,+DAA8D,aAAa,CAAC,GAElF;AACE,MAAAE,wDAAuD,6BAA6B,aAAa;;AAIrG,QACI,CAACP,iBAAgBM,kEAAiE,MAC9EA,iEAAgE,aAAa,CAAC,GAEpF;AACE,+DAAyD,2BAA2B;;AAIxF,IAAAP,qBAAoB,eAAe,2BAA2B;AAE9D,WAAO;EACX;AACJ;;;AC7FO,IAAM,sCAA6E,CAACS,YAAU;AACjG,MAAIA,YAAW,MAAM;AACjB,WAAO;;AAGX,MAAIA,QAAO,eAAe,cAAc,GAAG;AACvC,WAAOA,QAAO;;AAGlB,SAAOA,QAAO,eAAe,oBAAoB,IAAUA,QAAQ,qBAAqB;AAC5F;;;ACVO,IAAM,0CAAqF,CAC9FC,uBACAC,wBACA;AACA,SAAO,CAAC,eAAe,cAAc,sCAAqC;AACtE,UAAM,6BAA6B,cAAc;AAGjD,QAAI,2BAA2B,iBAAiB,cAAc;AAC1D,UAAI;AACA,mCAA2B,eAAe;cACtC;;;AAMZ,QAAI,qCAAqC,2BAA2B,qBAAqB,YAAY;AACjG,iCAA2B,mBAAmB;;AAIlD,QAAI,2BAA2B,oBAAoB,GAAG;AAClD,aAAO,eAAe,4BAA4B,mBAAmB;QACjE,OAAO;OACV;;AAIL,UAAM,WAAWD,sBAAqB,eAAe;MACjD;MACA,kBAAkB,2BAA2B;MAC7C,uBAAuB,2BAA2B;MAClD,MAAM;KACT;AAED,IAAAC,oBACI,UACA,gBACA,CAAC,QAAQ,MAAM,IAAI,KAAK,QAAQ,GAChC,CAAC,QAAQ,CAAC,UAAS;AACf,UAAI,KAAK,UAAU,KAAK;AAExB,UAAI;AACA,mCAA2B,eAAe;eACrC,KAAK;AAEV,YAAI,QAAQ,2BAA2B,iBAAiB;AACpD,gBAAM;;;IAGlB,CAAC;AAGL,IAAAA,oBACI,UACA,oBACA,CAAC,QAAQ,MAAM,IAAI,KAAK,QAAQ,GAChC,CAAC,QAAQ,CAAC,UAAS;AACf,UAAI,KAAK,UAAU,KAAK;AACxB,iCAA2B,mBAAmB;IAClD,CAAC;AAGL,IAAAA,oBACI,UACA,yBACA,CAAC,QAAQ,MAAM,IAAI,KAAK,QAAQ,GAChC,CAAC,QAAQ,CAAC,UAAS;AACf,UAAI,KAAK,UAAU,KAAK;AACxB,iCAA2B,wBAAwB;IACvD,CAAC;AAGL,WAAO,eAAe,UAAU,mBAAmB;MAC/C,KAAK,MAAM,2BAA2B;KACzC;AAGD,aAAS,QAAQ,0BAA0B;AAE3C,WAA8F;EAClG;AACJ;;;ACnFO,IAAM,0CAAqF,CAACC,YAAU;AACzG,MAAIA,YAAW,MAAM;AACjB,WAAO;;AAGX,SAAOA,QAAO,eAAe,kBAAkB,IAAIA,QAAO,mBAAmB;AACjF;;;ACNO,IAAM,2CAA2C,CAAC,4BAA2D;AAChH,QAAM,EAAE,MAAK,IAAK,IAAI,eAAc;AAEpC,MAAI;AAEA,UAAM,YAAY,uBAAuB;;AAEzC,UAAM,MAAK;;AAEnB;;;ACRO,IAAM,sCAA6E,CACtFC,0BACAC,oCACAC,uBACAC,0BACAC,wBACA;AACA,SAAO,CAAC,eAAe,aAAaC,oCAAmC,MAAM,sBAAsB,YAAW;AAC1G,QAAIA,uCAAsC,MAAM;AAC5C,UAAI;AACA,cAAM,yBAAyB,IAAIA,mCAC/B,eACA,MACgC,OAAO;AAE3C,cAAM,wBAGF,oBAAI,IAAG;AAEX,YAAI,mBAAgE;AAEpE,eAAO,iBAAiB,wBAAwB;;;;;UAK5C,cAAc;YACV,KAAK,MAAM,QAAQ;YACnB,KAAK,MAAK;AACN,oBAAML,yBAAuB;YACjC;;UAEJ,kBAAkB;YACd,KAAK,MAAM;YACX,KAAK,MAAK;AACN,oBAAMA,yBAAuB;YACjC;;;UAGJ,kBAAkB;YACd,KAAK,MAAM;YACX,KAAK,CAAC,UAAS;AACX,kBAAI,OAAO,qBAAqB,YAAY;AACxC,uCAAuB,oBAAoB,kBAAkB,gBAAgB;;AAGjF,iCAAmB,OAAO,UAAU,aAAa,QAAQ;AAEzD,kBAAI,OAAO,qBAAqB,YAAY;AACxC,uCAAuB,iBAAiB,kBAAkB,gBAAgB;;YAElF;;SAEP;AAED,+BAAuB,oBAAoB,CAAC,qBAAoB;AAC5D,iBAAO,IAAI,SAAkG;AACzG,gBAAI,KAAK,CAAC,MAAM,kBAAkB;AAC9B,oBAAM,yBACF,OAAO,KAAK,CAAC,MAAM,aACb,KAAK,CAAC,IACN,OAAO,KAAK,CAAC,MAAM,YAAY,KAAK,CAAC,MAAM,QAAQ,OAAO,KAAK,CAAC,EAAE,gBAAgB,aAClF,KAAK,CAAC,EAAE,cACR;AAEV,kBAAI,2BAA2B,MAAM;AACjC,sBAAM,uBAAuB,sBAAsB,IAAI,KAAK,CAAC,CAAC;AAE9D,oBAAI,yBAAyB,QAAW;AACpC,uBAAK,CAAC,IAAI;uBACP;AACH,uBAAK,CAAC,IAAI,CAAC,UAAgB;AAEvB,wBAAI,MAAM,SAAS,SAAS;AACxB,6BAAO,iBAAiB,OAAO;wBAC3B,MAAM,EAAE,OAAO,iBAAgB;uBAClC;AAED,6CAAuB,KAAK;2BACzB;AACH,6CAAuB,IAAI,WAAW,KAAK,CAAC,GAAG,EAAE,GAAG,MAAK,CAAE,CAAC;;kBAEpE;AAEA,wCAAsB,IAAI,wBAAwB,KAAK,CAAC,CAAC;;;;AAMrE,6BAAiB,KAAK,wBAAwB,SAAS,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAEvE,mBAAO,iBAAiB,KAAK,wBAAwB,GAAG,IAAI;UAChE;QACJ,GAAG,uBAAuB,gBAAgB;AAE1C,+BAAuB,uBAAuB,CAAC,wBAAuB;AAClE,iBAAO,IAAI,SAAqB;AAC5B,gBAAI,KAAK,CAAC,MAAM,kBAAkB;AAC9B,oBAAM,uBAAuB,sBAAsB,IAAI,KAAK,CAAC,CAAC;AAE9D,kBAAI,yBAAyB,QAAW;AACpC,sCAAsB,OAAO,KAAK,CAAC,CAAC;AAEpC,qBAAK,CAAC,IAAI;;;AAKlB,gCAAoB,KAAK,wBAAwB,SAAS,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;AAE1E,mBAAO,oBAAoB,KAAK,wBAAwB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;UACrF;QACJ,GAAG,uBAAuB,mBAAmB;AAM7C,YAAI,QAAQ,oBAAoB,GAAG;AAC/B,gBAAM,iBAAiBE,sBAAqB,eAAe;YACvD,cAAc;YACd,kBAAkB;YAClB,uBAAuB;YACvB,MAAM;WACT;AAED,iCAAuB,QAAQ,cAAc,EAAE,QAAQ,cAAc,WAAW;AAEhF,gBAAM,gBAAgB,MAAM,eAAe,WAAU;AACrD,gBAAM,mBAAmB,MAAM,eAAe,QAAQ,cAAc,WAAW;AAG/E,iBAAOE,oBAAmB,wBAAwB,eAAe,gBAAgB;;AAGrF,eAAO;eACF,KAAK;AAEV,YAAI,IAAI,SAAS,IAAI;AACjB,gBAAMD,yBAAuB;;AAGjC,cAAM;;;AAKd,QAAI,yBAAyB,QAAW;AACpC,YAAMA,yBAAuB;;AAGjC,6CAAyC,OAAO;AAEhD,WAAOF,mCAAkC,eAAe,aAAa,sBAAsB,OAAO;EACtG;AACJ;;;AChKO,IAAM,oBAAoB,CAAC,aAA4B,eAAsB;AAChF,MAAI,gBAAgB,MAAM;AACtB,WAAO;;AAGX,SAAO,KAAK,IAAI,KAAK,KAAK,IAAI,OAAO,KAAK,IAAI,GAAG,KAAK,MAAM,KAAK,KAAK,cAAc,UAAU,CAAC,CAAC,CAAC,CAAC;AACtG;;;ACJO,IAAM,+BAA+B,CAAC,4BAAwF;AACjI,SAAO,IAAI,QAAQ,CAAC,SAAS,WAAU;AACnC,UAAM,EAAE,OAAO,MAAK,IAAK,IAAI,eAAc;AAE3C,UAAM,YAAY,CAAC,EAAE,KAAI,MAAM;AAC3B,YAAM,MAAK;AACX,YAAM,MAAK;AAEX,cAAQ,IAAI;IAChB;AACA,UAAM,iBAAiB,CAAC,EAAE,KAAI,MAAM;AAChC,YAAM,MAAK;AACX,YAAM,MAAK;AAEX,aAAO,IAAI;IACf;AAGA,UAAM,YAAY,uBAAuB;EAC7C,CAAC;AACL;;;ACnBO,IAAM,qCAAqC,OAC9C,sBACA,4BACiC;AACjC,QAAM,gCAAgC,MAAM,6BAA6B,uBAAuB;AAEhG,SAAO,IAAI,qBAAqB,6BAA6B;AACjE;;;ACLO,IAAM,8BAA8B,CACvC,eACA,wBACA,sBACA,4BACiC;AACjC,MAAI,qBAAqB,uBAAuB,IAAI,aAAa;AAEjE,MAAI,uBAAuB,QAAW;AAClC,yBAAqB,oBAAI,QAAO;AAEhC,2BAAuB,IAAI,eAAe,kBAAkB;;AAGhE,QAAM,+BAA+B,mCAAmC,sBAAsB,uBAAuB;AAErH,qBAAmB,IAAI,wBAAwB,4BAA4B;AAE3E,SAAO;AACX;;;ACLO,IAAM,2CAAuF,CAChGK,yBACAC,uBACAC,0BACAC,gCACAC,kCACAC,iCACAC,uBACAC,kCACAC,0BACAC,4BACAC,mCACAC,kCACAC,wBACA;AACA,SAAO,CAAC,eAAe,aAAa,sBAAsB,YAAW;AACjE,QAAI,QAAQ,mBAAmB,KAAK,QAAQ,oBAAoB,GAAG;AAC/D,YAAMJ,yBAAuB;;AAGjC,UAAM,qBAAqB,MAAM,QAAQ,QAAQ,kBAAkB,IAC7D,QAAQ,qBACR,MAAM,KAAK,QAAQ,kBAAkB;AAG3C,QAAI,mBAAmB,KAAK,CAAC,iBAAiB,eAAe,CAAC,GAAG;AAC7D,YAAMA,yBAAuB;;AAGjC,QAAI,mBAAmB,WAAW,QAAQ,iBAAiB;AACvD,YAAMP,sBAAoB;;AAI9B,QAAI,QAAQ,qBAAqB,YAAY;AACzC,YAAMO,yBAAuB;;AAGjC,UAAM,wBAAwB,QAAQ,eAAe,QAAQ;AAC7D,UAAM,yBAAyB,mBAAmB,OAAO,CAAC,KAAK,UAAU,MAAM,OAAO,CAAC;AACvF,UAAM,qBACF,qBAAqB,yBAAyB,SAAY,IAAI,qBAAqB,qBAAqB;AAG5G,QAAI,wBAAwB,qBAAqB,KAAK,yBAAyB,GAAG;AAC9E,YAAMA,yBAAuB;;AAGjC,UAAM,iBAAiB,IAAI,eAAc;AACzC,UAAM,YAA+B,CAAA;AACrC,UAAM,4BAA0D,CAAA;AAEhE,aAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,gBAAU,KACNF,sBAAqB,eAAe;QAChC,cAAc,QAAQ;QACtB,kBAAkB,QAAQ;QAC1B,uBAAuB,QAAQ;QAC/B,MAAM;OACT,CAAC;AAEN,gCAA0B,KACtBF,iCAAgC,eAAe;QAC3C,cAAc,QAAQ;QACtB,kBAAkB;QAClB,uBAAuB;QACvB,iBAAiB,QAAQ;OAC5B,CAAC;;AAIV,UAAM,sBAAmD,CAAA;AAEzD,QAAI,qBAAqB,yBAAyB,QAAW;AACzD,iBAAW,EAAE,cAAc,UAAU,UAAU,KAAI,KAAM,qBAAqB,sBAAsB;AAChG,cAAM,qBAAqBC,gCAA+B,eAAe;UACrE,cAAc;UACd,kBAAkB;UAClB,uBAAuB;UACvB,QACI,QAAQ,cAAc,IAAI,MAAM,SAC1B,QAAQ,cAAc,IAAI,IAC1B,iBAAiB,SACjB,IACA;SACb;AAED,eAAO,iBAAiB,mBAAmB,QAAQ;UAC/C,cAAc;YACV,KAAK,MAAO,iBAAiB,SAAY,IAAI;;UAEjD,UAAU;YACN,KAAK,MAAO,aAAa,SAAY,6BAA6B;;UAEtE,UAAU;YACN,KAAK,MAAO,aAAa,SAAY,6BAA6B;;SAEzE;AAED,4BAAoB,KAAK,kBAAkB;;;AAInD,UAAM,yBAAyBF,+BAA8B,eAAe;MACxE,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,gBAAgB,KAAK,IAAI,GAAG,wBAAwB,kBAAkB;KACzE;AACD,UAAM,aAAa,kBAAkB,aAAa,cAAc,UAAU;AAC1E,UAAM,sBAAsBI;MACxB;MACA;MACA,wBAAwB;;MAExB,KAAK,IAAI,GAAG,sBAAsB;IAAC;AAEvC,UAAM,4BAA4BH,iCAAgC,eAAe;MAC7E,cAAc,KAAK,IAAI,GAAG,sBAAsB;MAChD,kBAAkB;MAClB,uBAAuB;MACvB,iBAAiB,KAAK,IAAI,GAAG,sBAAsB;KACtD;AACD,UAAM,2BAAuD,CAAA;AAE7D,aAAS,IAAI,GAAG,IAAI,QAAQ,iBAAiB,KAAK,GAAG;AACjD,+BAAyB,KACrBD,+BAA8B,eAAe;QACzC,cAAc;QACd,kBAAkB;QAClB,uBAAuB;QACvB,gBAAgB,mBAAmB,CAAC;OACvC,CAAC;;AAIV,aAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,gBAAU,CAAC,EAAE,QAAQ,0BAA0B,CAAC,CAAC;AAEjD,eAAS,IAAI,GAAG,IAAI,QAAQ,cAAc,KAAK,GAAG;AAC9C,kCAA0B,CAAC,EAAE,QAAQ,wBAAwB,GAAG,IAAI,QAAQ,eAAe,CAAC;;;AAIpG,UAAM,eAAe,IAAI,YACrB,qBAAqB,yBAAyB,SACxC,CAAA,IACA,qBAAqB,qBAAqB,IAAI,CAAC,EAAE,KAAI,GAAI,UAAS;AAC9D,YAAM,qBAAqB,oBAAoB,KAAK;AAEpD,yBAAmB,QAAQ,wBAAwB,GAAG,wBAAwB,KAAK;AACnF,yBAAmB,MAAM,CAAC;AAE1B,aAAoC,CAAC,MAAM,mBAAmB,MAAM;IACxE,CAAC,CAAC;AAGZ,2BAAuB,QAAQ,mBAAmB;AAElD,QAAI,wBAAwB,QAAQ;AACpC,QAAI,mBAAgE;AAGpE,UAAM,mBAAmB,QAAQ,oBAAoB,IAAI,CAAC,mBAAmB,IAAI;AACjF,UAAM,8BAA8B;MAChC,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,eAAY;AACZ,eAAO,QAAQ;MACnB;MACA,IAAI,aAAa,GAAC;AAEd,cAAMD,yBAAuB;MACjC;MACA,IAAI,mBAAgB;AAChB,eAAO,QAAQ;MACnB;MACA,IAAI,iBAAiB,GAAC;AAElB,cAAMA,yBAAuB;MACjC;MACA,IAAI,wBAAqB;AACrB,eAAO;MACX;MACA,IAAI,sBAAsB,OAAK;AAC3B,mBAAW,YAAY,WAAW;AAC9B,mBAAS,wBAAwB;;AAGrC,gCAAwB;MAC5B;MACA,IAAI,UAAO;AACP,eAAO,oBAAoB;MAC/B;MACA,IAAI,SAAM;AACN,eAAO;MACX;MACA,IAAI,iBAAc;AACd,eAAO,QAAQ;MACnB;MACA,IAAI,kBAAe;AACf,eAAO,QAAQ;MACnB;MACA,IAAI,mBAAgB;AAChB,eAAO;MACX;MACA,IAAI,iBAAiB,OAAK;AACtB,YAAI,OAAO,qBAAqB,YAAY;AACxC,sCAA4B,oBAAoB,kBAAkB,gBAAgB;;AAGtF,2BAAmB,OAAO,UAAU,aAAa,QAAQ;AAEzD,YAAI,OAAO,qBAAqB,YAAY;AACxC,sCAA4B,iBAAiB,kBAAkB,gBAAgB;;MAEvF;MACA,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,OAAI;AACJ,eAAO,eAAe;MAC1B;MACA,oBAAoB,MAAW;AAC3B,eAAO,oBAAoB,iBAAiB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACzE;MACA,SAAsCF,wBAAuB,KAAK,MAAM,gBAAgB;MACxF,YAA4CS,2BAA0B,KAAK,MAAM,gBAAgB;MACjG,iBAAiB,MAAW;AACxB,eAAO,oBAAoB,cAAc,KAAK,CAAC,CAAC;MACpD;MACA,uBAAuB,MAAW;AAC9B,eAAO,oBAAoB,oBAAoB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MAC5E;;AAGJ,UAAM,wBAAwG,oBAAI,IAAG;AAErH,mBAAe,MAAM,oBAAoB,CAAC,qBAAoB;AAC1D,aAAO,IAAI,SAAkG;AACzG,YAAI,KAAK,CAAC,MAAM,WAAW;AACvB,gBAAM,yBACF,OAAO,KAAK,CAAC,MAAM,aACb,KAAK,CAAC,IACN,OAAO,KAAK,CAAC,MAAM,YAAY,KAAK,CAAC,MAAM,QAAQ,OAAO,KAAK,CAAC,EAAE,gBAAgB,aAClF,KAAK,CAAC,EAAE,cACR;AAEV,cAAI,2BAA2B,MAAM;AACjC,kBAAM,uBAAuB,sBAAsB,IAAI,KAAK,CAAC,CAAC;AAE9D,gBAAI,yBAAyB,QAAW;AACpC,mBAAK,CAAC,IAAwC;mBAC3C;AACH,mBAAK,CAAC,IAAI,CAAC,UAAgB;AACvB,gBAAAC,kCAAiC,cAAc,aAAa,cAAc,YAAY,MAClF,uBAAuB,KAAK,CAAC;cAErC;AAEA,oCAAsB,IAAI,wBAAwB,KAAK,CAAC,CAAC;;;;AAKrE,eAAO,iBAAiB,KAAK,eAAe,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MAChF;IACJ,GAAG,eAAe,MAAM,gBAAgB;AAExC,mBAAe,MAAM,uBAAuB,CAAC,wBAAuB;AAChE,aAAO,IAAI,SAAqB;AAC5B,YAAI,KAAK,CAAC,MAAM,WAAW;AACvB,gBAAM,uBAAuB,sBAAsB,IAAI,KAAK,CAAC,CAAC;AAE9D,cAAI,yBAAyB,QAAW;AACpC,kCAAsB,OAAO,KAAK,CAAC,CAAC;AAEpC,iBAAK,CAAC,IAAI;;;AAIlB,eAAO,oBAAoB,KAAK,eAAe,OAAO,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACnF;IACJ,GAAG,eAAe,MAAM,mBAAmB;AAE3C,QAAI,YAAsC;AAE1C,WAAO,eAAe,eAAe,OAAO,aAAa;MACrD,KAAK,MAAM;MACX,KAAK,CAAC,UAAS;AACX,YAAI,OAAO,cAAc,YAAY;AACjC,yBAAe,MAAM,oBAAoB,WAAW,SAAS;;AAGjE,oBAAY,OAAO,UAAU,aAAa,QAAQ;AAElD,YAAI,OAAO,cAAc,YAAY;AACjC,yBAAe,MAAM,iBAAiB,WAAW,SAAS;AAC1D,yBAAe,MAAM,MAAK;;MAElC;KACH;AAED,yBAAqB,UAAU,OAAO,eAAe;AAErD,QAAI,wBAAuD;AAE3D,UAAM,+BAA+B,4BACjC,eACA,6BACA,sBACA,OAAO;AAGX,iCAA6B,KAAK,CAAC,iBAAkB,wBAAwB,YAAa;AAE1F,UAAM,SAAS,mBAAmB,QAAQ,gBAAgB,QAAQ,YAAY;AAC9E,UAAM,UAAU,mBAAmB,QAAQ,iBAAiB,kBAAkB;AAC9E,UAAM,aACF,qBAAqB,yBAAyB,SACxC,CAAA,IACA,qBAAqB,qBAAqB,OACtC,CAAC,QAAQ,EAAE,KAAI,OAAQ,EAAE,GAAG,QAAQ,CAAC,IAAI,GAAG,IAAI,aAAa,GAAG,EAAC,IACjE,CAAA,CAAE;AAGhB,QAAI,WAAW;AAEf,UAAM,yBAAyB,MAAK;AAChC,UAAI,QAAQ,kBAAkB,GAAG;AAC7B,4BAAoB,WAAW,yBAAyB;;AAG5D,eAAS,IAAI,GAAG,kCAAkC,GAAG,IAAI,QAAQ,iBAAiB,KAAK,GAAG;AACtF,cAAM,0BAA0B,yBAAyB,CAAC;AAE1D,iBAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAC/C,oCAA0B,WAAW,yBAAyB,kCAAkC,GAAG,CAAC;;AAGxG,2CAAmC,mBAAmB,CAAC;;IAE/D;AAEA,UAAM,qBAAqB,oBAAI,IAAG;AAGlC,wBAAoB,iBAAiB,CAAC,EAAE,aAAa,aAAY,MAA4B;AACzF,UAAI,0BAA0B,MAAM;AAChC,cAAM,eAAeC,iCAAgC,2BAA2B;AAEhF,iBAAS,IAAI,GAAG,IAAI,YAAY,KAAK,KAAK;AACtC,mBAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,qBAAS,IAAI,GAAG,IAAI,QAAQ,cAAc,KAAK,GAAG;AAC9C,8BAAgB,aAAa,OAAO,CAAC,GAAG,GAAG,GAAG,CAAC;;;AAIvD,cAAI,qBAAqB,yBAAyB,QAAW;AACzD,iCAAqB,qBAAqB,QAAQ,CAAC,EAAE,KAAI,GAAI,UAAS;AAClE,8BAAgB,aAAa,YAAY,MAAM,wBAAwB,OAAO,CAAC;YACnF,CAAC;;AAGL,mBAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,qBAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAE/C,kBAAI,QAAQ,CAAC,EAAE,CAAC,EAAE,eAAe,GAAG;AAChC,wBAAQ,CAAC,EAAE,CAAC,IAAI,IAAI,aAAa,GAAG;;;;AAKhD,cAAI;AACA,kBAAM,yBAAyB,OAAO,IAAI,CAAC,OAAO,UAAS;AACvD,oBAAM,cAAc,aAAa,KAAK;AAEtC,kBAAI,YAAY,OAAO,GAAG;AACtB,mCAAmB,IAAI,OAAO,aAAa,GAAG;AAE9C,uBAAO;;AAGX,oBAAM,QAAQ,mBAAmB,IAAI,KAAK;AAE1C,kBAAI,UAAU,QAAW;AACrB,uBAAO,CAAA;;AAGX,kBAAI,MAAM,MAAM,CAAC,gBAAgB,YAAY,MAAM,CAAC,WAAW,WAAW,CAAC,CAAC,GAAG;AAC3E,oBAAI,UAAU,GAAG;AACb,qCAAmB,OAAO,KAAK;uBAC5B;AACH,qCAAmB,IAAI,OAAO,QAAQ,CAAC;;;AAI/C,qBAAO;YACX,CAAC;AAED,kBAAM,mBAAmBD,kCACrB,cAAc,cAAc,IAAI,cAAc,YAC9C,cAAc,YACd,MAA+B,sBAAuB,QAAQ,wBAAwB,SAAS,UAAU,CAAC;AAG9G,uBAAW;AAEX,qBAAS,IAAI,GAAG,kCAAkC,GAAG,IAAI,QAAQ,iBAAiB,KAAK,GAAG;AACtF,uBAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAC/C,8BAAc,cAAc,QAAQ,CAAC,GAAG,GAAG,kCAAkC,GAAG,CAAC;;AAGrF,iDAAmC,mBAAmB,CAAC;;mBAEtD,OAAO;AACZ,uBAAW;AAEX,wCAA4B,cACxB,IAAI,WAAW,kBAAkB;cAC7B,OAAO,MAAM;cACb,UAAU,MAAM;cAChB,QAAQ,MAAM;cACd,SAAS,MAAM;aAClB,CAAC;;AAIV,cAAI,CAAC,UAAU;AACX,qBAAS,IAAI,GAAG,IAAI,QAAQ,gBAAgB,KAAK,GAAG;AAChD,wBAAU,CAAC,EAAE,WAAW,0BAA0B,CAAC,CAAC;AAEpD,uBAAS,IAAI,GAAG,IAAI,QAAQ,cAAc,KAAK,GAAG;AAC9C,0CAA0B,CAAC,EAAE,WAAW,wBAAwB,GAAG,IAAI,QAAQ,eAAe,CAAC;;;AAIvG,gBAAI,qBAAqB,yBAAyB,QAAW;AACzD,oBAAM,SAAS,qBAAqB,qBAAqB;AAEzD,uBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,sBAAM,qBAAqB,oBAAoB,CAAC;AAEhD,mCAAmB,WAAW,wBAAwB,GAAG,wBAAwB,CAAC;AAClF,mCAAmB,KAAI;;;AAI/B,mCAAuB,WAAW,mBAAmB;AAErD,gCAAoB,iBAAiB;AAErC,gBAAI,aAAa;AACb,qCAAsB;mBACnB;AACH,kCAAmB;;AAGvB;;;;IAIhB;AAEA,QAAI,cAAc;AAGlB,UAAM,iBAAiBJ,sBAAqB,eAAe;MACvD,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,MAAM;KACT;AAED,UAAM,mBAAmB,MAAM,oBAAoB,QAAQ,cAAc,EAAE,QAAQ,cAAc,WAAW;AAC5G,UAAM,sBAAsB,MAAK;AAC7B,0BAAoB,WAAW,cAAc;AAC7C,qBAAe,WAAU;IAC7B;AACA,UAAM,gBAAgB,MAAK;AACvB,UAAI,UAAU;AACV,4BAAmB;AAEnB,YAAI,QAAQ,kBAAkB,GAAG;AAC7B,8BAAoB,QAAQ,yBAAyB;;AAGzD,iBAAS,IAAI,GAAG,kCAAkC,GAAG,IAAI,QAAQ,iBAAiB,KAAK,GAAG;AACtF,gBAAM,0BAA0B,yBAAyB,CAAC;AAE1D,mBAAS,IAAI,GAAG,IAAI,mBAAmB,CAAC,GAAG,KAAK,GAAG;AAC/C,sCAA0B,QAAQ,yBAAyB,kCAAkC,GAAG,CAAC;;AAGrG,6CAAmC,mBAAmB,CAAC;;;AAI/D,oBAAc;IAClB;AACA,UAAM,mBAAmB,MAAK;AAC1B,UAAI,UAAU;AACV,yBAAgB;AAChB,+BAAsB;;AAG1B,oBAAc;IAClB;AAEA,qBAAgB;AAEhB,WAAOM,oBAAmB,6BAA6B,eAAe,gBAAgB;EAC1F;AACJ;;;AChhBO,IAAM,+BAA+D,CAAC,eAAe,YAAW;AACnG,QAAM,yBAAyB,cAAc,mBAAkB;AAE/D,+BAA6B,wBAAwB,OAAO;AAE5D,uCAAqC,wBAAwB,SAAS,GAAG;AACzE,uCAAqC,wBAAwB,SAAS,QAAQ;AAC9E,uCAAqC,wBAAwB,SAAS,WAAW;AACjF,uCAAqC,wBAAwB,SAAS,MAAM;AAE5E,8BAA4B,wBAAwB,SAAS,MAAM;AAEnE,SAAO;AACX;;;ACfO,IAAM,uCAA+E,CACxFC,gCACAC,2BACA;AACA,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,0BAA0B,cAAc,oBAAoB,QAAQ,cAAc;AAOxF,QAAID,mCAAkC,QAAQA,+BAA8B,SAAS,sBAAsB;AACvG,MAAAC,uBAAsB,eAAe,uBAAuB;;AAGhE,iCAA6B,yBAAyB,OAAO;AAE7D,WAAO;EACX;AACJ;;;ACpBO,IAAM,0BAA0B,CAAC,wBAAyD;AAC7F,QAAM,eAAe,oBAAoB;AAGzC,SAAO,eAAe,qBAAqB,gBAAgB;IACvD,KAAK,MAAM;IACX,KAAK,CAAC,UAAS;AACX,UAAI,UAAU,cAAc;AACxB,cAAM,wBAAuB;;IAErC;GACH;AAGD,SAAO,eAAe,qBAAqB,oBAAoB;IAC3D,KAAK,MAAM;IACX,KAAK,CAAC,UAAS;AACX,UAAI,UAAU,YAAY;AACtB,cAAM,wBAAuB;;IAErC;GACH;AAGD,SAAO,eAAe,qBAAqB,yBAAyB;IAChE,KAAK,MAAM;IACX,KAAK,CAAC,UAAS;AACX,UAAI,UAAU,YAAY;AACtB,cAAM,wBAAuB;;IAErC;GACH;AACL;;;AC/BO,IAAM,kCAAqE,CAAC,eAAe,YAAW;AACzG,QAAM,4BAA4B,cAAc,sBAAsB,QAAQ,eAAe;AAK7F,+BAA6B,2BAA2B,OAAO;AAG/D,0BAAwB,yBAAyB;AAEjD,SAAO;AACX;;;ACVO,IAAM,wCAAiF,CAC1FC,sBACAC,kBACAC,sCACAC,mEACAC,qEACA;AACA,SAAO,CAAC,eAAe,YAAW;AAE9B,QAAI,cAAc,yBAAyB,QAAW;AAClD,aAAOF,qCAAoC,eAAe,OAAO;;AAGrE,UAAM,2BAA2B,cAAc,qBAAoB;AAEnE,iCAA6B,0BAA0B,OAAO;AAE9D,yCAAqC,0BAA0B,SAAS,QAAQ;AAGhF,QACI,CAACD,iBAAgBE,mEAAkE,MAC/EA,kEAAiE,aAAa,CAAC,GAErF;AACE,gEAA0D,wBAAwB;;AAItF,QACI,CAACF,iBAAgBG,kEAAiE,MAC9EA,iEAAgE,aAAa,CAAC,GAEpF;AACE,+DAAyD,wBAAwB;;AAIrF,IAAAJ,qBAAoB,eAAe,wBAAwB;AAE3D,WAAO;EACX;AACJ;;;AC9CO,IAAM,uBAAuB,CAChC,UACA,gBAC0F;AAC3C,WAAU,UAAU,YAAY,QAAQ,KAAK,WAAW;AAElD,WAAU,aAAa,YAAY,WAAW,KAAK,WAAW;AAEnH,SAAiG;AACrG;;;ACHO,IAAM,6CAA2F,CACpGK,sBACAC,oCACAC,uBACAC,wBACA;AACA,SAAO,CAAC,eAAe,EAAE,QAAQ,GAAG,iBAAgB,MAAM;AACtD,UAAM,cAAc,cAAc,aAAa,GAAG,GAAG,KAAK;AAC1D,UAAM,wBAAwBF,mCAAkC,eAAe;MAC3E,QAAQ;MACR,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,MAAM;MACN,SAAS;MACT,WAAW;MACX,cAAc;KACjB;AACD,UAAM,WAAWC,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,MAAM,OAAM,CAAE;AAG1F,UAAM,cAAc,YAAY,eAAe,CAAC;AAGhD,gBAAY,CAAC,IAAI;AACjB,gBAAY,CAAC,IAAI;AAEjB,0BAAsB,SAAS;AAC/B,0BAAsB,OAAO;AAE7B,UAAM,gCAAgC;MAClC,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,eAAY;AACZ,eAAO,SAAS;MACpB;MACA,IAAI,aAAa,OAAK;AAClB,iBAAS,eAAe;MAC5B;MACA,IAAI,mBAAgB;AAChB,eAAO,SAAS;MACpB;MACA,IAAI,iBAAiB,OAAK;AACtB,iBAAS,mBAAmB;MAChC;MACA,IAAI,wBAAqB;AACrB,eAAO,SAAS;MACpB;MACA,IAAI,sBAAsB,OAAK;AAC3B,iBAAS,wBAAwB;MACrC;MACA,IAAI,UAAO;AACP,eAAO,SAAS;MACpB;MACA,IAAI,SAAM;AACN,eAAO,CAAA;MACX;MACA,IAAI,iBAAc;AACd,eAAO,sBAAsB;MACjC;MACA,IAAI,kBAAe;AACf,eAAO,SAAS;MACpB;MACA,IAAI,SAAM;AACN,eAAO,SAAS;MACpB;MACA,IAAI,UAAO;AACP,eAAO,sBAAsB;MACjC;MACA,IAAI,QAAQ,OAAK;AACb,8BAAsB,UAAmD;MAC7E;MACA,oBAAoB,MAAW;AAC3B,eAAO,sBAAsB,iBAAiB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MAC3E;MACA,iBAAiB,MAAW;AACxB,eAAO,sBAAsB,cAAc,KAAK,CAAC,CAAC;MACtD;MACA,uBAAuB,MAAW;AAC9B,eAAO,sBAAsB,oBAAoB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MAC9E;MACA,MAAM,OAAO,GAAC;AACV,8BAAsB,MAAM,KAAK,uBAAuB,IAAI;MAChE;MACA,KAAK,OAAO,GAAC;AACT,8BAAsB,KAAK,KAAK,uBAAuB,IAAI;MAC/D;;AAGJ,UAAM,gBAAgB,MAAM,sBAAsB,QAAQ,QAAQ;AAClE,UAAM,mBAAmB,MAAM,sBAAsB,WAAW,QAAQ;AAGxE,IAAAF,qBAAoB,eAAe,qBAAqB;AAExD,WAAOG,oBAAmB,qBAAqB,+BAA+B,QAAQ,GAAG,eAAe,gBAAgB;EAC5H;AACJ;;;ACtGO,IAAM,mCAAuE,CAACC,0BAAyBC,wBAAsB;AAChI,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,sBAAsB,cAAc,gBAAe;AAEzD,iCAA6B,qBAAqB,OAAO;AAGzD,QAAI,QAAQ,yBAAyB,oBAAoB,WAAW;AAChE,0BAAoB,YAAY,CAAC,QAAQ;;AAG7C,gCAA4B,qBAAqB,SAAS,QAAQ;AAGlE,QAAI,QAAQ,eAAe,GAAG;AAC1B,YAAMD,yBAAuB;;AAGjC,IAAAC,oBACI,qBACA,gBACA,CAAC,QAAQ,MAAM,IAAI,KAAK,mBAAmB,GAC3C,CAAC,QAAQ,CAAC,UAAS;AACf,UAAI,QAAQ,GAAG;AACX,cAAMD,yBAAuB;;AAGjC,aAAO,IAAI,KAAK,qBAAqB,KAAK;IAC9C,CAAC;AAIL,QAAI,QAAQ,qBAAqB,OAAO;AACpC,YAAMA,yBAAuB;;AAGjC,IAAAC,oBACI,qBACA,oBACA,CAAC,QAAQ,MAAM,IAAI,KAAK,mBAAmB,GAC3C,CAAC,QAAQ,CAAC,UAAS;AACf,UAAI,UAAU,OAAO;AACjB,cAAMD,yBAAuB;;AAGjC,aAAO,IAAI,KAAK,qBAAqB,KAAK;IAC9C,CAAC;AAGL,WAAO;EACX;AACJ;;;ACnDO,IAAM,wBAAiD,CAAC,eAAe,YAAW;AACrF,QAAM,kBAAkB,cAAc,YAAY,QAAQ,YAAY;AAEtE,+BAA6B,iBAAiB,OAAO;AAErD,uCAAqC,iBAAiB,SAAS,WAAW;AAE1E,SAAO;AACX;;;ACRO,IAAM,4CAAyF,CAACE,6BAA2B;AAC9H,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,+BAA+B,cAAc,yBAAwB;AAE3E,iCAA6B,8BAA8B,OAAO;AAGlE,QAAI,QAAQ,eAAe,GAAG;AAC1B,YAAMA,yBAAuB;;AAIjC,QAAI,QAAQ,qBAAqB,OAAO;AACpC,YAAMA,yBAAuB;;AAGjC,yCAAqC,8BAA8B,SAAS,QAAQ;AACpF,yCAAqC,8BAA8B,SAAS,MAAM;AAClF,yCAAqC,8BAA8B,SAAS,OAAO;AACnF,yCAAqC,8BAA8B,SAAS,SAAS;AACrF,yCAAqC,8BAA8B,SAAS,WAAW;AAEvF,WAAO;EACX;AACJ;;;ACxBO,IAAM,uBAA+C,CAAC,eAAe,YAAW;AACnF,QAAM,iBAAiB,cAAc,WAAU;AAE/C,+BAA6B,gBAAgB,OAAO;AAEpD,uCAAqC,gBAAgB,SAAS,MAAM;AAEpE,SAAO;AACX;;;ACTO,IAAM,mCAAuE,CAACC,oCAAkC;AACnH,SAAO,CAAC,eAAe,aAAa,YAAW;AAE3C,QAAI,cAAc,oBAAoB,QAAW;AAC7C,aAAOA,gCAA+B,eAAe,aAAa,OAAO;;AAI7E,UAAM,sBAAsB,cAAc,gBAA0B,QAAQ,aAAuB,QAAQ,QAAQ;AAEnH,iCAA6B,qBAAqB,OAAO;AAEzD,WAAO;EACX;AACJ;;;ACZA,SAAS,OAAO,GAAqB,GAAmB;AACpD,QAAM,cAAc,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC;AAE5C,SAAO,EAAE,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,cAAc,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,KAAK,WAAW;AAChG;AAEA,SAAS,SAAS,GAAqB,GAAmB;AACtD,SAAO,CAAC,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,IAAI,EAAE,CAAC,CAAC;AAChE;AAEA,SAAS,mBAAmB,aAA2B,GAAmB;AACtE,MAAI,SAA2B,CAAC,GAAG,CAAC;AAEpC,WAAS,IAAI,YAAY,SAAS,GAAG,KAAK,GAAG,KAAK,GAAG;AACjD,aAAS,SAAS,QAAQ,CAAC;AAE3B,WAAO,CAAC,KAAK,YAAY,CAAC;;AAG9B,SAAO;AACX;AAEO,IAAM,wCAAiF,CAC1FC,2BACAC,0BACAC,kCACAC,6BACA;AACA,SAAO,CAAC,eAAe,aAAa,EAAE,cAAc,kBAAkB,uBAAuB,UAAU,YAAW,MAAM;AACpH,UAAM,aAAa,kBAAkB,aAAa,cAAc,UAAU;AAC1E,UAAM,oBAAoB,oBAAoB,eAAe,WAAW,IAAI,aAAa,QAAQ;AACjG,UAAM,uBAAuB,uBAAuB,eAAe,cAAc,IAAI,aAAa,WAAW;AAC7G,UAAM,iBAAiB,kBAAkB;AACzC,UAAM,oBAAoB,qBAAqB;AAC/C,UAAM,YAAY,KAAK,IAAI,gBAAgB,iBAAiB;AAE5D,QAAI,mBAAmB,KAAK,iBAAiB,IAAI;AAC7C,YAAMA,yBAAuB;;AAGjC,QAAI,kBAAkB,CAAC,MAAM,GAAG;AAC5B,YAAMF,yBAAuB;;AAGjC,QAAI,sBAAsB,KAAK,oBAAoB,IAAI;AACnD,YAAME,yBAAuB;;AAGjC,QAAI,qBAAqB,CAAC,MAAM,GAAG;AAC/B,YAAMF,yBAAuB;;AAGjC,QAAI,kBAAkB,CAAC,MAAM,GAAG;AAC5B,eAAS,IAAI,GAAG,IAAI,mBAAmB,KAAK,GAAG;AAC3C,6BAAqB,CAAC,KAAK,kBAAkB,CAAC;;AAGlD,eAAS,IAAI,GAAG,IAAI,gBAAgB,KAAK,GAAG;AACxC,0BAAkB,CAAC,KAAK,kBAAkB,CAAC;;;AAInD,UAAM,sBAAsBC,iCAAgC,eAAe,YAAY,cAAc,YAAY;AAEjH,wBAAoB,eAAe;AACnC,wBAAoB,mBAAmB;AACvC,wBAAoB,wBAAwB;AAE5C,UAAM,eAAe;AACrB,UAAM,gBAA0B,CAAA;AAChC,UAAM,WAA2B,CAAA;AACjC,UAAM,WAA2B,CAAA;AAEjC,aAAS,IAAI,GAAG,IAAI,cAAc,KAAK,GAAG;AACtC,oBAAc,KAAK,CAAC;AAEpB,YAAM,UAAU,IAAI,aAAa,YAAY;AAC7C,YAAM,UAAU,IAAI,aAAa,YAAY;AAE7C,cAAQ,KAAK,CAAC;AACd,cAAQ,KAAK,CAAC;AAEd,eAAS,KAAK,OAAO;AACrB,eAAS,KAAK,OAAO;;AAIzB,wBAAoB,iBAAiB,CAAC,UAA+B;AACjE,YAAM,cAAc,MAAM;AAC1B,YAAM,eAAe,MAAM;AAE3B,YAAM,mBAAmB,YAAY;AAErC,eAAS,IAAI,GAAG,IAAI,kBAAkB,KAAK,GAAG;AAC1C,cAAM,QAAQ,YAAY,eAAe,CAAC;AAC1C,cAAM,SAAS,aAAa,eAAe,CAAC;AAE5C,sBAAc,CAAC,IAAI,aACf,mBACA,gBACA,sBACA,mBACA,WACA,SAAS,CAAC,GACV,SAAS,CAAC,GACV,cAAc,CAAC,GACf,cACA,OACA,MAAM;;IAGlB;AAEA,UAAM,UAAU,cAAc,aAAa;AAE3C,UAAM,2BAA2B;MAC7B,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,eAAY;AACZ,eAAO,oBAAoB;MAC/B;MACA,IAAI,aAAa,OAAK;AAClB,4BAAoB,eAAe;MACvC;MACA,IAAI,mBAAgB;AAChB,eAAO,oBAAoB;MAC/B;MACA,IAAI,iBAAiB,OAAK;AACtB,4BAAoB,mBAAmB;MAC3C;MACA,IAAI,wBAAqB;AACrB,eAAO,oBAAoB;MAC/B;MACA,IAAI,sBAAsB,OAAK;AAC3B,4BAAoB,wBAAwB;MAChD;MACA,IAAI,UAAO;AACP,eAAO,oBAAoB;MAC/B;MACA,IAAI,SAAM;AACN,eAAO,CAAC,mBAAmB;MAC/B;MACA,IAAI,iBAAc;AACd,eAAO,oBAAoB;MAC/B;MACA,IAAI,kBAAe;AACf,eAAO,oBAAoB;MAC/B;MACA,oBAAoB,MAAW;AAE3B,eAAO,oBAAoB,iBAAiB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACzE;MACA,iBAAiB,MAAW;AACxB,eAAO,oBAAoB,cAAc,KAAK,CAAC,CAAC;MACpD;MACA,qBAAqB,aAA2B,aAA2B,eAA2B;AAClG,YAAI,YAAY,WAAW,YAAY,UAAU,YAAY,WAAW,cAAc,QAAQ;AAC1F,gBAAMF,0BAAwB;;AAGlC,cAAM,SAAS,YAAY;AAE3B,iBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,gBAAM,QAAQ,CAAC,KAAK,MAAM,YAAY,CAAC,IAAI;AAC3C,gBAAM,IAAsB,CAAC,KAAK,IAAI,KAAK,GAAG,KAAK,IAAI,KAAK,CAAC;AAC7D,gBAAM,YAAY,mBAAmB,sBAAsB,CAAC;AAC5D,gBAAM,cAAc,mBAAmB,mBAAmB,CAAC;AAC3D,gBAAM,WAAW,OAAO,WAAW,WAAW;AAE9C,sBAAY,CAAC,IAAI,KAAK,KAAK,SAAS,CAAC,IAAI,SAAS,CAAC,IAAI,SAAS,CAAC,IAAI,SAAS,CAAC,CAAC;AAChF,wBAAc,CAAC,IAAI,KAAK,MAAM,SAAS,CAAC,GAAG,SAAS,CAAC,CAAC;;MAE9D;MACA,uBAAuB,MAAW;AAC9B,eAAO,oBAAoB,oBAAoB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MAC5E;;AAGJ,WAAO,qBAAqB,0BAA0B,mBAAmB;EAC7E;AACJ;;;ACxLO,IAAM,0CAAqF,CAAC,oBAAoB,YAAW;AAC9H,SAAO,mBAAmB,yBAAyB,QAAQ,YAAY;AAC3E;;;ACDO,IAAM,8CAA6F,CAAC,oBAAoB,YAAW;AACtI,QAAM,wCAAwC,mBAAmB,6BAA4B;AAE7F,+BAA6B,uCAAuC,OAAO;AAG3E,MAAI,sCAAsC,oBAAoB,GAAG;AAC7D,WAAO,eAAe,uCAAuC,mBAAmB,EAAE,KAAK,MAAM,EAAC,CAAE;;AAGpG,SAAO;AACX;;;ACZO,IAAM,yCAAmF,CAAC,oBAAoB,EAAE,YAAW,MAAM;AACpI,QAAM,oBAAoB,YAAY,eAAc;AAKpD,oBAAkB,KAAK,CAAC,GAAG,MAAO,EAAE,KAAK,EAAE,KAAK,KAAK,EAAE,KAAK,EAAE,KAAK,IAAI,CAAE;AAEzE,QAAM,4BAA4B,kBAAkB,MAAM,GAAG,CAAC;AAE9D,QAAM,mCAAmC,mBAAmB,wBAAwB,IAAI,YAAY,yBAAyB,CAAC;AAM9H,SAAO,eAAe,kCAAkC,eAAe,EAAE,OAAO,YAAW,CAAE;AAE7F,SAAO;AACX;;;ACnBO,IAAM,qDAA2G,CACpHI,0BACAC,iCACA;AACA,SAAO,CAAC,oBAAoB,EAAE,iBAAgB,MAAM;AAEhD,QAAI,OAAO,mBAAmB,iCAAiC,YAAY;AACvE,aAAO,mBAAmB,6BAA6B,gBAAgB;;AAG3E,UAAM,cAAc,IAAI,YAAY,CAAC,gBAAgB,CAAC;AACtD,UAAM,mCAAmC,mBAAmB,wBAAwB,WAAW;AAG/F,QAAI,iBAAiB,SAAS,SAAS;AACnC,YAAMD,yBAAuB;;AAIjC,QAAIC,6BAA4B,kBAAkB,GAAG;AACjD,YAAM,IAAI,UAAS;;AAGvB,WAAO;EACX;AACJ;;;ACzBO,IAAM,6CAA2F,CAACC,YAAU;AAC/G,MAAIA,YAAW,MAAM;AACjB,WAAO;;AAGX,MAAIA,QAAO,eAAe,qBAAqB,GAAG;AAC9C,WAAOA,QAAO;;AAGlB,SAAOA,QAAO,eAAe,2BAA2B,IAAUA,QAAQ,4BAA4B;AAC1G;;;ACLO,IAAM,oCAAyE,CAClFC,sBACAC,kBACAC,mEACAC,gEACAC,kEACAC,4DACA;AACA,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,uBAAuB,cAAc,iBAAgB;AAE3D,iCAA6B,sBAAsB,OAAO;AAE1D,yCAAqC,sBAAsB,SAAS,QAAQ;AAC5E,yCAAqC,sBAAsB,SAAS,WAAW;AAE/E,QAAI,QAAQ,iBAAiB,QAAW;AACpC,2BAAqB,gBAAgB,QAAQ,YAAY;WACtD;AACH,kCAA4B,sBAAsB,SAAS,MAAM;;AAIrE,QACI,CAACJ,iBAAgBC,mEAAkE,MAC/EA,kEAAiE,aAAa,CAAC,GAErF;AACE,gEAA0D,oBAAoB;;AAIlF,QACI,CAACD,iBAAgBE,gEAA+D,MAC5EA,+DAA8D,aAAa,CAAC,GAElF;AACE,MAAAE,wDAAuD,sBAAsB,aAAa;;AAI9F,QACI,CAACJ,iBAAgBG,kEAAiE,MAC9EA,iEAAgE,aAAa,CAAC,GAEpF;AACE,+DAAyD,oBAAoB;;AAIjF,IAAAJ,qBAAoB,eAAe,oBAAoB;AAEvD,WAAO;EACX;AACJ;;;ACxDO,IAAM,gCAAiE,CAACM,iCAA+B;AAC1G,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,mBAAmB,cAAc,aAAY;AAGnD,QAAI,iBAAiB,iBAAiB,QAAW;AAC7C,aAAOA,6BAA4B,eAAe,OAAO;;AAG7D,iCAA6B,kBAAkB,OAAO;AAEtD,yCAAqC,kBAAkB,SAAS,cAAc;AAC9E,yCAAqC,kBAAkB,SAAS,cAAc;AAC9E,yCAAqC,kBAAkB,SAAS,cAAc;AAC9E,yCAAqC,kBAAkB,SAAS,WAAW;AAC3E,yCAAqC,kBAAkB,SAAS,WAAW;AAC3E,yCAAqC,kBAAkB,SAAS,WAAW;AAE3E,gCAA4B,kBAAkB,SAAS,gBAAgB;AACvE,gCAA4B,kBAAkB,SAAS,gBAAgB;AACvE,gCAA4B,kBAAkB,SAAS,eAAe;AACtE,gCAA4B,kBAAkB,SAAS,eAAe;AACtE,gCAA4B,kBAAkB,SAAS,aAAa;AACpE,gCAA4B,kBAAkB,SAAS,cAAc;AACrE,gCAA4B,kBAAkB,SAAS,aAAa;AACpE,gCAA4B,kBAAkB,SAAS,eAAe;AAEtE,WAAO;EACX;AACJ;;;AC9BO,IAAM,qCAA2E,CACpFC,0CACAC,0BACAC,gCACAC,uBACAC,kCACAC,6BACAC,0BACAC,+CACAC,iBACAC,wBACA;AACA,SAAO,CACH,eACA,EACI,gBACA,gBACA,eACA,eACA,aACA,cACA,cACA,cACA,cACA,WACA,WACA,WACA,aACA,eACA,GAAG,iBAAgB,MAEvB;AACA,UAAM,aAAa,cAAc,aAAY;AAG7C,QAAI,iBAAiB,eAAe,GAAG;AACnC,YAAMH,yBAAuB;;AAIjC,QAAI,iBAAiB,qBAAqB,OAAO;AAC7C,YAAMA,yBAAuB;;AAGjC,iCAA6B,YAAY,gBAAgB;AAEzD,UAAM,yBAAyB;MAC3B,cAAc;MACd,kBAAkB;MAClB,uBAAuB;;AAG3B,UAAM,oBAAoBJ,+BAA8B,eAAe;MACnE,GAAG;MACH,uBAAuB;MACvB,gBAAgB;KACnB;AACD,UAAM,gBAAgBC,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,MAAM,EAAC,CAAE;AAC1F,UAAM,uBAAuBA,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACvG,UAAM,uBAAuBA,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACvG,UAAM,uBAAuBA,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACvG,UAAM,oBAAoBA,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACpG,UAAM,oBAAoBA,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACpG,UAAM,oBAAoBA,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACpG,UAAM,sBAAsBC,iCAAgC,eAAe,KAAK,GAAG,CAAC;AACpF,UAAM,iBAAiBC,4BAA2B,eAAe;MAC7D,GAAG;MACH,OAAO,IAAI,aAAa,CAAC,GAAG,CAAC,CAAC;MAC9B,YAAY;KACf;AAED,QAAI,kBAA4C,CAAC,cAAc,cAAc,YAAY;AACzF,QAAI,eAAyC,CAAC,WAAW,WAAW,SAAS;AAE7E,UAAM,SAAS,IAAI,aAAa,CAAC;AAGjC,wBAAoB,iBAAiB,CAAC,EAAE,YAAW,MAAM;AACrD,YAAM,cAAwC;QAC1CG,gBAAe,aAAa,QAAQ,CAAC;QACrCA,gBAAe,aAAa,QAAQ,CAAC;QACrCA,gBAAe,aAAa,QAAQ,CAAC;;AAGzC,UAAI,YAAY,KAAK,CAAC,OAAO,UAAU,UAAU,gBAAgB,KAAK,CAAC,GAAG;AACtE,mBAAW,eAAe,GAAG,WAAW;AAExC,0BAAkB;;AAGtB,YAAM,UAAoC;QACtCA,gBAAe,aAAa,QAAQ,CAAC;QACrCA,gBAAe,aAAa,QAAQ,CAAC;QACrCA,gBAAe,aAAa,QAAQ,CAAC;;AAGzC,UAAI,QAAQ,KAAK,CAAC,OAAO,UAAU,UAAU,aAAa,KAAK,CAAC,GAAG;AAC/D,mBAAW,YAAY,GAAG,OAAO;AAEjC,uBAAe;;IAEvB;AAEA,WAAO,eAAe,qBAAqB,MAAM,gBAAgB,EAAE,KAAK,MAAM,EAAC,CAAE;AACjF,WAAO,eAAe,qBAAqB,MAAM,gBAAgB,EAAE,KAAK,MAAM,EAAC,CAAE;AACjF,WAAO,eAAe,kBAAkB,MAAM,gBAAgB,EAAE,KAAK,MAAM,EAAC,CAAE;AAC9E,WAAO,eAAe,kBAAkB,MAAM,gBAAgB,EAAE,KAAK,MAAM,EAAC,CAAE;AAC9E,WAAO,eAAe,kBAAkB,MAAM,gBAAgB,EAAE,KAAK,MAAM,EAAC,CAAE;AAE9E,UAAM,wBAAwB;MAC1B,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,eAAY;AACZ,eAAO,WAAW;MACtB;MACA,IAAI,aAAa,OAAK;AAElB,YAAI,QAAQ,GAAG;AACX,gBAAMF,yBAAuB;;AAGjC,sBAAc,eAAe;AAC7B,mBAAW,eAAe;MAC9B;MACA,IAAI,mBAAgB;AAChB,eAAO,WAAW;MACtB;MACA,IAAI,iBAAiB,OAAK;AAEtB,YAAI,UAAU,OAAO;AACjB,gBAAMA,yBAAuB;;AAGjC,sBAAc,mBAAmB;AACjC,mBAAW,mBAAmB;MAClC;MACA,IAAI,wBAAqB;AACrB,eAAO,WAAW;MACtB;MACA,IAAI,sBAAsB,OAAK;AAC3B,sBAAc,wBAAwB;AACtC,mBAAW,wBAAwB;MACvC;MACA,IAAI,iBAAc;AACd,eAAO,WAAW;MACtB;MACA,IAAI,eAAe,OAAK;AACpB,mBAAW,iBAAiB;MAChC;MACA,IAAI,iBAAc;AACd,eAAO,WAAW;MACtB;MACA,IAAI,eAAe,OAAK;AACpB,mBAAW,iBAAiB;MAChC;MACA,IAAI,gBAAa;AACb,eAAO,WAAW;MACtB;MACA,IAAI,cAAc,OAAK;AAEnB,YAAI,QAAQ,KAAK,QAAQ,GAAG;AACxB,gBAAML,yBAAuB;;AAGjC,mBAAW,gBAAgB;MAC/B;MACA,IAAI,UAAO;AACP,eAAO,WAAW;MACtB;MACA,IAAI,gBAAa;AACb,eAAO,WAAW;MACtB;MACA,IAAI,cAAc,OAAK;AACnB,mBAAW,gBAAgB;MAC/B;MACA,IAAI,SAAM;AACN,eAAO,CAAC,aAAa;MACzB;MACA,IAAI,cAAW;AACX,eAAO,WAAW;MACtB;MACA,IAAI,YAAY,OAAK;AAEjB,YAAI,QAAQ,GAAG;AACX,gBAAM,IAAI,WAAU;;AAGxB,mBAAW,cAAc;MAC7B;MACA,IAAI,iBAAc;AACd,eAAO,WAAW;MACtB;MACA,IAAI,kBAAe;AACf,eAAO,WAAW;MACtB;MACA,IAAI,eAAY;AACZ,eAAO,qBAAqB;MAChC;MACA,IAAI,eAAY;AACZ,eAAO,qBAAqB;MAChC;MACA,IAAI,eAAY;AACZ,eAAO,qBAAqB;MAChC;MACA,IAAI,eAAY;AACZ,eAAO,WAAW;MACtB;MACA,IAAI,aAAa,OAAK;AAClB,mBAAW,eAAe;MAC9B;MACA,IAAI,YAAS;AACT,eAAO,kBAAkB;MAC7B;MACA,IAAI,YAAS;AACT,eAAO,kBAAkB;MAC7B;MACA,IAAI,YAAS;AACT,eAAO,kBAAkB;MAC7B;MACA,IAAI,cAAW;AACX,eAAO,WAAW;MACtB;MACA,IAAI,YAAY,OAAK;AAEjB,YAAI,QAAQ,GAAG;AACX,gBAAM,IAAI,WAAU;;AAGxB,mBAAW,cAAc;MAC7B;MACA,IAAI,gBAAa;AACb,eAAO,WAAW;MACtB;MACA,IAAI,cAAc,OAAK;AAEnB,YAAI,QAAQ,GAAG;AACX,gBAAM,IAAI,WAAU;;AAGxB,mBAAW,gBAAgB;MAC/B;MACA,oBAAoB,MAAW;AAC3B,eAAO,cAAc,iBAAiB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACnE;MACA,iBAAiB,MAAW;AACxB,eAAO,cAAc,cAAc,KAAK,CAAC,CAAC;MAC9C;MACA,uBAAuB,MAAW;AAC9B,eAAO,cAAc,oBAAoB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACtE;;AAGJ,QAAI,mBAAmB,sBAAsB,gBAAgB;AACzD,4BAAsB,iBAAiB;;AAG3C,QAAI,mBAAmB,sBAAsB,gBAAgB;AACzD,4BAAsB,iBAAiB;;AAG3C,QAAI,kBAAkB,sBAAsB,eAAe;AACvD,4BAAsB,gBAAgB;;AAG1C,QAAI,kBAAkB,sBAAsB,eAAe;AACvD,4BAAsB,gBAAgB;;AAG1C,QAAI,gBAAgB,sBAAsB,aAAa;AACnD,4BAAsB,cAAc;;AAGxC,QAAI,iBAAiB,sBAAsB,aAAa,OAAO;AAC3D,4BAAsB,aAAa,QAAQ;;AAG/C,QAAI,iBAAiB,sBAAsB,aAAa,OAAO;AAC3D,4BAAsB,aAAa,QAAQ;;AAG/C,QAAI,iBAAiB,sBAAsB,aAAa,OAAO;AAC3D,4BAAsB,aAAa,QAAQ;;AAG/C,QAAI,iBAAiB,sBAAsB,cAAc;AACrD,4BAAsB,eAAe;;AAGzC,QAAI,cAAc,sBAAsB,UAAU,OAAO;AACrD,4BAAsB,UAAU,QAAQ;;AAG5C,QAAI,cAAc,sBAAsB,UAAU,OAAO;AACrD,4BAAsB,UAAU,QAAQ;;AAG5C,QAAI,cAAc,sBAAsB,UAAU,OAAO;AACrD,4BAAsB,UAAU,QAAQ;;AAG5C,QAAI,gBAAgB,sBAAsB,aAAa;AACnD,4BAAsB,cAAc;;AAGxC,QAAI,kBAAkB,sBAAsB,eAAe;AACvD,4BAAsB,gBAAgB;;AAG1C,QAAI,gBAAgB,CAAC,MAAM,KAAK,gBAAgB,CAAC,MAAM,KAAK,gBAAgB,CAAC,MAAM,GAAG;AAClF,iBAAW,eAAe,GAAG,eAAe;;AAGhD,QAAI,aAAa,CAAC,MAAM,KAAK,aAAa,CAAC,MAAM,KAAK,aAAa,CAAC,MAAM,GAAG;AACzE,iBAAW,YAAY,GAAG,YAAY;;AAG1C,UAAM,gBAAgB,MAAK;AACvB,oBAAc,QAAQ,UAAU;AAGhC,MAAAD,yCAAwC,eAAe,gBAAgB,GAAG,CAAC;AAE3E,qBAAe,QAAQ,oBAAoB,EAAE,QAAQ,mBAAmB,GAAG,CAAC;AAC5E,qBAAe,QAAQ,oBAAoB,EAAE,QAAQ,mBAAmB,GAAG,CAAC;AAC5E,qBAAe,QAAQ,oBAAoB,EAAE,QAAQ,mBAAmB,GAAG,CAAC;AAC5E,qBAAe,QAAQ,iBAAiB,EAAE,QAAQ,mBAAmB,GAAG,CAAC;AACzE,qBAAe,QAAQ,iBAAiB,EAAE,QAAQ,mBAAmB,GAAG,CAAC;AACzE,qBAAe,QAAQ,iBAAiB,EAAE,QAAQ,mBAAmB,GAAG,CAAC;AAEzE,wBAAkB,QAAQ,mBAAmB,EAAE,QAAQ,cAAc,WAAW;IACpF;AACA,UAAM,mBAAmB,MAAK;AAC1B,oBAAc,WAAW,UAAU;AAGnC,MAAAO,8CAA6C,eAAe,gBAAgB,GAAG,CAAC;AAEhF,qBAAe,WAAW,oBAAoB;AAC9C,2BAAqB,WAAW,iBAAiB;AACjD,qBAAe,WAAW,oBAAoB;AAC9C,2BAAqB,WAAW,iBAAiB;AACjD,qBAAe,WAAW,oBAAoB;AAC9C,2BAAqB,WAAW,iBAAiB;AACjD,qBAAe,WAAW,iBAAiB;AAC3C,wBAAkB,WAAW,iBAAiB;AAC9C,qBAAe,WAAW,iBAAiB;AAC3C,wBAAkB,WAAW,iBAAiB;AAC9C,qBAAe,WAAW,iBAAiB;AAC3C,wBAAkB,WAAW,iBAAiB;AAE9C,wBAAkB,WAAW,mBAAmB;AAChD,0BAAoB,WAAW,cAAc,WAAW;IAC5D;AAEA,WAAOE,oBAAmB,qBAAqB,uBAAuB,UAAU,GAAG,eAAe,gBAAgB;EACtH;AACJ;;;ACvWO,IAAM,kCAAqE,CAACC,0BAAwB;AACvG,SAAO,CAAC,eAAe,EAAE,sBAAsB,MAAM,KAAI,MAAM;AAE3D,UAAM,gBAAgB,gBAAgB,eAAe,OAAO,IAAI,aAAa,IAAI;AACjF,UAAM,gBAAgB,gBAAgB,eAAe,OAAO,IAAI,aAAa,IAAI;AAEjF,UAAM,qBAAqB,cAAc,mBAAmB,eAAe,eAAe,EAAE,qBAAoB,CAAE;AAGlH,QAAI,MAAM,KAAK,IAAI,EAAE,SAAS,GAAG;AAC7B,YAAMA,sBAAoB;;AAG9B,WAAO;EACX;AACJ;;;ACfO,IAAM,kCAAqE,CAC9E,eACA,YACA,uBACA,2BACA;AACA,SAAO,cAAc,sBAAsB,YAAY,uBAAuB,sBAAsB;AACxG;;;ACLO,IAAM,sCAA6E,CACtF,mCACAC,6BACA;AACA,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,mBAAmB,QAAQ;AAMjC,QAAI,qBAAqB,eAAe;AACpC,YAAMA,yBAAuB;;AAIjC,QAAI,cAAc,uBAAuB,QAAW;AAChD,aAAO,kCAAkC,eAAe,OAAO;;AAGnE,UAAM,yBAAyB,cAAc,mBAAkB;AAE/D,iCAA6B,wBAAwB,OAAO;AAE5D,yCAAqC,wBAAwB,SAAS,KAAK;AAM3E,WAAO,eAAe,wBAAwB,oBAAoB;MAC9D,KAAK,MAAM;MACX,KAAK,CAAC,UAAS;AACX,YAAI,UAAU,kBAAkB;AAC5B,gBAAMA,yBAAuB;;MAErC;KACH;AAED,WAAO;EACX;AACJ;;;AClCO,IAAM,2CAAuF,CAChGC,gCACAC,kCACAC,uBACAC,6BACAC,0BACAC,wBACA;AAEA,QAAM,aAAa;AACnB,QAAM,WAAW,IAAI,aAAa,CAAC,GAAG,CAAC,CAAC;AACxC,QAAM,UAAU,KAAK,KAAK;AAC1B,QAAM,yBAAyB,EAAE,cAAc,GAAG,kBAAkB,YAAY,uBAAuB,WAAU;AACjH,QAAM,qCAAqC,EAAE,GAAG,wBAAwB,YAAY,OAAM;AAE1F,QAAM,4BAA4B,CAC9B,eACA,eACA,aACA,sBACA;AACA,UAAM,sBAAsB,IAAI,aAAa,UAAU;AACvD,UAAM,uBAAuB,IAAI,aAAa,UAAU;AAExD,aAAS,IAAI,GAAG,IAAI,YAAY,KAAK,GAAG;AACpC,YAAM,IAAK,KAAK,aAAa,KAAM;AAEnC,0BAAoB,CAAC,IAAI,KAAK,IAAI,CAAC;AACnC,2BAAqB,CAAC,IAAI,KAAK,IAAI,CAAC;;AAGxC,UAAM,eAAeH,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAE/F,UAAM,qBACFC,4BAA2B,eAAe,EAAE,GAAG,oCAAoC,OAAO,oBAAmB,CAAE;AAGnH,UAAM,oBACFA,4BAA2B,eAAe,EAAE,GAAG,oCAAoC,OAAO,SAAQ,CAAE;AAExG,UAAM,gBAAgBD,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAEhG,UAAM,sBACFC,4BAA2B,eAAe,EAAE,GAAG,oCAAoC,OAAO,qBAAoB,CAAE;AAGpH,WAAO;MACH,eAAY;AACR,sBAAc,QAAQ,YAAY;AAClC,sBAAc,QAAQ,kBAAkB,WAAW,SAAY,oBAAoB,kBAAkB,OAAO,CAAC,CAAC;AAC9G,sBAAc,QAAQ,aAAa;AAEnC,0BAAkB,QAAQ,WAAW;AAErC,oBAAY,QAAQ,mBAAmB,WAAW,SAAY,qBAAqB,mBAAmB,OAAO,CAAC,CAAC;AAC/G,oBAAY,QAAQ,oBAAoB,WAAW,SAAY,sBAAsB,oBAAoB,OAAO,CAAC,CAAC;AAElH,2BAAmB,QAAQ,aAAa,IAAI;AAC5C,4BAAoB,QAAQ,cAAc,IAAI;AAE9C,qBAAa,QAAQ,mBAAmB,GAAG,CAAC;AAC5C,sBAAc,QAAQ,mBAAmB,GAAG,CAAC;MACjD;MACA,kBAAe;AACX,sBAAc,WAAW,YAAY;AACrC,sBAAc,WAAW,kBAAkB,WAAW,SAAY,oBAAoB,kBAAkB,OAAO,CAAC,CAAC;AACjH,sBAAc,WAAW,aAAa;AAEtC,0BAAkB,WAAW,WAAW;AAExC,oBAAY,WAAW,mBAAmB,WAAW,SAAY,qBAAqB,mBAAmB,OAAO,CAAC,CAAC;AAClH,oBAAY,WAAW,oBAAoB,WAAW,SAAY,sBAAsB,oBAAoB,OAAO,CAAC,CAAC;AAErH,2BAAmB,WAAW,aAAa,IAAI;AAC/C,4BAAoB,WAAW,cAAc,IAAI;AAEjD,qBAAa,WAAW,mBAAmB,GAAG,CAAC;AAC/C,sBAAc,WAAW,mBAAmB,GAAG,CAAC;MACpD;;EAER;AAEA,QAAM,8BAA8B,CAChC,eACA,eACA,aACA,sBACA;AACA,UAAM,wCAAwC,IAAI,aAAa,UAAU;AACzE,UAAM,yCAAyC,IAAI,aAAa,UAAU;AAC1E,UAAM,yCAAyC,IAAI,aAAa,UAAU;AAC1E,UAAM,0CAA0C,IAAI,aAAa,UAAU;AAE3E,UAAM,cAAc,KAAK,MAAM,aAAa,CAAC;AAE7C,aAAS,IAAI,GAAG,IAAI,YAAY,KAAK,GAAG;AACpC,UAAI,IAAI,aAAa;AACjB,cAAM,KAAM,IAAI,gBAAgB,aAAa,IAAI,eAAgB;AAEjE,8CAAsC,CAAC,IAAI,KAAK,IAAI,CAAC;AACrD,+CAAuC,CAAC,IAAI,KAAK,IAAI,CAAC;AACtD,+CAAuC,CAAC,IAAI;AAC5C,gDAAwC,CAAC,IAAI;aAC1C;AACH,cAAM,IAAK,KAAK,aAAa,IAAI,eAAgB;AAEjD,8CAAsC,CAAC,IAAI;AAC3C,+CAAuC,CAAC,IAAI;AAC5C,+CAAuC,CAAC,IAAI,KAAK,IAAI,CAAC;AACtD,gDAAwC,CAAC,IAAI,KAAK,IAAI,CAAC;;;AAI/D,UAAM,sBAAsBF,iCAAgC,eAAe;MACvE,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,iBAAiB;KACpB;AACD,UAAM,iCAAiCC,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAEjH,UAAM,uCAAmEC,4BAA2B,eAAe;MAC/G,GAAG;MACH,OAAO;KACV;AACD,UAAM,kCAAkCD,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAElH,UAAM,wCAAoEC,4BAA2B,eAAe;MAChH,GAAG;MACH,OAAO;KACV;AAED,UAAM,oBACFA,4BAA2B,eAAe,EAAE,GAAG,oCAAoC,OAAO,SAAQ,CAAE;AAExG,UAAM,kCAAkCD,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAElH,UAAM,wCAAoEC,4BAA2B,eAAe;MAChH,GAAG;MACH,OAAO;KACV;AACD,UAAM,mCAAmCD,sBAAqB,eAAe,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAEnH,UAAM,yCAAqEC,4BAA2B,eAAe;MACjH,GAAG;MACH,OAAO;KACV;AAED,WAAO;MACH,eAAY;AACR,sBAAc,QAAQ,mBAAmB;AACzC,sBAAc,QAAQ,kBAAkB,WAAW,SAAY,oBAAoB,kBAAkB,OAAO,CAAC,CAAC;AAE9G,4BAAoB,QAAQ,gCAAgC,CAAC;AAC7D,4BAAoB,QAAQ,iCAAiC,CAAC;AAC9D,4BAAoB,QAAQ,iCAAiC,CAAC;AAC9D,4BAAoB,QAAQ,kCAAkC,CAAC;AAE/D,0BAAkB,QAAQ,WAAW;AAErC,oBAAY,QACR,qCAAqC,WAAW,SAC1C,uCACA,qCAAqC,OAAO,CAAC,CAAC;AAExD,oBAAY,QACR,sCAAsC,WAAW,SAC3C,wCACA,sCAAsC,OAAO,CAAC,CAAC;AAEzD,oBAAY,QACR,sCAAsC,WAAW,SAC3C,wCACA,sCAAsC,OAAO,CAAC,CAAC;AAEzD,oBAAY,QACR,uCAAuC,WAAW,SAC5C,yCACA,uCAAuC,OAAO,CAAC,CAAC;AAG1D,6CAAqC,QAAQ,+BAA+B,IAAI;AAChF,8CAAsC,QAAQ,gCAAgC,IAAI;AAClF,8CAAsC,QAAQ,gCAAgC,IAAI;AAClF,+CAAuC,QAAQ,iCAAiC,IAAI;AAEpF,uCAA+B,QAAQ,mBAAmB,GAAG,CAAC;AAC9D,wCAAgC,QAAQ,mBAAmB,GAAG,CAAC;AAE/D,wCAAgC,QAAQ,mBAAmB,GAAG,CAAC;AAC/D,yCAAiC,QAAQ,mBAAmB,GAAG,CAAC;MACpE;MACA,kBAAe;AACX,sBAAc,WAAW,mBAAmB;AAC5C,sBAAc,WAAW,kBAAkB,WAAW,SAAY,oBAAoB,kBAAkB,OAAO,CAAC,CAAC;AAEjH,4BAAoB,WAAW,gCAAgC,CAAC;AAChE,4BAAoB,WAAW,iCAAiC,CAAC;AACjE,4BAAoB,WAAW,iCAAiC,CAAC;AACjE,4BAAoB,WAAW,kCAAkC,CAAC;AAElE,0BAAkB,WAAW,WAAW;AAExC,oBAAY,WACR,qCAAqC,WAAW,SAC1C,uCACA,qCAAqC,OAAO,CAAC,CAAC;AAExD,oBAAY,WACR,sCAAsC,WAAW,SAC3C,wCACA,sCAAsC,OAAO,CAAC,CAAC;AAEzD,oBAAY,WACR,sCAAsC,WAAW,SAC3C,wCACA,sCAAsC,OAAO,CAAC,CAAC;AAEzD,oBAAY,WACR,uCAAuC,WAAW,SAC5C,yCACA,uCAAuC,OAAO,CAAC,CAAC;AAG1D,6CAAqC,WAAW,+BAA+B,IAAI;AACnF,8CAAsC,WAAW,gCAAgC,IAAI;AACrF,8CAAsC,WAAW,gCAAgC,IAAI;AACrF,+CAAuC,WAAW,iCAAiC,IAAI;AAEvF,uCAA+B,WAAW,mBAAmB,GAAG,CAAC;AACjE,wCAAgC,WAAW,mBAAmB,GAAG,CAAC;AAElE,wCAAgC,WAAW,mBAAmB,GAAG,CAAC;AAClE,yCAAiC,WAAW,mBAAmB,GAAG,CAAC;MACvE;;EAER;AAEA,QAAM,qBAAqB,CACvB,eACA,cACA,eACA,aACA,sBACA;AACA,QAAI,iBAAiB,GAAG;AACpB,aAAO,0BAA0B,eAAe,eAAe,aAAa,iBAAiB;;AAGjG,QAAI,iBAAiB,GAAG;AACpB,aAAO,4BAA4B,eAAe,eAAe,aAAa,iBAAiB;;AAGnG,UAAMC,yBAAuB;EACjC;AAEA,SAAO,CAAC,eAAe,EAAE,cAAc,kBAAkB,KAAK,GAAG,iBAAgB,MAAM;AACnF,QAAI,qBAAqB,OAAO;AAC5B,YAAMA,yBAAuB;;AAGjC,UAAM,oBAAoBJ,+BAA8B,eAAe;MACnE,GAAG;MACH,cAAc;MACd;MACA,gBAAgB;KACnB;AACD,UAAM,gBAAgBE,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,cAAc,kBAAkB,MAAM,EAAC,CAAE;AAC1H,UAAM,cAAcA,sBAAqB,eAAe;MACpD,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,MAAM;KACT;AAED,QAAI,EAAE,cAAc,gBAAe,IAAK,mBACpC,eACA,cACA,eACA,aACA,iBAAiB;AAGrB,WAAO,eAAe,YAAY,MAAM,gBAAgB,EAAE,KAAK,MAAM,EAAC,CAAE;AACxE,WAAO,eAAe,YAAY,MAAM,YAAY,EAAE,KAAK,MAAM,EAAC,CAAE;AACpE,WAAO,eAAe,YAAY,MAAM,YAAY,EAAE,KAAK,MAAM,GAAE,CAAE;AAErE,UAAMI,sCAAqC;MACvC,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,eAAY;AACZ,eAAO,cAAc;MACzB;MACA,IAAI,aAAa,OAAK;AAClB,YAAI,cAAc,iBAAiB,OAAO;AACtC,cAAI,aAAa;AACb,4BAAe;;AAGnB,WAAC,EAAE,cAAc,gBAAe,IAAK,mBACjC,eACA,OACA,eACA,aACA,iBAAiB;AAGrB,cAAI,aAAa;AACb,yBAAY;;;AAIpB,sBAAc,eAAe;MACjC;MACA,IAAI,mBAAgB;AAChB,eAAO,cAAc;MACzB;MACA,IAAI,iBAAiB,OAAK;AACtB,YAAI,UAAU,iBAAiB,UAAU,OAAO;AAC5C,gBAAMF,yBAAuB;;AAGjC,sBAAc,mBAAmB;MACrC;MACA,IAAI,wBAAqB;AACrB,eAAO,cAAc;MACzB;MACA,IAAI,sBAAsB,OAAK;AAC3B,sBAAc,wBAAwB;MAC1C;MACA,IAAI,UAAO;AACP,eAAO,cAAc;MACzB;MACA,IAAI,SAAM;AACN,eAAO,CAAC,aAAa;MACzB;MACA,IAAI,iBAAc;AACd,eAAO,cAAc;MACzB;MACA,IAAI,kBAAe;AACf,eAAO,cAAc;MACzB;MACA,IAAI,MAAG;AACH,eAAO,YAAY;MACvB;MACA,oBAAoB,MAAW;AAC3B,eAAO,cAAc,iBAAiB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACnE;MACA,iBAAiB,MAAW;AACxB,eAAO,cAAc,cAAc,KAAK,CAAC,CAAC;MAC9C;MACA,uBAAuB,MAAW;AAC9B,eAAO,cAAc,oBAAoB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACtE;;AAGJ,QAAI,cAAc;AAElB,UAAM,gBAAgB,MAAK;AACvB,mBAAY;AAEZ,oBAAc;IAClB;AACA,UAAM,mBAAmB,MAAK;AAC1B,sBAAe;AAEf,oBAAc;IAClB;AAEA,WAAOC,oBACH,qBAAqBC,qCAAoC,iBAAiB,GAC1E,eACA,gBAAgB;EAExB;AACJ;;;AC/XO,IAAM,oCAAyE,CAClFC,6CACAC,0BACAC,kCACAC,YACAC,qBACAC,gCACAC,wBACA;AACA,SAAO,CAAC,eAAe,YAAW;AAC9B,UAAM,uBAAuB,cAAc,iBAAgB;AAQ3D,QACID,mCAAkC,QAClCA,+BAA8B,SAAS,wBACvC,cAAc,WAAU,EAAG,KAAK,mBAAmB,QACrD;AACE,aAAOH,iCAAgC,eAAe,OAAO;;AAGjE,iCAA6B,sBAAsB,OAAO;AAE1D,UAAM,QAAQ,QAAQ,UAAU,QAAQ,QAAQ,iBAAiB,eAAe,QAAQ,QAAQ,IAAI,aAAa,QAAQ,KAAK;AAG9H,QAAI,UAAU,QAAQ,MAAM,SAAS,GAAG;AACpC,YAAMD,yBAAuB;;AAIjC,gCAA4B,sBAAsB,EAAE,MAAK,GAAI,OAAO;AACpE,gCAA4B,sBAAsB,SAAS,YAAY;AAEvE,QAAI,wCAA6D;AACjE,QAAI,cAAc;AAElB,IAAAK,oBACI,sBACA,SACA,CAAC,QAAQ,MAAM,IAAI,KAAK,oBAAoB,GAC5C,CAAC,QAAQ,CAAC,UAAS;AACf,UAAI,KAAK,sBAAsB,KAAK;AAEpC,UAAI,aAAa;AACb,YAAIH,WAAU,KAAK,KAAK,0CAA0C,MAAM;AACpE,kDAAwCH,4CACpC,eACA,oBAAoB;mBAEjB,CAACG,WAAU,KAAK,KAAK,0CAA0C,MAAM;AAC5E,gDAAqC;AACrC,kDAAwC;;;AAIhD,aAAO;IACX,CAAC;AAGL,UAAM,gBAAgB,MAAK;AACvB,oBAAc;AAEd,UAAIA,WAAU,qBAAqB,KAAK,GAAG;AACvC,gDAAwCH,4CAA2C,eAAe,oBAAoB;;IAE9H;AACA,UAAM,mBAAmB,MAAK;AAC1B,oBAAc;AAEd,UAAI,0CAA0C,MAAM;AAChD,8CAAqC;AACrC,gDAAwC;;IAEhD;AAEA,WAAOI,oBAAmB,sBAAsB,eAAe,gBAAgB;EACnF;AACJ;;;ACnFO,IAAM,yCAAmF,CAC5FG,6CACAC,0BACAC,uBACAC,YACAC,wBACA;AACA,SAAO,CAAC,eAAe,EAAE,OAAO,YAAY,GAAG,iBAAgB,MAAM;AACjE,UAAM,yBAAyB,cAAc,iBAAgB;AAC7D,UAAM,yBAAyB,cAAc,iBAAgB;AAE7D,iCAA6B,wBAAwB,gBAAgB;AACrE,iCAA6B,wBAAwB,gBAAgB;AAErE,UAAM,gBAAgBF,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,MAAM,EAAC,CAAE;AAC1F,UAAM,iBAAiBA,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,MAAM,GAAE,CAAE;AAC5F,UAAM,iBAAiBA,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,MAAM,EAAC,CAAE;AAC3F,UAAM,iBAAiBA,sBAAqB,eAAe,EAAE,GAAG,kBAAkB,MAAM,GAAE,CAAE;AAE5F,QAAI,wCAA6D;AACjE,QAAI,cAAc;AAClB,QAAI,kBAAyD;AAE7D,UAAM,4BAA4B;MAC9B,IAAI,aAAU;AACV,eAAO;MACX;MACA,IAAI,eAAY;AACZ,eAAO,uBAAuB;MAClC;MACA,IAAI,aAAa,OAAK;AAClB,sBAAc,eAAe;AAC7B,uBAAe,eAAe;AAC9B,+BAAuB,eAAe;AACtC,uBAAe,eAAe;AAC9B,+BAAuB,eAAe;AACtC,uBAAe,eAAe;MAClC;MACA,IAAI,mBAAgB;AAChB,eAAO,uBAAuB;MAClC;MACA,IAAI,iBAAiB,OAAK;AACtB,sBAAc,mBAAmB;AACjC,uBAAe,mBAAmB;AAClC,+BAAuB,mBAAmB;AAC1C,uBAAe,mBAAmB;AAClC,+BAAuB,mBAAmB;AAC1C,uBAAe,mBAAmB;MACtC;MACA,IAAI,wBAAqB;AACrB,eAAO,uBAAuB;MAClC;MACA,IAAI,sBAAsB,OAAK;AAC3B,sBAAc,wBAAwB;AACtC,uBAAe,wBAAwB;AACvC,+BAAuB,wBAAwB;AAC/C,uBAAe,wBAAwB;AACvC,+BAAuB,wBAAwB;AAC/C,uBAAe,wBAAwB;MAC3C;MACA,IAAI,UAAO;AACP,eAAO,uBAAuB;MAClC;MACA,IAAI,QAAK;AACL,eAAO;MACX;MACA,IAAI,MAAM,OAAK;AAEX,YAAI,UAAU,QAAQ,MAAM,SAAS,GAAG;AACpC,gBAAMD,yBAAuB;;AAGjC,YAAI,UAAU,MAAM;AAChB,iCAAuB,QAAQ;AAC/B,iCAAuB,QAAQ;eAC5B;AACH,gBAAM,cAAc,MAAM;AAE1B,gBAAM,gBAAgB,IAAI,aAAa,cAAc,IAAK,cAAc,CAAE;AAC1E,gBAAM,gBAAgB,IAAI,aAAa,cAAc,IAAK,cAAc,CAAE;AAE1E,wBAAc,CAAC,IAAI,MAAM,CAAC;AAC1B,wBAAc,CAAC,IAAI,CAAC,MAAM,cAAc,CAAC;AAEzC,gBAAM,SAAS,KAAK,MAAM,cAAc,KAAK,CAAC;AAC9C,gBAAM,eAAe,cAAc,KAAK,IAAI;AAE5C,mBAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,kBAAM,iBAAkB,IAAI,SAAU;AAEtC,kBAAM,aAAa,KAAK,MAAM,cAAc;AAC5C,kBAAM,aAAa,KAAK,KAAK,cAAc;AAE3C,0BAAc,CAAC,IACX,eAAe,aACT,MAAM,UAAU,KACf,KAAK,iBAAiB,eAAe,MAAM,UAAU,KACrD,KAAK,aAAa,mBAAmB,MAAM,UAAU;AAChE,0BAAc,CAAC,IACX,eAAe,aACT,CAAC,MAAM,cAAc,IAAI,UAAU,IACnC,GAAG,KAAK,iBAAiB,eAAe,MAAM,cAAc,IAAI,UAAU,MACzE,KAAK,aAAa,mBAAmB,MAAM,cAAc,IAAI,UAAU;;AAGtF,wBAAc,MAAM,IAAI,cAAc,MAAM,IAAI,MAAM,SAAS,CAAC,KAAK,MAAM,SAAS,CAAC,IAAI,MAAM,SAAS,CAAC,KAAK;AAE9G,iCAAuB,QAAQ;AAC/B,iCAAuB,QAAQ;;AAGnC,0BAAkB;AAElB,YAAI,aAAa;AACb,cAAIE,WAAU,eAAe,KAAK,0CAA0C,MAAM;AAC9E,oDAAwCH,4CAA2C,eAAe,aAAa;qBACxG,0CAA0C,MAAM;AACvD,kDAAqC;AACrC,oDAAwC;;;MAGpD;MACA,IAAI,SAAM;AACN,eAAO,CAAC,aAAa;MACzB;MACA,IAAI,iBAAc;AACd,eAAO,uBAAuB;MAClC;MACA,IAAI,kBAAe;AACf,eAAO,uBAAuB;MAClC;MACA,IAAI,aAAU;AACV,eAAO,uBAAuB;MAClC;MACA,IAAI,WAAW,OAAK;AAChB,+BAAuB,aAAa;AACpC,+BAAuB,aAAa;MACxC;MACA,oBAAoB,MAAW;AAC3B,eAAO,cAAc,iBAAiB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACnE;MACA,iBAAiB,MAAW;AACxB,eAAO,cAAc,cAAc,KAAK,CAAC,CAAC;MAC9C;MACA,uBAAuB,MAAW;AAC9B,eAAO,cAAc,oBAAoB,KAAK,CAAC,GAAG,KAAK,CAAC,GAAG,KAAK,CAAC,CAAC;MACtE;;AAGJ,QAAI,UAAU,MAAM;AAEhB,gCAA0B,QAAQ,iBAAiB,eAAe,QAAQ,IAAI,aAAa,KAAK;;AAGpG,QAAI,eAAe,0BAA0B,YAAY;AACrD,gCAA0B,aAAa;;AAG3C,UAAM,gBAAgB,MAAK;AACvB,oBAAc,QAAQ,sBAAsB,EAAE,QAAQ,cAAc;AAEpE,oBAAc,QAAQ,cAAc,EAAE,QAAQ,sBAAsB,EAAE,QAAQ,cAAc,EAAE,QAAQ,cAAc;AAEpH,oBAAc;AAEd,UAAIG,WAAU,eAAe,GAAG;AAC5B,gDAAwCH,4CAA2C,eAAe,aAAa;;IAEvH;AACA,UAAM,mBAAmB,MAAK;AAC1B,oBAAc,WAAW,sBAAsB;AAC/C,6BAAuB,WAAW,cAAc;AAEhD,oBAAc,WAAW,cAAc;AACvC,qBAAe,WAAW,sBAAsB;AAChD,6BAAuB,WAAW,cAAc;AAChD,qBAAe,WAAW,cAAc;AAExC,oBAAc;AAEd,UAAI,0CAA0C,MAAM;AAChD,8CAAqC;AACrC,gDAAwC;;IAEhD;AAEA,WAAOI,oBAAmB,qBAAqB,2BAA2B,cAAc,GAAG,eAAe,gBAAgB;EAC9H;AACJ;;;AC9LO,IAAM,0BAAqD,MAAM,IAAI,aAAa,IAAI,mBAAmB;;;ACGhH,IAAMC,oBAAkB;EACpB,kBAAkB;;AAGf,IAAM,uCAA+E,CACxFC,8BACAC,kBACAC,0BACAC,kCACAC,oBACA;AACA,SAAO,MAAM,4BAA4BJ,6BAAiD;IAStF,YAAY,GAAyC,GAAY,GAAU;AACvE,UAAI;AAEJ,UAAI,OAAO,MAAM,YAAY,MAAM,UAAa,MAAM,QAAW;AAC7D,kBAAU,EAAE,QAAQ,GAAG,kBAAkB,GAAG,YAAY,EAAC;iBAClD,OAAO,MAAM,UAAU;AAC9B,kBAAU;aACP;AACH,cAAM,IAAI,MAAM,qCAAqC;;AAGzD,YAAM,EAAE,QAAQ,kBAAkB,WAAU,IAAK,EAAE,GAAGD,mBAAiB,GAAG,QAAO;AAEjF,YAAM,4BAA4BI,iCAAgC,kBAAkB,QAAQ,UAAU;AAGtG,UAAI,CAACF,iBAAgB,oBAAoB,MAAM,mBAAmB,yBAAyB,CAAC,GAAG;AAC3F,kCAA0B,iBACtB,gBACC,MAAK;AACF,cAAI,IAAI;AAER,gBAAM,wBAAwB,CAAC,UAAgB;AAC3C,gBAAI,KAAK,WAAW,WAAW;AAC3B,kBAAI,IAAI,GAAG;AACP,0CAA0B,oBAAoB,eAAe,qBAAqB;AAClF,sBAAM,yBAAwB;AAE9B,qBAAK,2BAA2B,KAAK;qBAClC;AACH,qBAAK;;;UAGjB;AAEA,iBAAO;QACX,GAAE,CAAE;;AAIZ,YAAM,2BAA2B,gBAAgB;AAEjD,WAAK,UAAU;AACf,WAAK,6BAA6B;AAClC,WAAK,SAAS;IAClB;IAEA,IAAI,SAAM;AAEN,UAAI,KAAK,2BAA2B,WAAW,QAAW;AACtD,eAAO,KAAK;;AAGhB,aAAO,KAAK,2BAA2B;IAC3C;IAEA,IAAI,QAAK;AACL,aAAO,KAAK,WAAW,OAAO,KAAK,2BAA2B,QAAQ,KAAK;IAC/E;IAEO,iBAAc;AAKjB,UAAI,KAAK,WAAW,WAAW;AAC3B,eAAO,QAAQ,OAAOC,yBAAuB,CAAE;;AAGnD,WAAK,SAAS;AAEd,aAAOE,gBAAe,KAAK,aAAa,KAAK,0BAA0B,EAAE,QAAQ,MAAK;AAClF,aAAK,SAAS;AAEd,6BAAqB,IAAI;MAC7B,CAAC;IACL;IAEQ,2BAA2B,OAAY;AAC3C,UAAI,KAAK,WAAW,MAAM;AACtB,aAAK,2BAA2B,cAAc,KAAK;aAChD;AACH,mBAAW,MAAM,KAAK,2BAA2B,KAAK,CAAC;;IAE/D;;AAER;;;AC3FA,IAAMC,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,QAAQ;EACR,WAAW;EACX,cAAc;EACd,MAAM;;AAGH,IAAM,kCAAqE,CAC9EC,uBACAC,mBACAC,6BACAC,+BACAC,mBACAC,8BACAC,uBACA;AACA,SAAO,MAAM,uBACDN,sBAA0D;IAalE,YAAYO,UAAY,SAAqC;AACzD,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGR,mBAAiB,GAAG,QAAO;AACtD,YAAM,uBAAuBG,4BAA2B,eAAe,aAAa;AACpF,YAAM,YAAYG,6BAA4B,aAAa;AAC3D,YAAM,yBAAsD,YAAYF,8BAA4B,IAAK;AACzG,YAAM,UAAUI,SAAQ,aAAa;AAErC,YAAMA,UAAS,OAAO,sBAAsB,sBAAsB;AAGlE,WAAK,UAAUN,kBAAiB,MAAM,WAAW,qBAAqB,QAAQ,QAAQ,OAAO;AAE7F,WAAK,aAAaA,kBAAiB,MAAM,WAAW,qBAAqB,WAAW,SAAS,CAAC,OAAO;AACrG,WAAK,wBAAwB;AAC7B,WAAK,WAAW;AAChB,WAAK,0BAA0B;AAE/B,UAAI,KAAK,4BAA4B,QAAQ,cAAc,iBAAiB,QAAW;AAC5B,aAAK,wBAAyB,eACjF,cAAc;;IAE1B;IAEA,IAAI,SAAM;AACN,aAAO,KAAK;IAChB;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;IAEA,IAAI,UAAO;AACP,aAAO,KAAK;IAChB;IAEA,IAAI,QAAQ,OAAK;AACb,YAAM,kBAAkB,OAAO,UAAU,aAAaK,mBAAkB,MAAM,KAAK,IAAI;AAEvF,WAAK,sBAAsB,UAAU;AAErC,YAAM,gBAAgB,KAAK,sBAAsB;AAEjD,WAAK,WAAW,kBAAkB,QAAQ,kBAAkB,kBAAkB,QAAQ;IAC1F;IAEA,IAAI,OAAI;AACJ,aAAO,KAAK,sBAAsB;IACtC;IAEA,IAAI,KAAK,OAAK;AACV,WAAK,sBAAsB,OAAO;AAElC,UAAI,KAAK,4BAA4B,MAAM;AACvC,aAAK,wBAAwB,eAAe;;IAEpD;IAEO,gBAAgB,cAA0B;AAC7C,WAAK,sBAAsB,gBAAgB,YAAY;AAEvD,UAAI,KAAK,4BAA4B,MAAM;AACvC,aAAK,wBAAwB,eAAe;;IAEpD;IAEO,MAAM,OAAO,GAAC;AACjB,WAAK,sBAAsB,MAAM,IAAI;AAErC,UAAI,KAAK,4BAA4B,MAAM;AACvC,aAAK,wBAAwB,QAAQ;;AAGzC,UAAI,KAAK,QAAQ,UAAU,UAAU;AACjC,iCAAyB,IAAI;AAE7B,cAAM,8BAA8B,MAAK;AACrC,eAAK,sBAAsB,oBAAoB,SAAS,2BAA2B;AAEnF,cAAI,kBAAkB,IAAI,GAAG;AACzB,sCAA0B,IAAI;;QAEtC;AAEA,aAAK,sBAAsB,iBAAiB,SAAS,2BAA2B;;IAExF;IAEO,KAAK,OAAO,GAAC;AAChB,WAAK,sBAAsB,KAAK,IAAI;AAEpC,UAAI,KAAK,4BAA4B,MAAM;AACvC,aAAK,wBAAwB,OAAO;;IAE5C;;AAER;;;ACjJO,IAAM,sCAA6E,CACtFE,oBACAC,6BACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,gCAAgC,oBAAI,QAAO;AAEjD,QAAI,eAAqC;AACzC,QAAIC,SAAuB;AAC3B,QAAI,OAAsB;AAE1B,UAAM,uBAAuB,OAAO,OAA2B,8BAAyD;AACpH,UAAI,uBAAuBH,oBAA6C,KAAK;AAG7E,YAAM,uCAAuC,iBAAiB,sBAAsB,yBAAyB;AAE7G,UAAI,CAAC,sCAAsC;AACvC,cAAM,UAAU;UACZ,cAAc,qBAAqB;UACnC,kBAAkB,qBAAqB;UACvC,uBAAuB,qBAAqB;UAC5C,QAAQ,qBAAqB,OAAO;UACpC,WAAW,qBAAqB,UAAU;UAC1C,cAAc,iBAAiB,OAAO,SAAY;UAClD,MAAM,qBAAqB;;AAG/B,+BAAuBD,4BAA2B,2BAA2B,OAAO;AAEpF,YAAII,WAAU,MAAM;AAChB,+BAAqB,MAAMA,MAAK;;AAGpC,YAAI,SAAS,MAAM;AACf,+BAAqB,KAAK,IAAI;;;AAItC,oCAA8B,IAAI,2BAA2B,oBAAoB;AAEjF,UAAI,CAAC,sCAAsC;AACvC,cAAMF,kBAAiB,2BAA2B,MAAM,QAAQ,qBAAqB,MAAM;AAC3F,cAAMA,kBAAiB,2BAA2B,MAAM,WAAW,qBAAqB,SAAS;aAC9F;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,QAAQ,qBAAqB,MAAM;AAC5F,cAAMA,mBAAkB,2BAA2B,MAAM,WAAW,qBAAqB,SAAS;;AAGtG,YAAMI,yBAAwB,OAAO,2BAA2B,oBAAoB;AAEpF,aAAO;IACX;AAEA,WAAO;MACH,IAAI,aAAa,OAA2B;AACxC,uBAAe;MACnB;MACA,IAAI,MAAM,OAAa;AACnB,QAAAC,SAAQ;MACZ;MACA,IAAI,KAAK,OAAa;AAClB,eAAO;MACX;MACA,OAAO,OAA2B,2BAAqD;AACnF,cAAM,+BAA+B,8BAA8B,IAAI,yBAAyB;AAEhG,YAAI,iCAAiC,QAAW;AAC5C,iBAAO,QAAQ,QAAQ,4BAA4B;;AAGvD,eAAO,qBAAqB,OAAO,yBAAyB;MAChE;;EAER;AACJ;;;ACvEA,IAAMC,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,gBAAgB;EAChB,gBAAgB;EAChB,eAAe;EACf,eAAe;EACf,aAAa;EACb,cAAc;EACd,cAAc;EACd,cAAc;EACd,cAAc;EACd,WAAW;EACX,WAAW;EACX,WAAW;EACX,aAAa;EACb,eAAe;;AAGZ,IAAM,8BAA6D,CACtEC,uBACAC,mBACAC,yBACAC,2BACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,mBAAuCN,sBAAuB;IAevE,YAAYO,UAAY,SAAiC;AACrD,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGR,mBAAiB,GAAG,QAAO;AACtD,YAAM,mBAAmBG,wBAAuB,eAAe,aAAa;AAC5E,YAAM,YAAYG,6BAA4B,aAAa;AAC3D,YAAM,qBAAmD,YAAYF,0BAAwB,IAAK;AAElG,YAAMI,UAAS,OAAO,kBAAkB,kBAAkB;AAE1D,WAAK,oBAAoB;AAEzB,WAAK,gBAAgBN,kBACjB,MACA,WACA,iBAAiB,cACjB,4BACA,0BAA0B;AAE9B,WAAK,gBAAgBA,kBACjB,MACA,WACA,iBAAiB,cACjB,4BACA,0BAA0B;AAE9B,WAAK,gBAAgBA,kBACjB,MACA,WACA,iBAAiB,cACjB,4BACA,0BAA0B;AAE9B,WAAK,aAAaA,kBACd,MACA,WACA,iBAAiB,WACjB,4BACA,0BAA0B;AAE9B,WAAK,aAAaA,kBACd,MACA,WACA,iBAAiB,WACjB,4BACA,0BAA0B;AAE9B,WAAK,aAAaA,kBACd,MACA,WACA,iBAAiB,WACjB,4BACA,0BAA0B;AAI9B,MAAAK,sBAAqB,MAAM,CAAC;IAChC;IAEA,IAAI,iBAAc;AACd,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,eAAe,OAAK;AACpB,WAAK,kBAAkB,iBAAiB;IAC5C;IAEA,IAAI,iBAAc;AACd,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,eAAe,OAAK;AACpB,WAAK,kBAAkB,iBAAiB;IAC5C;IAEA,IAAI,gBAAa;AACb,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,cAAc,OAAK;AACnB,WAAK,kBAAkB,gBAAgB;IAC3C;IAEA,IAAI,gBAAa;AACb,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,cAAc,OAAK;AACnB,WAAK,kBAAkB,gBAAgB;IAC3C;IAEA,IAAI,cAAW;AACX,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,YAAY,OAAK;AACjB,WAAK,kBAAkB,cAAc;IACzC;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK;IAChB;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK;IAChB;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK;IAChB;IAEA,IAAI,eAAY;AACZ,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,aAAa,OAAK;AAClB,WAAK,kBAAkB,eAAe;IAC1C;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;IAEA,IAAI,YAAS;AACT,aAAO,KAAK;IAChB;IAEA,IAAI,cAAW;AACX,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,YAAY,OAAK;AACjB,WAAK,kBAAkB,cAAc;IACzC;IAEA,IAAI,gBAAa;AACb,aAAO,KAAK,kBAAkB;IAClC;IAEA,IAAI,cAAc,OAAK;AACnB,WAAK,kBAAkB,gBAAgB;IAC3C;;AAER;;;AC9LO,IAAM,kCAAqE,CAC9EE,oBACAC,gCACAC,iCACAC,uBACAC,yBACAC,qBACAC,uCACAC,mBACAC,0BACAC,qCACA;AACA,SAAO,MAAmE;AACtE,UAAM,2BAA2B,oBAAI,QAAO;AAE5C,QAAI,wBAA4D;AAEhE,UAAM,kBAAkB,OAAO,OAAuB,8BAAyD;AAC3G,UAAI,iBAAyC;AAC7C,UAAI,mBAAmBJ,oBAAyC,KAAK;AAErE,YAAM,yBAAyB;QAC3B,cAAc,iBAAiB;QAC/B,kBAAkB,iBAAiB;QACnC,uBAAuB,iBAAiB;;AAE5C,YAAM,gCAAgC;QAClC,GAAG;QACH,gBAAgB,iBAAiB;QACjC,gBAAgB,iBAAiB;QACjC,eAAe,iBAAiB;QAChC,eAAe,iBAAiB;QAChC,aAAa,iBAAiB;QAC9B,cAAc,iBAAiB;QAC/B,aAAa,iBAAiB;QAC9B,eAAe,iBAAiB;;AAIpC,YAAM,mCAAmC,iBAAiB,kBAAkB,yBAAyB;AAGrG,UAAI,gBAAgB,kBAAkB;AAClC,yBAAiBF,sBAAqB,2BAA2B,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;iBAChG,CAAC,kCAAkC;AAC1C,cAAM,UAAU;UACZ,GAAG;UACH,cAAc,iBAAiB,aAAa;UAC5C,cAAc,iBAAiB,aAAa;UAC5C,cAAc,iBAAiB,aAAa;UAC5C,WAAW,iBAAiB,UAAU;UACtC,WAAW,iBAAiB,UAAU;UACtC,WAAW,iBAAiB,UAAU;;AAG1C,2BAAmBC,wBAAuB,2BAA2B,OAAO;;AAGhF,+BAAyB,IAAI,2BAA2B,mBAAmB,OAAO,mBAAmB,cAAc;AAEnH,UAAI,mBAAmB,MAAM;AACzB,YAAI,0BAA0B,MAAM;AAChC,cAAIE,0CAAyC,MAAM;AAC/C,kBAAM,IAAI,MAAM,qDAAqD;;AAGzE,gBAAM,6BAA6B,IAAIA;YACnC;;YAEA,MAAM,QAAQ;YACd,0BAA0B;UAAU;AAExC,gBAAM,0BAA0BL,+BAA8B,4BAA4B;YACtF,cAAc;YACd,kBAAkB;YAClB,uBAAuB;YACvB,gBAAgB;WACnB;AACD,kCAAwB,QAAQ,2BAA2B,WAAW;AAEtE,mCAAyB,YAAW;AAChC,kBAAM,4BAA4B,MAAM,QAAQ,IAC5C;cACI,MAAM;cACN,MAAM;cACN,MAAM;cACN,MAAM;cACN,MAAM;cACN,MAAM;cACR,IAAI,OAAO,YAAY,UAAS;AAC9B,oBAAM,2BAA2BC,gCAA+B,4BAA4B;gBACxF,cAAc;gBACd,kBAAkB;gBAClB,uBAAuB;gBACvB,QAAQ,UAAU,IAAI,IAAI;eAC7B;AAED,oBAAMK,kBAAiB,4BAA4B,YAAY,yBAAyB,MAAM;AAE9F,qBAAO;YACX,CAAC,CAAC;AAGN,qBAAS,IAAI,GAAG,IAAI,GAAG,KAAK,GAAG;AAC3B,wCAA0B,CAAC,EAAE,QAAQ,yBAAyB,GAAG,CAAC;AAClE,wCAA0B,CAAC,EAAE,MAAM,CAAC;;AAGxC,mBAAOE,iCAAgC,0BAA0B;UACrE,GAAE;;AAGN,cAAM,iBAAiB,MAAM;AAC7B,cAAM,gBAAgBN,sBAAqB,2BAA2B,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AAE5G,cAAMK,yBAAwB,OAAO,2BAA2B,aAAa;AAE7E,cAAM,eAA+B,CAAA;AAErC,iBAAS,IAAI,GAAG,IAAI,eAAe,kBAAkB,KAAK,GAAG;AACzD,uBAAa,KAAK,eAAe,eAAe,CAAC,CAAC;;AAGtD,YAAI,kBAAkB,CAAC,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;AACjF,YAAI,eAAe,CAAC,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;AAC9E,YAAI,eAAeL,sBAAqB,2BAA2B,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACzG,YAAI,oBAAoBC,wBAAuB,2BAA2B;UACtE,GAAG;UACH,cAAc,gBAAgB,CAAC;UAC/B,cAAc,gBAAgB,CAAC;UAC/B,cAAc,gBAAgB,CAAC;UAC/B,WAAW,aAAa,CAAC;UACzB,WAAW,aAAa,CAAC;UACzB,WAAW,aAAa,CAAC;SAC5B;AAED,sBAAc,QAAQ,YAAY,EAAE,QAAiC,kBAAmB,OAAO,CAAC,CAAC;AACjG,0BAAkB,QAAQ,cAAc;AAExC,iBAAS,IAAI,KAAK,IAAI,eAAe,QAAQ,KAAK,KAAK;AACnD,gBAAM,cAAwC,CAAC,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;AACzG,gBAAM,UAAoC,CAAC,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,GAAG,aAAa,CAAC,EAAE,CAAC,CAAC;AAErG,cACI,YAAY,KAAK,CAAC,OAAO,UAAU,UAAU,gBAAgB,KAAK,CAAC,KACnE,QAAQ,KAAK,CAAC,OAAO,UAAU,UAAU,aAAa,KAAK,CAAC,GAC9D;AACE,8BAAkB;AAClB,2BAAe;AAEf,kBAAM,cAAc,IAAI,0BAA0B;AAElD,yBAAa,KAAK,eAAe,GAAG,WAAW;AAE/C,2BAAeD,sBAAqB,2BAA2B,EAAE,GAAG,wBAAwB,MAAM,EAAC,CAAE;AACrG,gCAAoBC,wBAAuB,2BAA2B;cAClE,GAAG;cACH,cAAc,gBAAgB,CAAC;cAC/B,cAAc,gBAAgB,CAAC;cAC/B,cAAc,gBAAgB,CAAC;cAC/B,WAAW,aAAa,CAAC;cACzB,WAAW,aAAa,CAAC;cACzB,WAAW,aAAa,CAAC;aAC5B;AAED,yBAAa,KAAK,eAAe,GAAG,WAAW;AAE/C,0BAAc,QAAQ,YAAY,EAAE,QAAiC,kBAAmB,OAAO,CAAC,CAAC;AACjG,8BAAkB,QAAQ,cAAc;;;AAIhD,eAAO;;AAGX,UAAI,CAAC,kCAAkC;AACnC,cAAMG,kBAAiB,2BAA2B,MAAM,cAAc,iBAAiB,YAAY;AACnG,cAAMA,kBAAiB,2BAA2B,MAAM,cAAc,iBAAiB,YAAY;AACnG,cAAMA,kBAAiB,2BAA2B,MAAM,cAAc,iBAAiB,YAAY;AACnG,cAAMA,kBAAiB,2BAA2B,MAAM,WAAW,iBAAiB,SAAS;AAC7F,cAAMA,kBAAiB,2BAA2B,MAAM,WAAW,iBAAiB,SAAS;AAC7F,cAAMA,kBAAiB,2BAA2B,MAAM,WAAW,iBAAiB,SAAS;aAC1F;AACH,cAAMP,mBAAkB,2BAA2B,MAAM,cAAc,iBAAiB,YAAY;AACpG,cAAMA,mBAAkB,2BAA2B,MAAM,cAAc,iBAAiB,YAAY;AACpG,cAAMA,mBAAkB,2BAA2B,MAAM,cAAc,iBAAiB,YAAY;AACpG,cAAMA,mBAAkB,2BAA2B,MAAM,WAAW,iBAAiB,SAAS;AAC9F,cAAMA,mBAAkB,2BAA2B,MAAM,WAAW,iBAAiB,SAAS;AAC9F,cAAMA,mBAAkB,2BAA2B,MAAM,WAAW,iBAAiB,SAAS;;AAGlG,UAAI,uBAAuB,gBAAgB,GAAG;AAC1C,cAAMQ,yBAAwB,OAAO,2BAA2B,iBAAiB,OAAO,CAAC,CAAC;aACvF;AACH,cAAMA,yBAAwB,OAAO,2BAA2B,gBAAgB;;AAGpF,aAAO;IACX;AAEA,WAAO;MACH,OACI,OACA,2BAAqD;AAErD,cAAM,2CAA2C,yBAAyB,IAAI,yBAAyB;AAEvG,YAAI,6CAA6C,QAAW;AACxD,iBAAO,QAAQ,QAAQ,wCAAwC;;AAGnE,eAAO,gBAAgB,OAAO,yBAAyB;MAC3D;;EAER;AACJ;;;AC/NA,IAAME,oBAAkB;EACpB,sBAAsB;;AAGnB,IAAM,gCAAiE,CAC1EC,2BACAC,mBACA,mBACAC,iCACA;AACA,SAAO,MAAM,aAAY;IACrB,YAAYC,UAAY,SAAuC;AAC3D,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,gBAAgBD,6BAA4B,EAAE,GAAGH,mBAAiB,GAAG,QAAO,CAAE;AACpF,YAAM,eAAeC,0BAAyB,eAAe,aAAa;AAE1E,wBAAkB,IAAI,YAAY;AAGlC,aAAO;IACX;IAEO,QAAQ,OAAO,WAAW,EAAE,UAAiB;AAChD,aACK,aAAa,QAAQ,OAAO,aAAa,YAAY,OAAO,eAAe,QAAQ,MAAM,aAAa,aACvG,kBAAkB,IAAS,QAAQ;IAE3C;;AAER;;;AC9BO,IAAM,yBAAmD,CAAC,uBAAuBI,8BAA4B;AAChH,SAAO,CAAC,2BAA2B,YAAY,qBAAoB;AAC/D,UAAM,qBAAqB,sBAAsB,UAAU;AAE3D,uBAAmB,OAAO,gBAAgB;AAE1C,WAAOA,0BAAyB,YAAY,2BAA2B,gBAAgB;EAC3F;AACJ;;;ACPO,IAAM,gCAAiE,CAC1EC,0BACAC,uBACAC,oBACA;AACA,SAAO,OAAO,WAAW,2BAA2B,oBAAmB;AACnE,UAAM,uBAAuBF,yBAAwB,SAAS;AAE9D,UAAM,QAAQ,IACV,qBAAqB,aAChB,IAAI,CAAC,aAAa,UACf,MAAM,KAAK,WAAW,EAAE,IAAI,OAAO,CAAC,QAAQ,MAAM,MAAK;AACnD,YAAM,oBAAoBC,sBAAqB,MAAM;AACrD,YAAM,0BAA0B,MAAM,kBAAkB,OAAO,QAAQ,yBAAyB;AAChG,YAAM,cAA+D,UAAU,QAAQ;AAEvF,UAAI,CAACC,gBAAe,MAAM,MAAM,cAAc,eAAe,CAACA,gBAAe,SAAS,IAAI;AACtF,gCAAwB,QAAQ,iBAAiB,QAAQ,KAAK;;IAEtE,CAAC,CAAC,EAEL,OAAO,CAAC,sBAAsB,sBAAsB,CAAC,GAAG,sBAAsB,GAAG,iBAAiB,GAAG,CAAA,CAAE,CAAC;EAErH;AACJ;;;ACxBO,IAAM,iCAAmE,CAC5EC,uBACAC,2BACAC,oBACA;AACA,SAAO,OACH,YACA,2BACA,qBACe;AACf,UAAM,wBAAwBD,0BAA4B,UAAU;AAEpE,UAAM,QAAQ,IACV,MAAM,KAAK,sBAAsB,YAAY,EAAE,IAAI,OAAO,CAAC,QAAQ,MAAM,MAAK;AAC1E,YAAM,oBAAoBD,sBAAqB,MAAM;AACrD,YAAM,0BAA0B,MAAM,kBAAkB,OAAO,QAAQ,yBAAyB;AAEhG,UAAI,CAACE,gBAAe,MAAM,GAAG;AACzB,gCAAwB,QAAQ,kBAAkB,MAAM;;IAEhE,CAAC,CAAC;EAEV;AACJ;;;ACtBO,IAAM,wCAAiF,CAC1FC,kBACAC,uBACAC,kCACA,8CACA;AACA,SAAO,CAAC,8BAA6B;AAEjC,QAAIF,iBAAgB,oBAAoB,MAAM,mBAAmB,yBAAyB,CAAC,GAAG;AAE1F,aAAO,QAAQ,QACXA,iBAAgB,2CAA2C,yCAAyC,CAAC,EACvG,KAAK,CAAC,8CAA6C;AACjD,YAAI,CAAC,2CAA2C;AAC5C,gBAAM,sBAAsBE,iCAAgC,2BAA2B,KAAK,GAAG,CAAC;AAEhG,oCAA0B,aAAa,MAAK;AACxC,gCAAoB,iBAAiB;AACrC,gCAAoB,WAAU;UAClC;AACA,8BAAoB,iBAAiB,MAAM,0BAA0B;AAErE,8BAAoB,QAAQ,0BAA0B,WAAW;;AAGrE,eAAO,0BAA0B,eAAc;MACnD,CAAC;;AAGL,WAAO,IAAI,QAA4B,CAAC,YAAW;AAE/C,YAAM,WAAWD,sBAAqB,2BAA2B;QAC7D,cAAc;QACd,kBAAkB;QAClB,uBAAuB;QACvB,MAAM;OACT;AAED,gCAA0B,aAAa,CAAC,UAAuC;AAC3E,iBAAS,WAAU;AAEnB,gBAAQ,MAAM,cAAc;MAChC;AAEA,eAAS,QAAQ,0BAA0B,WAAW;AAEtD,gCAA0B,eAAc;IAC5C,CAAC;EACL;AACJ;;;ACnDO,IAAM,wCAAiF,CAACE,uCAAqC;AAChI,SAAO,CAAC,wBAAwB,iBAAgB;AAC5C,IAAAA,mCAAkC,IAAI,wBAAwB,YAAY;EAC9E;AACJ;;;ACJO,IAAM,6BAA2D,CAACC,4BAA0B;AAC/F,SAAO,CAAC,WAAW,aAAaA,wBAAuB,IAAI,WAAW,QAAQ;AAClF;;;ACDO,IAAM,uBAA+C,CACxDC,mBACAC,kBACAC,uBACAC,iCACAC,kCACAC,sDACAC,oCACAC,kDACA;AACA,SAAO,CAAC,aAAa,8BACjBL,sBAAqB,WAAW,EAC3B,OAAO,aAAa,yBAAyB,EAK7C,KAAK,MACF,QAAQ,IACJ,MAAM,KAAKC,gCAA+B,yBAAyB,CAAC,EAAE,IAAI,CAAC,qBACvED,sBAAqB,gBAAgB,EAAE,OAAO,kBAAkB,yBAAyB,CAAC,CAC7F,CACJ,EAEJ,KAAK,MAAME,iCAAgC,yBAAyB,CAAC,EACrE,KAAK,CAAC,gBAAe;AAGlB,QAAI,OAAO,YAAY,oBAAoB,YAAY;AACnD,MAAAE,mCAAkC,WAAW;AAC7C,0CAAoC,WAAW;eAG/C,CAACL,iBAAgBI,sDAAqD,MAClEA,qDAAoD,WAAW,CAAC,GAEtE;AACE,MAAAE,8CAA6C,WAAW;;AAG5D,IAAAP,kBAAiB,IAAI,WAAW;AAEhC,WAAO;EACX,CAAC;AACb;;;AC5CA,IAAMQ,oBAAkB;EACpB,cAAc;;;;;EAKd,kBAAkB;EAClB,uBAAuB;EACvB,KAAK;;AAGF,IAAM,oCAAyE,CAClFC,uBACAC,mBACAC,+BACAC,iCACAC,mBACAC,iCACA;AACA,SAAO,MAAM,yBAA6CL,sBAAuB;IAG7E,YAAYM,UAAY,SAAuC;AAC3D,YAAM,gBAAgBF,kBAAiBE,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGP,mBAAiB,GAAG,QAAO;AACtD,YAAM,yBAAyBG,8BAA6B,eAAe,aAAa;AACxF,YAAM,YAAYG,6BAA4B,aAAa;AAC3D,YAAM,2BAAyD,YAAYF,gCAA8B,IAAK;AAE9G,YAAMG,UAAS,OAAO,wBAAwB,wBAAwB;AAEtE,WAAK,OAAOL,kBAAiB,MAAM,WAAW,uBAAuB,GAAG;IAC5E;IAEA,IAAI,MAAG;AACH,aAAO,KAAK;IAChB;;AAER;;;ACpCO,IAAM,wCAAiF,CAC1FM,oBACAC,+BACAC,qBACAC,mBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,kCAAkC,oBAAI,QAAO;AAEnD,UAAM,yBAAyB,OAAO,OAA6B,8BAAyD;AACxH,UAAI,yBAAyBF,oBAA+C,KAAK;AAMjF,YAAM,yCAAyC,iBAAiB,wBAAwB,yBAAyB;AAEjH,UAAI,CAAC,wCAAwC;AACzC,cAAM,UAAU;UACZ,cAAc,uBAAuB;UACrC,kBAAkB,uBAAuB;UACzC,uBAAuB,uBAAuB;UAC9C,KAAK,uBAAuB,IAAI;;AAGpC,iCAAyBD,8BAA6B,2BAA2B,OAAO;;AAG5F,sCAAgC,IAAI,2BAA2B,sBAAsB;AAErF,UAAI,CAAC,wCAAwC;AACzC,cAAME,kBAAiB,2BAA2B,MAAM,KAAK,uBAAuB,GAAG;aACpF;AACH,cAAMH,mBAAkB,2BAA2B,MAAM,KAAK,uBAAuB,GAAG;;AAG5F,UAAI,uBAAuB,sBAAsB,GAAG;AAChD,cAAMI,yBAAwB,OAAO,2BAA2B,uBAAuB,OAAO,CAAC,CAAC;aAC7F;AACH,cAAMA,yBAAwB,OAAO,2BAA2B,sBAAsB;;AAG1F,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAA6B,2BAAqD;AACrF,cAAM,iCAAiC,gCAAgC,IAAI,yBAAyB;AAEpG,YAAI,mCAAmC,QAAW;AAC9C,iBAAO,QAAQ,QAAQ,8BAA8B;;AAGzD,eAAO,uBAAuB,OAAO,yBAAyB;MAClE;;EAER;AACJ;;;AC7DO,IAAM,0CAAqF,CAACC,kCAAgC;AAC/H,SAAO,MAAK;AACR,QAAIA,kCAAiC,MAAM;AACvC,aAAO;;AAGX,QAAI;AACA,UAAIA,8BAA6B,EAAE,QAAQ,GAAG,YAAY,MAAK,CAAE;YAC7D;AACJ,aAAO;;AAGX,WAAO;EACX;AACJ;;;ACXO,IAAM,yDAAmH,CAC5HC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,4BAA4B,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AACtF,UAAM,oBAAoB,0BAA0B,aAAa,GAAG,GAAG,KAAK;AAG5E,QAAI,kBAAkB,kBAAkB,QAAW;AAC/C,aAAO;;AAGX,UAAM,SAAS,IAAI,aAAa,CAAC;AAEjC,QAAI;AACA,wBAAkB,gBAAgB,QAAQ,GAAG,CAAC;YAC1C;AACJ,aAAO;;AAGX,WAAO;EACX;AACJ;;;AC9BO,IAAM,2CAAuF,CAACC,mCAAiC;AAClI,SAAO,MAAK;AACR,QAAIA,mCAAkC,MAAM;AACxC,aAAO;;AAIX,QAAIA,+BAA8B,cAAc,UAAaA,+BAA8B,UAAU,UAAU,QAAW;AACtH,aAAO;;AAGX,UAAM,eAAe,IAAIA,+BAA6B;AAEtD,UAAM,yBAAyB,aAAa,UAAU;AAEtD,QAAI;AACA,mBAAa,MAAK;YACd;;AAIR,WAAO;EACX;AACJ;;;ACnBO,IAAM,8DAA6H,CACtIC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO,QAAQ,QAAQ,KAAK;;AAGhC,UAAM,sBAAsB,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAGhF,WAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,UAAI,YAAY;AAEhB,YAAM,iBAAiB,CAAC,QAAc;AAClC,YAAI,WAAW;AACX,sBAAY;AAEZ,8BAAoB,eAAc;AAElC,kBAAQ,eAAe,SAAS;;MAExC;AAEA,UAAI;AAGJ,UAAI;AACA,kBAAU,oBAEL,gBACQ,MACL,MAAK;QAEL,GACA,cAAc;eAEjB,KAAK;AACV,uBAAe,GAAG;;AAItB,UAAI,YAAY,QAAW;AAEvB,gBAAQ,MAAM,cAAc;;IAEpC,CAAC;EACL;AACJ;;;ACpDO,IAAM,uCAA+E,CAACC,mCAAiC;AAC1H,SAAO,MAAK;AACR,QAAIA,mCAAkC,MAAM;AACxC,aAAO;;AAGX,QAAI;AAEJ,QAAI;AACA,qBAAe,IAAIA,+BAA8B,EAAE,aAAa,WAAU,CAAE;YACxE;AACJ,aAAO;;AAGX,iBAAa,MAAK;AAElB,WAAO;EACX;AACJ;;;ACjBO,IAAM,0CAAqF,CAC9FC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,4BAA4B,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AACtF,UAAM,iBAAiB,0BAA0B,WAAU;AAC3D,UAAMC,eAAc,eAAe,QAAQ,cAAc,MAAM;AAE/D,mBAAe,WAAW,cAAc;AAExC,WAAOA;EACX;AACJ;;;ACbO,IAAM,kDAAqG,CAC9GC,oCACAC,0CACA;AACA,SAAO,YAAW;AAEd,QAAID,uCAAsC,MAAM;AAC5C,aAAO;;AAGX,QAAIC,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,OAAO,IAAI,KACb;MACI;OAEJ;MACI,MAAM;KACT;AAEL,UAAM,iBAAiB,IAAI,eAAc;AAEzC,UAAM,sBAAsB,IAAIA,sCAAqC,GAAG,KAAK,KAAK;AAClF,UAAM,MAAM,IAAI,gBAAgB,IAAI;AAEpC,QAAI,mBAAmB;AAEvB,QAAI;AACA,YAAM,oBAAoB,aAAa,UAAU,GAAG;AAEpD,YAAM,mBAAmB,IAAID,mCAAkC,qBAAqB,KAAK,EAAE,iBAAiB,EAAC,CAAE;AAC/G,YAAM,aAAa,oBAAoB,iBAAgB;AAEvD,YAAM,IAAI,QAAc,CAAC,YAAW;AAChC,yBAAiB,KAAK,YAAY,MAAM,QAAO;AAC/C,yBAAiB,KAAK,YAAY,eAAe,OAAO,CAAC,eAAe,KAAK,CAAC;MAClF,CAAC;AAED,uBAAiB,KAAK,YAAY,MAAO,mBAAmB;AAE5D,iBAAW,QAAQ,gBAAgB;AACnC,iBAAW,MAAM,CAAC;AAElB,YAAM,oBAAoB,eAAc;AAExC,yBAAmB,MAAM,IAAI,QAAQ,CAAC,YAAW;AAC7C,uBAAe,MAAM,YAAY,CAAC,EAAE,KAAI,MAAO,QAAQ,SAAS,CAAC;AACjE,uBAAe,MAAM,YAAY,CAAC;MACtC,CAAC;YACG;;AAGJ,qBAAe,MAAM,MAAK;AAC1B,UAAI,gBAAgB,GAAG;;AAG3B,WAAO;EACX;AACJ;;;AC/DO,IAAM,oDAAyG,CAClHE,oCACAC,0CACA;AACA,SAAO,YAAW;AAEd,QAAID,uCAAsC,MAAM;AAC5C,aAAO;;AAGX,QAAIC,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,OAAO,IAAI,KACb,CAAC,sHAAsH,GACvH;MACI,MAAM;KACT;AAGL,UAAM,sBAAsB,IAAIA,sCAAqC,GAAG,KAAK,KAAK;AAClF,UAAM,MAAM,IAAI,gBAAgB,IAAI;AAEpC,QAAI,0BAA0B;AAC9B,QAAI,iCAAiC;AAErC,QAAI;AACA,YAAM,oBAAoB,aAAa,UAAU,GAAG;AAEpD,YAAM,mBAAmB,IAAID,mCAAkC,qBAAqB,KAAK,EAAE,iBAAiB,EAAC,CAAE;AAC/G,YAAM,aAAa,oBAAoB,iBAAgB;AAEvD,uBAAiB,KAAK,YAAY,MAAO,0BAA0B;AACnE,uBAAiB,mBAAmB,MAAO,iCAAiC;AAE5E,iBAAW,QAAQ,gBAAgB;AACnC,iBAAW,MAAM,CAAC;AAElB,YAAM,oBAAoB,eAAc;AAGxC,YAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,OAAO,CAAC;YAC9C;;AAGJ,UAAI,gBAAgB,GAAG;;AAG3B,WAAO,2BAA2B,CAAC;EACvC;AACJ;;;ACjDO,IAAM,iDAAmG,CAC5GE,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,sBAAsB,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAChF,UAAM,0BAA0B,oBAAoB,oBAAmB;AAMvE,QAAI,wBAAwB,qBAAqB,OAAO;AACpD,aAAO;;AAGX,QAAI;AACA,8BAAwB,eAAe;YACnC;AACJ,aAAO;;AAGX,WAAO;EACX;AACJ;;;AC9BO,IAAM,wDAAiH,CAC1HC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,4BAA4B,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAGtF,QAAI,0BAA0B,yBAAyB,QAAW;AAC9D,aAAO;;AAGX,UAAM,2BAA2B,0BAA0B,qBAAoB;AAM/E,WAAO,yBAAyB,OAAO,aAAa,OAAO;EAC/D;AACJ;;;ACtBO,IAAM,sDAA6G,CACtHC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,sBAAsB,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAChF,UAAM,sBAAsB,oBAAoB,gBAAe;AAE/D,wBAAoB,SAAS,oBAAoB,aAAa,GAAG,GAAG,oBAAoB,UAAU;AAElG,QAAI;AACA,0BAAoB,SAAS,oBAAoB,aAAa,GAAG,GAAG,oBAAoB,UAAU;YAC9F;AACJ,aAAO;;AAGX,WAAO;EACX;AACJ;;;ACrBO,IAAM,6CAA2F,CACpGC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO;;AAGX,UAAM,sBAAsB,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAChF,UAAM,sBAAsB,oBAAoB,gBAAe;AAE/D,QAAI;AACA,0BAAoB,eAAe;YAC/B;AACJ,aAAO;;AAGX,WAAO;EACX;AACJ;;;ACpBO,IAAM,mCAAuE,CAACC,YAAU;AAC3F,SAAO,MAAMA,YAAW,QAAQA,QAAO,eAAe,iBAAiB;AAC3E;;;ACDO,IAAM,0EACT,CAACC,mCAAiC;AAC9B,SAAO,MAAK;AACR,QAAIA,mCAAkC,MAAM;AACxC,aAAO;;AAGX,UAAM,eAAe,IAAIA,+BAA6B;AAEtD,QAAI;AACA,mBAAa,wBAAwB,IAAI,YAAW,CAAE;AAEtD,aAAO;aACF,KAAK;AACV,aAAO;;AAEP,mBAAa,MAAK;;EAE1B;AACJ;;;ACpBG,IAAM,kDAAqG,CAC9GC,uBACAC,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO,QAAQ,QAAQ,KAAK;;AAGhC,UAAM,4BAA4B,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAGtF,UAAM,WAAWD,sBAAqB,2BAA2B;MAC7D,cAAc;MACd,kBAAkB;MAClB,uBAAuB;MACvB,MAAM;KACT;AAGD,WAAO,IAAI,QAAQ,CAAC,YAAW;AAC3B,gCAA0B,aAAa,MAAK;AACxC,iBAAS,WAAU;AAEnB,gBAAQ,0BAA0B,gBAAgB,CAAC;MACvD;AACA,gCAA0B,eAAc;IAC5C,CAAC;EACL;AACJ;;;AC1BO,IAAM,gDAAiG,CAC1GE,0CACA;AACA,SAAO,MAAK;AACR,QAAIA,0CAAyC,MAAM;AAC/C,aAAO,QAAQ,QAAQ,KAAK;;AAGhC,UAAM,4BAA4B,IAAIA,sCAAqC,GAAG,GAAG,KAAK;AAMtF,QAAI,0BAA0B,uBAAuB,QAAW;AAC5D,aAAO,QAAQ,QAAQ,IAAI;;AAI/B,QAAI,0BAA0B,yBAAyB,QAAW;AAC9D,aAAO,QAAQ,QAAQ,IAAI;;AAG/B,UAAM,qBAAqB,0BAA0B,qBAAoB;AACzE,UAAM,eAAe,0BAA0B,mBAAkB;AAEjE,uBAAmB,eAAe;AAClC,uBAAmB,OAAO,QAAQ;AAElC,iBAAa,eAAe;AAE5B,uBAAmB,MAAK;AAExB,uBAAmB,QAAQ,YAAY,EAAE,QAAQ,0BAA0B,WAAW;AAEtF,WAAO,0BAA0B,eAAc,EAAG,KAAK,CAAC,WAAW,OAAO,eAAe,CAAC,EAAE,CAAC,MAAM,CAAC;EACxG;AACJ;;;ACxCO,IAAM,qBAA2C,MAAM,IAAI,aAAa,IAAI,cAAc;;;ACCjG,IAAMC,oBAAkB;EACpB,cAAc;EACd,kBAAkB;EAClB,uBAAuB;EACvB,OAAO;EACP,YAAY;;AAGT,IAAM,kCAAqE,CAC9EC,uBACAC,0BACAC,6BACAC,+BACAC,mBACAC,8BACAC,0BACA;AACA,SAAO,MAAM,uBAA2CN,sBAAuB;IAK3E,YAAYO,UAAY,SAAqC;AACzD,YAAM,gBAAgBH,kBAAiBG,QAAO;AAC9C,YAAM,gBAAgB,EAAE,GAAGR,mBAAiB,GAAG,QAAO;AACtD,YAAM,uBAAuBG,4BAA2B,eAAe,aAAa;AACpF,YAAM,YAAYG,6BAA4B,aAAa;AAC3D,YAAM,yBAAuD,YAAYF,8BAA4B,IAAK;AAG1G,YAAMI,UAAS,MAAM,sBAAsB,sBAAsB;AAEjE,WAAK,oBAAoB;AACzB,WAAK,wBAAwB;AAG7B,MAAAD,sBAAqB,MAAM,CAAC;IAChC;IAEA,IAAI,QAAK;AACL,UAAI,KAAK,mBAAmB;AACxB,eAAO;;AAGX,aAAO,KAAK,sBAAsB;IACtC;IAEA,IAAI,MAAM,OAAK;AAEX,UAAI,UAAU,MAAM;AAChB,aAAK,oBAAoB;AACzB,aAAK,sBAAsB,QAAQ,IAAI,aAAa,CAAC,GAAG,CAAC,CAAC;aACvD;AAGH,YAAI,MAAM,SAAS,GAAG;AAClB,gBAAML,yBAAuB;;AAGjC,aAAK,oBAAoB;AACzB,aAAK,sBAAsB,QAAQ;;IAE3C;IAEA,IAAI,aAAU;AACV,aAAO,KAAK,sBAAsB;IACtC;IAEA,IAAI,WAAW,OAAK;AAChB,WAAK,sBAAsB,aAAa;IAC5C;;AAER;;;ACtEO,IAAM,sCAA6E,CACtFO,6BACAC,qBACAC,6BACA;AACA,SAAO,MAAmE;AACtE,UAAM,gCAAgC,oBAAI,QAAO;AAEjD,UAAM,uBAAuB,OAAO,OAA2B,8BAAyD;AACpH,UAAI,uBAAuBD,oBAA6C,KAAK;AAG7E,YAAM,uCAAuC,iBAAiB,sBAAsB,yBAAyB;AAE7G,UAAI,CAAC,sCAAsC;AACvC,cAAM,UAAU;UACZ,cAAc,qBAAqB;UACnC,kBAAkB,qBAAqB;UACvC,uBAAuB,qBAAqB;UAC5C,OAAO,qBAAqB;UAC5B,YAAY,qBAAqB;;AAGrC,+BAAuBD,4BAA2B,2BAA2B,OAAO;;AAGxF,oCAA8B,IAAI,2BAA2B,oBAAoB;AAEjF,UAAI,uBAAuB,oBAAoB,GAAG;AAC9C,cAAME,yBAAwB,OAAO,2BAA2B,qBAAqB,OAAO,CAAC,CAAC;aAC3F;AACH,cAAMA,yBAAwB,OAAO,2BAA2B,oBAAoB;;AAGxF,aAAO;IACX;AAEA,WAAO;MACH,OAAO,OAA2B,2BAAqD;AACnF,cAAM,+BAA+B,8BAA8B,IAAI,yBAAyB;AAEhG,YAAI,iCAAiC,QAAW;AAC5C,iBAAO,QAAQ,QAAQ,4BAA4B;;AAGvD,eAAO,qBAAqB,OAAO,yBAAyB;MAChE;;EAER;AACJ;;;ACpDO,IAAM,eAA+B,MAAO,OAAO,WAAW,cAAc,OAAgB;;;ACA5F,IAAM,0CAAqF,CAC9FC,8BACAC,0BACA;AACA,SAAO,CAAC,gBAAyC;AAC7C,gBAAY,kBAAkB,CAAC,aAAa,uBAAuB,uBAAuB,MAAK;AAC3F,YAAM,eAAeD,6BAA4B,oBAAoB;AACrE,YAAM,gBAAgBA,6BAA4B,qBAAqB;AAEvE,UAAI,iBAAiB,YAAY,kBAAkB;AAC/C,cAAMC,sBAAoB;;AAG9B,YAAM,oBAAoB,YAAY;AACtC,YAAM,cAAc,YAAY,eAAe,aAAa;AAC5D,YAAM,oBAAoB,YAAY;AAEtC,eAAS,IAAI,eAAe,IAAI,CAAC,eAAe,GAAG,IAAI,eAAe,qBAAqB,IAAI,mBAAmB,KAAK,GAAG;AACtH,oBAAY,CAAC,IAAI,YAAY,IAAI,YAAY;;IAErD;AAEA,gBAAY,gBAAgB,CAAC,QAAQ,uBAAuB,uBAAuB,MAAK;AACpF,YAAM,eAAeD,6BAA4B,oBAAoB;AACrE,YAAM,gBAAgBA,6BAA4B,qBAAqB;AAEvE,UAAI,iBAAiB,YAAY,kBAAkB;AAC/C,cAAMC,sBAAoB;;AAG9B,YAAM,oBAAoB,YAAY;AACtC,YAAM,cAAc,YAAY,eAAe,aAAa;AAC5D,YAAM,eAAe,OAAO;AAE5B,eAAS,IAAI,eAAe,IAAI,CAAC,eAAe,GAAG,IAAI,eAAe,qBAAqB,IAAI,cAAc,KAAK,GAAG;AACjH,oBAAY,IAAI,YAAY,IAAI,OAAO,CAAC;;IAEhD;EACJ;AACJ;;;ACvCO,IAAM,qDAA2G,CACpHC,iCACA;AACA,SAAO,CAAC,gBAAyC;AAC7C,gBAAY,mBAAmB,CAACC,qBAAmB;AAC/C,aAAO,CAAC,aAA2B,uBAA+B,uBAAuB,MAAK;AAC1F,cAAM,eAAeD,6BAA4B,oBAAoB;AACrE,cAAM,gBAAgBA,6BAA4B,qBAAqB;AAEvE,YAAI,eAAe,YAAY,QAAQ;AACnC,iBAAOC,iBAAgB,KAAK,aAAa,aAAa,eAAe,YAAY;;MAEzF;IACJ,GAAG,YAAY,eAAe;AAE9B,gBAAY,iBAAiB,CAACC,mBAAiB;AAC3C,aAAO,CAAC,QAAsB,uBAA+B,uBAAuB,MAAK;AACrF,cAAM,eAAeF,6BAA4B,oBAAoB;AACrE,cAAM,gBAAgBA,6BAA4B,qBAAqB;AAEvE,YAAI,eAAe,YAAY,QAAQ;AACnC,iBAAOE,eAAc,KAAK,aAAa,QAAQ,eAAe,YAAY;;MAElF;IACJ,GAAG,YAAY,aAAa;EAChC;AACJ;;;AC1BO,IAAM,2DAAuH,CAChIC,wBACA;AACA,SAAO,CAAC,6BAA6B,kBAAiB;AAClD,UAAM,kBAAkB,cAAc,aAAa,GAAG,GAAG,KAAK;AAE9D,QAAI,4BAA4B,WAAW,MAAM;AAC7C,kCAA4B,SAAS;;AAGzC,IAAAA,oBACI,6BACA,UACA,CAAC,QAAQ,MAAK;AACV,YAAM,QAAQ,IAAI,KAAK,2BAA2B;AAElD,aAAO,UAAU,kBAAkB,OAAO;IAC9C,GACA,CAAC,QAAQ,CAAC,UAAS;AACf,aAAO,IAAI,KAAK,6BAA6B,UAAU,OAAO,kBAAkB,KAAK;IACzF,CAAC;EAET;AACJ;;;ACvBO,IAAM,8BAA6D,CAACC,0BAAyBC,wBAAsB;AACtH,SAAO,CAAC,eAAe,sBAAqB;AAExC,sBAAkB,eAAe;AACjC,sBAAkB,mBAAmB;AAGrC,WAAO,eAAe,mBAAmB,gBAAgB;MACrD,KAAK,MAAM;MACX,KAAK,MAAK;AACN,cAAMD,yBAAuB;MACjC;KACH;AAED,WAAO,eAAe,mBAAmB,oBAAoB;MACzD,KAAK,MAAM;MACX,KAAK,MAAK;AACN,cAAMA,yBAAuB;MACjC;KACH;AAGD,UAAM,wBAAwB,cAAc,mBAAkB;AAE9D,UAAM,gBAAgB,MAAK;AACvB,YAAM,SAAS,kBAAkB;AAEjC,eAAS,IAAI,GAAG,IAAI,QAAQ,KAAK,GAAG;AAChC,8BAAsB,QAAQ,mBAAmB,GAAG,CAAC;;IAE7D;AACA,UAAM,mBAAmB,MAAM,sBAAsB,WAAW,iBAAiB;AAEjF,IAAAC,oBAAmB,mBAAmB,eAAe,gBAAgB;EACzE;AACJ;;;ACnCO,IAAM,iBAA0C,CAAC,aAAa,QAAQ,kBAAiB;AAE1F,MAAI,YAAY,oBAAoB,QAAW;AAC3C,WAAO,YAAY,eAAe,aAAa,EAAE,CAAC;;AAGtD,cAAY,gBAAgB,QAAQ,aAAa;AAEjD,SAAO,OAAO,CAAC;AACnB;;;ACTO,IAAM,YAAgC,CAAC,UAAS;AACnD,MAAI,UAAU,MAAM;AAChB,WAAO;;AAGX,QAAM,SAAS,MAAM;AAErB,MAAI,SAAS,MAAM,GAAG;AAClB,WAAO,MAAM,KAAK,MAAM,SAAS,CAAC,CAAC,MAAM;;AAG7C,SAAO,MAAM,SAAS,IAAI,CAAC,IAAI,MAAM,SAAS,CAAC,MAAM;AACzD;;;ACZO,IAAM,qBAAkD,CAAC,QAAQ,UAAU,cAAc,iBAAgB;AAC5G,MAAI,YAAY;AAEhB,SAAO,CAAC,UAAU,eAAe,QAAQ,GAAG;AACxC,gBAAY,OAAO,eAAe,SAAS;;AAG/C,QAAM,EAAE,KAAK,IAAG,IAAmC,OAAO,yBAAyB,WAAW,QAAQ;AAEtG,SAAO,eAAe,QAAQ,UAAU,EAAE,KAAK,aAAa,GAAG,GAAG,KAAK,aAAa,GAAG,EAAC,CAAE;AAC9F;;;ACVO,IAAM,kCAA4E,CAAC,YAAW;AACjG,SAAO;IACH,GAAG;IACH,oBACI,QAAQ,uBAAuB,SACzB,QAAQ,qBACR,QAAQ,mBAAmB,KAAK,QAAQ,oBAAoB;;;;;;MAM5D,CAAC,QAAQ,YAAY;QACrB,MAAM,KAAK,EAAE,QAAQ,QAAQ,gBAAe,GAAI,MAAM,CAAC;;AAEzE;;;ACfO,IAAM,iCAA0E,CAAC,YAAW;AAC/F,SAAO,EAAE,GAAG,SAAS,cAAc,QAAQ,gBAAe;AAC9D;;;ACFO,IAAM,8BAAoE,CAAC,YAAW;AACzF,QAAM,EAAE,MAAM,KAAI,IAAK;AAEvB,MAAI,SAAS,QAAW;AACpB,QAAI,SAAS,QAAW;AACpB,aAAO,EAAE,GAAG,SAAS,MAAM,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC,GAAG,CAAC,EAAC;;AAGnD,WAAO,EAAE,GAAG,SAAS,MAAM,MAAM,KAAK,MAAM,MAAM,CAAC,GAAG,KAAI;;AAG9D,MAAI,SAAS,QAAW;AACpB,WAAO,EAAE,GAAG,SAAS,MAAM,MAAM,MAAM,KAAK,MAAM,MAAM,CAAC,EAAC;;AAG9D,SAAO,EAAE,GAAG,SAAS,MAAM,KAAI;AACnC;;;AChBO,IAAM,8BAAoE,CAAC,YAAY,OAAO,cAAa;AAC9G,MAAI;AACA,eAAW,eAAe,OAAO,SAAS;WACrC,KAAK;AACV,QAAI,IAAI,SAAS,GAAG;AAChB,YAAM;;AAGV,gCAA4B,YAAY,OAAO,YAAY,IAAI;;AAEvE;;;ACVO,IAAM,8DAA8D,CAAC,kBAAiC;AACzG,QAAM,8BAA8B,cAAc,mBAAkB;AAEpE,8BAA4B,MAAK;AAEjC,MAAI;AACA,gCAA4B,MAAK;UAC7B;AACJ,WAAO;;AAGX,SAAO;AACX;;;ACZO,IAAM,4DAA4D,CAAC,kBAAiC;AACvG,QAAM,8BAA8B,cAAc,mBAAkB;AACpE,QAAM,oBAAoB,cAAc,aAAa,GAAG,GAAG,KAAK;AAEhE,8BAA4B,SAAS;AAErC,MAAI;AACA,gCAA4B,MAAM,GAAG,CAAC;UAClC;AACJ,WAAO;;AAGX,SAAO;AACX;;;ACbO,IAAM,4DAA4D,CAAC,kBAAiC;AACvG,QAAM,8BAA8B,cAAc,mBAAkB;AAEpE,8BAA4B,MAAK;AAEjC,MAAI;AACA,gCAA4B,KAAI;UAC5B;AACJ,WAAO;;AAGX,SAAO;AACX;;;ACZO,IAAM,mEAAmE,CAAC,kBAAiC;AAC9G,QAAM,8BAA8B,cAAc,iBAAgB;AAElE,MAAI;AACA,gCAA4B,MAAM,EAAE;WAC/B,KAAK;AACV,WAAO,eAAe;;AAG1B,SAAO;AACX;;;ACVO,IAAM,gEAAgE,CAAC,kBAAiC;AAC3G,QAAM,oBAAoB,cAAc,aAAa,GAAG,GAAG,KAAK;AAChE,QAAM,8BAA8B,cAAc,mBAAkB;AAEpE,8BAA4B,SAAS;AACrC,8BAA4B,MAAK;AACjC,8BAA4B,KAAI;AAEhC,MAAI;AACA,gCAA4B,KAAI;AAEhC,WAAO;UACH;AACJ,WAAO;;AAEf;;;ACfO,IAAM,kEAAkE,CAAC,kBAAiC;AAC7G,QAAM,8BAA8B,cAAc,iBAAgB;AAElE,MAAI;AACA,gCAA4B,KAAK,EAAE;WAC9B,KAAK;AACV,WAAO,eAAe;;AAG1B,SAAO;AACX;;;ACVO,IAAM,yCAA0F,CAAC,4BAA2B;AAC/H,QAAM,EAAE,OAAO,MAAK,IAAK,IAAI,eAAc;AAE3C,MAAI;AAEA,UAAM,YAAY,uBAAuB;;AAEzC,UAAM,MAAK;AACX,UAAM,MAAK;;AAEnB;;;ACkBO,IAAM,qCAAqC,MAAK;AACnD,MAAI;AACA,QAAI,aAAY;UACZ;AACJ,WAAO;;AAGX,SAAO;AACX;;;ACrCO,IAAM,2BAA2B,MACpC,IAAI,QAAiB,CAAC,YAAW;AAC7B,QAAM,cAAc,IAAI,YAAY,CAAC;AACrC,QAAM,EAAE,OAAO,MAAK,IAAK,IAAI,eAAc;AAE3C,QAAM,YAAY,CAAC,EAAE,KAAI,MAAO,QAAQ,SAAS,IAAI;AACrD,QAAM,YAAY,aAAa,CAAC,WAAW,CAAC;AAChD,CAAC;;;ACNE,IAAM,qDAAqD,CAAC,gCAAmE;AAClI,8BAA4B,SAAS,CAACC,WAAS;AAC3C,WAAO,CAAC,OAAO,GAAG,SAAS,GAAG,aAAqB;AAC/C,YAAM,SAAS,4BAA4B;AAE3C,YAAM,gBAAgB,WAAW,OAAO,SAAS,KAAK,IAAI,OAAO,UAAU,MAAM;AAGjF,UAAI,WAAW,QAAQ,gBAAgB,OAAO,WAAW,MAAM,4BAA4B,QAAQ,YAAY;AAC3G,QAAAA,OAAM,KAAK,6BAA6B,MAAM,GAAG,CAAC;aAC/C;AACH,QAAAA,OAAM,KAAK,6BAA6B,MAAM,eAAe,QAAQ;;IAE7E;EACJ,GAAG,4BAA4B,KAAK;AACxC;;;ACdO,IAAM,yDAA0H,CACnI,gCACA,kBACA;AACA,QAAM,iBAAiB,cAAc,WAAU;AAE/C,iCAA+B,QAAQ,cAAc;AAErD,QAAM,sBAAsB,CAACC,gBAAc;AACvC,WAAO,MAAK;AAEiC,MAAAA,YAAY,KAAK,gCAAgC,cAAc;AACxG,qCAA+B,oBAAoB,SAAS,kBAAkB;IAClF;EACJ,GAAG,+BAA+B,UAAU;AAE5C,iCAA+B,iBAAiB,SAAS,kBAAkB;AAE3E,uBAAqB,gCAAgC,cAAc;AAEnE,iCAA+B,QAAQ,CAAC,SAAQ;AAC5C,QAAI,YAAY;AAEhB,WAAO,CAAC,OAAO,MAAK;AAChB,UAAI,WAAW;AACX,YAAI;AACA,eAAK,KAAK,gCAAgC,IAAI;gBAC1C;AACJ,yBAAe,KAAK,eAAe,GAAG,IAAI;;aAE3C;AACH,aAAK,KAAK,gCAAgC,IAAI;AAE9C,oBAAY;;IAEpB;EACJ,GAAG,+BAA+B,IAAI;AAC1C;;;ACtCO,IAAM,oBAAgD,CAAC,QAAQ,kBAAiB;AACnF,SAAO,CAAC,UAAS;AACb,UAAM,aAAa,EAAE,OAAO,OAAM;AAElC,WAAO,iBAAiB,OAAO;MAC3B,eAAe;MACf,QAAQ;KACX;AAED,QAAI,OAAO,kBAAkB,YAAY;AACrC,aAAO,cAAc,KAAK,QAAQ,KAAK;;AAG3C,WAAO,cAAc,YAAY,KAAK,QAAQ,KAAK;EACvD;AACJ;;;AC6QA,IAAM,sCAAsC,0CAA0C,kBAAkB;AACxG,IAAM,uCAAuC,2CAA2C,kBAAkB;AAC1G,IAAM,yCAAyC,6CAA6C,kBAAkB;AAC9G,IAAM,yBAAyB,oBAAI,QAAO;AAC1C,IAAM,uBAAuB,2BAA2B,sBAAsB;AAC9E,IAAM,kBAAkB,sBAAsB,oBAAI,IAAG,GAAI,oBAAI,QAAO,CAAE;AACtE,IAAMC,UAAS,aAAY;AAC3B,IAAM,2BAA2B,gCAAgC,iBAAiB,oBAAoB;AACtG,IAAM,uBAAuB,2BAA2B,uBAAuB;AAC/E,IAAM,0BAA0B,8BAA8B,yBAAyB,sBAAsB,cAAc;AAC3H,IAAM,6BAA6B,kCAAkC,0BAA0B,oBAAoB,uBAAuB;AAC1I,IAAM,mBAAmB,uBAAuB,aAAa;AAC7D,IAAM,uCAAuC,2CAA2CA,OAAM;AAC9F,IAAM,8BAA8B,kCAAkC,oCAAoC;AAC1G,IAAM,2BAAsD,oBAAI,QAAO;AACvE,IAAM,yBAAyB,6BAA6B,iBAAiB;AAC7E,IAAM,gCAAgC,oCAAoCA,OAAM;AAChF,IAAM,uBAAuB,2BAA2B,6BAA6B;AACrF,IAAMC,qBAAoB,wBAAwBD,OAAM;AACxD,IAAM,qBAAqB,yBAAyBA,OAAM;AAC1D,IAAM,oCAAoC,wCAAwCA,OAAM;AACxF,IAAM,uBAAuB,2BACzB,8BAA8B,4BAA4B,GAC1D,+BACI,qCACA,sCACA,yCACA,wCACA,8CACA,yBACA,sBACA,8BACA,oBACA,oBACA,mBACA,gBACA,kBAAkB,GAEtB,iBACA,mCACI,gBACA,8CACA,yBACA,oBACA,qBACA,iBAAiB,GAErB,sBACA,0BACA,yBACA,4BACI,yCACA,gBACA,yBACA,oBACA,qBACA,kBACA,mBACA,2BAA2B,GAE/B,mBAAmB,0BAA0B,yBAAyB,cAAc,GACpF,wBACA,kBACA,sBACAC,oBACA,oBACA,6BACA,iCAAiC;AAErC,IAAM,0BAAoD,8BACtD,sBACA,4BACA,sBACA,0BACA,kBACA,2BAA2B;AAO/B,IAAM,mBAAsC,oBAAI,QAAO;AACvD,IAAM,+BAA+B,mCAAmCC,OAAM;AAC9E,IAAM,8BAA8B,kCAAkC,IAAI,YAAY,CAAC,CAAC;AACxF,IAAM,oCAAoC,wCAAwC,6BAA6B,oBAAoB;AACnI,IAAM,+CAA+C,mDAAmD,2BAA2B;AACnI,IAAM,yBAAkD,6BACpD,kBACA,iBACA,yBACA,8BACA,sCACA,wCAAwC,4BAA4B,GACpE,mCACA,4CAA4C;AAOhD,IAAM,sBAAsB,0BAA0B,oBAAoB;AAC1E,IAAM,2BAA2B,+BAA+B,sBAAsB,0BAA0B,cAAc;AAC9H,IAAM,oBAAoB,wBAAwB,wBAAwB;AAC1E,IAAM,oCAAoC,yCACtC,qBACA,iBACA,6DACA,2DACA,2DACA,kEACA,+DACA,iEACA,oDACA,yDAAyD,kBAAkB,GAC3E,sDAAsD;AAE1D,IAAM,mBAAmB,uBAAuB,4BAA4B,wBAAwB,GAAG,wBAAwB;AAC/H,IAAM,sCAAsC,2CACxC,mBACA,mCACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,mBAAmB,wBACrB,+BAA+B,6BAA6B,GAC5D,0BACA,mBACA,0BACA,oCACA,4CACA,6CACA,wCACA,gCACA,+BACA,oCACA,+BACA,2BAA2B;AAE/B,IAAM,mCAAsE,uCACxE,sBACA,qCACA,kBACA,yBACA,mCACA,kBACA,6BACA,iBAAiB;AAOrB,IAAM,kCAAkC,sCACpC,sBACA,oCACA,sBACA,yBACA,wCAAwC,sBAAsB,kBAAkB,GAChF,kBACA,6BACA,uBAAuB;AAE3B,IAAM,iCAAiC,sCACnC,mBACA,8BACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,uBAAuB,2BAA2B,sBAAsB;AAC9E,IAAM,8BAA4D,kCAC9D,sBACA,kBACA,gCACA,0BACA,8BACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,qBAAqB,yBAAyB,oBAAoBC,kBAAiB;AACzF,IAAM,wBAAwB,4BAA4B,yBAAyB,kBAAkB;AACrG,IAAM,gCAAgC,qCAAqC,+BAA+B,qBAAqB;AAC/H,IAAM,kCAAkC,uCACpC,+BACA,oBACA,uBAAuB;AAE3B,IAAM,+BAA8D,mCAChE,sBACA,iCACA,+BACA,kBACA,2BAA2B;AAE/B,IAAM,oCAAoC,yCACtC,iCACA,oBACA,uBAAuB;AAE3B,IAAM,iCAAkE,qCACpE,sBACA,mCACA,iCACA,kBACA,6BACA,8BAA8B;AAElC,IAAM,sCAAsC,2CACxC,qBACA,mCACA,sBACA,kBAAkB;AAEtB,IAAM,iCAAiC,sCACnC,qBACA,iBACA,qCACA,kEACA,+DAA+D;AAEnE,IAAM,mCAAmC,wCACrC,mBACA,gCACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,gCAAgE,oCAClE,sBACA,kBACA,kCACA,gCACA,kBACA,6BACA,iBAAiB;AAErB,IAAM,4BAA4B,iCAAiC,yBAAyB,kBAAkB;AAC9G,IAAM,8BAA8B,mCAChC,2BACA,oBACA,uBAAuB;AAE3B,IAAM,2BAAsD,+BACxD,sBACA,6BACA,2BACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,0BAA0B,+BAC5B,mBACA,uBACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,uBAA8C,2BAChD,sBACA,kBACA,yBACA,uBACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,qCAAqC,0CAA0C,uBAAuB;AAC5G,IAAM,uCAAuC,4CACzC,mBACA,oCACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,oCAAwE,wCAC1E,sBACA,kBACA,sCACA,oCACA,yBACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,yBAAyB,8BAC3B,mBACA,sBACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,sBAA4C,0BAC9C,sBACA,kBACA,wBACA,sBACA,kBACA,2BAA2B;AAE/B,IAAM,iCAAiC,sCACnC,0BACA,yBACA,iCACA,uBAAuB;AAE3B,IAAM,kCAAkC,sCACpC,iBACA,sBACA,iCACA,gDAAgD,sBAAsB,oCAAoC,CAAC;AAE/G,IAAM,8BAA8B,mCAChC,mCACA,oBACA,sCACA,yBACA,+BAA+B;AAEnC,IAAM,4BAA4B,iCAAiC,8BAA8B;AACjG,IAAM,2BAAsD,+BACxD,sBACA,2BACA,6BACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,sBAAsB,2BACxB,kBACA,+BACA,gCACA,iCACA,yBACA,gBACA,6BACA,kBAAkB;AAEtB,IAAM,kCAAoE,oBAAI,QAAO;AACrF,IAAM,qCAAqC,yCACvC,iCACA,qBACA,wBACA,6BACA,iCACA,iBAAiB;AAErB,IAAM,6BAA6B,kCAC/B,qBACA,iBACA,kEACA,+DACA,iEACA,sDAAsD;AAE1D,IAAM,+BAA+B,oCACjC,mBACA,4BACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,4BAAwD,gCAC1D,sBACA,kBACA,4BACA,8BACA,kBACA,6BACA,iBAAiB;AAErB,IAAM,6CAA6C,kDAAkD,iCAAiC;AACtI,IAAM,kCAAkC,uCACpC,4CACA,yBACA,sBACA,WACA,kBAAkB;AAEtB,IAAM,6BAA6B,kCAC/B,4CACA,yBACA,iCACA,WACA,oBACA,+BACA,kBAAkB;AAEtB,IAAM,8BAA8B,mCAChC,yCACA,yBACA,+BACA,sBACA,iCACA,4BACA,yBACA,8CACA,gBACA,kBAAkB;AAEtB,IAAM,yBAAyB,8BAA8B,2BAA2B;AACxF,IAAM,2BAA2B,gCAC7B,mBACA,+BACA,gCACA,sBACA,wBACA,oBACA,sCACA,kBACA,yBACA,+BAA+B;AAEnC,IAAM,wBAAgD,4BAClD,sBACA,kBACA,wBACA,0BACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,2BAA2B,gCAAgC,oBAAoB;AACrF,IAAM,0BAAoD,8BACtD,0BACA,kBACA,oBAAI,QAAO,GACX,2BAA2B;AAE/B,IAAM,qCAAqC,yCACvC,+BACA,iCACA,sBACA,4BACA,yBACA,kBAAkB;AAEtB,IAAM,+BAA+B,oCAAoC,oCAAoC,uBAAuB;AACpI,IAAM,iCAAiC,sCACnC,mBACA,8BACA,oBACA,kBACA,uBAAuB;AAE3B,IAAM,8BAA4D,kCAC9D,sBACA,kBACA,8BACA,gCACA,kBACA,2BAA2B;AAE/B,IAAM,+BAA+B,oCACjC,4BACA,oBACA,uBAAuB;AAE3B,IAAM,4BAAwD,gCAC1D,sBACA,yBACA,4BACA,8BACA,kBACA,6BACA,oBAAoB;AAExB,IAAM,kBAAkB,sBAAsBC,OAAM;AACpD,IAAM,mCAAmC,uCAAuCA,OAAM;AACtF,IAAM,iCAAkE,oBAAI,QAAO;AACnF,IAAM,uCAAuC,2CACzC,gCACA,oCAAoC;AAIjC,IAAM,wBAAoE,kBAC3E;EACI;EACA;EACA,qBAAqBA,OAAM;EAC3B;EACA,kBAAkB,gBAAgB;EAClC;EACA;EACA;EACA;EACA,oBAAI,QAAO;EACX,oBAAI,QAAO;EACX,kDAAkD,mCAAmC,oCAAoC;;EAE7FA;AAAM,IAEtC;AAEN,IAAM,kBAAkB,sBAAsB,sBAAsB,2BAA2B;AAExF,IAAM,kBAA4C,sBACrD,kBACA,iBACA,sBACA,qBACA,oBAAI,QAAO,GACX,kBACA,iBACA,qDACA,oBACA,mCACA,4CAA4C;AAGhD,IAAM,8BAA8B,kCAChC,uBACA,yBACA,wBACA,kCACA,6BACA,8BACA,gCACA,+BACA,0BACA,iBACA,sBACA,mCACA,qBACA,0BACA,oCACA,2BACA,uBACA,yBACA,6BACA,yBAAyB;AAE7B,IAAM,yCAAkF,6CACpF,sBACA,yCACA,kBACA,2BAA2B;AAE/B,IAAM,6CACF,iDACI,sBACA,6CACA,kBACA,2BAA2B;AAEnC,IAAM,wCAAgF,4CAClF,sBACA,wCACA,kBACA,2BAA2B;AAE/B,IAAM,8CAA8C,mDAChD,yBACA,2BAA2B;AAE/B,IAAM,6CACF,iDAAiD,sBAAsB,6CAA6C,gBAAgB;AACxI,IAAM,0BAAoD,8BACtD,6BACA,yBACA,yBACA,oBACA,wCACA,4CACA,uCACA,4CACA,6BAA6B;AAOjC,IAAM,iCAAiC,qCAAqC,+BAA+B;AAC3G,IAAM,gCAAgC,oCAAoC,8BAA8B;AACxG,IAAM,yBAAyB,6BAA6B,oBAAoB;AAChF,IAAM,mCAAmC,uCAAuC,8BAA8B;AAC9G,IAAM,4BAA4B,gCAAgC,oBAAoB;AACtF,IAAM,oCAAwE,oBAAI,QAAO;AACzF,IAAM,kCAAkC,sCAAsC,mCAAmC,cAAc;AAC/H,IAAM,oCAAoC,yCACtC,wBACA,sBACA,yBACA,+BACA,iCACA,gCACA,sBACA,iCACA,yBACA,2BACA,kCACA,iCACA,kBAAkB;AAEtB,IAAM,+BAA+B,oCACjC,yBACA,mCACA,sBACA,yBACA,kBAAkB;AAEtB,IAAM,iCAAiC,sCACnC,mBACA,wBACA,mCACA,+BACA,iCACA,gCACA,sBACA,kCACA,2BACA,kCACA,oBACA,mCACA,sCACA,kBACA,yBACA,+BAA+B;AAEnC,IAAM,+BAA+B,mCAAmC,8BAA8B;AACtG,IAAM,kCAAkC,sCAAsC,iCAAiC;AAG/G,IAAM,8BAAwE,kBACxE,kCACI,+BACA,sBACA,kBACA,gCACA,8BACA,yBACA,8BACA,kBACA,6BACA,mCACA,iCACA,iCACA,wCACA,iBAAiB,IAErB;AA0DN,IAAM,iCAAkE,qCACpE,yBACA,yBACA,oBACA,oCACA,6BAA6B;AAOjC,IAAM,kCAAkC,sCACpC,yBACA,oCAAoC;AAExC,IAAM,iBAAiB,qBACnB,kBACA,iBACA,sBACA,gCACA,iCACA,qDACA,mCACA,4CAA4C;AAEhD,IAAM,wCAAgF,4CAClF,iBACA,yBACA,iCACA,oCACA,cAAc;AAOlB,IAAM,iCAAkE,qCACpE,6BACA,iBACA,yBACA,iCACA,cAAc;AA2BX,IAAM,oBAAoB,wBAAwB,eAAe,oBAAoB;AAErF,IAAM,iBAAiB,qBAAqB,kBAAkBC,kBAAiB;AAE/E,IAAM,kBAAkB,sBAAsB,mBAAmB,kBAAkB;AAEnF,IAAM,2BAA2B,+BAA+B,eAAe,2BAA2B;AAE1G,IAAM,cAAc,MACvB,yBACI,iBACA,uDAAuD,oCAAoC,GAC3F,yCAAyC,6BAA6B,GACtE,4DAA4D,oCAAoC,GAChG,qCAAqC,6BAA6B,GAClE,wCAAwC,oCAAoC,GAC5E,gDAAgD,mCAAmC,oCAAoC,GACvH,+CAA+C,oCAAoC,GACnF,sDAAsD,oCAAoC,GAC1F,oDAAoD,oCAAoC,GACxF,2CAA2C,oCAAoC,GAC/E,oCACA,iCAAiCC,OAAM,GACvC,wEAAwE,6BAA6B,GACrG,8CAA8C,oCAAoC,GAClF,wBAAwB;;;AC7jChC;;;;;;;;;AAKM,SAAU,OAAO,WAAoB,OAAa;AACvD,MAAI,CAAC,WAAW;AACf,UAAM,IAAI,MAAM,KAAK;;AAEvB;AAKM,SAAU,YAAY,OAAe,KAAa,MAAM,UAAQ;AACrE,MAAI,EAAE,OAAO,SAAS,SAAS,MAAM;AACpC,UAAM,IAAI,WAAW,yBAAyB,GAAG,KAAK,GAAG,WAAW,KAAK,EAAE;;AAE7E;AAKM,SAAU,qBAAqBC,UAAqD;AAEzF,MAAI,CAACA,SAAQ,aAAaA,SAAQ,UAAU,WAAW;AACtD,SAAK,6FAA+F;;AAEtG;AAaA,IAAI,gBAAwB;AAKtB,SAAU,UAAU,QAAc;AACvC,kBAAgB;AACjB;AAKM,SAAU,OAAO,MAAW;AACjC,gBAAc,IAAI,GAAG,IAAI;AAC1B;AAKM,SAAU,QAAQ,MAAW;AAClC,gBAAc,KAAK,GAAG,IAAI;AAC3B;;;ACzDM,SAAU,QAAQ,KAAQ;AAC/B,SAAO,OAAO,QAAQ;AACvB;AAKM,SAAU,UAAa,KAAkB;AAC9C,SAAO,CAAC,QAAQ,GAAG;AACpB;AAKM,SAAU,WAAW,KAAQ;AAClC,SAAO,OAAO,QAAQ;AACvB;AAKM,SAAU,SAAS,KAAQ;AAChC,SAAQ,OAAO,QAAQ;AACxB;AAKM,SAAU,SAAS,KAAQ;AAChC,SAAQ,OAAO,UAAU,SAAS,KAAK,GAAG,MAAM,qBAAqB,IAAI,gBAAgB;AAC1F;AAKM,SAAU,UAAU,KAAQ;AACjC,SAAQ,OAAO,QAAQ;AACxB;AAKM,SAAU,QAAQ,KAAQ;AAC/B,SAAQ,MAAM,QAAQ,GAAG;AAC1B;AAKM,SAAU,SAAS,KAAQ;AAChC,SAAQ,OAAO,QAAQ;AACxB;AAMM,SAAU,OAAO,KAAQ;AAC9B,SAAO,SAAS,GAAG,KAAK,sCAAsC,KAAK,GAAG;AACvE;;;ACrDM,SAAU,mBAAmB,SAA6B;AAC/D,SAAO,IAAI,wBAAgB,OAAO;AACnC;AAKM,SAAU,0BAA0B,UAAkB,QAAgB,YAAkB;AAC7F,SAAO,IAAI,+BAAuB,UAAU,QAAQ,UAAU;AAC/D;AAmBO,IAAM,YAA+B,OAAO,SAAS,WAAW,OAAO;AAMvE,IAAM,kBAAkB,cAC7B,UAAU,eAAe,cAAc,KAAK,UAAU,eAAe,oBAAoB;AAErF,SAAU,uBAAuBC,UAA0B,MAAc,SAA0C;AACxH,SAAO,UAAU,2BAAmB,GAAG,+DAA+D;AAEtG,SAAO,IAAI,4BAAoBA,UAAS,MAAM,OAAO;AACtD;;;AC5CM,IAAO,SAAP,MAAa;EA2BlB,YAAY,UAAsB,MAAyB,gBAAuB;AAEjF,SAAK,YAAY;AACjB,SAAK,QAAQ;AACb,SAAK,kBAAkB;AAGvB,SAAK,aAAY;EAClB;;;;EAKQ,gBAAa;AAEpB,UAAM,OAAO,IAAI,KAAK;;MACL;;yBAEM,KAAK,kBAAkB,KAAM,QAAQ,CAAC,CAAC;;;;;;;;;;;;;;OAc3D,EAAE,MAAM,kBAAiB,CAAE;AAC9B,UAAM,UAAU,IAAI,gBAAgB,IAAI;AACxC,UAAM,SAAS,IAAI,OAAO,OAAO;AAEjC,WAAO,YAAY,KAAK,UAAU,KAAK,IAAI;AAE3C,SAAK,UAAU;EAChB;;;;EAKQ,iBAAc;AACrB,SAAK,WAAW,WAAW,MAAK;AAC/B,WAAK,eAAc;AACnB,WAAK,UAAS;IACf,GAAG,KAAK,kBAAkB,GAAI;EAC/B;;;;EAKQ,eAAY;AACnB,QAAI,KAAK,UAAU,UAAU;AAC5B,UAAI;AACH,aAAK,cAAa;eACV,GAAG;AAEX,aAAK,QAAQ;AACb,aAAK,aAAY;;eAER,KAAK,UAAU,WAAW;AACpC,WAAK,eAAc;;EAErB;;;;EAKQ,gBAAa;AACpB,QAAI,KAAK,UAAU;AAClB,mBAAa,KAAK,QAAQ;AAC1B,WAAK,WAAW;;AAEjB,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,UAAS;AACtB,WAAK,QAAQ,YAAY;;EAE3B;;;;EAKA,IAAI,iBAAc;AACjB,WAAO,KAAK;EACb;EACA,IAAI,eAAe,UAAiB;AACnC,SAAK,kBAAkB,KAAK,IAAI,UAAU,MAAM,KAAK;AACrD,QAAI,KAAK,UAAU,UAAU;AAC5B,WAAK,QAAQ,YAAY,KAAK,IAAI,WAAW,KAAM,CAAC,CAAC;;EAEvD;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAuB;AAC/B,SAAK,cAAa;AAClB,SAAK,QAAQ;AACb,SAAK,aAAY;EAClB;;;;EAKA,UAAO;AACN,SAAK,cAAa;EACnB;;;;AC3IK,SAAU,aAAa,KAAQ;AACpC,SAAO,gBAAgB,GAAG;AAC3B;AAKM,SAAUC,aAAY,KAAQ;AACnC,SAAO,eAAe,GAAG;AAC1B;AAKM,SAAU,sBAAsB,KAAQ;AAC7C,SAAO,yBAAyB,GAAG;AACpC;AAKM,SAAU,eAAe,KAAQ;AACtC,SAAO,kBAAkB,GAAG;AAC7B;AAKM,SAAU,cAAc,KAAQ;AACrC,SAAO,eAAe;AACvB;;;AC9BA,SAAS,OAAO,KAAa,KAAQ;AACpC,SAAO,QAAQ,WAAW,aAAa,GAAG,KAAKC,aAAY,GAAG,KAAK,cAAc,GAAG;AACrF;AAWM,SAAU,UAAU,WAAgB,SAAc;AACvD,MAAI,CAAC,QAAQ,QAAQ;AACpB,WAAO;;AAER,QAAM,SAAS,QAAQ,MAAK;AAE5B,MAAI,SAAS,MAAM,KAAK,SAAS,MAAM,GAAG;AACzC,eAAW,OAAO,QAAQ;AACzB,UAAI,OAAO,KAAK,OAAO,GAAG,CAAC,GAAG;AAC7B,eAAO,GAAG,IAAI,OAAO,GAAG;iBACd,SAAS,OAAO,GAAG,CAAC,GAAG;AACjC,YAAI,CAAC,OAAO,GAAG,GAAG;AACjB,iBAAO,OAAO,QAAQ,EAAE,CAAC,GAAG,GAAG,CAAA,EAAE,CAAE;;AAEpC,kBAAU,OAAO,GAAG,GAAG,OAAO,GAAG,CAAQ;aACnC;AACN,eAAO,OAAO,QAAQ,EAAE,CAAC,GAAG,GAAG,OAAO,GAAG,EAAQ,CAAE;;;;AAKtD,SAAO,UAAU,QAAQ,GAAG,OAAO;AACpC;AAKM,SAAU,WAAc,QAAa,QAAW;AACrD,SAAO,OAAO,WAAW,OAAO,UAAU,OAAO,MAAM,CAAC,SAAS,UAAU,OAAO,KAAK,MAAM,OAAO;AACrG;AAKM,SAAU,qBACf,UACA,WACA,OAAuB,CAAA,GACvB,QAAgB;AAEhB,QAAM,OAAmB,CAAA;AACzB,QAAM,OAAO,MAAM,KAAK,SAAS;AAEjC,MAAI,SAAS,KAAK,CAAC,CAAC,KAAK,UAAU,CAAC,QAAQ,IAAI,KAAK,CAAC,GAAG,MAAM,GAAG;AAEjE,UAAM,iBAAiB,OAAO,KAAK,KAAK,CAAC,CAAC,EAAE,KAAK,SAAO,QAAQ,IAAI,UAAU,GAAG,CAAC;AAClF,QAAI,CAAC,gBAAgB;AAEpB,gBAAU,MAAM,EAAE,CAAC,MAAM,GAAG,KAAK,CAAC,EAAC,CAAE;AAErC,WAAK,OAAO,KAAK,QAAQ,MAAM,GAAG,CAAC;AAEnC,WAAK,MAAK;;;AAGZ,MAAI,KAAK,WAAW,KAAK,SAAS,KAAK,CAAC,CAAC,GAAG;AAC3C,cAAU,MAAM,KAAK,CAAC,CAAC;SACjB;AACN,aAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACrC,UAAI,UAAU,KAAK,CAAC,CAAC,GAAG;AACvB,aAAK,KAAK,CAAC,CAAC,IAAI,KAAK,CAAC;;;;AAIzB,SAAO,UAAU,UAAU,IAAI;AAChC;AAKM,SAAU,wBAA2B,UAAW;AAMrD,SAAQ,SAAuB,YAAY,YAAW;AACvD;AAMM,SAAU,WAAc,OAAU,UAAW;AAClD,MAAI,QAAQ,KAAK,GAAG;AACnB,WAAO;SACD;AACN,WAAO;;AAET;AAKM,SAAU,eAAqD,KAAQ,MAAO;AACnF,OAAK,QAAQ,UAAO;AACnB,QAAI,QAAQ,IAAI,KAAK,IAAI,GAAG;AAC3B,aAAO,IAAI,IAAI;;EAEjB,CAAC;AACD,SAAO;AACR;;;ACpGM,IAAgB,OAAhB,MAAoB;EAA1B,cAAA;AA0BC,SAAA,QAAQ;AA6BA,SAAA,eAAe;EA4BxB;;;;EApEC,OAAO,cAAW;AACjB,WAAO,CAAA;EACR;;;;;;;;;;;;;EAuBU,OAAO,MAAW;AAG3B,QAAI,KAAK,SAAU,aAAa,KAAK,SAAQ,MAAO,UAAU,kBAAmB;AAChF,UAAI,MAAM,GAAG,IAAI;;EAEnB;;;;EAcA,UAAO;AACN,SAAK,eAAe;AACpB,WAAO;EACR;;;;;;EAOA,IAAI,WAAQ;AACX,WAAO,KAAK;EACb;;;;;;;EAQA,WAAQ;AACP,WAAO,KAAK;EACb;;AA7EO,KAAA,UAAkB;;;ACvB1B,IAAM,UAAU;AAKV,SAAU,GAAG,GAAW,GAAS;AACtC,SAAO,IAAI,IAAI;AAChB;AAKM,SAAU,IAAI,GAAW,GAAS;AACvC,SAAO,GAAG,GAAG,CAAC,KAAK,GAAG,GAAG,CAAC;AAC3B;AAKM,SAAU,GAAG,GAAW,GAAS;AACtC,SAAO,IAAI,UAAU;AACtB;AAKM,SAAU,GAAG,GAAW,GAAS;AACtC,SAAO,KAAK,IAAI,IAAI,CAAC,IAAI;AAC1B;AAKM,SAAU,MAAM,OAAe,KAAa,KAAW;AAC5D,SAAO,KAAK,IAAI,KAAK,IAAI,OAAO,GAAG,GAAG,GAAG;AAC1C;;;ACVM,IAAO,WAAP,MAAO,kBAAqD,KAAI;EA0BrE,cAAA;AACC,UAAK;AAzBG,SAAA,OAAe;AAWd,SAAA,YAA4B,CAAA;AAerC,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC;AAElF,SAAK,SAAS,QAAQ;AACtB,SAAK,aAAa,QAAQ;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO;MACN,QAAQ;MACR,YAAY;;EAEd;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,UAAU;EACvB;;;;;EAMA,IAAI,OAAmB;AAEtB,WAAO,QAAQ,IAAI,OAAO,MAAM,GAAG,6CAA6C;AAChF,UAAM,OAAO,MAAM,KAAK,QAAO;AAC/B,QAAI,KAAK,cAAc,KAAK,QAAQ;AACnC,YAAM,YAAY,KAAK,UAAU,KAAK,SAAS,CAAC;AAChD,aAAO,IAAI,MAAM,MAAM,UAAU,IAAI,GAAG,mEAAmE;AAC3G,WAAK,UAAU,KAAK,KAAK;WACnB;AACN,YAAM,QAAQ,KAAK,QAAQ,MAAM,IAAI;AACrC,WAAK,UAAU,OAAO,QAAQ,GAAG,GAAG,KAAK;;AAG1C,QAAI,KAAK,SAAS,KAAK,QAAQ;AAC9B,YAAM,OAAO,KAAK,SAAS,KAAK;AAChC,WAAK,UAAU,OAAO,GAAG,IAAI;;AAE9B,WAAO;EACR;;;;;;EAOA,OAAO,OAAmB;AACzB,UAAM,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAC1C,QAAI,UAAU,IAAI;AACjB,WAAK,UAAU,OAAO,OAAO,CAAC;;AAE/B,WAAO;EACR;;;;;EAMA,IAAI,MAAc,QAA6B,QAAM;AACpD,UAAM,QAAQ,KAAK,QAAQ,MAAM,KAAK;AACtC,QAAI,UAAU,IAAI;AACjB,aAAO,KAAK,UAAU,KAAK;WACrB;AACN,aAAO;;EAET;;;;;EAMA,OAAI;AACH,WAAO,KAAK,UAAU,CAAC;EACxB;;;;EAKA,QAAK;AACJ,WAAO,KAAK,UAAU,MAAK;EAC5B;;;;;EAMA,SAAS,MAAc,QAA6B,QAAM;AACzD,UAAM,QAAQ,KAAK,QAAQ,MAAM,KAAK;AACtC,QAAI,QAAQ,IAAI,KAAK,UAAU,QAAQ;AACtC,aAAO,KAAK,UAAU,QAAQ,CAAC;WACzB;AACN,aAAO;;EAET;;;;;EAMA,UAAU,MAAY;AACrB,UAAM,MAAM,KAAK,UAAU;AAE3B,QAAI,MAAM,KAAK,KAAK,UAAU,MAAM,CAAC,EAAE,OAAO,MAAM;AACnD,aAAO,KAAK,UAAU,MAAM,CAAC;;AAE9B,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI,QAAQ,KAAK,GAAG;AACnB,aAAO,KAAK,UAAU,QAAQ,CAAC;WACzB;AACN,aAAO;;EAET;;;;;EAMA,OAAO,OAAa;AACnB,QAAI,KAAK,UAAU,SAAS,GAAG;AAC9B,UAAI,QAAQ,KAAK,QAAQ,KAAK;AAC9B,UAAI,SAAS,GAAG;AACf,YAAI,GAAG,KAAK,UAAU,KAAK,EAAE,MAAM,KAAK,GAAG;AAE1C,mBAAS,IAAI,OAAO,KAAK,GAAG,KAAK;AAChC,gBAAI,GAAG,KAAK,UAAU,CAAC,EAAE,MAAM,KAAK,GAAG;AACtC,sBAAQ;mBACF;AACN;;;AAGF,eAAK,YAAY,KAAK,UAAU,MAAM,GAAG,KAAK;eACxC;AACN,eAAK,YAAY,KAAK,UAAU,MAAM,GAAG,QAAQ,CAAC;;aAE7C;AACN,aAAK,YAAY,CAAA;;eAER,KAAK,UAAU,WAAW,GAAG;AAEvC,UAAI,IAAI,KAAK,UAAU,CAAC,EAAE,MAAM,KAAK,GAAG;AACvC,aAAK,YAAY,CAAA;;;AAGnB,WAAO;EACR;;;;;EAMA,aAAa,MAAY;AACxB,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI,SAAS,GAAG;AACf,WAAK,YAAY,KAAK,UAAU,MAAM,QAAQ,CAAC;;AAEhD,WAAO;EACR;;;;;;EAOA,cAAc,OAAmB;AAChC,UAAM,QAAQ,KAAK,UAAU,QAAQ,KAAK;AAC1C,QAAI,QAAQ,GAAG;AACd,aAAO,KAAK,UAAU,QAAQ,CAAC;WACzB;AACN,aAAO;;EAET;;;;;;;EAQU,QAAQ,MAAc,QAA6B,QAAM;AAClE,QAAI,KAAK,UAAU,WAAW,GAAG;AAChC,aAAO;;AAER,QAAI,YAAY;AAChB,UAAM,MAAM,KAAK,UAAU;AAC3B,QAAI,MAAM;AACV,QAAI,MAAM,KAAK,KAAK,UAAU,MAAM,CAAC,EAAE,KAAK,KAAK,MAAM;AACtD,aAAO,MAAM;;AAEd,WAAO,YAAY,KAAK;AAEvB,UAAI,WAAW,KAAK,MAAM,aAAa,MAAM,aAAa,CAAC;AAC3D,YAAM,QAAQ,KAAK,UAAU,QAAQ;AACrC,YAAM,YAAY,KAAK,UAAU,WAAW,CAAC;AAC7C,UAAI,GAAG,MAAM,KAAK,GAAG,IAAI,GAAG;AAE3B,iBAAS,IAAI,UAAU,IAAI,KAAK,UAAU,QAAQ,KAAK;AACtD,gBAAM,YAAY,KAAK,UAAU,CAAC;AAClC,cAAI,GAAG,UAAU,KAAK,GAAG,IAAI,GAAG;AAC/B,uBAAW;iBACL;AACN;;;AAGF,eAAO;iBACG,GAAG,MAAM,KAAK,GAAG,IAAI,KAAK,GAAG,UAAU,KAAK,GAAG,IAAI,GAAG;AAChE,eAAO;iBACG,GAAG,MAAM,KAAK,GAAG,IAAI,GAAG;AAElC,cAAM;aACA;AAEN,oBAAY,WAAW;;;AAGzB,WAAO;EACR;;;;;EAMQ,SACP,UACA,aAAa,GAAG,aAAa,KAAK,UAAU,SAAS,GAAC;AAEtD,SAAK,UAAU,MAAM,YAAY,aAAa,CAAC,EAAE,QAAQ,QAAQ;EAClE;;;;;EAMA,QAAQ,UAAuC;AAC9C,SAAK,SAAS,QAAQ;AACtB,WAAO;EACR;;;;;;EAOA,cAAc,MAAe,UAAuC;AAEnE,UAAM,aAAa,KAAK,QAAQ,IAAI;AACpC,QAAI,eAAe,IAAI;AACtB,WAAK,SAAS,UAAU,GAAG,UAAU;;AAEtC,WAAO;EACR;;;;;;EAOA,aAAa,MAAe,UAAuC;AAElE,UAAM,aAAa,KAAK,QAAQ,IAAI;AACpC,SAAK,SAAS,UAAU,aAAa,CAAC;AACtC,WAAO;EACR;;;;;;;;;EAUA,eAAe,WAAmB,SAAiB,UAAuC;AACzF,QAAI,aAAa,KAAK,QAAQ,SAAS;AACvC,QAAI,aAAa,KAAK,QAAQ,OAAO;AACrC,QAAI,eAAe,MAAM,eAAe,IAAI;AAC3C,UAAI,KAAK,UAAU,UAAU,EAAE,SAAS,WAAW;AAClD,sBAAc;;AAGf,UAAI,KAAK,UAAU,UAAU,EAAE,SAAS,SAAS;AAChD,sBAAc;;AAEf,WAAK,SAAS,UAAU,YAAY,UAAU;eACpC,eAAe,IAAI;AAC7B,WAAK,SAAS,UAAU,GAAG,UAAU;;AAEtC,WAAO;EACR;;;;;;;EAQA,YAAY,MAAc,UAAuC;AAEhE,QAAI,aAAa,KAAK,QAAQ,IAAI;AAElC,WAAO,cAAc,KAAK,KAAK,UAAU,UAAU,EAAE,QAAQ,MAAM;AAClE;;AAED,SAAK,SAAS,UAAU,aAAa,CAAC;AACtC,WAAO;EACR;;;;;;EAOA,cAAc,MAAc,UAAuC;AAElE,UAAM,aAAa,KAAK,QAAQ,IAAI;AACpC,QAAI,eAAe,MAAM,GAAG,KAAK,UAAU,UAAU,EAAE,MAAM,IAAI,GAAG;AACnE,UAAI,aAAa;AACjB,eAAS,IAAI,YAAY,KAAK,GAAG,KAAK;AACrC,YAAI,GAAG,KAAK,UAAU,CAAC,EAAE,MAAM,IAAI,GAAG;AACrC,uBAAa;eACP;AACN;;;AAGF,WAAK,SAAS,WAAQ;AACrB,iBAAS,KAAK;MACf,GAAG,YAAY,UAAU;;AAE1B,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,YAAY,CAAA;AACjB,WAAO;EACR;;;;ACpYD,IAAM,mBAAkD,CAAA;AAKlD,SAAU,cAAc,IAA0B;AACvD,mBAAiB,KAAK,EAAE;AACzB;AAKM,SAAU,kBAAkB,KAAY;AAE7C,mBAAiB,QAAQ,QAAM,GAAG,GAAG,CAAC;AACvC;AAKA,IAAM,qBAAoD,CAAA;AAKpD,SAAU,eAAe,IAA0B;AACxD,qBAAmB,KAAK,EAAE;AAC3B;AAEM,SAAU,aAAa,KAAY;AAExC,qBAAmB,QAAQ,QAAM,GAAG,GAAG,CAAC;AACzC;;;AC3BM,IAAO,UAAP,MAAO,iBAAmD,KAAI;EAApE,cAAA;;AAEU,SAAA,OAAe;EA4GzB;;;;;;EAhGC,GAAG,OAAkB,UAAkC;AAEtD,UAAM,SAAS,MAAM,MAAM,KAAK;AAChC,WAAO,QAAQ,eAAY;AAC1B,UAAI,QAAQ,KAAK,OAAO,GAAG;AAC1B,aAAK,UAAU,CAAA;;AAEhB,UAAI,CAAC,KAAK,QAAQ,eAAe,SAAS,GAAG;AAC5C,aAAK,QAAQ,SAAS,IAAI,CAAA;;AAE3B,WAAK,QAAQ,SAAS,EAAE,KAAK,QAAQ;IACtC,CAAC;AACD,WAAO;EACR;;;;;;EAOA,KAAK,OAAkB,UAAkC;AACxD,UAAM,gBAAgB,IAAI,SAAe;AAExC,eAAS,GAAG,IAAI;AAEhB,WAAK,IAAI,OAAO,aAAa;IAC9B;AACA,SAAK,GAAG,OAAO,aAAa;AAC5B,WAAO;EACR;;;;;;;EAQA,IAAI,OAAkB,UAAmC;AACxD,UAAM,SAAS,MAAM,MAAM,KAAK;AAChC,WAAO,QAAQ,eAAY;AAC1B,UAAI,QAAQ,KAAK,OAAO,GAAG;AAC1B,aAAK,UAAU,CAAA;;AAEhB,UAAI,KAAK,QAAQ,eAAe,KAAK,GAAG;AACvC,YAAI,QAAQ,QAAQ,GAAG;AACtB,eAAK,QAAQ,KAAK,IAAI,CAAA;eAChB;AACN,gBAAM,YAAY,KAAK,QAAQ,KAAK;AACpC,mBAAS,IAAI,UAAU,SAAS,GAAG,KAAK,GAAG,KAAK;AAC/C,gBAAI,UAAU,CAAC,MAAM,UAAU;AAC9B,wBAAU,OAAO,GAAG,CAAC;;;;;IAK1B,CAAC;AACD,WAAO;EACR;;;;;;;EAQA,KAAK,UAAU,MAAW;AACzB,QAAI,KAAK,SAAS;AACjB,UAAI,KAAK,QAAQ,eAAe,KAAK,GAAG;AACvC,cAAM,YAAY,KAAK,QAAQ,KAAK,EAAE,MAAM,CAAC;AAC7C,iBAAS,IAAI,GAAG,MAAM,UAAU,QAAQ,IAAI,KAAK,KAAK;AACrD,oBAAU,CAAC,EAAE,MAAM,MAAM,IAAI;;;;AAIhC,WAAO;EACR;;;;EAKA,OAAO,MAAM,QAAW;AAEvB,KAAC,MAAM,QAAQ,OAAO,MAAM,EAAE,QAAQ,UAAO;AAC5C,YAAM,WAAW,OAAO,yBAAyB,SAAQ,WAAW,IAAI;AACxE,aAAO,eAAe,OAAO,WAAW,MAAM,QAAQ;IACvD,CAAC;EACF;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU;AACf,WAAO;EACR;;;;AC/FK,IAAgB,cAAhB,cACG,QAA+B;EADxC,cAAA;;AAoIU,SAAA,YAAqB;EAC/B;;;;;;EALC,SAAM;AACL,WAAO,CAAA;EACR;;;;ACxHK,IAAO,UAAP,MAAO,iBAAgB,YAAW;EAwEvC,cAAA;AACC,UAAK;AAxEG,SAAA,OAAe;AA2BhB,SAAA,aAAa,oBAAI,IAAG;AAKpB,SAAA,YAA2C,IAAI,SAAQ;AAKvD,SAAA,cAAc;AAyBd,SAAA,eAAe;AAKd,SAAA,YAAqB;AA+OtB,SAAA,kBAA8C,oBAAI,IAAG;AAzO5D,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW;MACtE;KACA;AAED,QAAI,QAAQ,SAAS;AACpB,WAAK,WAAW,QAAQ;WAClB;AACN,WAAK,WAAW,mBAAmB;QAClC,aAAa,QAAQ;OACrB;;AAGF,SAAK,UAAU,IAAI,OAClB,KAAK,KAAK,KAAK,MAAM,MAAM,GAC3B,QAAQ,aACR,QAAQ,cAAc;AAEvB,SAAK,GAAG,QAAQ,KAAK,aAAa,KAAK,IAAI,CAAC;AAG5C,SAAK,SAAS,gBAAgB,MAAK;AAClC,WAAK,KAAK,eAAe,KAAK,KAAK;IACpC;AAEA,SAAK,gBAAgB,QAAQ,WAAW;AACxC,SAAK,YAAY,QAAQ;EAC1B;EAEA,OAAO,cAAW;AACjB,WAAO;MACN,aAAa;MACb,aAAa;MACb,WAAW;MACX,gBAAgB;;EAElB;;;;EAKQ,aAAU;AACjB,QAAI,CAAC,KAAK,cAAc;AAEvB,wBAAkB,IAAI;AACtB,WAAK,eAAe;;AAErB,WAAO;EACR;;;;EAMA,iBAAc;AACb,WAAO,KAAK,SAAS,eAAc;EACpC;EACA,mBAAgB;AACf,WAAO,KAAK,SAAS,iBAAgB;EACtC;EACA,qBAAkB;AACjB,WAAO,KAAK,SAAS,mBAAkB;EACxC;EACA,qBAAkB;AACjB,WAAO,KAAK,SAAS,mBAAkB;EACxC;EACA,aACC,kBACA,QACA,YAAkB;AAElB,WAAO,KAAK,SAAS,aAAa,kBAAkB,QAAQ,UAAU;EACvE;EACA,oBACC,gBAAmC;AAEnC,WAAO,KAAK,SAAS,oBAAoB,cAAc;EACxD;EACA,sBACC,iBAAoC;AAEpC,WAAO,KAAK,SAAS,sBAAsB,eAAe;EAC3D;EACA,uBAAoB;AACnB,WAAO,KAAK,SAAS,qBAAoB;EAC1C;EACA,kBAAe;AACd,WAAO,KAAK,SAAS,gBAAe;EACrC;EACA,YAAY,cAAiC;AAC5C,WAAO,KAAK,SAAS,YAAY,YAAY;EAC9C;EACA,2BAAwB;AACvB,WAAO,KAAK,SAAS,yBAAwB;EAC9C;EACA,aAAU;AACT,WAAO,KAAK,SAAS,WAAU;EAChC;EACA,gBACC,aACA,UAAiC;AAGjC,WAAO,KAAK,SAAS,gBAAgB,aAAa,QAAQ;EAC3D;EACA,eAAY;AACX,WAAO,KAAK,SAAS,aAAY;EAClC;EACA,mBACC,MACA,MACA,aAAiD;AAEjD,WAAO,KAAK,SAAS,mBAAmB,MAAM,MAAM,WAAW;EAChE;EACA,qBAAkB;AACjB,WAAO,KAAK,SAAS,mBAAkB;EACxC;EACA,mBAAgB;AACf,WAAO,KAAK,SAAS,iBAAgB;EACtC;EACA,wBAAwB,QAAmB;AAC1C,WACC,eAAe,KAAK,QAAQ,GAC5B,sCAAsC;AAEvC,UAAMC,WAAU,KAAK;AACrB,WAAOA,SAAQ,wBAAwB,MAAM;EAC9C;EACA,yBACC,SAAyB;AAEzB,WACC,eAAe,KAAK,QAAQ,GAC5B,sCAAsC;AAEvC,UAAMA,WAAU,KAAK;AACrB,WAAOA,SAAQ,yBAAyB,OAAO;EAChD;EACA,+BAA4B;AAC3B,WACC,eAAe,KAAK,QAAQ,GAC5B,sCAAsC;AAEvC,UAAMA,WAAU,KAAK;AACrB,WAAOA,SAAQ,6BAA4B;EAC5C;EACA,gBAAgB,WAAsB;AACrC,WAAO,KAAK,SAAS,gBAAgB,SAAS;EAC/C;;;;EAKA,IAAI,cAAW;AACd,WAAO,KAAK,SAAS;EACtB;;;;EAIA,IAAI,QAAK;AACR,WAAO,KAAK,SAAS;EACtB;;;;EAIA,IAAI,aAAU;AACb,WAAO,KAAK,SAAS;EACtB;;;;EAKA,IAAI,WAAQ;AACX,SAAK,WAAU;AACf,WAAO,KAAK;EACb;EACA,IAAI,SAAS,GAAC;AACb,WACC,CAAC,KAAK,cACN,kDAAkD;AAEnD,SAAK,YAAY;EAClB;;;;EAKA,IAAI,YAAS;AACZ,SAAK,WAAU;AACf,WAAO,KAAK;EACb;EACA,IAAI,UAAU,GAAY;AACzB,WACC,CAAC,KAAK,cACN,mDAAmD;AAEpD,SAAK,aAAa;EACnB;;;;EAKA,IAAI,OAAI;AACP,SAAK,WAAU;AACf,WAAO,KAAK;EACb;EACA,IAAI,KAAK,GAAC;AACT,WAAO,CAAC,KAAK,cAAc,0CAA0C;AACrE,SAAK,QAAQ;EACd;;;;EAKA,IAAI,cAAW;AACd,SAAK,WAAU;AACf,WAAO,KAAK;EACb;EACA,IAAI,YAAY,GAAc;AAC7B,WACC,CAAC,KAAK,cACN,qDAAqD;AAEtD,SAAK,eAAe;EACrB;;;;;EAeA,uBACC,MACA,SAA0C;AAE1C,WAAO,uBAAuB,KAAK,YAAY,MAAM,OAAO;EAC7D;;;;;;EAOM,sBAAsB,KAAa,MAAY;;AACpD,aACC,UAAU,KAAK,WAAW,YAAY,GACtC,6EAA6E;AAE9E,UAAI,CAAC,KAAK,gBAAgB,IAAI,IAAI,GAAG;AACpC,aAAK,gBAAgB,IACpB,MACA,KAAK,WAAW,aAAa,UAAU,GAAG,CAAC;;AAG7C,YAAM,KAAK,gBAAgB,IAAI,IAAI;IACpC,CAAC;;;;;EAKe,mBAAgB;;AAC/B,YAAM,WAA4B,CAAA;AAClC,WAAK,gBAAgB,QAAQ,CAAC,YAAY,SAAS,KAAK,OAAO,CAAC;AAChE,YAAM,QAAQ,IAAI,QAAQ;IAC3B,CAAC;;;;;;;;;;;EAYD,IAAI,iBAAc;AACjB,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,eAAe,UAAiB;AACnC,SAAK,QAAQ,iBAAiB;EAC/B;;;;;EAMA,IAAI,cAAW;AACd,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,YAAY,MAAuB;AACtC,SAAK,QAAQ,OAAO;EACrB;;;;;;;;;;;;;;;;EAiBA,IAAI,cAAW;AACd,WAAO,KAAK;EACb;;;;EAKQ,gBAAgB,MAAkC;AACzD,QAAI,iBAAiB;AACrB,SAAK,eAAe;AACpB,QAAI,SAAS,IAAI,GAAG;AACnB,cAAQ,MAAM;QACb,KAAK;AACJ,2BAAiB;AACjB;QACD,KAAK;AACJ,2BAAiB;AACjB;QACD,KAAK;AACJ,2BAAiB;AACjB;;;AAGH,SAAK,YAAY;AACjB,SAAK,iBAAiB,iBAAiB;EACxC;;;;EAKA,IAAI,aAAU;AACb,WAAO,KAAK;EACb;;;;EAKA,MAAG;AACF,WAAO,KAAK,SAAS,cAAc,KAAK;EACzC;;;;;;;;EASA,YAAS;AACR,WAAO,KAAK,SAAS;EACtB;;;;;EAMA,SAAM;AACL,QAAI,eAAe,KAAK,QAAQ,GAAG;AAClC,aAAO,KAAK,SAAS,OAAM;WACrB;AACN,aAAO,QAAQ,QAAO;;EAExB;;;;;EAMM,QAAK;;AACV,UAAI,eAAe,KAAK,QAAQ,GAAG;AAClC,cAAM,KAAK,SAAS,MAAK;;AAE1B,UAAI,KAAK,cAAc;AACtB,qBAAa,IAAI;;IAEnB,CAAC;;;;;EAKD,YAAY,KAAW;AACtB,QAAI,KAAK,WAAW,IAAI,GAAG,GAAG;AAC7B,aAAO,KAAK,WAAW,IAAI,GAAG;WACxB;AACN,YAAM,SAAS,KAAK,SAAS,aAC5B,GACA,KACA,KAAK,SAAS,UAAU;AAEzB,YAAM,MAAM,OAAO,eAAe,CAAC;AACnC,eAAS,IAAI,GAAG,IAAI,IAAI,QAAQ,KAAK;AACpC,YAAI,CAAC,IAAI;;AAEV,YAAM,WAAW,KAAK,SAAS,mBAAkB;AACjD,eAAS,eAAe;AACxB,eAAS,mBAAmB;AAC5B,eAAS,SAAS;AAClB,eAAS,OAAO;AAChB,eAAS,MAAM,CAAC;AAChB,WAAK,WAAW,IAAI,KAAK,QAAQ;AACjC,aAAO;;EAET;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,UAAU,QAAO;AACtB,WAAO,KAAK,KAAK,UAAU,EAAE,IAAI,CAAC,QACjC,KAAK,WAAW,GAAG,EAAE,WAAU,CAAE;AAElC,WAAO;EACR;;;;;;;;EAUQ,eAAY;AACnB,UAAMC,OAAM,KAAK,IAAG;AACpB,QAAI,aAAa,KAAK,UAAU,KAAI;AACpC,WAAO,KAAK,UAAU,UAAU,cAAc,WAAW,QAAQA,MAAK;AAErE,iBAAW,SAAQ;AAEnB,WAAK,UAAU,MAAK;AAEpB,mBAAa,KAAK,UAAU,KAAI;;EAElC;;;;;;;;EASA,WAAW,IAA8B,SAAgB;AACxD,SAAK;AACL,UAAMA,OAAM,KAAK,IAAG;AACpB,SAAK,UAAU,IAAI;MAClB,UAAU;MACV,IAAI,KAAK;MACT,MAAMA,OAAM;KACZ;AACD,WAAO,KAAK;EACb;;;;;EAMA,aAAa,IAAU;AACtB,SAAK,UAAU,QAAQ,CAAC,UAAS;AAChC,UAAI,MAAM,OAAO,IAAI;AACpB,aAAK,UAAU,OAAO,KAAK;;IAE7B,CAAC;AACD,WAAO;EACR;;;;EAKA,cAAc,IAAU;AACvB,WAAO,KAAK,aAAa,EAAE;EAC5B;;;;EAKA,YAAY,IAA8B,UAAiB;AAC1D,UAAM,KAAK,EAAE,KAAK;AAClB,UAAM,aAAa,MAAK;AACvB,YAAMA,OAAM,KAAK,IAAG;AACpB,WAAK,UAAU,IAAI;QAClB,UAAU,MAAK;AAEd,aAAE;AAEF,qBAAU;QACX;QACA;QACA,MAAMA,OAAM;OACZ;IACF;AAEA,eAAU;AACV,WAAO;EACR;;;;ACzmBK,IAAO,eAAP,cAA4B,YAAW;EAA7C,cAAA;;AA4HC,SAAA,YAAY;AAEZ,SAAA,cAAc;AAgEL,SAAA,YAAqB;EAC/B;;;;EA3LC,iBAAc;AACb,WAAO,CAAA;EACR;EAEA,mBAAgB;AACf,WAAO,CAAA;EACR;EAEA,qBAAkB;AACjB,WAAO,CAAA;EACR;EAEA,qBAAkB;AACjB,WAAO,CAAA;EACR;EAEA,aACC,mBACA,SACA,aAAmB;AAEnB,WAAO,CAAA;EACR;EAEA,oBACC,iBAAoC;AAEpC,WAAO,CAAA;EACR;EAEA,sBACC,kBAAqC;AAErC,WAAO,CAAA;EACR;EAEA,uBAAoB;AACnB,WAAO,CAAA;EACR;EAEA,kBAAe;AACd,WAAO,CAAA;EACR;EAEA,YAAY,eAAkC;AAC7C,WAAO,CAAA;EACR;EAEA,2BAAwB;AACvB,WAAO,CAAA;EACR;EAEA,aAAU;AACT,WAAO,CAAA;EACR;EAEA,gBACC,cACA,WAAkC;AAElC,WAAO,CAAA;EACR;EAEA,eAAY;AACX,WAAO,CAAA;EACR;EAEA,mBACC,OACA,OACA,cAAkD;AAElD,WAAO,CAAA;EACR;EAEA,qBAAkB;AACjB,WAAO,CAAA;EACR;EAEA,mBAAgB;AACf,WAAO,CAAA;EACR;EAEA,wBAAwB,SAAoB;AAC3C,WAAO,CAAA;EACR;EAEA,yBACC,UAA0B;AAE1B,WAAO,CAAA;EACR;EAEA,+BAA4B;AAC3B,WAAO,CAAA;EACR;EAEA,gBAAgB,YAAuB;AACtC,WAAO,QAAQ,QAAQ,CAAA,CAAiB;EACzC;;;;EAMA,uBACC,OACA,UAA2C;AAE3C,WAAO,CAAA;EACR;EAEA,IAAI,aAAU;AACb,WAAO,CAAA;EACR;EAEM,sBAAsB,MAAc,OAAa;;AACtD,aAAO,QAAQ,QAAO;IACvB,CAAC;;EAMD,SAAM;AACL,WAAO,QAAQ,QAAO;EACvB;EAEA,WAAW,KAA+B,UAAiB;AAC1D,WAAO;EACR;EAEA,aAAa,KAAW;AACvB,WAAO;EACR;EAEA,YAAY,KAA+B,WAAkB;AAC5D,WAAO;EACR;EAEA,cAAc,KAAW;AACxB,WAAO;EACR;EAEA,YAAY,MAAY;AACvB,WAAO,CAAA;EACR;EAEA,IAAI,cAAW;AACd,WAAO;EACR;EAEA,IAAI,QAAK;AACR,WAAO,CAAA;EACR;EAEA,IAAI,aAAU;AACb,WAAO;EACR;EAEA,IAAI,WAAQ;AACX,WAAO,CAAA;EACR;EAEA,IAAI,YAAS;AACZ,WAAO,CAAA;EACR;EAEA,IAAI,OAAI;AACP,WAAO,CAAA;EACR;EACA,IAAI,KAAK,IAAE;EAAG;EAEd,IAAI,cAAW;AACd,WAAO,CAAA;EACR;EACA,IAAI,YAAY,IAAe;EAAG;EAElC,MAAG;AACF,WAAO;EACR;EAEA,YAAS;AACR,WAAO;EACR;;;;AC7LK,SAAU,SAAS,QAAgB,UAA2B;AACnE,MAAI,QAAQ,QAAQ,GAAG;AACtB,aAAS,QAAQ,SAAO,SAAS,QAAQ,GAAG,CAAC;SACvC;AACN,WAAO,eAAe,QAAQ,UAAU;MACvC,YAAY;MACZ,UAAU;KACV;;AAEH;AAKM,SAAU,SAAS,QAAgB,UAA2B;AACnE,MAAI,QAAQ,QAAQ,GAAG;AACtB,aAAS,QAAQ,SAAO,SAAS,QAAQ,GAAG,CAAC;SACvC;AACN,WAAO,eAAe,QAAQ,UAAU;MACvC,UAAU;KACV;;AAEH;AAEO,IAAM,OAAgC,MAAK;AAElD;;;ACRM,IAAO,kBAAP,MAAO,yBAAwB,KAAI;EAiCxC,cAAA;AAEC,UAAK;AAjCG,SAAA,OAAe;AAexB,SAAA,SAA4C;AAoB3C,UAAM,UAAU,qBAAqB,iBAAgB,YAAW,GAAI,WAAW,CAAC,OAAO,UAAU,SAAS,CAAC;AAE3G,SAAK,UAAU,QAAQ;AACvB,SAAK,SAAS,QAAQ;AAEtB,QAAI,QAAQ,OAAO,cAAc,QAAQ,GAAG,KAAK,QAAQ,eAAe,kBAAiB;AACxF,WAAK,IAAI,QAAQ,GAAG;eACV,SAAS,QAAQ,GAAG,GAAG;AAEjC,WAAK,KAAK,QAAQ,GAAG,EAAE,MAAM,QAAQ,OAAO;;EAE9C;EAEA,OAAO,cAAW;AACjB,WAAO;MACN,SAAS;MACT,QAAQ;MACR,SAAS;;EAEX;;;;EAKA,IAAI,aAAU;AACb,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO,WAAU,EAAG;;EAEtB;;;;EAKA,IAAI,QAAqC;AACxC,QAAI,kBAAkB,kBAAiB;AAEtC,UAAI,OAAO,QAAQ;AAClB,aAAK,UAAU,OAAO,IAAG;aACnB;AAEN,eAAO,SAAS,MAAK;AACpB,eAAK,IAAI,MAAM;AACf,eAAK,OAAO,IAAI;QACjB;;WAEK;AACN,WAAK,UAAU;;AAGhB,QAAI,KAAK,WAAW;AACnB,WAAK,SAAQ;;AAEd,WAAO;EACR;;;;EAKA,MAAG;AACF,WAAO,KAAK;EACb;;;;;;;EAQM,KAAK,KAAW;;AACrB,YAAM,cAA6B,iBAAgB,KAAK,GAAG,EAAE,KAAK,iBAAc;AAC/E,aAAK,IAAI,WAAW;AAEpB,aAAK,OAAO,IAAI;MACjB,CAAC;AACD,uBAAgB,UAAU,KAAK,WAAW;AAC1C,UAAI;AACH,cAAM;;AAGN,cAAM,QAAQ,iBAAgB,UAAU,QAAQ,WAAW;AAC3D,yBAAgB,UAAU,OAAO,OAAO,CAAC;;AAE1C,aAAO;IACR,CAAC;;;;;EAKD,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU;AACf,WAAO;EACR;;;;;;EAOA,UAAU,OAAoC;AAC7C,UAAM,qBAAqB,QAAQ,KAAK,KAAK,MAAM,CAAC,EAAE,SAAS;AAC/D,UAAM,WAAW,qBAAqB,MAAM,SAAS;AACrD,UAAM,MAAM,qBAAsB,MAAM,CAAC,EAAmB,SAAS,MAAM;AAC3E,UAAMC,WAAU,WAAU;AAC1B,UAAM,SAASA,SAAQ,aAAa,UAAU,KAAKA,SAAQ,UAAU;AACrE,UAAM,oBAAoC,CAAC,sBAAsB,aAAa,IAC7E,CAAC,KAAqB,IAAI;AAE3B,aAAS,IAAI,GAAG,IAAI,UAAU,KAAK;AAClC,aAAO,cAAc,kBAAkB,CAAC,GAAG,CAAC;;AAE7C,SAAK,UAAU;AACf,WAAO;EACR;;;;;EAMA,OAAO,SAAgB;AACtB,QAAI,SAAS,OAAO,GAAG;AACtB,WAAK,UAAU,KAAK,QAAQ,OAAO,CAAC;WAC9B;AACN,UAAI,cAAc,IAAI,aAAa,KAAK,MAAgB;AACxD,YAAM,cAAc,KAAK;AACzB,eAAS,UAAU,GAAG,UAAU,aAAa,WAAW;AACvD,cAAM,eAAe,KAAK,QAAQ,OAAO;AACzC,iBAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC7C,sBAAY,CAAC,KAAK,aAAa,CAAC;;;AAIlC,oBAAc,YAAY,IAAI,YAAU,SAAS,WAAW;AAC5D,WAAK,UAAU,WAAW;;AAE3B,WAAO;EACR;;;;;;EAOA,QAAQ,SAAgB;AACvB,QAAI,SAAS,OAAO,GAAG;AACtB,aAAO,KAAK,eAAe,OAAO;eACxB,KAAK,qBAAqB,GAAG;AACvC,aAAO,KAAK,QAAQ,CAAC;WACf;AACN,YAAM,MAAsB,CAAA;AAC5B,eAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,KAAK;AAC/C,YAAI,CAAC,IAAI,KAAK,eAAe,CAAC;;AAE/B,aAAO;;EAET;;;;;;EAOA,eAAe,SAAe;AAC7B,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ,eAAe,OAAO;WACpC;AACN,aAAO,IAAI,aAAa,CAAC;;EAE3B;;;;;;;EAQA,MAAMC,QAAgB,MAAe,KAAK,UAAQ;AACjD,UAAM,eAAe,KAAK,MAAMA,SAAQ,KAAK,UAAU;AACvD,UAAM,aAAa,KAAK,MAAM,MAAM,KAAK,UAAU;AACnD,WAAO,eAAe,YAAY,+CAA+C;AACjF,UAAM,SAAS,aAAa;AAC5B,UAAM,YAAY,WAAU,EAAG,aAAa,KAAK,kBAAkB,QAAQ,KAAK,UAAU;AAC1F,aAAS,UAAU,GAAG,UAAU,KAAK,kBAAkB,WAAW;AACjE,gBAAU,cAAc,KAAK,eAAe,OAAO,EAAE,SAAS,cAAc,UAAU,GAAG,OAAO;;AAEjG,WAAO,IAAI,iBAAgB,SAAS;EACrC;;;;EAKQ,WAAQ;AACf,QAAI,KAAK,QAAQ;AAChB,eAAS,IAAI,GAAG,IAAI,KAAK,kBAAkB,KAAK;AAC/C,aAAK,eAAe,CAAC,EAAE,QAAO;;;AAGhC,WAAO;EACR;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,SAAS;EACtB;;;;EAKA,IAAI,WAAQ;AACX,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO;;EAET;;;;EAKA,IAAI,SAAM;AACT,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO;;EAET;;;;EAKA,IAAI,mBAAgB;AACnB,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO;;EAET;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,KAAY;AACvB,QAAI,KAAK,cAAc,KAAK;AAC3B,WAAK,YAAY;AACjB,WAAK,SAAQ;;EAEf;;;;;;;EAiBA,OAAO,UAAU,OAAoC;AACpD,WAAQ,IAAI,iBAAe,EAAI,UAAU,KAAK;EAC/C;;;;;;EAOA,OAAa,QAAQ,KAAW;;AAC/B,YAAM,SAAS,IAAI,iBAAe;AAClC,aAAO,MAAM,OAAO,KAAK,GAAG;IAC7B,CAAC;;;;;EAUD,OAAa,KAAK,KAAW;;AAG5B,YAAM,UAAU,IAAI,MAAM,qBAAqB;AAC/C,UAAI,SAAS;AACZ,cAAM,aAAa,QAAQ,CAAC,EAAE,MAAM,GAAG;AACvC,YAAI,YAAY,WAAW,CAAC;AAC5B,mBAAW,OAAO,YAAY;AAC7B,cAAI,iBAAgB,aAAa,GAAG,GAAG;AACtC,wBAAY;AACZ;;;AAGF,cAAM,IAAI,QAAQ,QAAQ,CAAC,GAAG,SAAS;;AAIxC,YAAM,UAAU,iBAAgB,YAAY,MAAM,iBAAgB,QAAQ,SAAS,GAAG,IAAI,iBAAgB,UAAU,iBAAgB,UAAU;AAC9I,YAAM,WAAW,MAAM,MAAM,UAAU,GAAG;AAC1C,UAAI,CAAC,SAAS,IAAI;AACjB,cAAM,IAAI,MAAM,uBAAuB,GAAG,EAAE;;AAE7C,YAAM,cAAc,MAAM,SAAS,YAAW;AAE9C,YAAM,cAAc,MAAM,WAAU,EAAG,gBAAgB,WAAW;AAElE,aAAO;IACR,CAAC;;;;;;;;;;;EAWD,OAAO,aAAa,KAAW;AAC9B,UAAM,aAAa,IAAI,MAAM,GAAG;AAChC,UAAM,YAAY,WAAW,WAAW,SAAS,CAAC;AAClD,UAAM,WAAW,SAAS,cAAc,OAAO,EAAE,YAAY,WAAW,SAAS;AACjF,WAAO,aAAa;EACrB;;;;EAKA,OAAa,SAAM;;AAElB,YAAM,QAAQ,QAAO;AACrB,aAAO,iBAAgB,UAAU,QAAQ;AACxC,cAAM,iBAAgB,UAAU,CAAC;;IAEnC,CAAC;;;AApFM,gBAAA,UAAU;AAyBV,gBAAA,YAAkC,CAAA;;;AC7UpC,IAAO,iBAAP,cAA8B,QAAO;EAgC1C,cAAA;AAEC,UAAM;MACL,aAAa;MACb,SAAS,sBAAsB,UAAU,CAAC,CAAC,IAC1C,UAAU,CAAC,IAAI,0BAA0B,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI,UAAU,CAAC,GAAG,UAAU,CAAC,CAAC;MACjG,WAAW;MACX,gBAAgB,sBAAsB,UAAU,CAAC,CAAC,IACjD,MAAM,UAAU,CAAC,EAAE,aAAa,MAAM,UAAU,CAAC;KAClD;AAvCO,SAAA,OAAe;AAUhB,SAAA,eAAwB;AAOvB,SAAA,YAAqB;AAwB7B,SAAK,YAAY,sBAAsB,UAAU,CAAC,CAAC,IAClD,UAAU,CAAC,EAAE,SAAS,UAAU,CAAC,EAAE,aAAa,UAAU,CAAC;EAC7D;;;;EAKA,MAAG;AACF,WAAO,KAAK;EACb;;;;EAKA,IAAI,cAAW;AACd,WAAO,KAAK;EACb;;;;EAKc,aAAa,cAAqB;;AAC/C,UAAI,QAAQ;AACZ,aAAO,KAAK,YAAY,KAAK,gBAAgB,GAAG;AAG/C,aAAK,KAAK,MAAM;AAGhB,aAAK,gBAAgB,MAAM,KAAK;AAGhC;AACA,cAAM,aAAa,KAAK,MAAM,KAAK,aAAa,GAAG;AACnD,YAAI,gBAAgB,QAAQ,eAAe,GAAG;AAC7C,gBAAM,IAAI,QAAQ,UAAQ,WAAW,MAAM,CAAC,CAAC;;;IAGhD,CAAC;;;;;;EAMK,OAAO,eAAe,MAAI;;AAC/B,YAAM,KAAK,iBAAgB;AAC3B,YAAM,KAAK,aAAa,YAAY;AACpC,YAAM,SAAS,MAAM,KAAK,SAAS,eAAc;AACjD,aAAO,IAAI,gBAAgB,MAAM;IAClC,CAAC;;;;;EAKD,QAAK;AACJ,WAAO,QAAQ,QAAO;EACvB;;;;ACzGD,IAAM,eAAe,IAAI,aAAY;AAMrC,IAAI,gBAA6B;AAM3B,SAAU,aAAU;AACzB,MAAI,kBAAkB,gBAAgB,iBAAiB;AACtD,eAAW,IAAI,QAAO,CAAE;;AAEzB,SAAO;AACR;AAMM,SAAU,WAAWC,UAAsC;AAChE,MAAI,eAAeA,QAAO,GAAG;AAC5B,oBAAgB,IAAI,QAAQA,QAAO;aACzB,sBAAsBA,QAAO,GAAG;AAC1C,oBAAgB,IAAI,eAAeA,QAAO;SACpC;AACN,oBAAgBA;;AAElB;AAeM,SAAU,QAAK;AACpB,SAAO,cAAc,OAAM;AAC5B;AAKA,IAAI,aAAa,CAAC,UAAU,sBAAsB;AACjD,MAAI,SAAS;AACb,MAAI,YAAY,OAAO;AACtB,aAAS;;AAEV,QAAM,cAAc,cAAc,MAAM,GAAG,OAAO;AAElD,UAAQ,IAAI,KAAK,WAAW,IAAI,+BAA+B;;;;ACzD1D,SAAU,SAAS,IAAY;AACpC,SAAO,KAAK,IAAI,IAAI,KAAK,EAAE;AAC5B;AAKM,SAAU,SAAS,MAAgB;AACxC,SAAO,MAAM,KAAK,IAAI,IAAI,IAAI,KAAK;AACpC;AAUM,SAAU,yBAAyB,UAAkB;AAC1D,SAAO,KAAK,IAAI,GAAI,WAAW,EAAG;AACnC;AAMA,IAAI,KAAY;AAEV,SAAU,QAAK;AACpB,SAAO;AACR;AAEM,SAAU,MAAM,MAAW;AAChC,OAAK;AACN;AAQM,SAAU,KAAK,WAAgB;AACpC,SAAO,KAAK,MAAM,MAAM,SAAS,CAAC;AACnC;AAKM,SAAU,MAAM,WAAgB;AACrC,SAAO,KAAK,KAAK,KAAK,KAAK,YAAY,EAAE;AAC1C;AASM,SAAU,KAAK,MAAc;AAClC,SAAO,KAAK,KAAK,IAAI,IAAI,OAAO,MAAM,EAAE;AACzC;;;AClDM,IAAgB,gBAAhB,MAAgB,uBAAgE,KAAI;;;;;;;EA8BzF,YAAYC,UAAsB,OAAmB,OAAY;AAChE,UAAK;AATG,SAAA,eAAqB;AAW7B,SAAK,OAAO;AACZ,SAAK,SAAS;AACd,SAAK,UAAUA;AACf,SAAK,eAAe,KAAK,gBAAe;EACzC;;;;EAKU,kBAAe;AACxB,WAAO;MACN,IAAI;QACH,QAAQ,CAAC,UAAS;AACjB,iBAAO,KAAK,kBAAkB,WAAW,KAAK,CAAC;QAChD;QACA,QAAQ;;MAET,GAAG;QACF,QAAQ,CAAC,UAAS;AACjB,iBAAO,KAAK,cAAc,SAAS,OAAO,EAAE,CAAC;QAC9C;QACA,QAAQ;;MAET,GAAG;QACF,QAAQ,CAAC,UAAS;AACjB,iBAAO,KAAK,cAAc,SAAS,OAAO,EAAE,IAAI,KAAK,kBAAiB,CAAE;QACzE;QACA,QAAQ;;MAET,GAAG;QACF,QAAQ,CAAC,OAAO,QAAO;AACtB,gBAAM,eAAe,SAAS,OAAO,EAAE;AACvC,gBAAM,SAAS,QAAQ,MAAM,MAAM;AACnC,cAAI,iBAAiB,GAAG;AACvB,mBAAO,KAAK,cAAc,KAAK,kBAAiB,CAAE,IAAI;iBAChD;AACN,mBAAO,KAAK,cAAc,IAAI,YAAY,IAAI;;QAEhD;QACA,QAAQ;;MAET,QAAQ;QACP,QAAQ,CAAC,UAAS;AACjB,iBAAO,KAAK,aAAa,KAAK,YAAY,EAAE,OAAO,KAAK,MAAM,KAAK;QACpE;QACA,QAAQ;;MAET,GAAG;QACF,QAAQ,CAAC,UAAe;AACvB,iBAAO,KAAK,gBAAgB,WAAW,KAAK,CAAC;QAC9C;QACA,QAAQ;;MAET,SAAS;QACR,QAAQ,CAAC,UAAS;AACjB,iBAAO,SAAS,OAAO,EAAE,IAAI,KAAK,QAAQ;QAC3C;QACA,QAAQ;;MAET,GAAG;QACF,QAAQ,CAAC,UAAS;AACjB,gBAAM,eAAe,SAAS,OAAO,EAAE;AACvC,iBAAO,KAAK,cAAc,KAAK,KAAK,MAAM,YAAY,IAAI,EAAE;QAC7D;QACA,QAAQ;;MAET,IAAI;QACH,QAAQ,CAAC,GAAG,GAAG,MAAK;AACnB,cAAI,QAAQ;AACZ,cAAI,KAAK,MAAM,KAAK;AACnB,qBAAS,KAAK,cAAc,KAAK,kBAAiB,IAAK,WAAW,CAAC,CAAC;;AAErE,cAAI,KAAK,MAAM,KAAK;AACnB,qBAAS,KAAK,cAAc,WAAW,CAAC,CAAC;;AAE1C,cAAI,KAAK,MAAM,KAAK;AACnB,qBAAS,KAAK,cAAc,WAAW,CAAC,IAAI,CAAC;;AAE9C,iBAAO;QACR;QACA,QAAQ;;;EAGX;;;;;;;EASA,UAAO;AACN,QAAI,KAAK,gBAAgB,gBAAe;AACvC,WAAK,SAAS,KAAK,IAAI;;AAExB,QAAI,QAAQ,KAAK,IAAI,GAAG;AACvB,aAAO,KAAK,OAAM;eACR,SAAS,KAAK,IAAI,KAAK,QAAQ,KAAK,MAAM,GAAG;AACvD,iBAAW,SAAS,KAAK,cAAc;AACtC,YAAI,KAAK,aAAa,KAAK,EAAE,OAAO,KAAK,KAAK,KAAK,KAAI,CAAE,GAAG;AAC3D,eAAK,SAAS;AACd;;;eAGQ,SAAS,KAAK,IAAI,GAAG;AAC/B,UAAI,QAAQ;AACZ,iBAAW,YAAY,KAAK,MAAM;AACjC,YAAI,UAAU,KAAK,KAAK,QAAQ,CAAC,GAAG;AACnC,gBAAM,WAAW,KAAK,KAAK,QAAQ;AAEnC,gBAAM,OAAQ,IAAI,KAAK,YAAY,KAAK,SAAS,QAAQ,EAAG,QAAO,IAAK;AACxE,mBAAS;;;AAGX,aAAO;;AAER,QAAI,UAAU,KAAK,MAAM,GAAG;AAC3B,YAAM,OAAO,KAAK,aAAa,KAAK,MAAM;AAC1C,YAAM,WAAW,KAAK,KAAK,SAAQ,EAAG,KAAI,EAAG,MAAM,KAAK,MAAM;AAC9D,UAAI,UAAU;AACb,eAAO,KAAK,OAAO,MAAM,MAAM,SAAS,MAAM,CAAC,CAAC;aAC1C;AACN,eAAO,KAAK,OAAO,KAAK,MAAM,KAAK,IAAI;;eAE9B,SAAS,KAAK,IAAI,GAAG;AAC/B,aAAO,WAAW,KAAK,IAAI;WACrB;AACN,aAAO,KAAK;;EAEd;;;;;;;EASU,kBAAkB,MAAW;AACtC,WAAO,IAAI;EACZ;;;;EAKU,cAAc,OAAa;AACpC,WAAQ,KAAK,KAAK,QAAO,IAAM;EAChC;;;;EAKU,gBAAgB,SAAgB;AACzC,WAAO;EACR;;;;EAKU,cAAc,OAAY;AACnC,WAAQ,QAAS,KAAK,cAAc,CAAC,IAAK,KAAK,QAAO;EACvD;;;;EAKU,SAAM;AACf,WAAO,KAAK,KAAI;EACjB;;;;;;;EASU,UAAO;AAChB,WAAO,KAAK,QAAQ,UAAU,IAAI;EACnC;;;;EAKU,oBAAiB;AAC1B,WAAO,KAAK,QAAQ,UAAU;EAC/B;;;;EAKU,UAAO;AAChB,WAAO,KAAK,QAAQ,UAAU;EAC/B;;;;;;;;EAeA,SAAS,MAA6B;AACrC,SAAK,SAAS;AACd,YAAQ,KAAK,cAAc;MAC1B,KAAK;AACJ,aAAK,OAAO,KAAK,UAAS;AAC1B;MACD,KAAK;AACJ,aAAK,OAAO,KAAK,QAAO;AACxB;MACD,KAAK;AACJ,aAAK,OAAO,KAAK,YAAW;AAC5B;MACD,KAAK;AACJ,aAAK,OAAO,KAAK,OAAM;AACvB;;AAEF,WAAO;EACR;;;;EAoBA,cAAW;AACV,WAAO,IAAI,KAAK,UAAS;EAC1B;;;;EAKA,YAAS;AACR,WAAO,KAAK,UAAS,IAAK,KAAK,QAAQ;EACxC;;;;EAKA,iBAAc;AACb,WAAO,KAAK,UAAS,IAAK;EAC3B;;;;ACpTK,IAAO,YAAP,MAAO,mBACJ,cAAyB;EADlC,cAAA;;AAGU,SAAA,OAAe;EAsHzB;EApHW,kBAAe;AACxB,WAAO,OAAO,OAAO,MAAM,gBAAe,GAAI;MAC7C,KAAK;QACJ,QAAQ,CAAC,YAAyB;AACjC,iBAAO,KAAK,KAAI,IAAK,IAAK,KAAK,YAAiC,KAAK,SAAS,OAAO,EAAE,QAAO;QAC/F;QACA,QAAQ;;MAET,UAAU;QACT,QAAQ,CAAC,YAAyB;AACjC,gBAAM,UAAU,IAAI,WAAU,KAAK,SAAS,OAAO,EAAE,QAAO;AAC5D,iBAAO,KAAK,gBAAgB,KAAK,QAAQ,UAAU,gBAAgB,OAAO,CAAC;QAC5E;QACA,QAAQ;;KAET;EACF;;;;;;;;;;;EAYA,SAAS,QAAc,UAAU,GAAC;AACjC,UAAM,cAAc,IAAK,KAAK,YAAiC,KAAK,SAAS,MAAM,EAAE,QAAO;AAC5F,UAAM,QAAQ,KAAK,QAAO;AAC1B,UAAM,WAAW,KAAK,MAAM,QAAQ,WAAW;AAC/C,UAAM,QAAQ,WAAW;AACzB,UAAM,OAAO,QAAQ;AACrB,WAAO,QAAQ,OAAO;EACvB;;;;;;;;;;;;EAaA,aAAU;AACT,UAAM,OAAO,KAAK,UAAS;AAC3B,UAAM,gBAA+B,CAAC,IAAI;AAC1C,aAAS,QAAQ,GAAG,QAAQ,GAAG,SAAS;AACvC,YAAM,SAAS,KAAK,IAAI,GAAG,KAAK;AAChC,oBAAc,KAAK,SAAS,IAAmB;AAC/C,oBAAc,KAAK,SAAS,GAAkB;AAC9C,oBAAc,KAAK,SAAS,GAAkB;;AAE/C,kBAAc,KAAK,GAAG;AAEtB,QAAI,UAAU,cAAc,CAAC;AAC7B,QAAI,iBAAiB,IAAI,WAAU,KAAK,SAAS,cAAc,CAAC,CAAC,EAAE,UAAS;AAC5E,kBAAc,QAAQ,cAAW;AAChC,YAAM,kBAAkB,IAAI,WAAU,KAAK,SAAS,QAAQ,EAAE,UAAS;AACvE,UAAI,KAAK,IAAI,kBAAkB,IAAI,IAAI,KAAK,IAAI,iBAAiB,IAAI,GAAG;AACvE,kBAAU;AACV,yBAAiB;;IAEnB,CAAC;AACD,WAAO;EACR;;;;EAKA,wBAAqB;AACpB,UAAM,cAAc,KAAK,cAAc,CAAC;AACxC,QAAI,WAAW,KAAK,QAAO,IAAK;AAChC,eAAW,WAAW,SAAS,QAAQ,CAAC,CAAC;AACzC,UAAM,WAAW,KAAK,MAAM,WAAW,KAAK,kBAAiB,CAAE;AAC/D,QAAI,aAAc,WAAW,IAAK;AAClC,eAAW,KAAK,MAAM,QAAQ,IAAI,KAAK,kBAAiB;AACxD,UAAM,kBAAkB,WAAW,SAAQ;AAC3C,QAAI,gBAAgB,SAAS,GAAG;AAE/B,mBAAa,WAAW,WAAW,eAAe,EAAE,QAAQ,CAAC,CAAC;;AAE/D,UAAM,WAAW,CAAC,UAAU,UAAU,UAAU;AAChD,WAAO,SAAS,KAAK,GAAG;EACzB;;;;EAKA,UAAO;AACN,UAAM,cAAc,KAAK,cAAc,CAAC;AACxC,UAAM,WAAW,KAAK,QAAO,IAAK;AAClC,WAAO,KAAK,MAAM,WAAW,KAAK,QAAO,CAAE;EAC5C;;;;EAKA,YAAS;AACR,WAAO,KAAK,QAAO;EACpB;;;;EAKA,SAAM;AACL,WAAO,KAAK,KAAK,YAAW,CAAE;EAC/B;EAEU,OAAI;AACb,WAAO,KAAK,QAAQ,IAAG;EACxB;;AAmBK,SAAU,KAAK,OAAmB,OAAoB;AAC3D,SAAO,IAAI,UAAU,WAAU,GAAI,OAAO,KAAK;AAChD;;;ACzIM,IAAO,iBAAP,MAAO,wBAAoD,UAA8B;EAA/F,cAAA;;AAEU,SAAA,OAAe;AAEf,SAAA,eAA8B;EA4LxC;;;;;EAtLC,WAAW,KAAE;AACZ,WAAO,MAAK;EACb;EACA,WAAW,GAAG,MAAW;AACxB,UAAM,IAAI;EACX;;;;EAMU,kBAAe;AACxB,WAAO,OAAO,OAAO,CAAA,GAAI,MAAM,gBAAe,GAAI;MACjD,MAAM;QACL,QAAQ;QACR,OAAO,OAAK;AACX,cAAI,KAAK,iBAAiB,QAAQ;AACjC,mBAAO;iBACD;AACN,mBAAO,gBAAe,KAAK,KAAK;;QAElC;;MAED,MAAM;QACL,QAAQ;QACR,OAAO,OAAO,QAAM;AACnB,gBAAM,QAAQ,iBAAiB,MAAM,YAAW,CAAE;AAClD,gBAAM,aAAa,SAAS,SAAS,QAAQ,EAAE,IAAI,KAAK;AACxD,cAAI,KAAK,iBAAiB,QAAQ;AACjC,mBAAO;iBACD;AACN,mBAAO,gBAAe,KAAK,UAAU;;QAEvC;;MAED,IAAI;QACH,QAAQ;QACR,OAAO,GAAG,GAAG,GAAC;AACb,cAAI,QAAQ;AACZ,cAAI,KAAK,MAAM,KAAK;AACnB,qBAAS,KAAK,cAAc,KAAK,kBAAiB,IAAK,WAAW,CAAC,CAAC;;AAErE,cAAI,KAAK,MAAM,KAAK;AACnB,qBAAS,KAAK,cAAc,WAAW,CAAC,CAAC;;AAE1C,cAAI,KAAK,MAAM,KAAK;AACnB,qBAAS,KAAK,cAAc,WAAW,CAAC,IAAI,CAAC;;AAE9C,iBAAO;QACR;;KAED;EACF;;;;;;;;;;EAYA,UAAU,UAAkB;AAC3B,WAAO,IAAI,gBAAe,KAAK,SAAS,KAAK,QAAO,IAAK,yBAAyB,QAAQ,CAAC;EAC5F;;;;;;;;EASA,UAAU,WAAqB;AAC9B,WAAO,UAAU,IAAI,cAAW;AAC/B,aAAO,KAAK,UAAU,QAAQ;IAC/B,CAAC;EACF;;;;;;;;;EAWA,SAAM;AACL,WAAO,KAAK,KAAK,QAAO,CAAE;EAC3B;;;;;;EAOA,SAAM;AACL,UAAM,OAAO,KAAK,YAAW;AAC7B,UAAMC,OAAM,KAAK,KAAK,OAAO,gBAAe,EAAE;AAC9C,QAAI,aAAa,KAAK,MAAM,KAAKA,IAAG,IAAI;AACxC,UAAM,SAAS,KAAK,MAAM,aAAa,EAAE;AACzC,QAAI,SAAS,GAAG;AACf,oBAAc,MAAM;;AAErB,UAAM,WAAW,iBAAiB,aAAa,EAAE;AACjD,WAAO,WAAW,OAAO,SAAQ;EAClC;;;;EAKA,YAAS;AACR,WAAO,IAAI,MAAM,UAAS;EAC3B;;;;EAKA,UAAO;AACN,UAAM,cAAc,KAAK,cAAc,CAAC;AACxC,UAAM,WAAW,KAAK,QAAO,IAAK;AAClC,WAAO,KAAK,MAAM,WAAW,KAAK,QAAO,CAAE;EAC5C;;;;;;;EASU,SAAM;AACf,WAAO;EACR;;;;EAKU,kBAAkB,MAAW;AACtC,WAAO;EACR;;;;EAKU,cAAc,OAAY;AACnC,WAAO,KAAM,QAAQ,MAAO,KAAK,QAAO,IAAK,KAAK,QAAO;EAC1D;;;;EAKU,cAAc,OAAa;AACpC,WAAO,IAAI,MAAM,cAAc,KAAK;EACrC;;;;EAKU,gBAAgB,SAAgB;AACzC,WAAO,IAAI;EACZ;;;;;;EAOA,OAAO,KAAK,MAAc;AACzB,WAAO,KAAK,IAAI;EACjB;;;;;EAMA,OAAO,KAAK,WAAgB;AAC3B,WAAO,KAAK,SAAS;EACtB;;AAWD,IAAM,mBAAmB;EACxB,KAAK;EAAI,IAAI;EAAI,GAAG;EAAG,MAAM;EAAG,IAAI;EACpC,KAAK;EAAG,IAAI;EAAG,GAAG;EAAG,MAAM;EAAG,IAAI;EAClC,KAAK;EAAG,IAAI;EAAG,GAAG;EAAG,MAAM;EAAG,IAAI;EAClC,KAAK;EAAG,IAAI;EAAG,GAAG;EAAG,MAAM;EAAG,IAAI;EAClC,KAAK;EAAG,IAAI;EAAG,GAAG;EAAG,MAAM;EAAG,IAAI;EAClC,KAAK;EAAG,IAAI;EAAG,GAAG;EAAG,MAAM;EAAI,IAAI;EACnC,KAAK;EAAG,IAAI;EAAI,GAAG;EAAI,MAAM;EAAI,IAAI;;AAOtC,IAAM,mBAAmB,CAAC,KAAK,MAAM,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM,GAAG;AAYnF,SAAU,UAAU,OAA+B,OAAqB;AAC7E,SAAO,IAAI,eAAe,WAAU,GAAI,OAAO,KAAK;AACrD;;;AC5OM,IAAO,qBAAP,cAA0E,UAAe;EAA/F,cAAA;;AAEU,SAAA,OAAe;EAQzB;;;;EAHW,OAAI;AACb,WAAO,KAAK,QAAQ,UAAU;EAC/B;;AAUK,SAAU,cAAc,OAAmB,OAAoB;AACpE,SAAO,IAAI,mBAAmB,WAAU,GAAI,OAAO,KAAK;AACzD;;;ACZM,IAAgB,kBAAhB,MAAgB,yBAAgE,KAAI;EAmBzF,cAAA;AACC,UAAK;AACL,UAAM,UAAU,qBAAqB,iBAAgB,YAAW,GAAI,WAAW,CAAC,SAAS,CAAC;AAC1F,QAAI,KAAK,gBAAgB;AACxB,WAAK,UAAU,KAAK;WACd;AACN,WAAK,UAAU,QAAQ;;EAEzB;EAEA,OAAO,cAAW;AACjB,WAAO;MACN,SAAS,WAAU;;EAErB;;;;;;;;EASA,MAAG;AACF,WAAO,KAAK,QAAQ,cAAc,KAAK,QAAQ;EAChD;;;;;;;;EASA,YAAS;AACR,WAAO,KAAK,QAAQ;EACrB;;;;;;EAOA,IAAI,aAAU;AACb,WAAO,IAAI,KAAK,QAAQ;EACzB;;;;;;EAOA,IAAI,YAAS;AACZ,WAAO,MAAM,KAAK,QAAQ;EAC3B;;;;;;;;;;EAWA,UAAU,MAAW;AACpB,WAAO,IAAI,UAAU,KAAK,SAAS,IAAI,EAAE,UAAS;EACnD;;;;;;;EAQA,YAAY,MAAe;AAC1B,WAAO,IAAI,eAAe,KAAK,SAAS,IAAI,EAAE,YAAW;EAC1D;;;;;;;EAQA,QAAQ,MAAuB;AAC9B,WAAO,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,QAAO;EAC1D;;;;;;;EASU,sBAAsB,OAAc;AAC7C,UAAM,UAAU,KAAK,IAAG;AAExB,WAAO,KAAK,OAAO,EAAE,QAAQ,UAAO;AACnC,UAAI,QAAQ,MAAM,IAAI,CAAC,GAAG;AACzB,eAAO,QAAQ,IAAI;;IAErB,CAAC;AACD,WAAO;EACR;;;;;;;EAQA,MAAG;AACF,UAAM,WAAW,wBAAwB,IAAI;AAC7C,WAAO,KAAK,QAAQ,EAAE,QAAQ,eAAY;AACzC,UAAI,QAAQ,IAAI,MAAM,SAAS,GAAG;AACjC,cAAM,SAAS,KAAK,SAAS;AAC7B,YAAI,UAAU,MAAM,KAAK,UAAU,OAAO,KAAK,KAAK,UAAU,OAAO,cAAc,GAAG;AACrF,mBAAS,SAAS,IAAI,OAAO;mBACnB,kBAAkB,kBAAiB;AAC7C,mBAAS,SAAS,IAAI,OAAO,sBAAsB,SAAS,SAAS,CAAC;mBAE5D,QAAQ,MAAM,KAAK,SAAS,MAAM,KAAK,SAAS,MAAM,KAAK,UAAU,MAAM,GAAG;AACxF,mBAAS,SAAS,IAAI;eAChB;AAEN,iBAAO,SAAS,SAAS;;;IAG5B,CAAC;AAED,WAAO;EACR;;;;;;;;;;;;;EAcA,IAAI,OAAgC;AACnC,WAAO,KAAK,KAAK,EAAE,QAAQ,eAAY;AACtC,UAAI,QAAQ,IAAI,MAAM,SAAS,KAAK,UAAU,KAAK,SAAS,CAAC,GAAG;AAC/D,YAAI,KAAK,SAAS,KAAK,UAAU,KAAK,SAAS,EAAE,KAAK,KAAK,UAAU,KAAK,SAAS,EAAE,cAAc,GAAG;AAErG,cAAI,KAAK,SAAS,EAAE,UAAU,MAAM,SAAS,GAAG;AAC/C,iBAAK,SAAS,EAAE,QAAQ,MAAM,SAAS;;mBAE9B,KAAK,SAAS,aAAa,kBAAiB;AACtD,eAAK,SAAS,EAAE,IAAI,MAAM,SAAS,CAAC;eAC9B;AACN,eAAK,SAAS,IAAI,MAAM,SAAS;;;IAGpC,CAAC;AACD,WAAO;EACR;;;;AC5LK,IAAO,gBAAP,cAAgE,SAAgD;EASrH,YAAY,UAAyB,WAAS;AAC7C,UAAK;AARG,SAAA,OAAe;AASvB,SAAK,WAAW;AAChB,SAAK,eAAe,KAAK,UAAU,CAAC;EACrC;;;;;;;EAQA,eAAe,MAAa;AAC3B,UAAM,QAAQ,KAAK,IAAI,IAAI;AAC3B,QAAI,UAAU,MAAM;AACnB,aAAO,MAAM;WACP;AACN,aAAO,KAAK;;EAEd;;;;;;;EAQA,eAAe,OAAsB,MAAe,SAA2B;AAC9E,gBAAY,MAAM,CAAC;AACnB,SAAK,IAAI,OAAO,OAAO,CAAA,GAAI,SAAS;MACnC;MACA;KACA,CAAC;AACF,WAAO;EACR;;;;;;;EAQA,aAAa,OAAsB,MAAY;AAE9C,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,aAAS,IAAI,OAAO,KAAK,GAAG,KAAK;AAChC,YAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,UAAI,MAAM,UAAU,OAAO;AAC1B,eAAO;;;EAGV;;;;;;;EAQA,aAAa,OAAsB,MAAY;AAE9C,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI,UAAU,IAAI;AACjB,eAAS,IAAI,OAAO,IAAI,KAAK,UAAU,QAAQ,KAAK;AACnD,cAAM,QAAQ,KAAK,UAAU,CAAC;AAC9B,YAAI,MAAM,UAAU,OAAO;AAC1B,iBAAO;;;;EAIX;;;;AC5CK,IAAO,QAAP,MAAO,eACJ,gBAAuC;EAkD/C,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,SAAS,SAAS,SAAS,CAAC,CAAC;AAhDjF,SAAA,OAAe;AAMxB,SAAA,aAAa;AAoBL,SAAA,aAAa;AAwBpB,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,SAAS,SAAS,SAAS,CAAC;AAElG,WAAO,UAAU,QAAQ,KAAK,MAC5B,aAAa,QAAQ,KAAK,KAAK,QAAQ,iBAAiB,SAAQ,6BAA6B;AAE/F,WAAO,CAAC,aAAa,QAAQ,KAAK,GAAG;AACpC,cAAQ,QAAQ,QAAQ,MAAM;;AAG/B,SAAK,aAAa,UAAU,QAAQ,SAAS,IAAI,QAAQ,YAAY;AACrE,QAAI,KAAK,YAAY;AACpB,WAAK,QAAQ,KAAK,QAAQ,WAAU;AAEpC,WAAK,SAAS,QAAQ;AACtB,WAAK,MAAM,QAAQ,KAAK,MAAM;WACxB;AACN,WAAK,SAAS,KAAK,QAAQ,QAAQ;;AAEpC,SAAK,UAAU,IAAI,SAA0B,GAAI;AACjD,SAAK,gBAAgB,KAAK,OAAO;AACjC,SAAK,QAAQ,QAAQ;AACrB,SAAK,UAAU,QAAQ;AACvB,SAAK,YAAY,QAAQ;AACzB,SAAK,YAAY,QAAQ;AAGzB,QAAI,UAAU,QAAQ,KAAK,KAAK,QAAQ,UAAU,KAAK,QAAQ,KAAK,aAAa,GAAG;AACnF,WAAK,eAAe,QAAQ,OAAO,CAAC;;EAEtC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,gBAAgB,YAAW,GAAI;MACnD,SAAS;MACT,OAAO;KACc;EACvB;EAEA,IAAI,QAAK;AACR,UAAMC,OAAM,KAAK,IAAG;AACpB,WAAO,KAAK,eAAeA,IAAG;EAC/B;EACA,IAAI,MAAM,OAAK;AACd,SAAK,sBAAsB,KAAK,IAAG,CAAE;AACrC,SAAK,eAAe,OAAO,KAAK,IAAG,CAAE;EACtC;EAEA,IAAI,WAAQ;AAEX,QAAI,UAAU,KAAK,SAAS,GAAG;AAC9B,aAAO,KAAK;eACF,KAAK,UAAU,UAAU,KAAK,UAAU,eAClD,KAAK,UAAU,iBAAiB,KAAK,UAAU,cAC/C,KAAK,UAAU,mBAAmB,KAAK,UAAU,WACjD,KAAK,UAAU,SAAS,KAAK,UAAU,WAAW,KAAK,UAAU,WAAW;AAC5E,aAAO;eACG,KAAK,UAAU,cAAc;AACvC,aAAO;eACG,KAAK,UAAU,YAAY;AACrC,aAAO;WACD;AACN,aAAO,KAAK,OAAO;;EAErB;EAEA,IAAI,WAAQ;AACX,QAAI,UAAU,KAAK,SAAS,GAAG;AAC9B,aAAO,KAAK;eACF,KAAK,UAAU,iBACzB,KAAK,UAAU,cAAc;AAC7B,aAAO;WACD;AACN,aAAO,KAAK,OAAO;;EAErB;;;;EAKQ,IAAO,KAAU,MAAc;AACtC,WAAO,KAAK,UAAU;EACvB;;;;EAKQ,aAAa,OAAa;AACjC,QAAI,UAAU,KAAK,QAAQ,KAAK,UAAU,KAAK,QAAQ,GAAG;AACzD,kBAAY,OAAO,KAAK,UAAU,KAAK,QAAQ,GAAG,KAAK,UAAU,KAAK,QAAQ,CAAC;;AAEhF,WAAO;EACR;;;;;EAMU,UAAU,KAAsB;AACzC,QAAI,KAAK,WAAW,CAAC,KAAK,YAAY;AACrC,UAAI,KAAK,IAAU,KAAK,MAAM,GAAG;AAChC,eAAO,KAAK,UAAU,GAAG;iBACf,KAAK,IAAc,KAAK,UAAU,GAAG;AAC/C,eAAO,SAAS,GAAG;iBACT,KAAK,IAAe,KAAK,WAAW,GAAG;AACjD,eAAO,KAAK,YAAY,GAAG;aACrB;AACN,eAAO;;eAEE,KAAK,YAAY;AAE3B,aAAO;WACD;AACN,aAAO;;EAET;;;;EAKU,QAAQ,KAAW;AAC5B,QAAI,KAAK,WAAW,KAAK,UAAU,YAAY;AAC9C,aAAO,SAAS,GAAG;WACb;AACN,aAAO;;EAET;;;;;EAOA,eAAe,OAA0B,MAAU;AAClD,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,eAAe,KAAK,UAAU,KAAK;AACzC,WAAO,SAAS,YAAY,KAAK,SAAS,YAAY,GACrD,0CAA0C,KAAK,UAAU,KAAK,CAAC,KAAK,KAAK,UAAU,IAAI,CAAC,EAAE;AAC3F,SAAK,aAAa,YAAY;AAC9B,SAAK,IAAI,KAAK,OAAO,kBAAkB,OAAO,YAAY;AAC1D,SAAK,QAAQ,IAAI;MAChB,MAAM;MACN,MAAM;MACN,OAAO;KACP;AACD,SAAK,OAAO,eAAe,cAAc,YAAY;AACrD,WAAO;EACR;EAEA,eAAe,MAAU;AACxB,UAAM,eAAe,KAAK,IAAI,KAAK,UAAU,IAAI,GAAG,CAAC;AACrD,UAAM,QAAQ,KAAK,QAAQ,SAAS,YAAY;AAChD,UAAM,SAAS,KAAK,QAAQ,IAAI,YAAY;AAC5C,QAAI,QAAQ,KAAK;AAEjB,QAAI,WAAW,MAAM;AACpB,cAAQ,KAAK;eACH,OAAO,SAAS,sBAAsB,UAAU,QAAQ,MAAM,SAAS,mBAAmB;AACpG,YAAM,WAAW,KAAK,QAAQ,UAAU,OAAO,IAAI;AACnD,UAAI;AACJ,UAAI,aAAa,MAAM;AACtB,sBAAc,KAAK;aACb;AACN,sBAAc,SAAS;;AAExB,UAAI,OAAO,SAAS,mBAAmB;AACtC,gBAAQ,KAAK,qBAAqB,OAAO,MAAM,aAAa,OAAO,OAAO,OAAO,UAAU,YAAY;;eAE9F,UAAU,MAAM;AAC1B,cAAQ,OAAO;eACL,MAAM,SAAS,6BAA6B,MAAM,SAAS,gCAAgC;AACrG,UAAI,cAAc,OAAO;AACzB,UAAI,OAAO,SAAS,mBAAmB;AACtC,cAAM,WAAW,KAAK,QAAQ,UAAU,OAAO,IAAI;AACnD,YAAI,aAAa,MAAM;AACtB,wBAAc,KAAK;eACb;AACN,wBAAc,SAAS;;;AAGzB,UAAI,MAAM,SAAS,2BAA2B;AAC7C,gBAAQ,KAAK,mBAAmB,OAAO,MAAM,aAAa,MAAM,MAAM,MAAM,OAAO,YAAY;aACzF;AACN,gBAAQ,KAAK,wBAAwB,OAAO,MAAM,aAAa,MAAM,MAAM,MAAM,OAAO,YAAY;;WAE/F;AACN,cAAQ,OAAO;;AAEhB,WAAO,KAAK,QAAQ,KAAK;EAC1B;EAEA,aAAa,MAAU;AACtB,WAAO,KAAK,UAAU,IAAI;AAC1B,QAAI,aAAa,KAAK,eAAe,IAAI;AACzC,SAAK,oBAAoB,IAAI;AAC7B,QAAI,KAAK,UAAU,UAAU,MAAM,GAAG;AACrC,mBAAa,KAAK,QAAQ,KAAK,UAAU;;AAE1C,SAAK,eAAe,YAAY,IAAI;AACpC,WAAO;EACR;EAEA,wBAAwB,OAA0B,SAAa;AAC9D,UAAM,eAAe,KAAK,UAAU,KAAK;AACzC,UAAM,eAAe,KAAK,UAAU,OAAO;AAC3C,WAAO,SAAS,YAAY,KAAK,SAAS,YAAY,GACrD,mDAAmD,KAAK,UAAU,KAAK,CAAC,KAAK,KAAK,UAAU,OAAO,CAAC,EAAE;AACvG,SAAK,aAAa,YAAY;AAC9B,SAAK,QAAQ,IAAI;MAChB,MAAM;MACN,MAAM;MACN,OAAO;KACP;AACD,SAAK,IAAI,KAAK,OAAO,2BAA2B,OAAO,YAAY;AACnE,SAAK,OAAO,wBAAwB,cAAc,YAAY;AAC9D,WAAO;EACR;EAEA,6BAA6B,OAA0B,SAAa;AACnE,QAAI,eAAe,KAAK,UAAU,KAAK;AAEvC,mBAAe,GAAG,cAAc,CAAC,IAAI,KAAK,aAAa;AACvD,SAAK,aAAa,YAAY;AAC9B,UAAM,eAAe,KAAK,UAAU,OAAO;AAC3C,WAAO,SAAS,YAAY,KAAK,SAAS,YAAY,GACrD,wDAAwD,KAAK,UAAU,KAAK,CAAC,KAAK,KAAK,UAAU,OAAO,CAAC,EAAE;AAE5G,SAAK,QAAQ,IAAI;MAChB,MAAM;MACN,MAAM;MACN,OAAO;KACP;AACD,SAAK,IAAI,KAAK,OAAO,gCAAgC,OAAO,YAAY;AACxE,SAAK,OAAO,6BAA6B,cAAc,YAAY;AACnE,WAAO;EACR;EAEA,kBAAkB,OAA0B,UAAgB,WAAgB;AAC3E,gBAAY,KAAK,UAAU,SAAS;AACpC,SAAK,aAAa,SAAS;AAC3B,SAAK,6BAA6B,OAAO,YAAY,KAAK,UAAU,QAAQ,CAAC;AAC7E,WAAO;EACR;EAEA,aAAa,OAA0B,UAAgB,WAAgB;AACtE,gBAAY,KAAK,UAAU,SAAS;AACpC,SAAK,aAAa,SAAS;AAC3B,SAAK,wBAAwB,OAAO,YAAY,KAAK,UAAU,QAAQ,CAAC;AACxE,WAAO;EACR;EAEA,aAAa,OAA0B,UAAgB,WAAgB;AACtE,gBAAY,KAAK,UAAU,SAAS;AACpC,SAAK,aAAa,SAAS;AAC3B,SAAK,+BAA+B,OAAO,WAAW,QAAQ;AAC9D,WAAO;EACR;EAEA,+BAA+B,OAA0B,MAAY,UAAc;AAClF,WAAO,KAAK,UAAU,IAAI;AAC1B,eAAW,KAAK,UAAU,QAAQ;AAClC,UAAM,eAAe,KAAK,IAAI,WAAW,CAAC,IAAI,KAAK,IAAI,GAAG;AAC1D,SAAK,gBAAgB,OAAO,MAAM,YAAY;AAE9C,SAAK,oBAAoB,OAAO,WAAW,GAAG;AAC9C,SAAK,wBAAwB,OAAO,OAAO,QAAQ;AACnD,WAAO;EACR;EAEA,gBAAgB,OAA0B,WAAiB,cAAsB;AAChF,UAAM,eAAe,KAAK,UAAU,KAAK;AAEzC,WAAO,SAAS,YAAY,KAAK,eAAe,GAAG,8CAA8C;AACjG,UAAM,eAAe,KAAK,UAAU,SAAS;AAC7C,SAAK,aAAa,YAAY;AAC9B,WAAO,SAAS,YAAY,KAAK,SAAS,YAAY,GACrD,2CAA2C,KAAK,UAAU,KAAK,CAAC,KAAK,KAAK,UAAU,SAAS,CAAC,EAAE;AACjG,SAAK,QAAQ,IAAI;MAChB,UAAU;MACV,MAAM;MACN,MAAM;MACN,OAAO;KACP;AACD,SAAK,IAAI,KAAK,OAAO,mBAAmB,OAAO,cAAc,YAAY;AACzE,SAAK,OAAO,gBAAgB,cAAc,cAAc,YAAY;AACpE,WAAO;EACR;EAEA,oBAAoB,QAA6B,WAAiB,UAAgB,UAAU,GAAC;AAC5F,eAAW,KAAK,UAAU,QAAQ;AAClC,gBAAY,KAAK,UAAU,SAAS;AACpC,UAAM,gBAAgB,KAAK,UAAU,OAAO,CAAC,CAAC,IAAI;AAClD,SAAK,eAAe,KAAK,QAAQ,aAAa,GAAG,SAAS;AAC1D,UAAM,UAAU,YAAY,OAAO,SAAS;AAC5C,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,YAAM,eAAe,KAAK,UAAU,OAAO,CAAC,CAAC,IAAI;AACjD,WAAK,wBAAwB,KAAK,QAAQ,YAAY,GAAG,YAAY,IAAI,OAAO;;AAEjF,WAAO;EACR;EAEA,sBAAsB,MAAU;AAC/B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,WAAO,SAAS,YAAY,GAAG,8CAA8C,KAAK,UAAU,IAAI,CAAC,EAAE;AACnG,SAAK,QAAQ,OAAO,YAAY;AAChC,SAAK,OAAO,sBAAsB,YAAY;AAC9C,SAAK,IAAI,KAAK,OAAO,yBAAyB,YAAY;AAC1D,WAAO;EACR;EAEA,oBAAoB,MAAU;AAC7B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,cAAc,KAAK,UAAU,KAAK,eAAe,YAAY,CAAC;AAEpE,WAAO,SAAS,YAAY,GAAG,4CAA4C,KAAK,UAAU,IAAI,CAAC,EAAE;AAEjG,SAAK,IAAI,KAAK,OAAO,uBAAuB,cAAc,WAAW,WAAW;AAIhF,UAAM,SAAS,KAAK,QAAQ,IAAI,YAAY;AAC5C,UAAM,QAAQ,KAAK,QAAQ,SAAS,YAAY;AAChD,QAAI,UAAU,GAAG,OAAO,MAAM,YAAY,GAAG;AAE5C,UAAI,OAAO;AACV,aAAK,OAAO,sBAAsB,MAAM,IAAI;AAC5C,aAAK,QAAQ,OAAO,MAAM,IAAI;aACxB;AACN,aAAK,OAAO,oBAAoB,YAAY;AAC5C,aAAK,QAAQ,OAAO,eAAe,KAAK,UAAU;;eAEzC,OAAO;AACjB,WAAK,OAAO,sBAAsB,MAAM,IAAI;AAE5C,WAAK,QAAQ,OAAO,MAAM,IAAI;AAC9B,UAAI,MAAM,SAAS,2BAA2B;AAC7C,aAAK,wBAAwB,KAAK,QAAQ,WAAW,GAAG,YAAY;iBAC1D,MAAM,SAAS,gCAAgC;AACzD,aAAK,6BAA6B,KAAK,QAAQ,WAAW,GAAG,YAAY;;;AAK3E,SAAK,QAAQ,IAAI;MAChB,MAAM;MACN,MAAM;MACN,OAAO;KACP;AACD,SAAK,OAAO,eAAe,aAAa,YAAY;AACpD,WAAO;EACR;EAEA,OAAO,OAA0B,WAAiB,KAAK,WAAgB;AACtE,QAAI,KAAK,UAAU,eAAe,KAAK,UAAU,SAAS,KAAK,UAAU,YAAY;AACpF,WAAK,kBAAkB,OAAO,UAAU,SAAS;WAC3C;AACN,WAAK,aAAa,OAAO,UAAU,SAAS;;AAE7C,WAAO;EACR;;;;;;EAOA,MAAM,OAAyB;AAC9B,UAAMA,OAAM,KAAK,QAAQ;AAEzB,UAAM,eAAe,KAAK,eAAeA,IAAG,GAAaA,IAAG;AAE5D,UAAM,gBAAgB,KAAK,QAAQ,IAAIA,IAAG;AAC1C,QAAI,iBAAiB,cAAc,SAAS,mBAAmB;AAE9D,YAAM,YAAY,KAAK,QAAQ,SAAS,cAAc,IAAI;AAE1D,YAAM,UAAU,YAAY,UAAU,OAAOA,OAAM;AACnD,YAAM,gBAAgB,UAAUA,QAAO;AACvC,eAAS,IAAIA,MAAK,IAAI,SAAS,KAAK,cAAc;AACjD,cAAM,wBAAwB,KAAK,eAAe,CAAC,GAAa,CAAC;;;AAGnE,SAAK,QAAQ,aAAa,KAAK,QAAQ,aAAa,WAAQ;AAC3D,UAAI,MAAM,SAAS,yBAAyB;AAC3C,cAAM,sBAAsB,MAAM,IAAI;iBAC5B,MAAM,SAAS,mBAAmB;AAC5C,cAAM,gBAAgB,MAAM,OAAO,MAAM,MAAM,MAAM,QAAQ;aACvD;AACN,cAAM,MAAM,IAAI,EAAE,MAAM,OAAO,MAAM,IAAI;;IAE3C,CAAC;AACD,WAAO;EACR;;;;;EAMA,SAAS,OAAiB;AACzB,WAAO,KAAK,YAAY,8DAA8D;AACtF,UAAM,QAAQ,KAAK;AACnB,UAAM,WAAW,KAAK,MAAM;AAC5B,SAAK,MAAM,KAAK;AAChB,SAAK,SAAS;AACd,UAAM,QAAQ,KAAK,MAAM;AACzB,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;EAEA,IAAI,eAAY;AACf,WAAO,KAAK,QAAQ,KAAK,OAAO,YAAY;EAC7C;;;;;;EAQU,qBAAqB,IAAY,IAAY,IAAY,cAAsB,GAAS;AACjG,WAAO,MAAM,KAAK,MAAM,KAAK,IAAI,EAAE,IAAI,MAAM,YAAY;EAC1D;;EAGU,mBAAmB,IAAY,IAAY,IAAY,IAAY,GAAS;AACrF,WAAO,MAAM,KAAK,QAAQ,IAAI,OAAO,KAAK;EAC3C;;EAGU,wBAAwB,IAAY,IAAY,IAAY,IAAY,GAAS;AAC1F,WAAO,KAAK,KAAK,IAAI,KAAK,KAAK,IAAI,OAAO,KAAK,GAAG;EACnD;;;;ACpgBK,IAAgB,gBAAhB,MAAgB,uBACb,gBAAwB;EADjC,cAAA;;AAMmB,SAAA,OAAe;AAkDvB,SAAA,oBAAkC,CAAA;EA0M7C;;;;;;;;EAvOC,IAAI,iBAAc;AACjB,QAAI,UAAU,KAAK,KAAK,GAAG;AAC1B,UAAI,aAAa,KAAK,KAAK,KAAK,KAAK,iBAAiB,OAAO;AAC5D,eAAO;aACD;AACN,eAAO,KAAK,MAAM;;WAEb;AACN,aAAO;;EAET;;;;;;;EAQA,IAAI,kBAAe;AAClB,QAAI,UAAU,KAAK,MAAM,GAAG;AAC3B,aAAO,KAAK,OAAO;WACb;AACN,aAAO;;EAET;;;;;;;EAcQ,aAAa,MAAS;AAC7B,WAAO,UAAU,IAAI,MAAM,gBAAgB,kBAAiBC,aAAY,IAAI;EAC7E;;;;;EAMQ,oBAAiB;AACxB,UAAM,WAAW,KAAK,kBAAkB,MAAM,CAAC;AAC/C,QAAI,KAAK,aAAa,KAAK,KAAK,GAAG;AAClC,eAAS,KAAK,KAAK,KAAK;;AAEzB,QAAI,KAAK,aAAa,KAAK,MAAM,GAAG;AACnC,UAAI,KAAK,UAAU,KAAK,QAAQ;AAC/B,iBAAS,KAAK,KAAK,MAAM;;;AAG3B,WAAO;EACR;;;;;;EAOQ,sBAAsB,SAA0B;AACvD,UAAM,WAAW,KAAK,kBAAiB;AACvC,aAAS,QAAQ,UAAO;AACvB,WAAK,eAAe,QAAQ;AAC5B,WAAK,mBAAmB,QAAQ;AAChC,WAAK,wBAAwB,QAAQ;IACtC,CAAC;EACF;;;;;EAMQ,wBAAqB;AAC5B,UAAM,WAAW,KAAK,kBAAiB;AACvC,WAAO,SAAS,SAAS,GAAG,gDAAgD;AAG5E,UAAM,OAAO,SAAS,CAAC;AACvB,WAAO;MACN,cAAc,KAAK;MACnB,kBAAkB,KAAK;MACvB,uBAAuB,KAAK;;EAE9B;;;;;;EAOA,IAAI,eAAY;AACf,WAAO,KAAK,sBAAqB,EAAG;EACrC;EACA,IAAI,aAAa,cAAY;AAC5B,UAAM,QAAQ,KAAK,sBAAqB;AAExC,SAAK,sBAAsB,OAAO,OAAO,OAAO,EAAE,aAAY,CAAE,CAAC;EAClE;;;;;;;;;EAUA,IAAI,mBAAgB;AACnB,WAAO,KAAK,sBAAqB,EAAG;EACrC;EACA,IAAI,iBAAiB,kBAAgB;AACpC,UAAM,QAAQ,KAAK,sBAAqB;AAExC,SAAK,sBAAsB,OAAO,OAAO,OAAO,EAAE,iBAAgB,CAAE,CAAC;EACtE;;;;;;EAOA,IAAI,wBAAqB;AACxB,WAAO,KAAK,sBAAqB,EAAG;EACrC;EACA,IAAI,sBAAsB,uBAAqB;AAC9C,UAAM,QAAQ,KAAK,sBAAqB;AAExC,SAAK,sBAAsB,OAAO,OAAO,OAAO,EAAE,sBAAqB,CAAE,CAAC;EAC3E;;;;;;;;;;EAYA,QAAQ,aAAwB,YAAY,GAAG,WAAW,GAAC;AAC1D,YAAQ,MAAM,aAAa,WAAW,QAAQ;AAC9C,WAAO;EACR;;;;;;;EAQA,gBAAa;AACZ,SAAK,QAAQ,KAAK,QAAQ,WAAW;AACrC,WAAO;EACR;;;;;;EAOA,WAAQ;AACP,SAAK,6CAA6C;AAClD,WAAO,KAAK,cAAa;EAC1B;;;;EAKA,WAAW,aAAyB,YAAY,GAAG,WAAW,GAAC;AAC9D,eAAW,MAAM,aAAa,WAAW,QAAQ;AACjD,WAAO;EACR;;;;;;;;;;;EAYA,SAAS,OAAkB;AAC1B,kBAAc,MAAM,GAAG,KAAK;AAC5B,WAAO;EACR;;;;;;;;;;;EAYA,OAAO,OAAkB;AACxB,UAAM,QAAQ,UAAQ,KAAK,QAAQ,IAAI,CAAC;AACxC,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,QAAI,UAAU,KAAK,KAAK,GAAG;AAC1B,UAAI,KAAK,iBAAiB,gBAAe;AACxC,aAAK,MAAM,QAAO;iBACRA,aAAY,KAAK,KAAK,GAAG;AACnC,aAAK,MAAM,WAAU;;;AAGvB,QAAI,UAAU,KAAK,MAAM,GAAG;AAC3B,UAAI,KAAK,kBAAkB,gBAAe;AACzC,aAAK,OAAO,QAAO;iBACTA,aAAY,KAAK,MAAM,GAAG;AACpC,aAAK,OAAO,WAAU;;;AAGxB,SAAK,oBAAoB,CAAA;AACzB,WAAO;EACR;;AAWK,SAAU,iBAAiB,OAAkB;AAClD,QAAM,QAAQ,MAAM,MAAK;AACzB,QAAM,OAAO,CAAC,MAAM,YAAW;AAC9B,QAAI,gBAAgB,eAAe;AAClC,WAAK,QAAQ,OAAO;eACVA,aAAY,IAAI,GAAG;AAC7B,cAAQ,MAAM,OAAO;;AAEtB,WAAO;EACR,GAAG,KAAK;AACT;AAUM,SAAU,QAAQ,SAAqB,SAAoB,eAAe,GAAG,cAAc,GAAC;AAEjG,SAAO,UAAU,OAAO,GAAG,oCAAoC;AAC/D,SAAO,UAAU,OAAO,GAAG,kCAAkC;AAE7D,MAAI,mBAAmB,iBAAiBA,aAAY,OAAO,GAAG;AAC7D,WAAO,QAAQ,iBAAiB,GAAG,uCAAuC;;AAE3E,SAAO,QAAQ,kBAAkB,GAAG,0CAA0C;AAG9E,SAAQ,mBAAmB,iBAAiB,mBAAmB,OAAQ;AACtE,QAAI,UAAU,QAAQ,KAAK,GAAG;AAC7B,gBAAU,QAAQ;;;AAIpB,SAAO,mBAAmB,eAAe;AACxC,QAAI,UAAU,QAAQ,MAAM,GAAG;AAC9B,gBAAU,QAAQ;;;AAKpB,MAAI,aAAa,OAAO,GAAG;AAC1B,YAAQ,QAAQ,SAAuB,YAAY;SAC7C;AACN,YAAQ,QAAQ,SAAS,cAAc,WAAW;;AAEpD;AASM,SAAU,WACf,SACA,SACA,eAAe,GACf,cAAc,GAAC;AAIf,MAAI,UAAU,OAAO,GAAG;AACvB,WAAO,mBAAmB,eAAe;AACxC,gBAAU,QAAQ;;;AAKpB,SAAO,CAAEA,aAAY,OAAO,GAAI;AAC/B,QAAI,UAAU,QAAQ,MAAM,GAAG;AAC9B,gBAAU,QAAQ;;;AAIpB,MAAI,aAAa,OAAO,GAAG;AAC1B,YAAQ,WAAW,SAAS,YAAY;aAC9BA,aAAY,OAAO,GAAG;AAChC,YAAQ,WAAW,SAAS,cAAc,WAAW;SAC/C;AACN,YAAQ,WAAU;;AAEpB;;;AC9VM,IAAO,OAAP,MAAO,cAA4E,cAAoC;EA6B5H,cAAA;AACC,UAAM,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,QAAQ,OAAO,CAAC,CAAC;AA5BpE,SAAA,OAAe;AAehB,SAAA,YAAsB,KAAK,QAAQ,WAAU;AAG5C,SAAA,QAAkB,KAAK;AACvB,SAAA,SAAmB,KAAK;AAUhC,UAAM,UAAU,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,QAAQ,OAAO,CAAC;AAErF,SAAK,OAAO,IAAI,MAAM;MACrB,SAAS,KAAK;MACd,SAAS,QAAQ;MACjB,OAAO,KAAK,UAAU;MACtB,OAAO,QAAQ;MACf,OAAO,QAAQ;MACf,UAAU,QAAQ;MAClB,UAAU,QAAQ;KAClB;AACD,aAAS,MAAM,MAAM;EACtB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,SAAS;MACT,MAAM;MACN,OAAO;KACP;EACF;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,WAAU;AACzB,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;AChEK,IAAgB,gBAAhB,cAEI,cAAsB;EAuD/B,YAAY,SAA6B;AACxC,UAAM,OAAO;AAnDd,SAAA,UAA2B;AAUjB,SAAA,aAAa;AAKb,SAAA,YAAY;AAKd,SAAA,WAAW;AAKnB,SAAA,SAAe,IAAI,KAAK;MACvB,SAAS,KAAK;MACd,MAAM;KACN;AAKS,SAAA,YAAY,KAAK;AA2J3B,SAAA,iBAAiB,SAAS,MAAU;AACnC,YAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UACC,KAAK,eAAe,MACpB,gBAAgB,KAAK,eACpB,KAAK,cAAc,MAAM,gBAAgB,KAAK,YAC9C;AACD,eAAO;aACD;AACN,eAAO;;IAET;AAlJC,SAAK,UAAU,QAAQ;AACvB,SAAK,WAAW,QAAQ;AACxB,SAAK,SAAS,QAAQ;AACtB,SAAK,UAAU,QAAQ;EACxB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,OAAO;MACP,QAAQ;MACR,SAAS;MACT,SAAS;KACT;EACF;;;;;EAgBU,WAAW,MAAe,OAAmB,GAAC;AACvD,WACC,KAAK,eAAe,IACpB,yCAAyC;AAG1C,UAAM,aAAa,KAAK,UAAU,KAAK,OAAO;AAG9C,SAAK,aAAa,OAAO;AACzB,SAAK,aAAa,KAAK,IAAI,KAAK,YAAY,KAAK,QAAQ,WAAW;AAGpE,QAAI,aAAa,GAAG;AACnB,WAAK,UAAU,KAAK,eAAe,GAAG,IAAI;AAC1C,UAAI,KAAK,WAAW,UAAU;AAC7B,aAAK,UAAU,KAAK,wBACnB,MACA,OAAO,UAAU;aAEZ;AACN,aAAK,UAAU,KAAK,+BACnB,MACA,MACA,UAAU;;WAGN;AACN,WAAK,UAAU,KAAK,eAAe,MAAM,IAAI;;AAE9C,WAAO;EACR;;;;;EAMA,KAAK,MAAW;AACf,SAAK,IAAI,QAAQ,IAAI;AACrB,SAAK,UAAU,KAAK,UAAU,IAAI,CAAC;AACnC,WAAO;EACR;;;;;EAMU,UAAU,MAAa;AAChC,WAAO,KAAK,eAAe,IAAI,sCAAsC;AAErE,SAAK,WAAU;AAGf,UAAM,cAAc,KAAK,UAAU,KAAK,QAAQ;AAGhD,SAAK,YAAY,KAAK,UAAU,IAAI,IAAI;AACxC,SAAK,YAAY,KAAK,IAAI,KAAK,WAAW,KAAK,QAAQ,WAAW;AAClE,QAAI,cAAc,GAAG;AAEpB,UAAI,KAAK,WAAW,UAAU;AAC7B,aAAK,UAAU,KAAK,aAAa,GAAG,aAAa,IAAI;aAC/C;AACN,aAAK,UAAU,KAAK,aAAa,GAAG,aAAa,IAAI;;WAEhD;AAEN,WAAK,UAAU,KAAK,oBAAoB,IAAI;AAC5C,WAAK,UAAU,KAAK,eAAe,GAAG,IAAI;;AAE3C,SAAK,QAAQ,aAAa,KAAK,QAAQ;AACvC,SAAK,WAAW,KAAK,QAAQ,WAAW,MAAK;AAE5C,YAAM,iBACL,KAAK,WAAW,gBAAgB,cAAc,IAAI;AACnD,WAAK,YAAY,KAAK,IAAG,IAAK,cAAc;AAC5C,WAAK,SAAQ;IACd,GAAG,KAAK,YAAY,KAAK,QAAQ,WAAW;AAC5C,WAAO;EACR;;;;EAKU,WAAQ;AACjB,QAAI,KAAK,YAAY,MAAM;AAC1B,WAAK,QAAQ,IAAI;AAEjB,WAAK,UAAU;AAEf,UAAI,CAAC,KAAK,QAAQ,WAAW;AAC5B,cAAM,kBAAkB,MAAM,KAAK,QAAO;AAE1C,YAAI,OAAO,OAAO,wBAAwB,aAAa;AAEtD,iBAAO,oBAAoB,eAAe;eACpC;AACN,qBAAW,iBAAiB,GAAI;;;;EAIpC;;;;EAqBA,IAAI,QAAK;AACR,WAAO,KAAK,eAAe,KAAK,IAAG,CAAE;EACtC;;;;EAKA,aAAU;AACT,SAAK,IAAI,YAAY;AACrB,WAAO,KAAK,eAAe,IAAI,uBAAuB;AAEtD,SAAK,UAAU,KAAK,sBACnB,KAAK,aAAa,KAAK,UAAU;AAElC,SAAK,QAAQ,aAAa,KAAK,QAAQ;AACvC,SAAK,YAAY;AACjB,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,WAAU;AACzB,WAAO;EACR;;;;AC/OK,IAAO,qBAAP,MAAO,4BAAiE,cAAkD;EAmB/H,cAAA;AAEC,UAAM,qBAAqB,oBAAmB,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;AAnB3E,SAAA,OAAe;AAKhB,SAAA,UAAU,KAAK,QAAQ,qBAAoB;AAelD,UAAM,UAAU,qBAAqB,oBAAmB,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC;AAE5F,YAAQ,KAAK,SAAS,KAAK,SAAS;AAEpC,SAAK,SAAS,IAAI,MAAM;MACvB,SAAS,KAAK;MACd,SAAS,QAAQ;MACjB,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;MACf,OAAO,QAAQ;MACf,UAAU,QAAQ;MAClB,UAAU,QAAQ;KAClB;EACF;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,SAAS;MACT,QAAQ;MACR,OAAO;KACP;EACF;;;;;EAMA,MAAM,MAAW;AAChB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,IAAI,SAAS,YAAY;AAC9B,SAAK,WAAW,YAAY;AAC5B,SAAK,QAAQ,MAAM,YAAY;AAC/B,WAAO;EACR;EAEU,YAAY,MAAc;AACnC,SAAK,QAAQ,KAAK,IAAI;EACvB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,QAAI,KAAK,UAAU,WAAW;AAC7B,WAAK,KAAI;;AAEV,SAAK,QAAQ,WAAU;AACvB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACpDK,IAAO,SAAP,MAAO,gBAAqD,cAAiC;EAwBlG,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,SAAS,OAAO,CAAC,CAAC;AAvBvE,SAAA,OAAe;AAKf,SAAA,WAAoB;AAoB5B,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,SAAS,OAAO,CAAC;AAExF,SAAK,SAAS,KAAK,kBAAkB,IAAI,mBAAmB;MAC3D,SAAS,KAAK;MACd,SAAS,QAAQ;MACjB,QAAQ,QAAQ;MAChB,OAAO,QAAQ;MACf,UAAU,QAAQ;MAClB,UAAU,QAAQ;KAClB;AACD,SAAK,gBAAgB,MAAM,CAAC;AAC5B,SAAK,QAAQ,KAAK,SAAS,KAAK,gBAAgB;EACjD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,SAAS;MACT,OAAO;MACP,OAAO;KACP;EACF;EAEA,QAAQ,aAAwB,YAAY,GAAG,WAAW,GAAC;AAE1D,kBAAc,MAAM,aAAa,WAAW,QAAQ;AACpD,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;;;;;EAQA,eAAe,OAA0B,MAAU;AAClD,SAAK,OAAO,eAAe,OAAO,IAAI;AACtC,WAAO;EACR;EACA,eAAe,MAAU;AACxB,WAAO,KAAK,OAAO,eAAe,IAAI;EACvC;EACA,aAAa,MAAU;AACtB,SAAK,OAAO,aAAa,IAAI;AAC7B,WAAO;EACR;EACA,wBAAwB,OAA0B,MAAU;AAC3D,SAAK,OAAO,wBAAwB,OAAO,IAAI;AAC/C,WAAO;EACR;EACA,6BAA6B,OAA0B,MAAU;AAChE,SAAK,OAAO,6BAA6B,OAAO,IAAI;AACpD,WAAO;EACR;EACA,kBAAkB,OAA0B,UAAgB,WAAgB;AAC3E,SAAK,OAAO,kBAAkB,OAAO,UAAU,SAAS;AACxD,WAAO;EACR;EACA,aAAa,OAA0B,UAAgB,WAAgB;AACtE,SAAK,OAAO,aAAa,OAAO,UAAU,SAAS;AACnD,WAAO;EACR;EACA,aAAa,OAA0B,UAAgB,WAAgB;AACtE,SAAK,OAAO,aAAa,OAAO,UAAU,SAAS;AACnD,WAAO;EACR;EACA,+BAA+B,OAA0B,MAAY,UAAc;AAClF,SAAK,OAAO,+BAA+B,OAAO,MAAM,QAAQ;AAChE,WAAO;EACR;EACA,gBAAgB,OAA0B,WAAiB,cAAoB;AAC9E,SAAK,OAAO,gBAAgB,OAAO,WAAW,YAAY;AAC1D,WAAO;EACR;EACA,oBAAoB,QAA6B,WAAiB,UAAgB,SAAgB;AACjG,SAAK,OAAO,oBAAoB,QAAQ,WAAW,UAAU,OAAO;AACpE,WAAO;EACR;EACA,sBAAsB,MAAU;AAC/B,SAAK,OAAO,sBAAsB,IAAI;AACtC,WAAO;EACR;EACA,oBAAoB,MAAU;AAC7B,SAAK,OAAO,oBAAoB,IAAI;AACpC,WAAO;EACR;EACA,OAAO,OAA0B,UAAgB,WAAgB;AAChE,SAAK,OAAO,OAAO,OAAO,UAAU,SAAS;AAC7C,WAAO;EACR;EAEA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,MAAM,OAAwB;AACjC,SAAK,OAAO,QAAQ;EACrB;EAEA,IAAI,UAAO;AACV,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,QAAQ,SAAgB;AAC3B,SAAK,OAAO,UAAU;EACvB;EAEA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO;EACpB;EAEA,IAAI,aAAU;AACb,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,WAAW,YAAmB;AACjC,SAAK,OAAO,aAAa;EAC1B;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,WAAQ;AACX,WAAO,KAAK,OAAO;EACpB;;;;EAKA,MAAM,OAAyB;AAC9B,SAAK,OAAO,MAAM,KAAK;AACvB,WAAO;EACR;;AAaK,SAAU,cAAc,QAAoB,aAAwB,WAAoB,UAAiB;AAC9G,MAAI,uBAAuB,SAAS,aAAa,WAAW,KAC1D,uBAAuB,UAAU,YAAY,UAAW;AAEzD,gBAAY,sBAAsB,CAAC;AAEnC,gBAAY,eAAe,GAAG,CAAC;AAE/B,QAAI,uBAAuB,QAAQ;AAClC,kBAAY,aAAa;;;AAG3B,UAAQ,QAAQ,aAAa,WAAW,QAAQ;AACjD;;;AC9MM,IAAO,YAAP,MAAO,mBAAoD,MAAe;EAwB/E,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AAxBjE,SAAA,OAAe;AAKd,SAAA,UAAyC,IAAI,SAAS,QAAQ;AAKhE,SAAA,cAAc;AAerB,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAGlF,SAAK,cAAc,QAAQ;AAG3B,SAAK,QAAQ,OAAO,CAAC;AAErB,SAAK,QAAQ,IAAI;MAChB,OAAO;MACP,MAAM;MACN,MAAM;MACN,OAAO,KAAK,UAAU,QAAQ,KAAK;KACnC;AACD,SAAK,eAAe,QAAQ,OAAO,CAAC;EACrC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,MAAM,YAAW,GAAI;MACzC,YAAY;MACZ,OAAO;MACP,OAAO;KACP;EACF;EAEA,gBAAgB,OAA0B,MAAY,UAAgB;AAErE,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,aAAa,IAAI;AACtB,UAAM,gBAAgB,KAAK,UAAU,KAAK;AAG1C,UAAM,YAAY,KAAK,QAAQ,IAAI,IAAI;AACvC,UAAM,WAAW,KAAK,MAAM,KAAK,IAAI,IAAI,UAAU,CAAC,CAAC;AACrD,aAAS,IAAI,GAAG,KAAK,UAAU,KAAK;AACnC,YAAM,UAAU,WAAW,IAAI;AAC/B,YAAM,UAAU,KAAK,qBAAqB,UAAU,MAAM,UAAU,OAAO,eAAe,UAAU,OAAO;AAC3G,WAAK,wBAAwB,KAAK,QAAQ,OAAO,GAAG,OAAO;;AAE5D,WAAO;EACR;EAEA,eAAe,OAA0B,MAAU;AAClD,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,eAAe,OAAO,IAAI;AAChC,UAAM,QAAQ,KAAK,QAAQ,IAAI,YAAY;AAC3C,UAAM,gBAAgB,KAAK,QAAQ,cAAc,KAAK;AACtD,UAAM,iBAAiB,KAAK,oBAAoB,eAAe,YAAY;AAC3E,UAAM,QAAQ,KAAK,IAAI,gBAAgB,CAAC;AACxC,WAAO;EACR;EAEA,wBAAwB,OAA0B,MAAU;AAC3D,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,wBAAwB,OAAO,IAAI;AACzC,UAAM,QAAQ,KAAK,QAAQ,IAAI,YAAY;AAC3C,UAAM,gBAAgB,KAAK,QAAQ,cAAc,KAAK;AACtD,UAAM,iBAAiB,KAAK,oBAAoB,eAAe,YAAY;AAC3E,UAAM,QAAQ,KAAK,IAAI,gBAAgB,CAAC;AACxC,WAAO;EACR;EAEA,6BAA6B,OAA0B,MAAU;AAEhE,WAAO,KAAK,UAAU,IAAI;AAC1B,UAAM,cAAc,KAAK,UAAU,KAAK;AAGxC,UAAM,YAAY,KAAK,QAAQ,IAAI,IAAI;AAEvC,UAAM,WAAW,KAAK,MAAM,KAAK,KAAK,OAAO,UAAU,QAAQ,IAAI,CAAC,CAAC;AACrE,UAAM,cAAe,OAAO,UAAU,QAAQ;AAC9C,aAAS,IAAI,GAAG,KAAK,UAAU,KAAK;AACnC,YAAM,UAAU,aAAa,IAAI,UAAU;AAC3C,YAAM,UAAU,KAAK,wBAAwB,UAAU,MAAM,UAAU,OAAO,MAAM,aAAa,OAAO;AACxG,WAAK,wBAAwB,KAAK,QAAQ,OAAO,GAAG,OAAO;;AAE5D,WAAO;EACR;;;;;;;EAQQ,oBAAoB,OAAmC,MAAY;AAC1E,QAAI,UAAU,MAAM;AACnB,cAAQ;QACP,OAAO;QACP,MAAM;QACN,MAAM;QACN,OAAO;;eAEE,QAAQ,MAAM,KAAK,GAAG;AAChC,YAAM,gBAAgB,KAAK,QAAQ,cAAc,KAAK;AACtD,YAAM,QAAQ,KAAK,oBAAoB,eAAe,MAAM,IAAI;;AAEjE,UAAM,OAAO,KAAK,UAAU,KAAK,eAAe,MAAM,IAAI,CAAC;AAC3D,QAAI,OAAO,KAAK,UAAU,KAAK,eAAe,IAAI,CAAC;AAEnD,UAAM,iBAAiB,KAAK,QAAQ,IAAI,IAAI;AAC5C,QAAI,kBAAkB,eAAe,SAAS,QAAQ,eAAe,SAAS,kBAAkB;AAC/F,aAAO,KAAK,UAAU,KAAK,eAAe,OAAO,KAAK,UAAU,CAAC;;AAElE,WAAO,OAAO,OAAO,MAAM,SAAS,OAAO,QAAQ,MAAM;EAC1D;;;;;;;EAQA,eAAe,MAAU;AACxB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,QAAQ,KAAK,QAAQ,IAAI,YAAY;AAC3C,WAAO,KAAK,IAAI,KAAK,oBAAoB,OAAO,YAAY,GAAG,CAAC;EACjE;;;;;;;EAQA,mBAAmB,OAAc,MAAU;AAC1C,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,cAAc,KAAK,eAAe,IAAI;AAC5C,WAAO,KAAK,cAAc,cAAc,KAAK,IAAI;EAClD;;;;;EAMA,cAAc,MAAW;AACxB,UAAM,SAAS,KAAK,QAAQ,IAAI,MAAM,OAAO;AAC7C,UAAM,QAAQ,KAAK,QAAQ,SAAS,MAAM,OAAO;AACjD,QAAI,UAAU,OAAO,UAAU,MAAM;AACpC,aAAO,OAAO;eACJ,UAAU,SACpB,MAAM,SAAS,6BACf,OAAO,UAAU,MAAM,OAAO;AAC9B,YAAM,OAAO,KAAK,UAAU,KAAK,eAAe,OAAO,IAAI,CAAC;AAC5D,YAAM,OAAO,KAAK,UAAU,KAAK,eAAe,MAAM,IAAI,CAAC;AAC3D,YAAM,SAAS,OAAO,SAAS,MAAM,OAAO,OAAO;AACnD,YAAM,IAAI,KAAK,KAAK,KAAK,IAAI,MAAM,CAAC,IAAI,IAAI,SAAS,OAAO,QAAQ,KAAK;AACzE,YAAM,QAAQ,CAAC,OAAO,KAAK;AAC3B,YAAM,QAAQ,CAAC,OAAO,KAAK;AAC3B,cAAQ,OAAO,IAAI,OAAO,QAAQ,OAAO;eAC/B,QAAQ;AAClB,UAAI,OAAO,UAAU,GAAG;AACvB,eAAO;aACD;AACN,eAAO,OAAO,QAAQ,OAAO,OAAO,SAAS,OAAO;;WAE/C;AACN,aAAO,OAAO,KAAK;;EAErB;;;;;;;;EASA,YAAY,OAAc,MAAU;AACnC,WAAO,KAAK,mBAAmB,OAAO,IAAI;EAC3C;;;;;;;;;EAUA,YAAY,UAAgB,MAAU;AACrC,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,mBAAmB,KAAK,UAAU,QAAQ;AAChD,UAAM,aAAa,KAAK,eAAe,YAAY;AACnD,UAAM,WAAW,KAAK,eAAe,eAAe,gBAAgB;AACpE,WAAO,WAAW;EACnB;;;;EAKU,UAAU,KAAsB;AACzC,QAAI,KAAK,UAAU,SAAS,KAAK,YAAY;AAC5C,aAAO,KAAK,KAAK,MAAM,KAAK;WACtB;AACN,aAAO,MAAM,UAAU,GAAG;;EAE5B;;;;EAKU,QAAQ,KAAW;AAC5B,QAAI,KAAK,UAAU,SAAS,KAAK,YAAY;AAC5C,aAAQ,MAAM,KAAK,aAAc;WAC3B;AACN,aAAO,MAAM,QAAQ,GAAG;;EAE1B;;;;EAIA,IAAI,aAAU;AACb,WAAO,KAAK;EACb;EACA,IAAI,WAAW,GAAS;AAGvB,UAAM,aAAa,KAAK;AACxB,SAAK,cAAc;AACnB,SAAK,sBAAsB,CAAC;AAC5B,SAAK,eAAe,YAAY,CAAC;EAClC;;;;ACzPK,IAAO,aAAP,MAAO,oBAAqD,OAAgB;EAejF,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AAflE,SAAA,OAAe;AAgBvB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAEnF,SAAK,QAAQ,KAAK,SAAS,IAAI,UAAU;MACxC,SAAS,KAAK;MACd,SAAS,QAAQ;MACjB,YAAY,QAAQ;MACpB,OAAO,KAAK,gBAAgB;MAC5B,OAAO,QAAQ;MACf,OAAO,QAAQ;KACf;EACF;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,YAAY;MACZ,OAAO;MACP,OAAO;KACP;EACF;EAEA,YAAY,OAAc,MAAU;AACnC,WAAO,KAAK,OAAO,YAAY,OAAO,IAAI;EAC3C;EAEA,YAAY,UAAgB,MAAU;AACrC,WAAO,KAAK,OAAO,YAAY,UAAU,IAAI;EAC9C;EAEA,cAAc,MAAW;AACxB,WAAO,KAAK,OAAO,cAAc,IAAI;EACtC;EAEA,mBAAmB,OAAc,MAAU;AAC1C,WAAO,KAAK,OAAO,mBAAmB,OAAO,IAAI;EAClD;EAEA,eAAe,MAAU;AACxB,WAAO,KAAK,OAAO,eAAe,IAAI;EACvC;;;;EAKA,IAAI,aAAU;AACb,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,WAAW,GAAS;AACvB,SAAK,OAAO,aAAa;EAC1B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACpEK,IAAO,aAAP,MAAO,oBAAqD,gBAAkC;EAwBnG,cAAA;AACC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC,CAAC;AAvBtE,SAAA,OAAe;AAUhB,SAAA,SAAwB,IAAI,cAAa;AAKzC,SAAA,cAA+C,IAAI,SAAQ;AASlE,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC;AAEvF,SAAK,YAAY,IAAI,WAAW;MAC/B,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO,QAAQ;KACf;AACD,aAAS,MAAM,WAAW;AAG1B,SAAK,OAAO,eAAe,WAAW,CAAC;AAEvC,SAAK,eAAe,GAAG,CAAC;EACzB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO;MACpB,WAAW;MACX,OAAO;OACL,gBAAgB,YAAW,CAAE;EACjC;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,eAAe,KAAK,IAAG,CAAE;EACtC;;;;;;;EAQA,MAAM,MAAY,QAAc;AAC/B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAC3D,WAAK,OAAO,eAAe,WAAW,YAAY;AAClD,UAAI,UAAU,MAAM,GAAG;AACtB,aAAK,eAAe,QAAQ,YAAY;;;AAG1C,WAAO;EACR;;;;;EAMA,KAAK,MAAU;AACd,UAAM,eAAe,KAAK,UAAU,IAAI;AAExC,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAC3D,YAAM,QAAQ,KAAK,OAAO,IAAI,YAAY;AAC1C,UAAI,SAAS,MAAM,OAAO,GAAG;AAC5B,aAAK,YAAY,OAAO,MAAM,IAAI;AAClC,aAAK,OAAO,OAAO,MAAM,IAAI;;;AAG/B,SAAK,OAAO,OAAO,YAAY;AAC/B,SAAK,OAAO,eAAe,WAAW,YAAY;AAClD,SAAK,eAAe,GAAG,YAAY;AACnC,WAAO;EACR;;;;;EAMA,MAAM,MAAU;AACf,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAC3D,WAAK,OAAO,eAAe,UAAU,YAAY;;AAElD,WAAO;EACR;;;;;EAMA,OAAO,MAAU;AAChB,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,OAAO,OAAO,IAAI;AACvB,SAAK,YAAY,OAAO,IAAI;AAC5B,WAAO;EACR;;;;;;EAOA,eAAe,MAAW;AACzB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,YAAY,KAAK,OAAO,aAAa,WAAW,YAAY;AAElE,UAAM,WAA+B,EAAE,OAAO,UAAU,MAAM,aAAY;AAC1E,SAAK,OAAO,IAAI,QAAQ;AAGxB,QAAI,YAAY;AAChB,QAAI,eAAe;AAGnB,SAAK,OAAO,eAAe,UAAU,MAAM,eAAe,KAAK,YAAY,OAAI;AAC9E,UAAI,kBAAkB,UAAU;AAEhC,YAAM,cAAc,KAAK,YAAY,IAAI,EAAE,IAAI;AAC/C,UAAI,eAAe,YAAY,QAAQ,UAAU,MAAM;AACtD,uBAAe,YAAY;AAC3B,0BAAkB,YAAY;;AAE/B,UAAI,UAAU,UAAU,aAAa,EAAE,UAAU,WAAW;AAC3D,wBAAgB,KAAK,UAAU,eAAe,EAAE,IAAI,IAAI,KAAK,UAAU,eAAe,eAAe;;AAEtG,kBAAY;IACb,CAAC;AAGD,SAAK,OAAO,OAAO,QAAQ;AAG3B,WAAO;EACR;;;;;EAMA,IAAI,QAAK;AACR,WAAO,KAAK,eAAe,KAAK,IAAG,CAAE;EACtC;EACA,IAAI,MAAM,GAAQ;AACjB,SAAK,eAAe,GAAG,KAAK,IAAG,CAAE;EAClC;;;;;EAMA,IAAI,UAAO;AACV,WAAO,KAAK,iBAAiB,KAAK,IAAG,CAAE;EACxC;EACA,IAAI,QAAQ,GAAU;AACrB,UAAMC,OAAM,KAAK,IAAG;AACpB,UAAM,QAAQ,KAAK,UAAU,YAAY,GAAGA,IAAG;AAC/C,SAAK,eAAe,OAAOA,IAAG;EAC/B;;;;;;EAOA,iBAAiB,MAAU;AAC1B,WAAO,KAAK,UAAU,IAAI;AAC1B,UAAM,YAAY,KAAK,OAAO,aAAa,WAAW,IAAI;AAE1D,UAAM,WAA+B,EAAE,OAAO,UAAU,KAAI;AAC5D,SAAK,OAAO,IAAI,QAAQ;AAGxB,QAAI,YAAY;AAChB,QAAI,iBAAiB;AAGrB,SAAK,OAAO,eAAe,UAAU,MAAM,OAAO,KAAK,YAAY,OAAI;AACtE,UAAI,kBAAkB,UAAU;AAEhC,YAAM,cAAc,KAAK,YAAY,IAAI,EAAE,IAAI;AAC/C,UAAI,eAAe,YAAY,QAAQ,UAAU,MAAM;AACtD,yBAAiB,YAAY;AAC7B,0BAAkB,YAAY;;AAE/B,UAAI,UAAU,UAAU,aAAa,EAAE,UAAU,WAAW;AAC3D,0BAAkB,EAAE,OAAO;;AAE5B,kBAAY;IACb,CAAC;AAGD,SAAK,OAAO,OAAO,QAAQ;AAG3B,WAAO;EACR;;;;;;EAOA,eAAe,OAAc,MAAU;AACtC,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,YAAY,OAAO,IAAI;AAC5B,SAAK,YAAY,IAAI;MACpB,SAAS,KAAK,UAAU,mBAAmB,OAAO,IAAI;MACtD;MACA;KACA;AACD,WAAO;EACR;;;;;EAMA,eAAe,MAAU;AACxB,WAAO,KAAK,UAAU,IAAI;AAC1B,WAAO,KAAK,OAAO,eAAe,IAAI;EACvC;;;;;;;;;EAUA,cAAc,MAAa,SAAS,KAAK,IAAG,GAAE;AAC7C,UAAM,SAAS,KAAK,YAAY,IAAI,MAAM;AAC1C,UAAM,QAAQ,KAAK,OAAO,IAAI,MAAM;AACpC,UAAM,YAAY,KAAK,IAAI,OAAO,MAAM,MAAM,IAAI;AAClD,UAAM,gBAAgB,KAAK,UAAU,eAAe,SAAS,IAAI,OAAO,OAAO;AAC/E,WAAO,KAAK,UAAU,cAAc,aAAa;EAClD;;;;;;;;EASA,mBAAmB,WAAmB,SAAiB,UAA+C;AAErG,QAAI,iBAAiB,KAAK,OAAO,IAAI,SAAS;AAC9C,SAAK,OAAO,eAAe,WAAW,SAAS,WAAQ;AACtD,UAAI,kBAAkB,eAAe,UAAU,aAAa,MAAM,UAAU,WAAW;AACtF,aAAK,mBAAmB,KAAK,IAAI,eAAe,MAAM,SAAS,GAAG,MAAM,OAAO,KAAK,YAAY,QAAQ;;AAEzG,uBAAiB;IAClB,CAAC;AAED,QAAI,QAAsB;AAE1B,QAAI,kBAAkB,eAAe,UAAU,WAAW;AACzD,YAAM,eAAe,KAAK,IAAI,eAAe,MAAM,SAAS;AAE5D,YAAM,aAAa,KAAK,UAAU,eAAe,YAAY;AAC7D,YAAM,eAAe,KAAK,UAAU,eAAe,eAAe,IAAI;AACtE,YAAM,OAAO,aAAa;AAC1B,UAAI,SAAS,KAAK,KAAK,IAAI,IAAI;AAE/B,eAAS,GAAG,QAAQ,CAAC,IAAI,IAAI;AAC7B,UAAI,eAAe,KAAK,UAAU,cAAc,aAAa,MAAM;AACnE,aAAO,eAAe,SAAS;AAC9B,YAAI;AACH,mBAAS,cAAc,KAAK,MAAM,KAAK,eAAe,YAAY,CAAC,CAAC;iBAC5D,GAAG;AACX,kBAAQ;AACR;;AAED,wBAAgB,KAAK,UAAU,mBAAmB,GAAG,YAAY;;;AAInE,QAAI,OAAO;AACV,YAAM;;AAGP,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,YAAY,QAAO;AACxB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC7SK,IAAO,QAAP,MAAO,eACJ,gBAA6B;EAyCrC,cAAA;AAEC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,YAAY,WAAW,CAAC,CAAC;AAzC7E,SAAA,OAAe;AAKxB,SAAA,WAA0B;AAUlB,SAAA,cAAc;AAKd,SAAA,SAAwB,IAAI,cAAc,SAAS;AAMnD,SAAA,aAAyB,KAAK,MAAM,KAAK,IAAI;AAgBpD,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,YAAY,WAAW,CAAC;AAE9F,SAAK,WAAW,QAAQ;AACxB,SAAK,cAAc,IAAI,WAAW;MACjC,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,OAAO,QAAQ;KACf;AACD,SAAK,cAAc;AACnB,SAAK,YAAY,KAAK,YAAY;AAClC,aAAS,MAAM,WAAW;AAG1B,SAAK,OAAO,eAAe,WAAW,CAAC;AAGvC,SAAK,QAAQ,GAAG,QAAQ,KAAK,UAAU;EACxC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,gBAAgB,YAAW,GAAI;MACnD,UAAU;MACV,WAAW;MACX,OAAO;KACP;EACF;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO,eAAe,KAAK,IAAG,CAAE;EAC7C;;;;;;;EAQA,MAAM,MAAa,QAAc;AAEhC,yBAAqB,KAAK,OAAO;AAEjC,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,IAAI,SAAS,YAAY;AAC9B,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAC3D,WAAK,OAAO,eAAe,WAAW,YAAY;AAClD,WAAK,YAAY,MAAM,cAAc,MAAM;AAC3C,UAAI,eAAe,KAAK,aAAa;AACpC,aAAK,KAAK,SAAS,cAAc,MAAM;;;AAGzC,WAAO;EACR;;;;;;;;;;;;EAaA,KAAK,MAAW;AACf,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,IAAI,QAAQ,YAAY;AAC7B,SAAK,OAAO,OAAO,YAAY;AAC/B,SAAK,OAAO,eAAe,WAAW,YAAY;AAClD,SAAK,YAAY,KAAK,YAAY;AAClC,QAAI,eAAe,KAAK,aAAa;AACpC,WAAK,KAAK,QAAQ,YAAY;;AAE/B,WAAO;EACR;;;;;EAMA,MAAM,MAAW;AAChB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAC3D,WAAK,OAAO,eAAe,UAAU,YAAY;AACjD,WAAK,YAAY,MAAM,YAAY;AACnC,UAAI,eAAe,KAAK,aAAa;AACpC,aAAK,KAAK,SAAS,YAAY;;;AAGjC,WAAO;EACR;;;;;EAMA,IAAI,QAAK;AACR,WAAO,KAAK,KAAK,KAAK,eAAe,KAAK,IAAG,CAAE,CAAC;EACjD;EACA,IAAI,MAAM,GAAQ;AACjB,SAAK,YAAY,QAAQ;EAC1B;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,QAAQ,GAAU;AACrB,SAAK,YAAY,UAAU;EAC5B;;;;;;EAOA,iBAAiB,MAAU;AAC1B,WAAO,KAAK,YAAY,iBAAiB,IAAI;EAC9C;;;;;;EAOA,eAAe,OAAc,MAAU;AACtC,SAAK,YAAY,eAAe,OAAO,IAAI;AAC3C,WAAO;EACR;;;;;;;;;EAUA,cAAc,MAAa,SAAS,KAAK,IAAG,GAAE;AAC7C,WAAO,KAAK,YAAY,cAAc,MAAM,MAAM;EACnD;;;;;;EAOA,eAAe,MAAW;AACzB,WAAO,KAAK,YAAY,eAAe,IAAI;EAC5C;;;;;EAMA,aAAa,QAAe,MAAU;AACrC,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,cAAc,KAAK,eAAe,YAAY;AACpD,WAAO,KAAK,YAAY,cAAc,cAAc,QAAQ,YAAY;EACzE;;;;EAKQ,QAAK;AAEZ,UAAM,YAAY,KAAK;AACvB,UAAM,UAAU,KAAK,IAAG;AACxB,SAAK,cAAc;AACnB,SAAK,IAAI,QAAQ,WAAW,OAAO;AAEnC,QAAI,cAAc,SAAS;AAE1B,WAAK,OAAO,eAAe,WAAW,SAAS,OAAI;AAClD,gBAAQ,EAAE,OAAO;UAChB,KAAK;AACJ,kBAAM,SAAS,KAAK,YAAY,eAAe,EAAE,IAAI;AACrD,iBAAK,KAAK,SAAS,EAAE,MAAM,MAAM;AACjC;UACD,KAAK;AACJ,gBAAI,EAAE,SAAS,GAAG;AACjB,mBAAK,KAAK,QAAQ,EAAE,IAAI;;AAEzB;UACD,KAAK;AACJ,iBAAK,KAAK,SAAS,EAAE,IAAI;AACzB;;MAEH,CAAC;AAED,WAAK,YAAY,mBAAmB,WAAW,SAAS,CAAC,MAAM,UAAS;AACvE,aAAK,SAAS,MAAM,KAAK;MAC1B,CAAC;;EAEH;;;;;;;;;;EAWA,eAAe,MAAU;AACxB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,WAAO,KAAK,OAAO,eAAe,YAAY;EAC/C;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,IAAI,QAAQ,KAAK,UAAU;AACxC,SAAK,YAAY,QAAO;AACxB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;AAYD,QAAQ,MAAM,KAAK;;;ACrSb,IAAO,QAAP,MAAO,eAAc,cAA2B;EAiCrD,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,aAAa,UAAU,CAAC,CAAC;AAhC7E,SAAA,OAAe;AAkCvB,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,aAAa,UAAU,CAAC;AAE9F,UAAM,oBAAoB,KAAK,UAAU,QAAQ,QAAQ;AACzD,SAAK,YAAY,KAAK,IAAI,mBAAmB,KAAK,UAAU,QAAQ,SAAS,CAAC;AAE9E,SAAK,aAAa,KAAK,QAAQ,KAAK,SAAS,KAAK,QAAQ,YAAY,iBAAiB;AAEvF,SAAK,YAAY,IAAI,MAAM;MAC1B,SAAS,KAAK;MACd,OAAO,KAAK,WAAW;MACvB,OAAO;MACP,OAAO,QAAQ;MACf,UAAU;MACV,UAAU,KAAK;KACf;AAED,aAAS,MAAM,WAAW;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,UAAU;KACV;EACF;;;;;EAMA,IAAI,WAAQ;AACX,WAAO,KAAK;EACb;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,WAAU;AAC1B,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC/DK,SAAgB,QACrB,UACA,UACA,WAAW,GACX,aAAqB,WAAU,EAAG,YAAU;;AAG5C,UAAM,kBAAkB,WAAU;AAElC,UAAMC,WAAU,IAAI,eAAe,UAAU,UAAU,UAAU;AACjE,eAAWA,QAAO;AAGlB,UAAM,SAASA,QAAO;AAGtB,UAAM,gBAAgBA,SAAQ,OAAM;AAGpC,eAAW,eAAe;AAG1B,UAAM,SAAS,MAAM;AAGrB,WAAO,IAAI,gBAAgB,MAAM;EAClC,CAAC;;;;ACpBK,IAAO,mBAAP,MAAO,0BAAyB,KAAI;EA8BzC,cAAA;AAEC,UAAK;AA9BG,SAAA,OAAe;AAKhB,SAAA,WAAyC,oBAAI,IAAG;AAUhD,SAAA,gBAAgB;AAgBvB,UAAM,UAAU,qBACf,kBAAiB,YAAW,GAAI,WAAW,CAAC,QAAQ,UAAU,SAAS,GAAG,MAAM;AAGjF,SAAK,UAAU,QAAQ;AAEvB,WAAO,KAAK,QAAQ,IAAI,EAAE,QAAQ,UAAO;AACxC,WAAK;AACL,YAAM,MAAM,QAAQ,KAAK,IAAI;AAC7B,WAAK,IAAI,MAAM,KAAK,KAAK,cAAc,KAAK,MAAM,QAAQ,MAAM,GAAG,QAAQ,OAAO;IACnF,CAAC;EAEF;EAEA,OAAO,cAAW;AACjB,WAAO;MACN,SAAS;MACT,SAAS;MACT,QAAQ;MACR,MAAM,CAAA;;EAER;;;;;EAMA,IAAI,MAAqB;AACxB,WAAO,KAAK,SAAS,IAAI,KAAK,SAAQ,CAAE;EACzC;;;;;;EAOA,IAAI,MAAqB;AACxB,WAAO,KAAK,IAAI,IAAI,GAAG,yCAAyC,IAAI,EAAE;AACtE,WAAO,KAAK,SAAS,IAAI,KAAK,SAAQ,CAAE;EACzC;;;;EAKQ,cAAc,UAAoB;AACzC,SAAK;AACL,QAAI,KAAK,kBAAkB,KAAK,UAAU;AACzC,eAAQ;;EAEV;;;;EAKA,IAAI,SAAM;AACT,WAAO,MAAM,KAAK,KAAK,QAAQ,EAAE,MAAM,CAAC,CAAC,GAAG,MAAM,MAAM,OAAO,MAAM;EACtE;;;;;;;;EASA,IACC,MACA,KACA,WAAuB,MACvB,UAA8B,MAAI;AAElC,QAAI,SAAS,GAAG,GAAG;AAClB,WAAK,SAAS,IAAI,KAAK,SAAQ,GAAI,IAAI,gBAAgB,KAAK,UAAU,KAAK,UAAU,OAAO,CAAC;WACvF;AACN,WAAK,SAAS,IAAI,KAAK,SAAQ,GAAI,IAAI,gBAAgB,KAAK,UAAU,OAAO,CAAC;;AAE/E,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,SAAS,QAAQ,YAAU,OAAO,QAAO,CAAE;AAChD,SAAK,SAAS,MAAK;AACnB,WAAO;EACR;;;;ACrJK,IAAO,YAAP,MAAO,mBAAkB,eAAwB;EAAvD,cAAA;;AAEU,SAAA,OAAe;AAEf,SAAA,eAAe;EAyDzB;;;;EApDW,kBAAkB,MAAW;AACtC,WAAO,KAAK,MAAM,kBAAkB,IAAI,CAAC;EAC1C;;;;EAKU,cAAc,OAAY;AACnC,WAAO,KAAK,MAAM,cAAc,KAAK,CAAC;EACvC;;;;EAKU,cAAc,OAAa;AACpC,WAAO,KAAK,MAAM,cAAc,KAAK,CAAC;EACvC;;;;EAKU,gBAAgB,SAAgB;AACzC,WAAO,KAAK,MAAM,gBAAgB,OAAO,CAAC;EAC3C;;;;;;EAOA,SAAM;AACL,WAAO,KAAK,QAAO;EACpB;;;;;;EAOA,cAAW;AACV,WAAO,KAAK,KAAK,OAAM,CAAE;EAC1B;;;;;;;EAQA,UAAU,UAAkB;AAC3B,WAAO,IAAI,WAAU,KAAK,SAAS,KAAK,OAAM,IAAK,QAAQ;EAC5D;;AAOK,SAAU,KAAK,OAAmB,OAAqB;AAC5D,SAAO,IAAI,UAAU,WAAU,GAAI,OAAO,KAAK;AAChD;;;ACpEM,IAAO,aAAP,cAA0B,mBAAyB;EAAzD,cAAA;;AAEU,SAAA,OAAe;AAEf,SAAA,eAA6B;EA2CvC;;;;EAtCW,OAAI;AACb,WAAO,KAAK,QAAQ,UAAU;EAC/B;;;;EAKU,cAAc,OAAa;AACpC,WAAO,KAAK,QAAO,IAAK;EACzB;;;;EAKU,gBAAgB,SAAgB;AACzC,WAAO,KAAK,MAAM,WAAW,KAAK,KAAK,QAAO,KAAM,KAAK,QAAO,CAAE;EACnE;;;;EAKU,cAAc,OAAY;AACnC,WAAO;EACR;;;;EAKA,UAAO;AACN,WAAO,KAAK,QAAO;EACpB;;;;EAKA,YAAS;AACR,WAAQ,KAAK,QAAO,IAAK,KAAK,QAAO,KAAO,KAAK,KAAK,QAAO;EAC9D;;AAOK,SAAU,MAAM,OAAmB,OAAoB;AAC5D,SAAO,IAAI,WAAW,WAAU,GAAI,OAAO,KAAK;AACjD;;;ACzCM,IAAO,OAAP,cAAoB,gBAAuC;EAAjE,cAAA;;AAEU,SAAA,OAAe;AAKxB,SAAA,aAAsB;AAOtB,SAAA,eAAwB;AAKhB,SAAA,UAA+B,IAAI,SAAQ;AAK3C,SAAA,iBAAiB,KAAK,UAAU,KAAK,IAAI;AAKzC,SAAA,kBAAkB;EAwD3B;;;;;;;;;;;;EA3CC,SAAS,UAAsB,MAAU;AACxC,SAAK,QAAQ,IAAI;MAChB;MACA,MAAM,KAAK,UAAU,IAAI;KACzB;AAED,QAAI,KAAK,QAAQ,WAAW,GAAG;AAC9B,WAAK,kBAAkB,sBAAsB,KAAK,cAAc;;AAEjE,WAAO;EACR;;;;;EAMA,OAAO,OAAY;AAClB,SAAK,QAAQ,OAAO,KAAK,UAAU,KAAK,CAAC;AACzC,WAAO;EACR;;;;EAKQ,YAAS;AAChB,UAAMC,OAAM,KAAK,QAAQ;AACzB,WAAO,KAAK,QAAQ,UAAW,KAAK,QAAQ,KAAI,EAAiB,OAAO,KAAK,gBAAgBA,MAAK;AACjG,YAAM,QAAQ,KAAK,QAAQ,MAAK;AAChC,UAAI,SAASA,OAAM,MAAM,QAAQ,KAAK,YAAY;AACjD,cAAM,SAAQ;;;AAGhB,QAAI,KAAK,QAAQ,SAAS,GAAG;AAC5B,WAAK,kBAAkB,sBAAsB,KAAK,cAAc;;EAElE;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,yBAAqB,KAAK,eAAe;AACzC,WAAO;EACR;;AAOD,cAAc,CAAAC,aAAU;AACvB,EAAAA,SAAQ,OAAO,IAAI,KAAK,EAAE,SAAAA,SAAO,CAAE;AACpC,CAAC;AAED,eAAe,CAAAA,aAAU;AACxB,EAAAA,SAAQ,KAAK,QAAO;AACrB,CAAC;;;ACrGK,IAAO,mBAAP,cAAgC,KAAI;EAA1C,cAAA;;AAEU,SAAA,OAAe;AAKhB,SAAA,QAA6B;AAK7B,SAAA,UAAU;EA0TnB;;;;;;EAnTC,IAAI,OAA4B;AAC/B,WAAO,UAAU,MAAM,IAAI,GAAG,kCAAkC;AAChE,WAAO,UAAU,MAAM,QAAQ,GAAG,uCAAuC;AAEzE,UAAM,OAAO,MAAM,KAAK,QAAO;AAC/B,QAAI,OAA4B,IAAI,aAAa,MAAM,MAAM,MAAM,OAAO,MAAM,UAAU,KAAK;AAC/F,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,QAAQ;WACP;AACN,WAAK,MAAM,OAAO,IAAI;;AAEvB,SAAK;AAEL,WAAO,SAAS,MAAM;AACrB,WAAK,aAAY;AACjB,WAAK,UAAS;AACd,WAAK,WAAW,IAAI;AACpB,aAAO,KAAK;;AAEb,WAAO;EACR;;;;;EAMA,OAAO,OAA4B;AAClC,QAAI,KAAK,UAAU,MAAM;AACxB,YAAM,UAA0B,CAAA;AAChC,WAAK,MAAM,OAAO,MAAM,MAAM,OAAO;AACrC,iBAAW,QAAQ,SAAS;AAC3B,YAAI,KAAK,UAAU,OAAO;AACzB,eAAK,YAAY,IAAI;AACrB,eAAK;AACL;;;;AAIH,WAAO;EACR;;;;;EAMA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;;;;;EAMA,OAAO,OAAa;AACnB,SAAK,YAAY,OAAO,WAAS,KAAK,OAAO,KAAK,CAAC;AACnD,WAAO;EACR;;;;EAKQ,SAAS,MAAyB;AACzC,SAAK,QAAQ;AACb,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,MAAM,SAAS;;EAEtB;;;;;EAMQ,qBAAqB,MAAoB,aAAgC;AAChF,QAAI,KAAK,WAAW,MAAM;AACzB,UAAI,KAAK,YAAW,GAAI;AACvB,aAAK,OAAO,OAAO;aACb;AACN,aAAK,OAAO,QAAQ;;AAErB,WAAK,WAAW,KAAK,MAAM;WACrB;AACN,WAAK,SAAS,WAAW;;EAE3B;;;;;EAMQ,YAAY,MAAkB;AACrC,QAAI,KAAK,SAAS,QAAQ,KAAK,UAAU,MAAM;AAC9C,WAAK,qBAAqB,MAAM,IAAI;eAC1B,KAAK,UAAU,MAAM;AAC/B,WAAK,qBAAqB,MAAM,KAAK,IAAI;eAC/B,KAAK,SAAS,MAAM;AAC9B,WAAK,qBAAqB,MAAM,KAAK,KAAK;WACpC;AACN,YAAM,UAAU,KAAK,WAAU;AAC/B,UAAI;AACJ,UAAI,OAA4B;AAChC,UAAI,UAAU,GAAG;AAChB,YAAI,KAAK,KAAK,UAAU,MAAM;AAC7B,wBAAc,KAAK;AACnB,sBAAY,QAAQ,KAAK;AACzB,iBAAO;eACD;AACN,wBAAc,KAAK,KAAK;AACxB,iBAAO,YAAY,UAAU,MAAM;AAClC,0BAAc,YAAY;;AAE3B,cAAI,YAAY,QAAQ;AACvB,wBAAY,OAAO,QAAQ,YAAY;AACvC,mBAAO,YAAY;AACnB,wBAAY,OAAO,KAAK;AACxB,wBAAY,QAAQ,KAAK;;;iBAGjB,KAAK,MAAM,SAAS,MAAM;AACpC,sBAAc,KAAK;AACnB,oBAAY,OAAO,KAAK;AACxB,eAAO;aACD;AACN,sBAAc,KAAK,MAAM;AACzB,eAAO,YAAY,SAAS,MAAM;AACjC,wBAAc,YAAY;;AAE3B,YAAI,YAAY,QAAQ;AACvB,sBAAY,OAAO,OAAO,YAAY;AACtC,iBAAO,YAAY;AACnB,sBAAY,OAAO,KAAK;AACxB,sBAAY,QAAQ,KAAK;;;AAG3B,UAAI,KAAK,WAAW,MAAM;AACzB,YAAI,KAAK,YAAW,GAAI;AACvB,eAAK,OAAO,OAAO;eACb;AACN,eAAK,OAAO,QAAQ;;aAEf;AACN,aAAK,SAAS,WAAW;;AAE1B,UAAI,MAAM;AACT,aAAK,WAAW,IAAI;;;AAGtB,SAAK,QAAO;EACb;;;;EAKQ,YAAY,MAAkB;AACrC,UAAM,SAAS,KAAK;AACpB,UAAM,cAAc,KAAK,YAAW;AAGpC,UAAM,YAAY,KAAK;AACvB,QAAI,WAAW;AACd,WAAK,QAAQ,UAAU;AACvB,gBAAU,OAAO;;AAGlB,QAAI,WAAW,MAAM;AACpB,UAAI,aAAa;AAChB,eAAO,OAAO;aACR;AACN,eAAO,QAAQ;;WAEV;AACN,WAAK,SAAS,SAAS;;EAEzB;;;;EAKQ,aAAa,MAAkB;AACtC,UAAM,SAAS,KAAK;AACpB,UAAM,cAAc,KAAK,YAAW;AAGpC,UAAM,YAAY,KAAK;AACvB,QAAI,WAAW;AACd,WAAK,OAAO,UAAU;AACtB,gBAAU,QAAQ;;AAGnB,QAAI,WAAW,MAAM;AACpB,UAAI,aAAa;AAChB,eAAO,OAAO;aACR;AACN,eAAO,QAAQ;;WAEV;AACN,WAAK,SAAS,SAAS;;EAEzB;;;;EAKQ,WAAW,MAAkB;AACpC,UAAM,UAAU,KAAK,WAAU;AAC/B,QAAI,UAAU,KAAK,KAAK,MAAM;AAC7B,UAAI,KAAK,KAAK,WAAU,IAAK,GAAG;AAC/B,aAAK,YAAY,KAAK,IAAI;aACpB;AACN,aAAK,aAAa,IAAI;;eAEb,UAAU,MAAM,KAAK,OAAO;AACtC,UAAI,KAAK,MAAM,WAAU,IAAK,GAAG;AAChC,aAAK,aAAa,KAAK,KAAK;aACtB;AACN,aAAK,YAAY,IAAI;;;EAGxB;;;;;;EAOA,IAAI,MAAY;AACf,QAAI,KAAK,UAAU,MAAM;AACxB,YAAM,UAA0B,CAAA;AAChC,WAAK,MAAM,OAAO,MAAM,OAAO;AAC/B,UAAI,QAAQ,SAAS,GAAG;AACvB,YAAI,MAAM,QAAQ,CAAC;AACnB,iBAAS,IAAI,GAAG,IAAI,QAAQ,QAAQ,KAAK;AACxC,cAAI,QAAQ,CAAC,EAAE,MAAM,IAAI,KAAK;AAC7B,kBAAM,QAAQ,CAAC;;;AAGjB,eAAO,IAAI;;;AAGb,WAAO;EACR;;;;;EAMA,QAAQ,UAA0B;AACjC,QAAI,KAAK,UAAU,MAAM;AACxB,YAAM,WAA2B,CAAA;AACjC,WAAK,MAAM,SAAS,UAAQ,SAAS,KAAK,IAAI,CAAC;AAC/C,eAAS,QAAQ,UAAO;AACvB,YAAI,KAAK,OAAO;AACf,mBAAS,KAAK,KAAK;;MAErB,CAAC;;AAEF,WAAO;EACR;;;;;;;EAQA,cAAc,MAAc,UAA0B;AACrD,QAAI,KAAK,UAAU,MAAM;AACxB,YAAM,UAA0B,CAAA;AAChC,WAAK,MAAM,OAAO,MAAM,OAAO;AAC/B,cAAQ,QAAQ,UAAO;AACtB,YAAI,KAAK,OAAO;AACf,mBAAS,KAAK,KAAK;;MAErB,CAAC;;AAEF,WAAO;EACR;;;;;;;EAQA,YAAY,MAAc,UAA0B;AACnD,QAAI,KAAK,UAAU,MAAM;AACxB,YAAM,UAA0B,CAAA;AAChC,WAAK,MAAM,YAAY,MAAM,OAAO;AACpC,cAAQ,QAAQ,UAAO;AACtB,YAAI,KAAK,OAAO;AACf,mBAAS,KAAK,KAAK;;MAErB,CAAC;;AAEF,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,MAAM,SAAS,UAAQ,KAAK,QAAO,CAAE;;AAE3C,SAAK,QAAQ;AACb,WAAO;EACR;;AAiBD,IAAM,eAAN,MAAkB;EAmBjB,YAAY,KAAa,MAAc,OAA4B;AAR3D,SAAA,QAA6B;AAE7B,SAAA,SAA8B;AAEtC,SAAA,SAA8B;AAE9B,SAAA,SAAS;AAGR,SAAK,QAAQ;AAEb,SAAK,MAAM;AAEX,SAAK,OAAO;AAEZ,SAAK,MAAM,KAAK;EACjB;;;;EAKA,OAAO,MAAkB;AACxB,QAAI,KAAK,OAAO,KAAK,KAAK;AACzB,UAAI,KAAK,SAAS,MAAM;AACvB,aAAK,OAAO;aACN;AACN,aAAK,KAAK,OAAO,IAAI;;eAEZ,KAAK,UAAU,MAAM;AAC/B,WAAK,QAAQ;WACP;AACN,WAAK,MAAM,OAAO,IAAI;;EAExB;;;;;;;EAQA,OAAO,OAAe,SAAuB;AAG5C,QAAI,QAAQ,KAAK,KAAK;AACrB;;AAGD,QAAI,KAAK,SAAS,MAAM;AACvB,WAAK,KAAK,OAAO,OAAO,OAAO;;AAGhC,QAAI,KAAK,OAAO,SAAS,KAAK,OAAO,OAAO;AAC3C,cAAQ,KAAK,IAAI;;AAIlB,QAAI,KAAK,MAAM,OAAO;AACrB;;AAGD,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,MAAM,OAAO,OAAO,OAAO;;EAElC;;;;;;;EAQA,YAAY,OAAe,SAAuB;AAEjD,QAAI,KAAK,OAAO,OAAO;AACtB,cAAQ,KAAK,IAAI;AACjB,UAAI,KAAK,SAAS,MAAM;AACvB,aAAK,KAAK,YAAY,OAAO,OAAO;;;AAItC,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,MAAM,YAAY,OAAO,OAAO;;EAEvC;;;;;EAMA,SAAS,UAAsC;AAC9C,aAAS,IAAI;AACb,QAAI,KAAK,SAAS,MAAM;AACvB,WAAK,KAAK,SAAS,QAAQ;;AAE5B,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,MAAM,SAAS,QAAQ;;EAE9B;;;;EAKA,eAAY;AACX,QAAI,KAAK,SAAS,QAAQ,KAAK,UAAU,MAAM;AAC9C,WAAK,SAAS,KAAK,IAAI,KAAK,KAAK,QAAQ,KAAK,MAAM,MAAM,IAAI;eACpD,KAAK,UAAU,MAAM;AAC/B,WAAK,SAAS,KAAK,MAAM,SAAS;eACxB,KAAK,SAAS,MAAM;AAC9B,WAAK,SAAS,KAAK,KAAK,SAAS;WAC3B;AACN,WAAK,SAAS;;EAEhB;;;;EAKA,YAAS;AACR,SAAK,MAAM,KAAK;AAChB,QAAI,KAAK,SAAS,MAAM;AACvB,WAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK,GAAG;;AAE5C,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,MAAM,KAAK,IAAI,KAAK,KAAK,KAAK,MAAM,GAAG;;EAE9C;;;;;EAMA,aAAU;AACT,QAAI,UAAU;AACd,QAAI,KAAK,SAAS,QAAQ,KAAK,UAAU,MAAM;AAC9C,gBAAU,KAAK,KAAK,SAAS,KAAK,MAAM;eAC9B,KAAK,SAAS,MAAM;AAC9B,gBAAU,KAAK,KAAK,SAAS;eACnB,KAAK,UAAU,MAAM;AAC/B,gBAAU,EAAE,KAAK,MAAM,SAAS;;AAEjC,WAAO;EACR;;;;EAKA,cAAW;AACV,WAAO,KAAK,WAAW,QAAQ,KAAK,OAAO,SAAS;EACrD;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EAEA,IAAI,KAAK,MAAyB;AACjC,SAAK,QAAQ;AACb,QAAI,SAAS,MAAM;AAClB,WAAK,SAAS;;AAEf,SAAK,aAAY;AACjB,SAAK,UAAS;EACf;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EAEA,IAAI,MAAM,MAAyB;AAClC,SAAK,SAAS;AACd,QAAI,SAAS,MAAM;AAClB,WAAK,SAAS;;AAEf,SAAK,aAAY;AACjB,SAAK,UAAS;EACf;;;;EAKA,UAAO;AACN,SAAK,SAAS;AACd,SAAK,QAAQ;AACb,SAAK,SAAS;AACd,SAAK,QAAQ;EACd;;;;ACvjBD;;;ACoBM,IAAO,SAAP,MAAO,gBAAe,cAA4B;EAiCvD,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;AAjC/D,SAAA,OAAe;AAkCvB,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC;AAEhF,SAAK,QAAQ,KAAK,SAAS,IAAI,KAAK;MACnC,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,OAAO;KACP;AACD,SAAK,SAAS,KAAK,OAAO;AAC1B,aAAS,MAAM,QAAQ;AACvB,SAAK,iBAAiB,QAAQ;AAG9B,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,QAAQ;KACR;EACF;;;;;;;;;EAUA,IAAI,OAAI;AACP,WAAO,KAAK,OAAO,UAAU;EAC9B;EACA,IAAI,KAAK,MAAa;AACrB,QAAI,CAAC,KAAK,QAAQ,MAAM;AACvB,WAAK,iBAAiB,KAAK,OAAO;AAElC,WAAK,OAAO,QAAQ;eACV,KAAK,QAAQ,CAAC,MAAM;AAC9B,WAAK,OAAO,QAAQ,KAAK;;EAE3B;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;AC/EK,IAAO,cAAP,MAAO,qBAAoB,cAAiC;EAkBjE,cAAA;AAEC,UAAM,qBAAqB,aAAY,YAAW,GAAI,SAAS,CAAC;AAlBxD,SAAA,OAAe;AAExB,SAAA,QAAgB,IAAI,OAAO,EAAE,SAAS,KAAK,QAAO,CAAE;AACpD,SAAA,SAAe,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAUjD,SAAA,SAA4B,KAAK,MAAM;AAMtC,UAAM,UAAU,qBAAqB,aAAY,YAAW,GAAI,SAAS;AAEzE,kBAAc,KAAK,OAAO,KAAK,QAAQ,KAAK,QAAQ,WAAW,WAAW;AAE1E,SAAK,OAAO,QAAQ;AACpB,SAAK,oBAAoB,CAAC,KAAK,OAAO,KAAK,QAAQ,WAAW,aAAa,KAAK,MAAM;EACvF;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,QAAQ;KACR;EACF;;;;;;;;;;EAWA,IAAI,OAAI;AACP,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,KAAK,MAAa;AACrB,SAAK,MAAM,OAAO;EACnB;;;;;;;;;;;EAYA,SAAS,MAAsC;AAC9C,SAAK,MAAM,WAAU;AACrB,SAAK,QAAQ,KAAK,KAAK;AACvB,SAAK,KAAK,KAAK,MAAM;AACrB,kBAAc,GAAG,IAAI;AACrB,WAAO;EACR;;;;;;EAOA,IAAI,kBAAe;AAClB,WAAO,KAAK,QAAQ,WAAW,YAAY;EAC5C;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;AAOD,cAAc,CAAAC,aAAU;AACvB,EAAAA,SAAQ,cAAc,IAAI,YAAY,EAAE,SAAAA,SAAO,CAAE;AAClD,CAAC;AAED,eAAe,CAAAA,aAAU;AACxB,EAAAA,SAAQ,YAAY,QAAO;AAC5B,CAAC;;;ACpHK,IAAO,gBAAP,cAAmC,KAAI;;;;EAiB5C,YAAY,cAAkB;AAE7B,UAAK;AAjBG,SAAA,OAAe;AAKhB,SAAA,YAAgD,IAAI,SAAS,EAAE,QAAQ,GAAE,CAAE;AAalF,SAAK,gBAAgB;EACtB;;;;EAKA,IAAI,OAAa,MAAa;AAC7B,SAAK,UAAU,IAAI;MAClB;MAAO;KACP;AACD,WAAO;EACR;;;;EAKA,IAAI,MAAa;AAChB,UAAM,QAAQ,KAAK,UAAU,IAAI,IAAI;AACrC,QAAI,OAAO;AACV,aAAO,MAAM;WACP;AACN,aAAO,KAAK;;EAEd;;;;ACtCK,IAAO,iBAAP,MAAO,gBAAc;;;;EA8B1B,YAAY,WAAsB,MAAoC;AApBtE,SAAA,KAAa,gBAAe;AAsB3B,UAAM,UAAiC,OAAO,OAAO,gBAAe,YAAW,GAAI,IAAI;AAEvF,SAAK,YAAY;AACjB,SAAK,WAAW,QAAQ;AACxB,SAAK,QAAQ,QAAQ;AACrB,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO;MACN,UAAU;MACV,MAAM;MACN,MAAM;;EAER;;;;;EAWA,OAAO,MAAa;AACnB,QAAI,KAAK,UAAU;AAClB,WAAK,SAAS,IAAI;AAClB,UAAI,KAAK,OAAO;AACf,aAAK,UAAU,MAAM,KAAK,EAAE;;;EAG/B;;;;EAKA,UAAO;AACN,SAAK,WAAW;AAChB,WAAO;EACR;;AArBe,eAAA,WAAW;;;ACnDrB,IAAO,uBAAP,MAAO,8BAA6B,eAAc;;;;EAwCvD,YAAY,WAAsB,MAA0C;AAE3E,UAAM,WAAW,IAAI;AA3Bd,SAAA,aAAa;AAKb,SAAA,UAAU;AAKV,SAAA,YAAY,KAAK;AAKjB,SAAA,gBAAgB,KAAK,SAAS,KAAK,IAAI;AAc9C,UAAM,UAAU,OAAO,OAAO,sBAAqB,YAAW,GAAI,IAAI;AAEtE,SAAK,WAAW,IAAI,WAAW,UAAU,SAAS,QAAQ,QAAQ,EAAE,QAAO;AAC3E,SAAK,YAAY,IAAI,WAAW,UAAU,SAAS,QAAQ,QAAQ,EAAE,QAAO;AAC5E,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,GAAG,SAAS,KAAK,aAAa;AAC7C,SAAK,UAAU,GAAG,aAAa,KAAK,aAAa;AACjD,SAAK,UAAU,KAAK,UAAU;AAC9B,SAAK,SAAQ;EACd;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,CAAA,GAAI,eAAe,YAAW,GAAI;MACtD,UAAU;MACV,UAAU;MACV,MAAM;KACN;EACF;;;;;;EAOA,OAAO,MAAa;AAEnB,SAAK,cAAc,IAAI;AAEvB,UAAM,OAAO,IAAI;EAClB;;;;EAKQ,cAAc,MAAa;AAElC,UAAM,QAAQ,KAAK,UAAU,eAAe,IAAI;AAChD,QAAI,SAAS,KAAK,QAAQ,SAAS,KAAK,aAAa,KAAK,YAAY,KAAK,YAAY,KAAK,OAAO,KAAK,UAAU;AACjH,WAAK,aAAa,KAAK;AACvB,WAAK,aAAa,KAAK;AACvB,WAAK,UAAU,KAAK,UAAU,aAAa,KAAK,OAAO,KAAK,IAAI,GAC/D,IAAI,WAAW,KAAK,SAAS,KAAK,SAAS,EAAE,UAAS,CAAE;;EAE3D;;;;EAKQ,SAAS,MAAW;AAC3B,SAAK,UAAU,MAAM,KAAK,UAAU;AACpC,SAAK,UAAU,MAAM,KAAK,OAAO;AACjC,SAAK,YAAY,KAAK;AACtB,UAAM,QAAQ,KAAK,UAAU,eAAe,IAAI;AAChD,QAAI,QAAQ,KAAK,MAAM;AACtB,WAAK,YAAY,KAAK,OAAO,KAAK,MAAM,QAAQ,KAAK,QAAQ,KAAK,SAAS,IAAI,KAAK;;AAErF,SAAK,aAAa,KAAK,UAAU,aAAa,KAAK,OAAO,KAAK,IAAI,GAClE,IAAI,WAAW,KAAK,SAAS,KAAK,SAAS,EAAE,UAAS,CAAE;AACzD,SAAK,aAAa,KAAK;AACvB,SAAK,UAAU,KAAK,UAAU,aAAa,KAAK,OAAO,KAAK,IAAI,GAC/D,IAAI,WAAW,KAAK,SAAS,KAAK,SAAS,EAAE,UAAS,CAAE;EAC1D;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,MAAM,KAAK,UAAU;AACpC,SAAK,UAAU,MAAM,KAAK,OAAO;AACjC,SAAK,UAAU,IAAI,SAAS,KAAK,aAAa;AAC9C,SAAK,UAAU,IAAI,aAAa,KAAK,aAAa;AAClD,WAAO;EACR;;;;ACnEK,IAAO,YAAP,MAAO,mBAAkB,gBAAiC;EAkG/D,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,SAAS,CAAC;AAlGtD,SAAA,OAAe;AAShB,SAAA,QAAgC,IAAI,cAAc,KAAK;AAKvD,SAAA,aAAoB;AAKpB,SAAA,WAAkB;AA6ClB,SAAA,mBAAmB,CAAA;AAKnB,SAAA,YAAsC,IAAI,SAAQ;AAKlD,SAAA,kBAAoC,IAAI,iBAAgB;AAKxD,SAAA,iBAAsC,CAAA;AActC,SAAA,eAA4B;AAMnC,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,SAAS;AAGvE,SAAK,OAAO,QAAQ;AACpB,SAAK,SAAS,IAAI,MAAM;MACvB,UAAU,KAAK,aAAa,KAAK,IAAI;MACrC,SAAS,KAAK;MACd,WAAW;MACX,OAAO;KACP;AACD,SAAK,iBAAgB;AACrB,SAAK,MAAM,KAAK,OAAO;AACvB,SAAK,OAAO,UAAU,aAAa,QAAQ;AAC3C,SAAK,IAAI,eAAe,QAAQ,KAAK,CAAC;AACtC,aAAS,MAAM,KAAK;AACpB,SAAK,iBAAiB,QAAQ;AAG9B,SAAK,cAAc,QAAQ,MAAM;EAClC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,gBAAgB,YAAW,GAAI;MACnD,KAAK;MACL,SAAS;MACT,WAAW;MACX,KAAK;MACL,OAAO;MACP,kBAAkB;MAClB,eAAe;KACf;EACF;;;;;;;;EAUQ,aAAa,UAAmB,OAAY;AAEnD,QAAI,KAAK,MAAM,IAAI,QAAQ,GAAG;AAC7B,UAAI,SAAS,KAAK,UAAU;AAC3B,aAAK,KAAK,WAAW,QAAQ;AAC7B,aAAK,OAAO,eAAe,KAAK,YAAY,QAAQ;AACpD,gBAAQ,KAAK;AACb,aAAK,KAAK,aAAa,UAAU,KAAK,OAAO,iBAAiB,QAAQ,CAAC;AACvE,aAAK,KAAK,QAAQ,QAAQ;;;AAI5B,QAAI,KAAK,eAAe,KACvB,QAAQ,KAAK,SAAS;IACtB,SAAS,KAAK,cAAc,OAAO,GAAG;AAEtC,YAAM,WAAY,SAAS,KAAK,cAAc,MAAO,KAAK,cAAc;AACxE,YAAM,SAAS,KAAK,IAAK,WAAY,KAAK,EAAE,IAAI,KAAK;AACrD,kBAAY,IAAI,WAAW,KAAK,SAAS,KAAK,cAAc,IAAI,CAAC,EAAE,UAAS,IAAK;;AAGlF,SAAK,UAAU,cAAc,OAAO,WAAS,MAAM,OAAO,QAAQ,CAAC;EACpE;;;;;;;;;;;;;;;;EAkBA,SAAS,UAA6B,MAAwC;AAC7E,UAAM,QAAQ,IAAI,eAAe,MAAM;MACtC;MACA,MAAM,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,QAAO;KACxD;AACD,WAAO,KAAK,UAAU,OAAO,KAAK,SAAS;EAC5C;;;;;;;;;;;;;;;;;EAkBA,eACC,UACA,UACA,WACA,WAAiB,UAAQ;AAEzB,UAAM,QAAQ,IAAI,qBAAqB,MAAM;MAC5C;MACA,UAAU,IAAI,UAAU,KAAK,SAAS,QAAQ,EAAE,QAAO;MACvD,UAAU,IAAI,UAAU,KAAK,SAAS,QAAQ,EAAE,QAAO;MACvD,MAAM,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,QAAO;KAC7D;AAGD,WAAO,KAAK,UAAU,OAAO,KAAK,eAAe;EAClD;;;;;;;EAQA,aAAa,UAA6B,MAAwC;AACjF,UAAM,QAAQ,IAAI,eAAe,MAAM;MACtC;MACA,MAAM;MACN,MAAM,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,QAAO;KACxD;AACD,WAAO,KAAK,UAAU,OAAO,KAAK,SAAS;EAC5C;;;;;EAMA,MAAM,SAAe;AACpB,QAAI,KAAK,iBAAiB,eAAe,OAAO,GAAG;AAClD,YAAM,OAAO,KAAK,iBAAiB,QAAQ,SAAQ,CAAE;AACrD,WAAK,SAAS,OAAO,KAAK,KAAK;AAC/B,WAAK,MAAM,QAAO;AAClB,aAAO,KAAK,iBAAiB,QAAQ,SAAQ,CAAE;;AAEhD,WAAO;EACR;;;;;;EAOQ,UAAU,OAAuB,UAAkC;AAC1E,SAAK,iBAAiB,MAAM,GAAG,SAAQ,CAAE,IAAI;MAC5C;MACA;;AAED,aAAS,IAAI,KAAK;AAClB,WAAO,MAAM;EACd;;;;;;;EAQA,OAAO,QAAuB,GAAC;AAC9B,UAAM,gBAAgB,KAAK,QAAQ,KAAK;AACxC,SAAK,UAAU,YAAY,eAAe,WAAS,KAAK,MAAM,MAAM,EAAE,CAAC;AACvE,SAAK,gBAAgB,YAAY,eAAe,WAAS,KAAK,MAAM,MAAM,EAAE,CAAC;AAC7E,WAAO;EACR;;;;;;;EASQ,mBAAgB;AACvB,SAAK,OAAO,GAAG,SAAS,CAAC,MAAM,WAAU;AACxC,eAAS,IAAI,WAAW,KAAK,SAAS,MAAM,EAAE,UAAS;AACvD,WAAK,KAAK,SAAS,MAAM,MAAM;IAChC,CAAC;AAED,SAAK,OAAO,GAAG,QAAQ,CAAC,SAAQ;AAC/B,WAAK,KAAK,QAAQ,IAAI;IACvB,CAAC;AAED,SAAK,OAAO,GAAG,SAAS,CAAC,SAAQ;AAChC,WAAK,KAAK,SAAS,IAAI;IACxB,CAAC;EACF;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO,eAAe,KAAK,IAAG,CAAE;EAC7C;;;;;;;;;EAUA,MAAM,MAAa,QAAsB;AACxC,QAAI;AACJ,QAAI,UAAU,MAAM,GAAG;AACtB,oBAAc,KAAK,QAAQ,MAAM;;AAGlC,SAAK,OAAO,MAAM,MAAM,WAAW;AACnC,WAAO;EACR;;;;;;;EAQA,KAAK,MAAW;AACf,SAAK,OAAO,KAAK,IAAI;AACrB,WAAO;EACR;;;;EAKA,MAAM,MAAW;AAChB,SAAK,OAAO,MAAM,IAAI;AACtB,WAAO;EACR;;;;;;EAOA,OAAO,MAAW;AACjB,WAAO,KAAK,UAAU,IAAI;AAC1B,QAAI,KAAK,OAAO,eAAe,IAAI,MAAM,WAAW;AACnD,WAAK,MAAM,IAAI;WACT;AACN,WAAK,KAAK,IAAI;;AAEf,WAAO;EACR;;;;;;;;;;;;;;;EAiBA,IAAI,gBAAa;AAChB,WAAO,KAAK;EACb;EACA,IAAI,cAAc,SAAsB;AACvC,QAAI,QAAQ,OAAO,GAAG;AACrB,gBAAW,QAAQ,CAAC,IAAI,QAAQ,CAAC,IAAK;;AAEvC,SAAK,iBAAiB;EACvB;;;;EAKA,IAAI,YAAS;AACZ,WAAO,IAAI,UAAU,KAAK,SAAS,KAAK,YAAY,GAAG,EAAE,UAAS;EACnE;EACA,IAAI,UAAU,eAAmB;AAChC,SAAK,aAAa,KAAK,QAAQ,aAAa;EAC7C;;;;EAKA,IAAI,UAAO;AACV,WAAO,IAAI,UAAU,KAAK,SAAS,KAAK,UAAU,GAAG,EAAE,UAAS;EACjE;EACA,IAAI,QAAQ,aAAiB;AAC5B,SAAK,WAAW,KAAK,QAAQ,WAAW;EACzC;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,MAAM,IAAI,KAAK,IAAG,CAAE;EACjC;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,MAAM,IAAI,MAAM,KAAK,IAAG,CAAE;EAChC;;;;;;;;EASA,cAAc,eAA8B,aAA0B;AACrE,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,WAAO;EACR;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,QAAmB;AAE5B,SAAK,eAAe;EACrB;;;;;;EAOA,IAAI,mBAAgB;AACnB,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,WAAW,EAAE,WAAU;EACjE;EACA,IAAI,iBAAiB,aAAwB;AAC5C,SAAK,cAAc,KAAK,QAAQ,WAAW;EAC5C;;;;;EAMA,IAAI,WAAQ;AACX,UAAMC,OAAM,KAAK,IAAG;AACpB,UAAM,QAAQ,KAAK,OAAO,eAAeA,IAAG;AAC5C,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,EAAE,sBAAqB;EACjE;EACA,IAAI,SAAS,UAAc;AAC1B,UAAM,QAAQ,KAAK,QAAQ,QAAQ;AACnC,SAAK,QAAQ;EACd;;;;;EAMA,IAAI,UAAO;AACV,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,QAAQ,GAAU;AACrB,UAAMA,OAAM,KAAK,IAAG;AACpB,UAAM,QAAQ,KAAK,OAAO,UAAU,YAAY,GAAGA,IAAG;AACtD,SAAK,QAAQ;EACd;;;;;EAMA,IAAI,WAAQ;AACX,QAAI,KAAK,MAAM;AACd,YAAMA,OAAM,KAAK,IAAG;AACpB,YAAM,QAAQ,KAAK,OAAO,eAAeA,IAAG;AAC5C,cAAQ,QAAQ,KAAK,eAAe,KAAK,WAAW,KAAK;WACnD;AACN,aAAO;;EAET;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,MAAM,GAAQ;AACjB,QAAI,KAAK,OAAO,UAAU,GAAG;AAC5B,YAAMA,OAAM,KAAK,IAAG;AAEpB,UAAI,KAAK,UAAU,WAAW;AAC7B,cAAM,QAAQ,KAAK,OAAO,eAAeA,IAAG;AAE5C,cAAM,gBAAgB,KAAK,OAAO,UAAU,mBAAmB,KAAK,KAAK,KAAK,IAAI,OAAOA,IAAG;AAC5F,cAAM,OAAOA,OAAM;AACnB,aAAK,KAAK,QAAQ,IAAI;AACtB,aAAK,OAAO,eAAe,GAAG,IAAI;AAElC,aAAK,KAAK,SAAS,MAAM,KAAK,OAAO,iBAAiB,IAAI,CAAC;aACrD;AACN,aAAK,OAAO,eAAe,GAAGA,IAAG;;;EAGpC;;;;;;EAOA,eAAe,MAAW;AACzB,WAAO,KAAK,MAAM,KAAK,OAAO,eAAe,IAAI,CAAC;EACnD;;;;;;EAOA,iBAAiB,MAAU;AAC1B,WAAO,KAAK,OAAO,iBAAiB,IAAI;EACzC;;;;;;;EAQA,IAAI,MAAG;AACN,WAAO,KAAK,OAAO,UAAU;EAC9B;EACA,IAAI,IAAI,KAAW;AAClB,SAAK,OAAO,UAAU,aAAa;EACpC;;;;;;;;;;;;;;;;EAkBA,gBAAgB,aAAkB;AACjC,kBAAc,KAAK,QAAQ,WAAW;AACtC,QAAI,KAAK,UAAU,WAAW;AAE7B,aAAO;WACD;AACN,YAAMA,OAAM,KAAK,IAAG;AAEpB,YAAM,eAAe,KAAK,eAAeA,IAAG;AAC5C,YAAM,iBAAiB,cAAc,eAAe;AACpD,aAAO,KAAK,OAAO,aAAa,gBAAgBA,IAAG;;EAErD;;;;;;;;;;EAWA,WAAW,QAAqB,OAAc;AAC7C,QAAI,CAAC,OAAO;AAEX,YAAMA,OAAM,KAAK,IAAG;AACpB,UAAI,OAAO,eAAeA,IAAG,MAAM,GAAG;AACrC,cAAM,MAAM,KAAK,IAAI,eAAeA,IAAG;AACvC,cAAM,eAAe,KAAK,KAAK,MAAM,KAAK;AAC1C,gBAAQ,OAAO,eAAeA,IAAG,IAAI;aAC/B;AACN,gBAAQ;;;AAGV,UAAM,cAAc,IAAI,KAAK,KAAK;AAElC,SAAK,IAAI,QAAQ,WAAW;AAE5B,gBAAY,QAAQ,OAAO,MAAM;AACjC,SAAK,eAAe,KAAK;MACxB,SAAS,OAAO;MAChB,OAAO;MACP;KACA;AACD,WAAO,QAAQ;AACf,WAAO;EACR;;;;;EAMA,aAAa,QAAmB;AAC/B,aAAS,IAAI,KAAK,eAAe,SAAS,GAAG,KAAK,GAAG,KAAK;AACzD,YAAM,eAAe,KAAK,eAAe,CAAC;AAC1C,UAAI,aAAa,WAAW,QAAQ;AACnC,qBAAa,MAAM,QAAO;AAC1B,qBAAa,OAAO,QAAQ,aAAa;AACzC,aAAK,eAAe,OAAO,GAAG,CAAC;;;AAGjC,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,aAAS,MAAM,KAAK;AACpB,SAAK,UAAU,QAAO;AACtB,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;AAYD,QAAQ,MAAM,SAAS;AAMvB,cAAc,CAAAC,aAAU;AACvB,EAAAA,SAAQ,YAAY,IAAI,UAAU,EAAE,SAAAA,SAAO,CAAE;AAC9C,CAAC;AAED,eAAe,CAAAA,aAAU;AACxB,EAAAA,SAAQ,UAAU,QAAO;AAC1B,CAAC;;;ACnrBK,IAAgB,SAAhB,cAA8D,cAAsB;EA2DzF,YAAY,SAAsB;AACjC,UAAM,OAAO;AA7Cd,SAAA,QAAQ;AAkBE,SAAA,SAQL,IAAI,cAAc,SAAS;AAKtB,SAAA,UAAU;AAKZ,SAAA,aAAuB,CAAA;AAKvB,SAAA,eAAyD;AACzD,SAAA,cAAuC;AAI9C,SAAK,OAAO,SAAS;AACrB,SAAK,OAAO,aAAa;AAEzB,SAAK,UAAU,KAAK,SAAS,IAAI,OAAO;MACvC,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,QAAQ,QAAQ;KAChB;AACD,SAAK,SAAS,KAAK,QAAQ;AAC3B,aAAS,MAAM,QAAQ;AACvB,SAAK,SAAS,QAAQ;EACvB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,QAAQ;MACR,QAAQ;KACR;EACF;;;;;;;;;EAUA,IAAI,QAAK;AACR,QAAI,KAAK,SAAS;AACjB,UAAI,KAAK,QAAQ,UAAU,UAAU,WAAW;AAC/C,eAAO,KAAK,OAAO,eAAe,KAAK,QAAQ,UAAU,OAAO;aAC1D;AACN,eAAO;;WAEF;AACN,aAAO,KAAK,OAAO,eAAe,KAAK,IAAG,CAAE;;EAE9C;;;;;;;;EASA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAa;AACrB,SAAK,QAAQ,OAAO;EACrB;;;;;EAWQ,oBAAoB,MAAa;AACxC,QAAI,KAAK,SAAS;AACjB,aAAO;WACD;AACN,aAAO,KAAK,IAAI,MAAM,KAAK,QAAQ,WAAW;;EAEhD;;;;;;;;;EAUA,MAAM,MAAa,QAAe,UAAe;AAChD,QAAI,eAAe,QAAQ,IAAI,KAAK,KAAK,UAAU,KAAK,QAAQ,UAAU,UAAU,KAAK,UAAU,IAAI;AACvG,mBAAe,KAAK,oBAAoB,YAAY;AAEpD,QAAI,CAAC,KAAK,WAAW,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAE5E,aAAO,GAAG,cAAe,KAAK,OAAO,IAAI,YAAY,EAAyB,IAAI,GAAG,8DAA8D;AACnJ,WAAK,OAAO,OAAO,YAAY;AAC/B,WAAK,OAAO,eAAe,WAAW,YAAY;AAClD,WAAK,IAAI,WAAW,YAAY;AAChC,WAAK,QAAQ,cAAc,QAAQ,QAAQ;WACrC;AACN,WAAK,IAAI,SAAS,YAAY;AAC9B,WAAK,OAAO,eAAe,WAAW,YAAY;AAClD,UAAI,KAAK,SAAS;AAEjB,cAAM,QAAQ,KAAK,OAAO,IAAI,YAAY;AAC1C,YAAI,OAAO;AACV,gBAAM,SAAS,KAAK,UAAU,WAAW,QAAQ,CAAC,CAAC;AACnD,gBAAM,WAAW,WAAW,KAAK,UAAU,QAAQ,IAAI;;AAExD,cAAM,QAAQ,KAAK,QAAQ,UAAU,SAAS,OAAI;AACjD,eAAK,OAAO,GAAG,QAAQ,QAAQ;QAChC,GAAG,YAAY;AACf,aAAK,WAAW,KAAK,KAAK;AAI1B,YAAI,KAAK,QAAQ,UAAU,UAAU,aACpC,KAAK,QAAQ,UAAU,iBAAiB,KAAK,UAAS,CAAE,IAAI,cAAc;AAC1E,eAAK,aAAa,KAAK,IAAG,GAAI,KAAK,QAAQ,UAAU,OAAO;;aAEvD;AACN,6BAAqB,KAAK,OAAO;AACjC,aAAK,OAAO,cAAc,QAAQ,QAAQ;;;AAG5C,WAAO;EACR;;;;;;;;;;EAWA,KAAK,MAAW;AACf,QAAI,eAAe,QAAQ,IAAI,KAAK,KAAK,UAAU,KAAK,QAAQ,UAAU,UAAU,KAAK,UAAU,IAAI;AACvG,mBAAe,KAAK,oBAAoB,YAAY;AACpD,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,aAAa,UAAU,KAAK,OAAO,aAAa,WAAW,YAAY,CAAC,GAAG;AAC3H,WAAK,IAAI,QAAQ,YAAY;AAC7B,UAAI,CAAC,KAAK,SAAS;AAClB,aAAK,MAAM,YAAY;aACjB;AACN,cAAM,QAAQ,KAAK,QAAQ,UAAU,SAAS,KAAK,MAAM,KAAK,IAAI,GAAG,YAAY;AACjF,aAAK,WAAW,KAAK,KAAK;;AAE3B,WAAK,OAAO,OAAO,YAAY;AAC/B,WAAK,OAAO,eAAe,WAAW,YAAY;;AAEnD,WAAO;EACR;;;;EAKA,QAAQ,MAAa,QAAe,UAAe;AAClD,WAAO,KAAK,UAAU,IAAI;AAC1B,QAAI,KAAK,OAAO,eAAe,IAAI,MAAM,WAAW;AACnD,WAAK,OAAO,OAAO,IAAI;AACvB,WAAK,SAAS,MAAM,QAAQ,QAAQ;;AAErC,WAAO;EACR;;;;;;;;;;;;;;;;EAiBA,OAAI;AACH,QAAI,CAAC,KAAK,SAAS;AAClB,WAAK,UAAU;AACf,WAAK,eAAe,CAAC,MAAM,WAAU;AACpC,YAAI,SAAS,GAAG;AAEf,gBAAM,aAAa,KAAK,OAAO,IAAI,MAAM;AAEzC,cAAI,cAAc,WAAW,UAAU,aAAa,WAAW,SAAS,QAAQ;AAE/E,kBAAM,cAAc,SAAS,KAAK,UAAU,WAAW,IAAI;AAC3D,gBAAI;AACJ,gBAAI,WAAW,UAAU;AACxB,yBAAW,KAAK,UAAU,WAAW,QAAQ,IAAI;;AAElD,iBAAK,OAAO,MAAM,KAAK,UAAU,WAAW,MAAM,IAAI,aAAa,QAAQ;;;MAG9E;AACA,WAAK,cAAc,UAAO;AACzB,cAAM,UAAU,KAAK,QAAQ,UAAU,iBAAiB,KAAK,IAAI,OAAO,KAAK,YAAY,CAAC,CAAC;AAC3F,YAAI,KAAK,OAAO,eAAe,OAAO,MAAM,WAAW;AACtD,eAAK,MAAM,IAAI;;MAEjB;AACA,WAAK,QAAQ,UAAU,GAAG,SAAS,KAAK,YAAY;AACpD,WAAK,QAAQ,UAAU,GAAG,aAAa,KAAK,YAAY;AACxD,WAAK,QAAQ,UAAU,GAAG,QAAQ,KAAK,WAAW;AAClD,WAAK,QAAQ,UAAU,GAAG,SAAS,KAAK,WAAW;AACnD,WAAK,QAAQ,UAAU,GAAG,WAAW,KAAK,WAAW;;AAEtD,WAAO;EACR;;;;EAKA,SAAM;AACL,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,UAAU,IAAI,QAAQ,KAAK,WAAW;AACnD,WAAK,QAAQ,UAAU,IAAI,SAAS,KAAK,WAAW;AACpD,WAAK,QAAQ,UAAU,IAAI,WAAW,KAAK,WAAW;AACtD,WAAK,QAAQ,UAAU,IAAI,SAAS,KAAK,YAAY;AACrD,WAAK,QAAQ,UAAU,IAAI,aAAa,KAAK,YAAY;;AAE1D,SAAK,UAAU;AAEf,SAAK,WAAW,QAAQ,QAAM,KAAK,QAAQ,UAAU,MAAM,EAAE,CAAC;AAC9D,SAAK,aAAa,CAAA;AAClB,SAAK,OAAO,OAAO,CAAC;AAEpB,SAAK,MAAM,CAAC;AACZ,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,SAAS;AACd,SAAK,OAAM;AACX,SAAK,QAAQ,QAAO;AACpB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACnTK,IAAO,mBAAP,MAAO,0BAAyB,cAAsC;EAgC3E,cAAA;AAEC,UAAM,qBAAqB,kBAAiB,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC,CAAC;AAhChF,SAAA,OAAe;AAKhB,SAAA,UAAU,KAAK,QAAQ,mBAAkB;AACvC,SAAA,oBAAoB,CAAC,KAAK,OAAO;AAenC,SAAA,iBAAiB;AACjB,SAAA,iBAAiB;AAWxB,UAAM,UAAU,qBAAqB,kBAAiB,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC;AAEjG,YAAQ,KAAK,SAAS,KAAK,SAAS;AACpC,SAAK,QAAQ,UAAU,MAAM,KAAK,YAAW;AAK7C,SAAK,eAAe,IAAI,MAAM;MAC7B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO;MACP,OAAO,QAAQ;KACf;AAGD,SAAK,OAAO,QAAQ;AACpB,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AACvB,SAAK,UAAU,IAAI,gBAAgB,QAAQ,KAAK,QAAQ,QAAQ,QAAQ,OAAO;AAE/E,SAAK,kBAAkB,KAAK,KAAK,OAAO;EACzC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,KAAK,IAAI,gBAAe;MACxB,MAAM;MACN,SAAS;MACT,WAAW;MACX,QAAQ;MACR,SAAS;MACT,cAAc;KACd;EACF;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,GAAO;AACjB,SAAK,UAAU;EAChB;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,GAAO;AAClB,SAAK,WAAW;EACjB;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,GAAC;AACV,SAAK,SAAS;EACf;;;;;;;;EASA,MAAM,MAAa,QAAe,UAAiB,OAAmB,GAAC;AACtE,WAAO,KAAK,OAAO,QAAQ,wCAAwC;AACnE,UAAM,eAAe,KAAK,UAAU,IAAI;AAGxC,SAAK,WAAW,cAAc,IAAI;AAGlC,QAAI,KAAK,MAAM;AACd,eAAS,WAAW,QAAQ,KAAK,SAAS;WACpC;AAEN,eAAS,WAAW,QAAQ,CAAC;;AAG9B,QAAI,iBAAiB,KAAK,IAAI,KAAK,UAAU,MAAM,GAAG,CAAC;AAGvD,QAAI,KAAK,MAAM;AAEd,YAAM,UAAU,KAAK,UAAU,KAAK,OAAO,KAAK,KAAK,OAAO;AAC5D,YAAM,YAAY,KAAK,UAAU,KAAK,SAAS;AAC/C,YAAM,eAAe,UAAU;AAE/B,UAAI,IAAI,gBAAgB,OAAO,GAAG;AACjC,0BAAmB,iBAAiB,aAAa,eAAgB;;AAGlE,UAAI,GAAG,gBAAgB,KAAK,OAAO,QAAQ,GAAG;AAC7C,yBAAiB;;;AAKnB,SAAK,QAAQ,SAAS,KAAK,OAAO,IAAG;AACrC,SAAK,QAAQ,UAAU,KAAK,UAAU,KAAK,OAAO,KAAK,KAAK,OAAO;AACnE,QAAI,GAAG,gBAAgB,KAAK,OAAO,QAAQ,GAAG;AAC7C,WAAK,iBAAiB;AACtB,WAAK,QAAQ,MAAM,cAAc,cAAc;;AAIhD,QAAI,UAAU,QAAQ,GAAG;AACxB,UAAI,cAAc,KAAK,UAAU,QAAQ;AAEzC,oBAAc,KAAK,IAAI,aAAa,CAAC;AACrC,WAAK,KAAK,eAAe,WAAW;;AAGrC,WAAO;EACR;EAEU,YAAY,MAAc;AACnC,QAAI,CAAC,KAAK,kBAAkB,KAAK,gBAAgB;AAChD,WAAK,iBAAiB;AACtB,WAAK,QAAQ,KAAK,KAAK,UAAU,IAAI,CAAC;AACtC,WAAK,SAAQ;;EAEf;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,UAAU,WAAe;AAC5B,SAAK,QAAQ,YAAY,KAAK,UAAU,SAAS;EAClD;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,QAAQ,SAAa;AACxB,SAAK,QAAQ,UAAU,KAAK,UAAU,OAAO;EAC9C;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,QAAuB;AACjC,SAAK,QAAQ,IAAI,MAAM;EACxB;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAa;AACrB,SAAK,QAAQ,OAAO;AACpB,QAAI,KAAK,gBAAgB;AACxB,WAAK,WAAU;;EAEjB;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,UAAU;AACvB,SAAK,QAAQ,WAAU;AACvB,SAAK,QAAQ,QAAO;AACpB,SAAK,aAAa,QAAO;AACzB,WAAO;EACR;;;;ACvNK,IAAO,QAAP,MAAO,eAAc,OAAoB;EAmC9C,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC,CAAC;AAlC5D,SAAA,OAAe;AAKhB,SAAA,UAAmC;AA8B1C,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC;AAE7E,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,OAAO,QAAQ;AACpB,SAAK,UAAU,QAAQ;AACvB,SAAK,WAAW,QAAQ;EACzB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,QAAQ;MACR,SAAS;MACT,cAAc;MACd,MAAM;KACN;EACF;;;;;;;EAQA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAe;AACvB,WAAO,QAAQ,eAAe,0BAA0B,IAAI;AAC5D,QAAI,KAAK,UAAU,MAAM;AACxB,WAAK,QAAQ;AAEb,UAAI,KAAK,UAAU,WAAW;AAC7B,cAAMC,OAAM,KAAK,IAAG;AACpB,aAAK,MAAMA,IAAG;AACd,aAAK,OAAOA,IAAG;;;EAGlB;;;;;EAMA,IAAI,eAAY;AACf,WAAO,KAAK;EACb;EACA,IAAI,aAAa,MAAc;AAC9B,SAAK,gBAAgB;AACrB,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,aAAa,QAAQ;;EAEpC;;;;EAKU,OAAO,MAAW;AAC3B,UAAM,SAAS,cAAc,KAAK,KAAK;AACvC,SAAK,UAAU,IAAI,iBAAiB;MACnC,KAAK;MACL,SAAS,KAAK;MACd,QAAQ,KAAK;MACb,SAAS,KAAK;MACd,MAAM;MACN,SAAS,MAAM,KAAK,OAAO,IAAI;MAC/B,cAAc,KAAK;KACnB,EAAE,QAAQ,KAAK,MAAM;AACtB,SAAK,QAAQ,MAAM,KAAK,UAAU,IAAI,GAAG,KAAK,OAAM,KAAM,OAAO,WAAW,KAAM;EACnF;;;;EAKU,MAAM,MAAW;AAC1B,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,KAAK,KAAK,UAAU,IAAI,CAAC;AACtC,WAAK,UAAU;;EAEjB;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,MAAI;AACd,SAAK,UAAU;AACf,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,SAAS,KAAK;;EAE7B;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,MAAI;AACf,SAAK,WAAW;AAChB,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,UAAU,KAAK;;EAE9B;EAEU,SAAS,MAAW;AAE7B,SAAK,MAAM,IAAI;AACf,SAAK,OAAO,IAAI;EACjB;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,WAAU;;AAExB,WAAO;EACR;;AAQD,IAAM,gBAAgB,QAAQ;AAC9B,IAAM,eAAe;AAYrB,IAAM,cAA0B;EAC/B,OAAO;EACP,MAAM;EACN,OAAO;;AAQR,IAAM,gBAAgB;EACrB,IAAI,QAAK;AACR,QAAI,CAAC,YAAY,OAAO;AACvB,YAAM,SAAyB,CAAA;AAC/B,eAAS,aAAa,GAAG,aAAa,cAAc,cAAc;AACjE,cAAM,UAAU,IAAI,aAAa,aAAa;AAC9C,eAAO,UAAU,IAAI;AACrB,YAAI,UAAU;AACd,iBAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACvC,gBAAM,QAAQ,KAAK,OAAM,IAAK,IAAI;AAClC,kBAAQ,CAAC,KAAK,UAAW,OAAO,SAAU;AAC1C,oBAAU,QAAQ,CAAC;AACnB,kBAAQ,CAAC,KAAK;;;AAGhB,kBAAY,QAAQ,IAAI,gBAAe,EAAG,UAAU,MAAM;;AAE3D,WAAO,YAAY;EACpB;EAEA,IAAI,OAAI;AACP,QAAI,CAAC,YAAY,MAAM;AACtB,YAAM,SAAyB,CAAA;AAC/B,eAAS,aAAa,GAAG,aAAa,cAAc,cAAc;AACjE,cAAM,UAAU,IAAI,aAAa,aAAa;AAC9C,eAAO,UAAU,IAAI;AACrB,YAAI,IAAI,IAAI,IAAI,IAAI,IAAI,IAAI;AAC5B,aAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK;AACnC,iBAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACvC,gBAAM,QAAQ,KAAK,OAAM,IAAK,IAAI;AAClC,eAAK,UAAU,KAAK,QAAQ;AAC5B,eAAK,UAAU,KAAK,QAAQ;AAC5B,eAAK,QAAU,KAAK,QAAQ;AAC5B,eAAK,SAAU,KAAK,QAAQ;AAC5B,eAAK,OAAU,KAAK,QAAQ;AAC5B,eAAK,UAAU,KAAK,QAAQ;AAC5B,kBAAQ,CAAC,IAAI,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,KAAK,QAAQ;AACxD,kBAAQ,CAAC,KAAK;AACd,eAAK,QAAQ;;;AAGf,kBAAY,OAAO,IAAI,gBAAe,EAAG,UAAU,MAAM;;AAE1D,WAAO,YAAY;EACpB;EAEA,IAAI,QAAK;AACR,QAAI,CAAC,YAAY,OAAO;AACvB,YAAM,SAAyB,CAAA;AAC/B,eAAS,aAAa,GAAG,aAAa,cAAc,cAAc;AACjE,cAAM,UAAU,IAAI,aAAa,aAAa;AAC9C,eAAO,UAAU,IAAI;AACrB,iBAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACvC,kBAAQ,CAAC,IAAI,KAAK,OAAM,IAAK,IAAI;;;AAGnC,kBAAY,QAAQ,IAAI,gBAAe,EAAG,UAAU,MAAM;;AAE3D,WAAO,YAAY;EACpB;;;;AC5PK,IAAO,YAAP,MAAO,mBAAkB,cAA+B;EAqC7D,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC,CAAC;AArClE,SAAA,OAAe;AAsCvB,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,QAAQ,CAAC;AAEnF,SAAK,UAAU,KAAK,SAAS,IAAI,OAAO;MACvC,SAAS,KAAK;MACd,QAAQ,QAAQ;KAChB;AACD,SAAK,SAAS,KAAK,QAAQ;AAC3B,aAAS,MAAM,QAAQ;AACvB,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,QAAQ;KACR;EACF;;;;;;;;;EAUM,KAAK,WAA2B;;AACrC,aAAO,WAAU,WAAW,4BAA4B;AAExD,UAAI,KAAK,UAAU,WAAW;AAC7B,aAAK,MAAK;;AAEX,YAAM,UAAU,MAAM,WAAU,iBAAgB;AAChD,UAAI,SAAS,SAAS,GAAG;AACxB,aAAK,UAAU,QAAQ,SAAS;aAC1B;AACN,aAAK,UAAU,QAAQ,KAAK,CAAC,WAAU;AACtC,iBAAO,OAAO,UAAU,aAAa,OAAO,aAAa;QAC1D,CAAC;AAED,YAAI,CAAC,KAAK,WAAW,QAAQ,SAAS,GAAG;AACxC,eAAK,UAAU,QAAQ,CAAC;;AAEzB,eAAO,UAAU,KAAK,OAAO,GAAG,sBAAsB,SAAS,EAAE;;AAGlE,YAAM,cAAc;QACnB,OAAO;UACN,kBAAkB;UAClB,YAAY,KAAK,QAAQ;UACzB,kBAAkB;UAClB,qBAAqB;;;AAGvB,UAAI,KAAK,SAAS;AAEjB,oBAAY,MAAM,WAAW,KAAK,QAAQ;;AAE3C,YAAM,SAAS,MAAM,UAAU,aAAa,aAAa,WAAW;AAEpE,UAAI,CAAC,KAAK,SAAS;AAClB,aAAK,UAAU;AAEf,cAAM,kBAAkB,KAAK,QAAQ,wBAAwB,MAAM;AAEnE,gBAAQ,iBAAiB,KAAK,MAAM;AACpC,aAAK,eAAe;;AAErB,aAAO;IACR,CAAC;;;;;EAKD,QAAK;AACJ,QAAI,KAAK,WAAW,KAAK,cAAc;AACtC,WAAK,QAAQ,eAAc,EAAG,QAAQ,CAAC,UAAS;AAC/C,cAAM,KAAI;MACX,CAAC;AACD,WAAK,UAAU;AAEf,WAAK,aAAa,WAAU;AAC5B,WAAK,eAAe;;AAErB,SAAK,UAAU;AACf,WAAO;EACR;;;;;;;;;;EAWA,OAAa,mBAAgB;;AAC5B,YAAM,aAAa,MAAM,UAAU,aAAa,iBAAgB;AAChE,aAAO,WAAW,OAAO,YAAS;AACjC,eAAO,OAAO,SAAS;MACxB,CAAC;IACF,CAAC;;;;;;EAMD,IAAI,QAAK;AACR,WAAO,KAAK,WAAW,KAAK,QAAQ,SAAS,YAAY;EAC1D;;;;;;;;;EAUA,IAAI,WAAQ;AACX,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO;;EAET;;;;;;EAOA,IAAI,UAAO;AACV,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO;;EAET;;;;;;EAOA,IAAI,QAAK;AACR,QAAI,KAAK,SAAS;AACjB,aAAO,KAAK,QAAQ;WACd;AACN,aAAO;;EAET;;;;;;;;;;;EAYA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ,OAAO;EACrB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAK;AACV,SAAK,QAAQ,QAAO;AACpB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;EAKA,WAAW,YAAS;AACnB,WAAO,UAAU,UAAU,YAAY,KACtC,UAAU,UAAU,aAAa,YAAY;EAC/C;;;;ACrJK,SAAgB,iBAAiB,UAAe,QAAc;;AACnE,UAAM,WAAW,SAAS,SAAS,QAAQ;AAC3C,UAAMC,WAAU,IAAI,eAAe,GAAG,UAAU,SAAS,QAAQ,UAAU;AAC3E,UAAM,QAAQ,IAAI,SAAS,YAAY,OAAO,OAAO,SAAS,IAAG,GAAI;;MAEpE,WAAW,IAAI;;MAEf,QAAQ;MACR,SAAAA;KACA,CAAC,EAAE,cAAa;AACjB,UAAM,MAAM,CAAC;AACb,UAAM,SAAS,MAAMA,SAAQ,OAAM;AACnC,WAAO,OAAO,eAAe,CAAC;EAC/B,CAAC;;;;ACvGK,IAAO,qBAAP,MAAO,4BAA2B,cAAwC;EA6B/E,cAAA;AAEC,UAAM,qBAAqB,oBAAmB,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC,CAAC;AA7BtF,SAAA,OAAe;AAKhB,SAAA,cAAc,KAAK,QAAQ,iBAAgB;AACzC,SAAA,oBAAoB,CAAC,KAAK,WAAW;AAwB9C,UAAM,UAAU,qBAAqB,oBAAmB,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC;AAEvG,YAAQ,KAAK,aAAa,KAAK,SAAS;AAExC,SAAK,OAAO,QAAQ;AAEpB,SAAK,YAAY,IAAI,MAAM;MAC1B,SAAS,KAAK;MACd,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,SAAS,IAAI,MAAM;MACvB,SAAS,KAAK;MACd,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAED,aAAS,MAAM,CAAC,aAAa,QAAQ,CAAC;EACvC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,QAAQ;MACR,WAAW;MACX,MAAM;KACN;EACF;;;;;EAMA,MAAM,MAAW;AAChB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,IAAI,SAAS,YAAY;AAC9B,SAAK,WAAW,YAAY;AAC5B,SAAK,YAAY,MAAM,YAAY;AACnC,WAAO;EACR;EAEU,YAAY,MAAc;AACnC,SAAK,YAAY,KAAK,IAAI;EAC3B;;;;;EAMA,gBAAgB,cAA0B;AACzC,SAAK,YAAY,gBAAgB,YAAY;AAC7C,WAAO;EACR;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,KAAK,MAAoB;AAC5B,SAAK,YAAY,OAAO;EACzB;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,QAAI,KAAK,UAAU,WAAW;AAC7B,WAAK,KAAI;;AAEV,SAAK,YAAY,WAAU;AAC3B,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACzGK,IAAO,aAAP,MAAO,oBAAmB,OAA6B;EAkD5D,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC,CAAC;AAlD9E,SAAA,OAAe;AAKhB,SAAA,cAAyC;AA8ChD,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC;AAE/F,SAAK,YAAY,IAAI,OAAoB;MACxC,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,aAAS,MAAM,WAAW;AAE1B,SAAK,SAAS,IAAI,OAAgB;MACjC,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,aAAS,MAAM,QAAQ;AAEvB,SAAK,YAAY,QAAQ;AACzB,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,QAAQ,QAAQ;AAErB,QAAI,QAAQ,gBAAgB,QAAQ,SAAS,UAAU;AACtD,WAAK,QAAQ,KAAK,WAAW,QAAQ,aAAa,SAAQ;;AAE3D,SAAK,QAAQ,QAAQ;EACtB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,QAAQ;MACR,WAAW;MACX,cAAc;MACd,UAAU,CAAA;MACV,OAAO;MACP,MAAM;KACN;EACF;;;;EAKU,OAAO,MAAW;AAC3B,UAAM,eAAe,KAAK,UAAU,IAAI;AAExC,UAAM,aAAa,IAAI,mBAAmB;MACzC,SAAS,KAAK;MACd,SAAS,MAAM,KAAK,OAAO,IAAI;KAC/B;AACD,SAAK,cAAc;AACnB,QAAI,KAAK,OAAO;AACf,WAAK,YAAY,gBAAgB,KAAK,KAAK;WACrC;AACN,WAAK,YAAY,OAAO,KAAK;;AAG9B,SAAK,YAAY,QAAQ,KAAK,MAAM;AACpC,SAAK,UAAU,QAAQ,KAAK,YAAY,SAAS;AACjD,SAAK,OAAO,QAAQ,KAAK,YAAY,MAAM;AAG3C,SAAK,YAAY,MAAM,YAAY;EACpC;;;;EAKU,MAAM,MAAW;AAC1B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,QAAI,KAAK,aAAa;AACrB,WAAK,YAAY,KAAK,YAAY;;EAEpC;;;;;EAMU,SAAS,MAAW;AAC7B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,IAAI,WAAW,YAAY;AAChC,QAAI,KAAK,aAAa;AACrB,WAAK,YAAY,WAAU;;AAE5B,SAAK,OAAO,OAAO,YAAY;AAC/B,WAAO;EACR;;;;;;;;;;;;;EAcA,gBAAa;AACZ,SAAK,QAAQ,UAAU,WAAW,KAAK,SAAS;AAChD,WAAO;EACR;;;;;EAMA,kBAAe;AACd,SAAK,QAAQ,UAAU,aAAa,KAAK,SAAS;AAClD,WAAO;EACR;;;;;;EAoBQ,yBAAsB;AAC7B,QAAI,KAAK,UAAU,UAAU;AAC5B,YAAM,WAAW,YAAW,mBAAmB,KAAK,iBAAc;AACjE,eAAO,YAAY,UAAU,KAAK,UACjC,WAAW,YAAY,UAAU,KAAK,SAAS;MACjD,CAAC;AACD,aAAO;WACD;AACN,YAAM,WAAW,YAAW,mBAAmB,KAAK,iBAAc;AACjE,eAAO,YAAY,SAAS,KAAK,SAChC,YAAY,UAAU,KAAK;MAC7B,CAAC;AACD,WAAK,gBAAgB,WAAW,SAAS,eAAe,KAAK;AAC7D,aAAO;;EAET;EAEA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ;AACb,UAAM,cAAc,CAAC,QAAQ,UAAU,YAAY,UAAU,EAAE,QAAQ,IAAI,MAAM;AACjF,QAAI,KAAK,WAAW,KAAK,aAAa;AACrC,WAAK,QAAQ;AACb,WAAK,gBAAgB;AAErB,UAAI,KAAK,gBAAgB,MAAM;AAE9B,aAAK,YAAY,OAAO;;WAEnB;AAEN,YAAM,QAAQ,KAAK,uBAAsB;AACzC,UAAI,UAAU,KAAK,GAAG;AACrB,cAAM,EAAE,UAAU,KAAI,IAAK;AAC3B,aAAK,QAAQ;AACb,aAAK,YAAY;AACjB,YAAI,KAAK,gBAAgB,MAAM;AAC9B,eAAK,YAAY,gBAAgB,KAAK,KAAK;;aAEtC;AACN,cAAM,CAAC,MAAM,IAAI,IAAI,KAAK,kBAAkB,MAAM,KAAK,MAAM;AAC7D,cAAM,eAAe,KAAK,QAAQ,mBAAmB,MAAM,IAAI;AAC/D,aAAK,QAAQ;AACb,YAAI,KAAK,gBAAgB,MAAM;AAC9B,eAAK,YAAY,gBAAgB,KAAK,KAAK;;AAG5C,oBAAW,mBAAmB,KAAK;UAClC;UACA,cAAc,KAAK;UACnB,UAAU,KAAK;UACf,OAAO,KAAK;UACZ;UACA,MAAM,KAAK;UACX,MAAM,KAAK;SACX;AACD,YAAI,YAAW,mBAAmB,SAAS,KAAK;AAC/C,sBAAW,mBAAmB,MAAK;;;;EAIvC;EAEA,IAAI,WAAQ;AACX,WAAQ,KAAK,MAAiB,QAAQ,KAAK,aAAa,SAAQ,GAAI,EAAE;EACvE;EACA,IAAI,SAAS,UAAQ;AACpB,QAAI,KAAK,gBAAgB,KAAK,UAAU,YAAY,aAAa,UAAU;AAC1E,WAAK,OAAO,WAAW,KAAK;WACtB;AACN,WAAK,OAAO;;EAEd;EAEA,IAAI,eAAY;AACf,WAAO,KAAK;EACb;EACA,IAAI,aAAa,GAAC;AACjB,gBAAY,GAAG,CAAC;AAChB,QAAI,OAAO,KAAK;AAChB,UAAM,UAAU,yCAAyC,KAAK,KAAK,KAAK;AACxE,QAAI,SAAS;AACZ,aAAO,QAAQ,CAAC;;AAEjB,QAAI,KAAK,UAAU,UAAU;AAC5B,UAAI,MAAM,GAAG;AACZ,aAAK,OAAO;aACN;AACN,aAAK,OAAO,OAAO,EAAE,SAAQ;;WAExB;AAEN,YAAM,eAAe,IAAI,aAAa,CAAC;AAEvC,WAAK,UAAU,QAAQ,CAAC,GAAG,MAAM,aAAa,CAAC,IAAI,CAAC;AACpD,WAAK,YAAY,MAAM,KAAK,YAAY;AACxC,WAAK,OAAO,KAAK;;EAEnB;;;;;;EAOQ,kBAAkB,MAA0B,OAAc;AACjE,UAAM,UAAU;AAChB,QAAI,mBAAmB,UAAU;AAEjC,UAAM,OAAO,IAAI,aAAa,gBAAgB;AAC9C,UAAM,OAAO,IAAI,aAAa,gBAAgB;AAE9C,QAAI,eAAe;AACnB,QAAI,SAAS,UAAU;AACtB,qBAAe,KAAK,UAAU,SAAS;AACvC,WAAK,gBAAgB,KAAK,UAAU;AACpC,yBAAmB;AAEnB,UAAI,KAAK,UAAU,WAAW,GAAG;AAChC,eAAO,CAAC,MAAM,IAAI;;WAEb;AACN,YAAM,UAAU,yCAAyC,KAAK,IAAI;AAClE,UAAI,SAAS;AACZ,uBAAe,SAAS,QAAQ,CAAC,GAAG,EAAE,IAAI;AAC1C,aAAK,gBAAgB,SAAS,QAAQ,CAAC,GAAG,EAAE;AAC5C,eAAO,QAAQ,CAAC;AAChB,uBAAe,KAAK,IAAI,cAAc,CAAC;AACvC,2BAAmB;aACb;AACN,aAAK,gBAAgB;;AAEtB,WAAK,YAAY,CAAA;;AAGlB,aAAS,IAAI,GAAG,IAAI,kBAAkB,EAAE,GAAG;AAC1C,YAAM,WAAW,KAAK,IAAI,KAAK;AAC/B,UAAI;AACJ,cAAQ,MAAM;QACb,KAAK;AACJ,cAAK,KAAK,eAAgB,IAAI;AAC9B,eAAK,UAAU,IAAI,CAAC,IAAI;AACxB;QACD,KAAK;AACJ,cAAK,IAAI,IAAK,IAAI,WAAW;AAC7B,eAAK,UAAU,IAAI,CAAC,IAAI;AACxB;QACD,KAAK;AACJ,cAAI,YAAa,IAAI,IAAK,IAAI;AAC9B,eAAK,UAAU,IAAI,CAAC,IAAI;AACxB;QACD,KAAK;AACJ,cAAI,IAAI,GAAG;AACV,gBAAI,KAAK,WAAW,aAAgB,IAAI,KAAM,IAAK,IAAK,KAAK;iBACvD;AACN,gBAAI;;AAEL,eAAK,UAAU,IAAI,CAAC,IAAI;AACxB;QACD,KAAK;AACJ,cAAI,KAAK,UAAU,IAAI,CAAC;AACxB;QACD;AACC,gBAAM,IAAI,UAAU,+BAA+B,IAAI;;AAEzD,UAAI,MAAM,GAAG;AACZ,aAAK,CAAC,IAAI,CAAC,IAAI,KAAK,IAAI,QAAQ,CAAC;AACjC,aAAK,CAAC,IAAI,IAAI,KAAK,IAAI,QAAQ,CAAC;aAC1B;AACN,aAAK,CAAC,IAAI;AACV,aAAK,CAAC,IAAI;;;AAGZ,WAAO,CAAC,MAAM,IAAI;EACnB;;;;EAKQ,YAAY,MAAoB,MAAoB,OAAc;AACzE,QAAI,MAAM;AACV,UAAM,MAAM,KAAK;AACjB,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC7B,aAAO,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,KAAK,IAAI,KAAK,CAAC,IAAI,KAAK,IAAI,IAAI,KAAK;;AAEpE,WAAO;EACR;;;;;EAMA,kBAAe;AACd,UAAM,CAAC,MAAM,IAAI,IAAI,KAAK,kBAAkB,KAAK,OAAO,CAAC;AACzD,QAAI,WAAW;AACf,UAAM,QAAQ,KAAK,KAAK;AACxB,UAAM,gBAAgB;AAEtB,aAAS,IAAI,GAAG,IAAI,eAAe,KAAK;AACvC,iBAAW,KAAK,IAAI,KAAK,YAAY,MAAM,MAAO,IAAI,gBAAiB,KAAK,GAAG,QAAQ;;AAExF,WAAO,MAAM,CAAC,KAAK,YAAY,MAAM,MAAM,KAAK,MAAM,IAAI,UAAU,IAAI,CAAC;EAC1E;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,UAAU,MAAM,GAAG,KAAK,YAAY;EACjD;EACA,IAAI,SAAS,UAAQ;AACpB,SAAK,YAAY;AACjB,SAAK,gBAAgB,KAAK,UAAU;AACpC,QAAI,SAAS,QAAQ;AACpB,WAAK,OAAO;;EAEd;EAEA,IAAI,QAAK;AACR,WAAO,KAAK,UAAU,MAAM,KAAK;EAClC;EACA,IAAI,MAAM,OAAK;AACd,SAAK,SAAS,QAAQ,KAAK,KAAK;AAEhC,SAAK,OAAO,KAAK;EAClB;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;EAED,UAAO;AACN,UAAM,QAAO;AACb,QAAI,KAAK,gBAAgB,MAAM;AAC9B,WAAK,YAAY,QAAO;;AAEzB,SAAK,QAAQ;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;AA9Pe,WAAA,qBAQV,CAAA;;;AC/LA,IAAgB,iBAAhB,MAAgB,wBAA8D,cAAsB;EAGzG,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,gBAAe,YAAW,GAAI,WAAW,CAAC,SAAS,CAAC,CAAC,CAAC;EAChG;EAEA,QAAQ,aAAwB,YAAY,GAAG,WAAW,GAAC;AAC1D,kBAAc,MAAM,aAAa,WAAW,QAAQ;AACpD,WAAO;EACR;;;;ACSK,IAAO,aAAP,MAAO,oBAAmB,eAAiC;EAiChE,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,WAAW,QAAQ,CAAC,CAAC,CAAC;AAhC7F,SAAA,OAAe;AAKhB,SAAA,UAA0B,KAAK,QAAQ,iBAAgB;AAK/D,SAAA,QAAQ,KAAK;AAKb,SAAA,SAAS,KAAK;AAkBb,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,WAAW,QAAQ,CAAC;AAE/F,QAAI,QAAQ,QAAQ,OAAO,KAAK,QAAQ,mBAAmB,cAAc;AACxE,WAAK,QAAQ,aAAa,KAAK,QAAQ,OAAO;eACpC,WAAW,QAAQ,OAAO,GAAG;AACvC,WAAK,OAAO,QAAQ,SAAS,QAAQ,MAAM;;EAE7C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,QAAQ;KACR;EACF;;;;;;;;;;;;;EAcA,OAAO,SAA8B,SAAS,MAAI;AACjD,UAAM,QAAQ,IAAI,aAAa,MAAM;AACrC,aAAS,IAAI,GAAG,MAAM,QAAQ,IAAI,KAAK,KAAK;AAC3C,YAAM,aAAc,KAAK,MAAM,KAAM,IAAI;AACzC,YAAM,CAAC,IAAI,QAAQ,YAAY,CAAC;;AAEjC,SAAK,QAAQ;AACb,WAAO;EACR;;;;;;EAOA,IAAI,QAAK;AACR,WAAO,KAAK,QAAQ;EACrB;EAEA,IAAI,MAAM,SAA4B;AACrC,SAAK,QAAQ,QAAQ;EACtB;;;;;EAMA,IAAI,aAAU;AACb,WAAO,KAAK,QAAQ;EACrB;EAEA,IAAI,WAAW,cAA4B;AAC1C,UAAM,mBAAmB,CAAC,QAAQ,MAAM,IAAI,EAAE,KAAK,SAAO,IAAI,SAAS,YAAY,CAAC;AACpF,WAAO,kBAAkB,mDAAmD;AAC5E,SAAK,QAAQ,aAAa;EAC3B;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,WAAU;AACvB,WAAO;EACR;;;;AC7HK,IAAO,cAAP,cAA2B,eAAoC;EAArE,cAAA;;AAEU,SAAA,OAAe;AAKhB,SAAA,QAAQ,IAAI,WAAW;MAC9B,SAAS,KAAK;MACd,SAAS,QAAM,IAAI,KAAK;KACxB;AAKD,SAAA,QAAQ,KAAK;AAKb,SAAA,SAAS,KAAK;EAUf;;;;EALC,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACbK,IAAO,WAAP,MAAO,kBAAoE,OAAgB;EAkChG,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AAjC/E,SAAA,OAAe;AAKf,SAAA,WAAW;AA6BnB,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAEjF,SAAK,QAAQ,KAAK,QAAQ,KAAK,SAAS,IAAI,KAAK;MAChD,SAAS,KAAK;MACd,UAAU,QAAQ;MAClB,UAAU,QAAQ;KAClB;AAED,SAAK,SAAS,KAAK,SAAS,KAAK,MAAM;AACvC,SAAK,OAAO,eAAe,QAAQ,OAAO,CAAC;EAC5C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,OAAO;KACP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;AC9CK,IAAO,eAAP,MAAO,sBAAqB,OAA2B;EAqD5D,cAAA;AAEC,UAAM,qBAAqB,cAAa,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,gBAAgB,CAAC,CAAC;AArDlG,SAAA,OAAe;AAkBhB,SAAA,mBAAmB,IAAI,YAAY,EAAE,SAAS,KAAK,QAAO,CAAE;AAsB5D,SAAA,kBAAkB,IAAI,KAAK;MAClC,SAAS,KAAK;KACd;AAYA,UAAM,UAAU,qBAAqB,cAAa,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,gBAAgB,CAAC;AAEnH,SAAK,WAAW,IAAI,WAAW;MAC9B,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,WAAW,QAAQ;MACnB,QAAQ,MAAM,KAAK,OAAO,IAAI;MAC9B,OAAO,QAAQ;MACf,MAAM,QAAQ;KACO;AACtB,SAAK,YAAY,KAAK,SAAS,WAC/B,KAAK,SAAS,KAAK,SAAS;AAE5B,SAAK,aAAa,IAAI,WAAW;MAChC,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,MAAM,QAAQ;KACO;AAEtB,SAAK,cAAc,IAAI,SAAS;MAC/B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAGD,SAAK,UAAU,MAAM,KAAK,aAAa,KAAK,WAAW,SAAS;AAChE,SAAK,WAAW,MAAM,KAAK,kBAAkB,KAAK,gBAAgB,IAAI;AACtE,SAAK,SAAS,MAAM,KAAK,iBAAiB,KAAK,MAAM;AAErD,aAAS,MAAM,CAAC,aAAa,UAAU,aAAa,CAAC;EACtD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,aAAa;MACb,gBAAgB;KAChB;EACF;;;;EAKU,OAAO,MAAa;AAC7B,SAAK,WAAW,MAAM,IAAI;AAC1B,SAAK,SAAS,MAAM,IAAI;EACzB;;;;EAKU,MAAM,MAAa;AAC5B,SAAK,WAAW,KAAK,IAAI;AACzB,SAAK,SAAS,KAAK,IAAI;EACxB;EAEU,SAAS,MAAa;AAC/B,SAAK,WAAW,QAAQ,IAAI;AAC5B,SAAK,SAAS,QAAQ,IAAI;EAC3B;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,KAAK,MAAwB;AAChC,SAAK,SAAS,OAAO;EACtB;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,SAAS,UAAwB;AACpC,SAAK,SAAS,WAAW;EAC1B;EAEA,IAAI,eAAY;AACf,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,aAAa,cAAoB;AACpC,SAAK,SAAS,eAAe;EAC9B;;;;EAKA,IAAI,iBAAc;AACjB,WAAO,KAAK,WAAW;EACxB;EACA,IAAI,eAAe,MAAwB;AAC1C,SAAK,WAAW,OAAO;EACxB;EAEA,IAAI,QAAK;AACR,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,MAAM,OAAc;AACvB,SAAK,SAAS,QAAQ;AACtB,SAAK,WAAW,QAAQ;EACzB;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,SAAS,UAAkB;AAC9B,SAAK,SAAS,WAAW;EAC1B;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;;;;EAKD,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,SAAK,YAAY,QAAO;AACxB,SAAK,SAAS,QAAO;AACrB,SAAK,WAAW,QAAO;AACvB,SAAK,gBAAgB,QAAO;AAC5B,SAAK,iBAAiB,QAAO;AAC7B,WAAO;EACR;;;;ACpLK,IAAO,eAAP,MAAO,sBAAqB,OAA2B;EAkD5D,cAAA;AAEC,UAAM,qBAAqB,cAAa,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,gBAAgB,CAAC,CAAC;AAlDlG,SAAA,OAAe;AAoChB,SAAA,kBAAwB,IAAI,KAAK;MACxC,SAAS,KAAK;MACd,MAAM;KACN;AAYA,UAAM,UAAU,qBAAqB,cAAa,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,gBAAgB,CAAC;AAEnH,SAAK,WAAW,IAAI,WAAW;MAC9B,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,WAAW;MACX,QAAQ,MAAM,KAAK,OAAO,IAAI;MAC9B,OAAO,QAAQ;MACf,MAAM,QAAQ;KACO;AAEtB,SAAK,SAAS,KAAK,SAAS;AAE5B,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,aAAa,IAAI,WAAW;MAChC,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,MAAM,QAAQ;KACO;AAEtB,SAAK,cAAc,IAAI,SAAS;MAC/B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,kBAAkB,IAAI,SAAS;MACnC,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAGD,SAAK,UAAU,QAAQ,KAAK,SAAS,SAAS;AAC9C,SAAK,UAAU,MAAM,KAAK,aAAa,KAAK,WAAW,SAAS;AAChE,SAAK,UAAU,MAAM,KAAK,iBAAiB,KAAK,eAAe;AAC/D,SAAK,WAAW,QAAQ,KAAK,gBAAgB,IAAI;AACjD,SAAK,gBAAgB,QAAQ,KAAK,SAAS,SAAS;AACpD,SAAK,SAAS,QAAQ,KAAK,MAAM;AACjC,SAAK,OAAO,QAAQ,KAAK,WAAW,MAAM;AAE1C,aAAS,MAAM,CAAC,mBAAmB,aAAa,UAAU,aAAa,CAAC;EACzE;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,aAAa;MACb,iBAAiB;MACjB,gBAAgB;KAChB;EACF;;;;EAKU,OAAO,MAAU;AAC1B,SAAK,WAAW,MAAM,IAAI;AAC1B,SAAK,SAAS,MAAM,IAAI;EACzB;;;;EAKU,MAAM,MAAU;AACzB,SAAK,WAAW,KAAK,IAAI;AACzB,SAAK,SAAS,KAAK,IAAI;EACxB;EAEU,SAAS,MAAa;AAC/B,SAAK,WAAW,QAAQ,IAAI;AAC5B,SAAK,SAAS,QAAQ,IAAI;AAC1B,WAAO;EACR;EAEA,IAAI,OAAI;AACP,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,KAAK,MAAwB;AAChC,SAAK,SAAS,OAAO;EACtB;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,SAAS,UAAwB;AACpC,SAAK,SAAS,WAAW;EAC1B;EAEA,IAAI,eAAY;AACf,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,aAAa,cAAoB;AACpC,SAAK,SAAS,eAAe;EAC9B;;;;EAKA,IAAI,iBAAc;AACjB,WAAO,KAAK,WAAW;EACxB;EACA,IAAI,eAAe,MAAwB;AAC1C,SAAK,WAAW,OAAO;EACxB;EAEA,IAAI,QAAK;AACR,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,MAAM,OAAc;AACvB,SAAK,SAAS,QAAQ;AACtB,SAAK,WAAW,QAAQ;EACzB;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,SAAS,UAAkB;AAC9B,SAAK,SAAS,WAAW;EAC1B;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;;;;EAKD,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,YAAY,QAAO;AACxB,SAAK,SAAS,QAAO;AACrB,SAAK,WAAW,QAAO;AACvB,SAAK,gBAAgB,QAAO;AAC5B,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;;;AC3LK,IAAO,kBAAP,MAAO,yBAAwB,OAA8B;EAkDlE,cAAA;AAEC,UAAM,qBAAqB,iBAAgB,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC,CAAC;AAlDpF,SAAA,OAAe;AAchB,SAAA,aAAmB,IAAI,KAAK;MACnC,SAAS,KAAK;MACd,MAAM;KACN;AAoBO,SAAA,UAAU,IAAI,WAAW;MAChC,SAAS,KAAK;MACd,SAAS,SAAO,OAAO,IAAI,KAAK;KAChC;AAWA,UAAM,UAAU,qBAAqB,iBAAgB,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC;AAErG,SAAK,QAAQ,IAAI,OAAO;MACvB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,YAAY,IAAI,WAAW;MAC/B,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,WAAW,QAAQ;MACnB,QAAQ,MAAM,KAAK,OAAO,IAAI;MAC9B,OAAO,QAAQ;MACf,MAAM;KACN;AACD,SAAK,YAAY,KAAK,UAAU;AAChC,SAAK,SAAS,KAAK,UAAU;AAG7B,SAAK,UAAU,MAAM,KAAK,SAAS,KAAK,MAAM;AAC9C,SAAK,MAAM,MAAM,KAAK,YAAY,KAAK,OAAO;AAC9C,aAAS,MAAM,CAAC,SAAS,aAAa,QAAQ,CAAC;EAChD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,QAAQ;MACR,WAAW;MACX,OAAO;MACP,MAAM;MACN,OAAO;KACP;EACF;;;;EAKU,OAAO,MAAU;AAC1B,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,UAAU,MAAM,IAAI;AACzB,SAAK,WAAW,KAAK,eAAe,GAAG,IAAI;EAC5C;;;;EAKU,MAAM,MAAU;AACzB,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,UAAU,KAAK,IAAI;AAGxB,SAAK,WAAW,KAAK,sBAAsB,IAAI;AAC/C,SAAK,WAAW,KAAK,eAAe,GAAG,IAAI;EAC5C;EAEU,SAAS,MAAa;AAC/B,SAAK,UAAU,QAAQ,IAAI;AAC3B,SAAK,WAAW,KAAK,sBAAsB,IAAI;AAC/C,SAAK,WAAW,KAAK,eAAe,GAAG,IAAI;EAC5C;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,MAAM,OAAc;AACvB,SAAK,UAAU,QAAQ;EACxB;;;;EAKA,IAAI,OAAI;AACP,WAAO;EACR;;;;EAKA,IAAI,WAAQ;AACX,WAAO;EACR;;;;EAKA,IAAI,WAAQ;AACX,WAAO,CAAA;EACR;;;;EAKA,IAAI,eAAY;AACf,WAAO;EACR;;;;;;EAOA,IAAI,YAAY,MAAyB;AACxC,SAAK,UAAU,OAAO;EACvB;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;;;;EAKD,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,MAAM,QAAO;AAClB,SAAK,WAAW,QAAO;AACvB,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;;;;AC3MK,IAAO,gBAAP,MAAO,uBAAsB,OAA4B;EA4C9D,cAAA;AAEC,UAAM,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,QAAQ,CAAC,CAAC;AA5C3F,SAAA,OAAe;AAQhB,SAAA,eAA6B,CAAA;AAqCpC,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,QAAQ,CAAC;AAE5G,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,SAAK,SAAS,IAAI,OAAO;MACxB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,UAAU,QAAQ;AACvB,SAAK,QAAQ,QAAQ;AACrB,SAAK,SAAS,QAAQ;AACtB,SAAK,YAAY,QAAQ;AACzB,SAAK,gBAAgB,QAAQ;AAG7B,SAAK,QAAQ,QAAQ;AAErB,aAAS,MAAM,CAAC,aAAa,QAAQ,CAAC;EACvC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,OAAO;MACP,QAAQ;MACR,MAAM;KACN;EACF;;;;EAKU,OAAO,MAAU;AAC1B,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,SAAS,SAAO,IAAI,MAAM,IAAI,CAAC;EACrC;;;;EAKU,MAAM,MAAU;AACzB,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,SAAS,SAAO,IAAI,KAAK,IAAI,CAAC;EACpC;EAEU,SAAS,MAAa;AAC/B,SAAK,SAAS,SAAO,IAAI,QAAQ,IAAI,CAAC;EACvC;;;;EAKQ,SAAS,UAAkD;AAClE,aAAS,IAAI,GAAG,IAAI,KAAK,aAAa,QAAQ,KAAK;AAClD,eAAS,KAAK,aAAa,CAAC,GAAG,CAAC;;EAElC;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAwB;AAChC,SAAK,QAAQ;AACb,SAAK,SAAS,SAAO,IAAI,OAAO,IAAI;EACrC;;;;;;;;;;EAWA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,QAAa;AACvB,SAAK,UAAU;AACf,QAAI,KAAK,aAAa,SAAS,GAAG;AACjC,YAAMC,SAAQ,CAAC,SAAS;AACxB,YAAM,OAAO,UAAU,KAAK,aAAa,SAAS;AAClD,WAAK,SAAS,CAAC,KAAK,MAAM,IAAI,OAAO,QAAQA,SAAQ,OAAO,CAAC;;EAE/D;;;;;;;;EASA,IAAI,QAAK;AACR,WAAO,KAAK,aAAa;EAC1B;EACA,IAAI,MAAM,OAAa;AACtB,gBAAY,OAAO,CAAC;AACpB,QAAI,KAAK,aAAa,WAAW,OAAO;AAEvC,WAAK,SAAS,SAAO,IAAI,QAAO,CAAE;AAClC,WAAK,eAAe,CAAA;AACpB,eAAS,IAAI,GAAG,IAAI,OAAO,KAAK;AAC/B,cAAM,MAAM,IAAI,WAAW;UAC1B,SAAS,KAAK;UACd,QAAQ,KAAK,QAAQ;UACrB,MAAM,KAAK;UACX,OAAO,KAAK,SAAU,IAAI,QAAS;UACnC,cAAc,KAAK;UACnB,QAAQ,MAAM,IAAI,MAAM,KAAK,OAAO,IAAI,IAAI;SAC5C;AACD,YAAI,KAAK,SAAS,UAAU;AAC3B,cAAI,WAAW,KAAK;;AAErB,aAAK,UAAU,QAAQ,IAAI,SAAS;AACpC,aAAK,OAAO,QAAQ,IAAI,MAAM;AAC9B,YAAI,OAAO,aAAa;AACxB,YAAI,QAAQ,KAAK,MAAM;AACvB,aAAK,aAAa,CAAC,IAAI;;AAGxB,WAAK,SAAS,KAAK;AACnB,UAAI,KAAK,UAAU,WAAW;AAC7B,aAAK,SAAS,SAAO,IAAI,MAAK,CAAE;;;EAGnC;EAEA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,OAAc;AACvB,SAAK,SAAS;AACd,SAAK,SAAS,CAAC,KAAK,MAAM,IAAI,QAAQ,KAAK,SAAU,IAAI,KAAK,QAAS,GAAG;EAC3E;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,aAAa,CAAC,EAAE;EAC7B;EACA,IAAI,SAAS,UAAwB;AACpC,SAAK,SAAS,SAAO,IAAI,WAAW,QAAQ;AAC5C,SAAK,QAAQ,KAAK,aAAa,CAAC,EAAE;EACnC;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,aAAa,CAAC,EAAE;EAC7B;EACA,IAAI,SAAS,UAAkB;AAC9B,SAAK,YAAY;AACjB,SAAK,gBAAgB,KAAK,UAAU;AACpC,QAAI,SAAS,QAAQ;AACpB,WAAK,QAAQ;AACb,WAAK,SAAS,SAAO,IAAI,WAAW,QAAQ;;EAE9C;EAEA,IAAI,eAAY;AACf,WAAO,KAAK,aAAa,CAAC,EAAE;EAC7B;EACA,IAAI,aAAa,cAAoB;AACpC,SAAK,gBAAgB;AACrB,SAAK,SAAS,SAAO,IAAI,eAAe,YAAY;AACpD,SAAK,QAAQ,KAAK,aAAa,CAAC,EAAE;EACnC;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;;;;EAKD,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,SAAK,SAAS,SAAO,IAAI,QAAO,CAAE;AAClC,WAAO;EACR;;;;ACtOK,IAAO,gBAAP,MAAO,uBAAsB,OAA4B;EAiD9D,cAAA;AACC,UAAM,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,qBAAqB,CAAC,CAAC;AAhDhG,SAAA,OAAe;AAEf,SAAA,aAAa;AAed,SAAA,SAAmB,IAAI,SAAS;MACvC,SAAS,KAAK;MACd,OAAO;KACP;AA6BA,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,qBAAqB,CAAC;AAEjH,SAAK,SAAS,IAAI,gBAAgB;MACjC,SAAS,KAAK;MACd,WAAW,QAAQ;KACnB;AAED,SAAK,OAAO,cAAc;AAE1B,SAAK,sBAAsB,KAAK,OAAO;AAEvC,SAAK,aAAa,IAAI,WAAW;MAChC,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,WAAW,QAAQ;MACnB,QAAQ,MAAM,KAAK,OAAO,IAAI;MAC9B,OAAO,QAAQ;KACf;AAED,SAAK,YAAY,KAAK,WAAW;AACjC,SAAK,SAAS,KAAK,WAAW;AAG9B,SAAK,WAAW,MAAM,KAAK,QAAQ,KAAK,OAAO,KAAK;AACpD,SAAK,OAAO,QAAQ,KAAK,MAAM;AAC/B,aAAS,MAAM,CAAC,uBAAuB,aAAa,QAAQ,CAAC;EAC9D;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,QAAQ;MACR,WAAW;MACX,qBAAqB;MACrB,OAAO;MACP,MAAM;KACN;EACF;;;;EAIU,OAAO,MAAU;AAC1B,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,WAAW,MAAM,IAAI;AAC1B,SAAK,OAAO,MAAM,IAAI;EACvB;;;;EAKU,MAAM,MAAU;AACzB,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,WAAW,KAAK,IAAI;AACzB,SAAK,OAAO,KAAK,IAAI;EACtB;;;;EAKU,SAAS,MAAa;AAC/B,SAAK,WAAW,QAAQ,IAAI;AAC5B,SAAK,OAAO,QAAQ,IAAI;EACzB;;;;EAKA,IAAI,OAAI;AACP,WAAO;EACR;;;;EAKA,IAAI,WAAQ;AACX,WAAO;EACR;;;;EAKA,IAAI,WAAQ;AACX,WAAO,CAAA;EACR;;;;EAKA,IAAI,eAAY;AACf,WAAO;EACR;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,WAAW;EACxB;EACA,IAAI,MAAM,OAAc;AACvB,SAAK,WAAW,QAAQ;EACzB;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;;;;EAKD,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,OAAO,QAAO;AACnB,SAAK,WAAW,QAAO;AACvB,WAAO;EACR;;;;ACzID,IAAM,0BAEF;EACH,IAAI;EACJ,KAAK;EACL,IAAI;EACJ,YAAY;EACZ,OAAO;EACP,KAAK;;AAWA,IAAO,iBAAP,MAAO,wBACJ,OAA6B;EAwBrC,cAAA;AAEC,UAAM,qBAAqB,gBAAe,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC,CAAC;AAvBlF,SAAA,OAAe;AAwBvB,UAAM,UAAU,qBAAqB,gBAAe,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC;AAEnG,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,SAAK,SAAS,IAAI,OAAO;MACxB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,aAAS,MAAM,CAAC,aAAa,QAAQ,CAAC;AAGtC,SAAK,IAAI,OAAO;EACjB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OACb,WAAW,YAAW,GACtB,aAAa,YAAW,GACxB,aAAa,YAAW,GACxB,cAAc,YAAW,GACzB,gBAAgB,YAAW,GAC3B,cAAc,YAAW,CAAE;EAE7B;;;;EAKU,OAAO,MAAU;AAC1B,SAAK,YAAY,MAAM,IAAI;EAC5B;;;;EAKU,MAAM,MAAU;AACzB,SAAK,YAAY,KAAK,IAAI;EAC3B;EAEU,SAAS,MAAa;AAC/B,SAAK,YAAY,QAAQ,IAAI;AAC7B,WAAO;EACR;;;;;;;;;;;;;;EAeA,IAAI,OAAI;AACP,QAAI,SAAS;AACb,QAAI,CAAC,MAAM,MAAM,KAAK,EAAE,KAAK,OAAK,KAAK,gBAAgB,CAAC,GAAG;AAC1D,eAAS,KAAK;;AAEf,WAAO,SAAS,KAAK,YAAY;EAClC;EACA,IAAI,KAAK,MAAI;AACZ,QAAI,KAAK,OAAO,GAAG,CAAC,MAAM,MAAM;AAC/B,WAAK,qBAAqB,IAAI;AAC9B,WAAK,cAAc,KAAK;AACxB,WAAK,YAAY,OAAO,KAAK,OAAO,CAAC;eAC3B,KAAK,OAAO,GAAG,CAAC,MAAM,MAAM;AACtC,WAAK,qBAAqB,IAAI;AAC9B,WAAK,cAAc,KAAK;AACxB,WAAK,YAAY,OAAO,KAAK,OAAO,CAAC;eAC3B,KAAK,OAAO,GAAG,CAAC,MAAM,OAAO;AACvC,WAAK,qBAAqB,KAAK;AAC/B,WAAK,cAAc,KAAK;AACxB,WAAK,YAAY,OAAO,KAAK,OAAO,CAAC;eAC3B,SAAS,OAAO;AAC1B,WAAK,qBAAqB,KAAK;AAC/B,WAAK,cAAc,KAAK;eACd,SAAS,SAAS;AAC5B,WAAK,qBAAqB,OAAO;WAC3B;AACN,WAAK,qBAAqB,YAAY;AACtC,WAAK,cAAc,KAAK;AACxB,WAAK,YAAY,OAAQ;;EAE3B;;;;;;EAOA,IAAI,WAAQ;AACX,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,SAAS,UAAQ;AACpB,QAAI,CAAC,KAAK,YAAY,KAAK,aAAa,OAAO,KAAK,CAAC,KAAK,YAAY,KAAK,aAAa,KAAK,GAAG;AAC/F,WAAK,YAAY,WAAW;;EAE9B;EAEA,IAAI,eAAY;AACf,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,aAAa,cAAY;AAC5B,QAAI,CAAC,KAAK,YAAY,KAAK,aAAa,OAAO,KAAK,CAAC,KAAK,YAAY,KAAK,aAAa,KAAK,GAAG;AAC/F,WAAK,YAAY,eAAe;;EAElC;EAEA,IAAI,OAAqC;AAExC,QAAI,QAAQ,IAAI,OAAO,MAAM,KAAK,MAAM,MAAM;AAC7C,WAAK,OAAO,MAAM;;AAGnB,UAAM,IAAI,KAAK;AACf,WAAO;EACR;;;;EAKQ,qBAAqB,SAA0B;AACtD,QAAI,YAAY,KAAK,aAAa;AACjC,WAAK,cAAc;AACnB,YAAM,iBAAiB,wBAAwB,OAAO;AAEtD,YAAMC,OAAM,KAAK,IAAG;AACpB,UAAI,KAAK,aAAa;AACrB,cAAM,SAAS,KAAK;AACpB,eAAO,KAAKA,IAAG;AAEf,aAAK,QAAQ,WAAW,MAAM,OAAO,QAAO,GAAI,KAAK,SAAS;;AAE/D,WAAK,cAAc,IAAI,eAAe;QACrC,SAAS,KAAK;OACd;AACD,WAAK,UAAU,QAAQ,KAAK,YAAY,SAAS;AACjD,WAAK,OAAO,QAAQ,KAAK,YAAY,MAAM;AAC3C,WAAK,YAAY,QAAQ,KAAK,MAAM;AACpC,WAAK,YAAY,SAAS,MAAM,KAAK,OAAO,IAAI;AAChD,UAAI,KAAK,UAAU,WAAW;AAC7B,aAAK,YAAY,MAAMA,IAAG;;;EAG7B;EAEA,IAAI,QAAK;AACR,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,MAAM,OAAK;AACd,SAAK,YAAY,QAAQ;EAC1B;;;;;;;EAQA,IAAI,aAAU;AACb,WAAO,KAAK;EACb;EACA,IAAI,WAAW,OAAK;AAEnB,QAAI,WAAW;AACf,QAAI,KAAK,YAAY,SAAS,SAAS,KAAK,YAAY,SAAS,SAAS;AACzE,iBAAW,KAAK,YAAY;;AAI7B,QAAI,UAAU,MAAM;AACnB,WAAK,OAAO,OAAO;eACT,UAAU,MAAM;AAC1B,WAAK,OAAO,OAAO;eACT,UAAU,OAAO;AAC3B,WAAK,OAAO,QAAQ;eACV,UAAU,cAAc;AAClC,WAAK,OAAO;eACF,UAAU,SAAS;AAC7B,WAAK,OAAO;eACF,UAAU,OAAO;AAC3B,WAAK,OAAO;;EAEd;EAEQ,YACP,KACA,YAAsB;AAEtB,WAAO,eAAe,wBAAwB,UAAU;EACzD;;;;;;;EAQA,IAAI,WAAQ;AACX,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,SAAS,UAAQ;AACpB,QAAI,CAAC,KAAK,YAAY,KAAK,aAAa,OAAO,KAC9C,CAAC,KAAK,YAAY,KAAK,aAAa,KAAK,KACzC,aAAa,WAAW,aAAa,OAAO;AAC5C,WAAK,YAAY,WAAW;;EAE9B;;;;;EAMA,IAAI,QAAK;AACR,QAAI,KAAK,YAAY,KAAK,aAAa,OAAO,GAAG;AAChD,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;;;;;EAMA,IAAI,QAAK;AACR,QAAI,KAAK,YAAY,KAAK,aAAa,KAAK,GAAG;AAC9C,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;EACA,IAAI,MAAM,OAAK;AACd,QAAI,KAAK,YAAY,KAAK,aAAa,KAAK,KAAK,SAAS,KAAK,GAAG;AACjE,WAAK,YAAY,QAAQ;;EAE3B;;;;;EAMA,IAAI,SAAM;AACT,QAAI,KAAK,YAAY,KAAK,aAAa,KAAK,GAAG;AAC9C,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;EACA,IAAI,OAAO,QAAM;AAChB,QAAI,KAAK,YAAY,KAAK,aAAa,KAAK,KAAK,SAAS,MAAM,GAAG;AAClE,WAAK,YAAY,SAAS;;EAE5B;;;;;EAMA,IAAI,iBAAc;AACjB,QAAI,KAAK,YAAY,KAAK,aAAa,IAAI,KAAK,KAAK,YAAY,KAAK,aAAa,IAAI,GAAG;AACzF,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;EACA,IAAI,eAAe,OAAK;AACvB,SAAK,KAAK,YAAY,KAAK,aAAa,IAAI,KAAK,KAAK,YAAY,KAAK,aAAa,IAAI,MAAM,SAAS,KAAK,GAAG;AAC9G,WAAK,YAAY,iBAAiB;;EAEpC;;;;;EAMA,IAAI,kBAAe;AAClB,QAAI,KAAK,YAAY,KAAK,aAAa,IAAI,GAAG;AAC7C,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;;;;;EAMA,IAAI,cAAW;AACd,QAAI,KAAK,YAAY,KAAK,aAAa,IAAI,KAAK,KAAK,YAAY,KAAK,aAAa,IAAI,GAAG;AACzF,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;;;;;;;EAQA,IAAI,sBAAmB;AACtB,QAAI,KAAK,YAAY,KAAK,aAAa,KAAK,GAAG;AAC9C,aAAO,KAAK,YAAY;WAClB;AACN,aAAO;;EAET;EAEM,QAAQ,SAAS,MAAI;;AAC1B,aAAO,iBAAiB,MAAM,MAAM;IACrC,CAAC;;EAED,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,UAAU,QAAO;AACtB,SAAK,YAAY,QAAO;AACxB,WAAO;EACR;;;;ACpZK,IAAO,MAAP,MAAO,aAAY,OAAM;EAuB9B,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AAtBnF,SAAA,WAAW;AAEF,SAAA,OAAe;AAKhB,SAAA,OAAa,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC9C,SAAA,QAAQ,KAAK;AACb,SAAA,SAAS,KAAK;AAKd,SAAA,SAA0B,KAAK;AAUvC,kBAAc,KAAK,iBAAiB,KAAK,IAAI;EAC9C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,OAAO;KACP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;ACvCK,IAAO,QAAP,MAAO,eAA2D,eAAuB;EAiC9F,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,OAAO,KAAK,CAAC,CAAC,CAAC;AAhCjF,SAAA,OAAe;AAiCvB,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,OAAO,KAAK,CAAC;AAEnF,SAAK,QAAQ,KAAK,QAAQ,IAAI,SAAS;MACtC,SAAS,KAAK;MACd,OAAO,QAAQ,MAAM,QAAQ;KAC7B;AAED,SAAK,OAAO,KAAK,SAAS,IAAI,IAAI;MACjC,SAAS,KAAK;MACd,OAAO,QAAQ;KACf;AAED,SAAK,OAAO,QAAQ;AACpB,SAAK,OAAO,QAAQ;AAEpB,SAAK,MAAM,QAAQ,KAAK,MAAM;EAC/B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,eAAe,YAAW,GAAI;MAClD,KAAK;MACL,KAAK;KACL;EACF;;;;EAKA,IAAI,MAAG;AACN,WAAO,KAAK;EACb;EACA,IAAI,IAAI,KAAG;AACV,SAAK,OAAO;AACZ,SAAK,UAAS;EACf;;;;EAKA,IAAI,MAAG;AACN,WAAO,KAAK;EACb;EACA,IAAI,IAAI,KAAG;AACV,SAAK,OAAO;AACZ,SAAK,UAAS;EACf;;;;EAKQ,YAAS;AAChB,SAAK,KAAK,QAAQ,KAAK;AACvB,SAAK,MAAM,QAAQ,KAAK,OAAO,KAAK;EACrC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;AC1GK,IAAO,OAAP,MAAO,cAAa,eAAoC;EAoB7D,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,MAAK,YAAW,GAAI,SAAS,CAAC,CAAC;AAnBhE,SAAA,OAAe;AAKhB,SAAA,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAKlD,SAAA,SAAS,KAAK;AAKd,SAAA,QAAQ;AAKP,YAAQ,KAAK,QAAQ,YAAY,CAAC,GAAG,KAAK,KAAK;EAChD;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,eAAW,KAAK,QAAQ,YAAY,CAAC,GAAG,KAAK,KAAK;AAClD,WAAO;EACR;;;;ACXK,IAAO,MAAP,MAAO,aAAY,cAAyB;EAiFjD,cAAA;AAEC,UAAM,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,KAAK,CAAC,CAAC;AAjF7E,SAAA,OAAe;AAkChB,SAAA,gBAAgB;AAyBhB,SAAA,SAAmB;AAK3B,SAAA,UAAU;AAsNF,SAAA,YAAY,MAAM,UAAU;AAE5B,SAAA,UAAU,MAAM,UAAU;AAE1B,SAAA,MAAM,MAAM,UAAU;AAEtB,SAAA,cAAc,MAAM,UAAU;AA1MrC,UAAM,UAAU,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,KAAK,CAAC;AAE9F,SAAK,cAAc,IAAI,WAAW,OAA2C;AAE7E,SAAK,YAAY,KAAK,YAAY;AAElC,SAAK,iBAAiB,IAAI,KAAK;MAC9B,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,OAAO;KACP;AACD,SAAK,YAAY,KAAK,eAAe;AACrC,SAAK,iBAAiB,IAAI,OAAO;MAChC,SAAS,KAAK;MACd,OAAO;MACP,OAAO;KACP;AACD,SAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAChD,SAAK,OAAO,IAAI,YAAY,EAAE,SAAS,KAAK,QAAO,CAAE;AACrD,SAAK,UAAU,KAAK,SAAS,IAAI,MAAM;MACtC,SAAS,KAAK;MACd,KAAK,QAAQ;MACb,KAAK,QAAQ;KACb;AAED,SAAK,QAAQ,QAAQ;AACrB,SAAK,MAAM,QAAQ;AACnB,SAAK,MAAM,QAAQ;AAGnB,SAAK,YAAY,MAAM,KAAK,gBAAgB,KAAK,MAAM,KAAK,OAAO;AACnE,SAAK,OAAO,QAAQ,KAAK,IAAI;AAC7B,SAAK,eAAe,QAAQ,KAAK,IAAI;AACrC,aAAS,MAAM,CAAC,aAAa,WAAW,CAAC;AACzC,SAAK,QAAQ,QAAQ;EACtB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,WAAW;MACX,WAAW;MACX,KAAK;MACL,KAAK;MACL,MAAM;MACN,OAAO;KACP;EACF;;;;;EAMA,MAAM,MAAW;AAChB,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,eAAe,eAAe,GAAG,IAAI;AAC1C,SAAK,YAAY,MAAM,IAAI;AAC3B,WAAO;EACR;;;;;EAMA,KAAK,MAAW;AACf,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,eAAe,eAAe,KAAK,eAAe,IAAI;AAC3D,SAAK,YAAY,KAAK,IAAI;AAC1B,WAAO;EACR;;;;;;;;;EAUA,OAAI;AACH,SAAK,YAAY,KAAI;AACrB,SAAK,YAAY,cAAa;AAC9B,WAAO;EACR;;;;EAKA,SAAM;AACL,SAAK,YAAY,OAAM;AACvB,SAAK,YAAY,gBAAe;AAChC,WAAO;EACR;;;;EAKQ,mBAAgB;AACvB,SAAK,gBAAgB,KAAK,YAAY,gBAAe;AACrD,SAAK,eAAe,QAAQ,KAAK;EAClC;;;;EAKA,IAAI,MAAG;AACN,WAAO,KAAK,QAAQ,KAAK,QAAQ,GAAG;EACrC;EACA,IAAI,IAAI,KAAG;AACV,UAAM,KAAK,UAAU,GAAG;AACxB,SAAK,QAAQ,MAAM;EACpB;;;;EAKA,IAAI,MAAG;AACN,WAAO,KAAK,QAAQ,KAAK,QAAQ,GAAG;EACrC;EACA,IAAI,IAAI,KAAG;AACV,UAAM,KAAK,UAAU,GAAG;AACxB,SAAK,QAAQ,MAAM;EACpB;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,YAAY,OAAO;AACxB,SAAK,iBAAgB;EACtB;;;;EAKA,IAAI,WAAQ;AACX,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,SAAS,UAAQ;AACpB,SAAK,YAAY,WAAW;AAC5B,SAAK,iBAAgB;EACtB;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,YAAY;EACzB;EACA,IAAI,MAAM,OAAK;AACd,SAAK,YAAY,QAAQ;AACzB,SAAK,iBAAgB;EACtB;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,KAAG;AACZ,UAAM,aAAa,KAAK;AACxB,UAAM,aAAa,KAAK;AAExB,SAAK,SAAS;AACd,SAAK,MAAM;AACX,SAAK,MAAM;EACZ;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,YAAY;EACzB;;;;;;EAOA,QAAQ,MAAiB,WAAoB,UAAiB;AAC7D,QAAI,gBAAgB,SAAS,gBAAgB,QAAQ;AACpD,WAAK,UAAU,KAAK;AACpB,WAAK,QAAQ,KAAK;;AAEnB,kBAAc,MAAM,MAAM,WAAW,QAAQ;AAC7C,WAAO;EACR;EAcA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,YAAY,QAAO;AACxB,SAAK,eAAe,QAAO;AAC3B,SAAK,OAAO,QAAO;AACnB,SAAK,QAAQ,QAAO;AACpB,SAAK,KAAK,QAAO;AACjB,SAAK,eAAe,QAAO;AAC3B,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;ACpUK,SAAU,MAAM,KAAa,MAAM,UAAQ;AAChD,QAAM,WAAiC,oBAAI,QAAO;AAClD,SAAO,SAAS,QAAa,aAA4B;AACxD,YAAQ,eACP,QACA,aACA;MACC,cAAc;MACd,YAAY;MACZ,KAAK,WAAA;AACJ,eAAO,SAAS,IAAI,IAAI;MACzB;MACA,KAAK,SAAS,UAAgB;AAC7B,oBAAY,UAAU,KAAK,GAAG;AAC9B,iBAAS,IAAI,MAAM,QAAQ;MAC5B;KACA;EAEH;AACD;AAMM,SAAU,UAAU,KAAa,MAAM,UAAQ;AACpD,QAAM,WAA+B,oBAAI,QAAO;AAChD,SAAO,SAAS,QAAa,aAAmB;AAC/C,YAAQ,eACP,QACA,aACA;MACC,cAAc;MACd,YAAY;MACZ,KAAK,WAAA;AACJ,eAAO,SAAS,IAAI,IAAI;MACzB;MACA,KAAK,SAAS,UAAc;AAC3B,oBAAY,KAAK,UAAU,QAAQ,GAAG,KAAK,GAAG;AAC9C,iBAAS,IAAI,MAAM,QAAQ;MAC5B;KACA;EAEH;AACD;;;AClBM,IAAO,SAAP,MAAO,gBAAe,OAAqB;EA0DhD,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC,CAAC;AA1DtE,SAAA,OAAe;AAoChB,SAAA,iBAAwC,oBAAI,IAAG;AAuBtD,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC;AAEvF,SAAK,UAAU,IAAI,gBAAgB;MAClC,QAAQ,KAAK,QAAQ,KAAK,MAAM,QAAQ,MAAM;MAC9C,SAAS,QAAQ;MACjB,SAAS,QAAQ;MACjB,KAAK,QAAQ;KACb;AACD,SAAK,YAAY,QAAQ;AACzB,SAAK,QAAQ,QAAQ;AACrB,SAAK,aAAa,QAAQ;AAC1B,SAAK,WAAW,QAAQ;AACxB,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,SAAS,QAAQ;AACtB,SAAK,UAAU,QAAQ;EACxB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,WAAW;MACX,QAAQ;MACR,SAAS;MACT,MAAM;MACN,SAAS;MACT,WAAW;MACX,QAAQ;MACR,SAAS;MACT,cAAc;MACd,SAAS;KACT;EACF;;;;;;;;;;EAWM,KAAK,KAAW;;AACrB,YAAM,KAAK,QAAQ,KAAK,GAAG;AAC3B,WAAK,QAAO;AACZ,aAAO;IACR,CAAC;;;;;EAKO,QAAQ,WAAuB,MAAI;AAC1C,aAAQ;AACR,QAAI,KAAK,WAAW;AACnB,WAAK,MAAK;;EAEZ;;;;EAKQ,aAAa,QAAwB;AAE5C,SAAK,OAAO,IAAI;AAGhB,SAAK,eAAe,OAAO,MAAM;AACjC,QAAI,KAAK,eAAe,SAAS,KAAK,CAAC,KAAK,WAC3C,KAAK,OAAO,eAAe,KAAK,IAAG,CAAE,MAAM,WAAW;AAEtD,WAAK,OAAO,OAAO,KAAK,IAAG,CAAE;AAC7B,WAAK,OAAO,eAAe,WAAW,KAAK,IAAG,CAAE;;EAElD;;;;;;;;;;EAWA,MAAM,MAAa,QAAe,UAAe;AAChD,UAAM,MAAM,MAAM,QAAQ,QAAQ;AAClC,WAAO;EACR;;;;EAKU,OAAO,WAAkB,QAAe,UAAe;AAEhE,QAAI,KAAK,OAAO;AACf,eAAS,WAAW,QAAQ,KAAK,UAAU;WACrC;AAEN,eAAS,WAAW,QAAQ,CAAC;;AAI9B,UAAM,iBAAiB,KAAK,UAAU,MAAM;AAG5C,UAAM,eAAe;AACrB,eAAW,WAAW,UAAU,KAAK,IAAI,KAAK,QAAQ,WAAW,gBAAgB,CAAC,CAAC;AACnF,QAAI,mBAAmB,KAAK,UAAU,QAAQ;AAG9C,uBAAmB,mBAAmB,KAAK;AAG3C,gBAAY,KAAK,UAAU,SAAS;AAGpC,UAAM,SAAS,IAAI,iBAAiB;MACnC,KAAK,KAAK;MACV,SAAS,KAAK;MACd,QAAQ,KAAK;MACb,SAAS,KAAK;MACd,MAAM,KAAK;MACX,SAAS,KAAK;MACd,WAAW,KAAK;MAChB,SAAS,KAAK,aAAa,KAAK,IAAI;MACpC,cAAc,KAAK;KACnB,EAAE,QAAQ,KAAK,MAAM;AAGtB,QAAI,CAAC,KAAK,SAAS,CAAC,KAAK,SAAS;AAEjC,WAAK,OAAO,OAAO,YAAY,gBAAgB;AAE/C,WAAK,OAAO,eAAe,WAAW,YAAY,kBAAkB;QACnE,aAAa;OACb;;AAIF,SAAK,eAAe,IAAI,MAAM;AAG9B,QAAI,KAAK,SAAS,QAAQ,YAAY,GAAG;AACxC,aAAO,MAAM,WAAW,cAAc;WAChC;AAEN,aAAO,MAAM,WAAW,gBAAgB,mBAAmB,KAAK,UAAU,KAAK,OAAO,CAAC;;EAEzF;;;;EAKU,MAAM,MAAW;AAC1B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,eAAe,QAAQ,YAAU,OAAO,KAAK,YAAY,CAAC;EAChE;;;;;;;;EASA,QAAQ,MAAgB,QAAe,UAAe;AACrD,UAAM,QAAQ,MAAM,QAAQ,QAAQ;AACpC,WAAO;EACR;EAEU,SAAS,MAAgB,QAAe,UAAe;AAChE,SAAK,MAAM,IAAI;AACf,SAAK,OAAO,MAAM,QAAQ,QAAQ;EACnC;;;;;;;;;;;;;EAcA,KAAK,QAAc,MAAW;AAC7B,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,QAAI,KAAK,OAAO,eAAe,YAAY,MAAM,WAAW;AAC3D,YAAM,iBAAiB,KAAK,UAAU,MAAM;AAE5C,WAAK,MAAM,YAAY;AAEvB,WAAK,OAAO,cAAc,cAAc;;AAEzC,WAAO;EACR;;;;;;;;;;;;EAaA,cAAc,WAAiB,SAAa;AAC3C,SAAK,YAAY;AACjB,SAAK,UAAU;AACf,WAAO;EACR;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK;EACb;EACA,IAAI,UAAU,WAAS;AACtB,SAAK,aAAa;AAClB,QAAI,KAAK,OAAO,QAAQ;AACvB,kBAAY,KAAK,UAAU,SAAS,GAAG,GAAG,KAAK,OAAO,QAAQ;;AAG/D,SAAK,eAAe,QAAQ,YAAS;AACpC,aAAO,YAAY;IACpB,CAAC;EACF;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,WAAW;AAChB,QAAI,KAAK,OAAO,QAAQ;AACvB,kBAAY,KAAK,UAAU,OAAO,GAAG,GAAG,KAAK,OAAO,QAAQ;;AAG7D,SAAK,eAAe,QAAQ,YAAS;AACpC,aAAO,UAAU;IAClB,CAAC;EACF;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,QAAM;AAChB,SAAK,QAAQ,IAAI,MAAM;EACxB;;;;;;;;EASA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAI;AAEZ,QAAI,KAAK,UAAU,MAAM;AACxB;;AAED,SAAK,QAAQ;AAEb,SAAK,eAAe,QAAQ,YAAS;AACpC,aAAO,OAAO;IACf,CAAC;AACD,QAAI,MAAM;AAET,YAAM,YAAY,KAAK,OAAO,aAAa,WAAW,KAAK,IAAG,CAAE;AAChE,UAAI,WAAW;AACd,aAAK,OAAO,OAAO,UAAU,IAAI;;;EAGpC;;;;;;;;;;EAWA,IAAI,eAAY;AACf,WAAO,KAAK;EACb;EACA,IAAI,aAAa,MAAI;AACpB,SAAK,gBAAgB;AACrB,UAAMC,OAAM,KAAK,IAAG;AAGpB,UAAM,YAAY,KAAK,OAAO,aAAa,WAAWA,IAAG;AACzD,QAAI,aAAa,UAAU,aAAa;AACvC,WAAK,OAAO,OAAO,UAAU,IAAI;AACjC,WAAK,eAAe,QAAQ,YAAU,OAAO,WAAU,CAAE;;AAI1D,SAAK,eAAe,QAAQ,YAAS;AACpC,aAAO,aAAa,eAAe,MAAMA,IAAG;IAC7C,CAAC;EACF;;;;;;;;EASA,IAAI,UAAO;AACV,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,QAAQ,KAAG;AACd,SAAK,QAAQ,UAAU;EACxB;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,QAAQ;EACrB;EAEA,UAAO;AACN,UAAM,QAAO;AAEb,SAAK,eAAe,QAAQ,YAAU,OAAO,QAAO,CAAE;AACtD,SAAK,eAAe,MAAK;AACzB,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;;AA1WA,WAAA;EADC,UAAU,CAAC;;AAOZ,WAAA;EADC,UAAU,CAAC;;;;ACrDP,IAAO,UAAP,MAAO,iBAAgB,cAA6B;EAuDzD,cAAA;AACC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,QAAQ,QAAQ,GAAG,MAAM,CAAC;AAtDhF,SAAA,OAAe;AAoBf,SAAA,QAAQ;AAKT,SAAA,WAAgC,oBAAI,IAAG;AA8B9C,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,QAAQ,QAAQ,GAAG,MAAM;AAKjG,SAAK,UAAU,KAAK,SAAS,IAAI,OAAO;MACvC,SAAS,KAAK;MACd,QAAQ,QAAQ;KAChB;AAED,SAAK,SAAS,KAAK,QAAQ;AAC3B,aAAS,MAAM,QAAQ;AACvB,SAAK,WAAW,IAAI,iBAAiB;MACpC,MAAM,QAAQ;MACd,QAAQ,QAAQ;MAChB,SAAS,QAAQ;MACjB,SAAS,QAAQ;KACjB;AAED,SAAK,OAAO,QAAQ;AACpB,SAAK,UAAU,QAAQ;AACvB,SAAK,WAAW,QAAQ;EACzB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,SAAS;MACT,QAAQ;MACR,SAAS;MACT,MAAM;MACN,QAAQ;MACR,SAAS;MACT,MAAM,CAAA;MACN,QAAQ;KACR;EACF;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ,OAAO;EACrB;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,QAAM;AAChB,SAAK,UAAU;AACf,SAAK,SAAS,QAAQ,YAAS;AAC9B,aAAO,SAAS;IACjB,CAAC;EACF;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,WAAW;AAChB,SAAK,SAAS,QAAQ,YAAS;AAC9B,aAAO,UAAU;IAClB,CAAC;EACF;;;;EAKA,IAAI,QAAK;AACR,UAAM,UAAU,MAAM,KAAK,KAAK,QAAQ,EAAE,KAAK,CAAC,CAAC,GAAG,MAAM,MAAM,OAAO,UAAU,SAAS;AAC1F,WAAO,UAAU,YAAY;EAC9B;;;;;EAMA,IAAI,MAAY;AACf,WAAO,KAAK,SAAS,IAAI,IAAI;EAC9B;;;;;EAMA,OAAO,MAAY;AAClB,WAAO,KAAK,IAAI,IAAI,GAAG,2BAA2B,IAAI,wBAAwB;AAC9E,QAAI,CAAC,KAAK,SAAS,IAAI,IAAI,GAAG;AAC7B,YAAM,SAAS,IAAI,OAAO;QACzB,SAAS,KAAK;QACd,QAAQ,KAAK;QACb,SAAS,KAAK;QACd,KAAK,KAAK,SAAS,IAAI,IAAI;OAC3B,EAAE,QAAQ,KAAK,MAAM;AACtB,WAAK,SAAS,IAAI,MAAM,MAAM;;AAE/B,WAAO,KAAK,SAAS,IAAI,IAAI;EAC9B;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,SAAS;EACtB;;;;;;;EAQA,IAAI,MAAc,KAA6C,UAAqB;AACnF,WAAO,CAAC,KAAK,SAAS,IAAI,IAAI,GAAG,uDAAuD;AACxF,SAAK,SAAS,IAAI,MAAM,KAAK,QAAQ;AACrC,WAAO;EACR;;;;;EAMA,QAAQ,MAAW;AAClB,SAAK,SAAS,QAAQ,YAAU,OAAO,KAAK,IAAI,CAAC;AACjD,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,OAAO,QAAO;AACnB,SAAK,SAAS,QAAQ,YAAU,OAAO,QAAO,CAAE;AAChD,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;ACpMK,IAAO,cAAP,MAAO,qBAAoB,OAA0B;EA4D1D,cAAA;AAEC,UAAM,qBAAqB,aAAY,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC,CAAC;AA5D3E,SAAA,OAAe;AAehB,SAAA,aAAa;AAKb,SAAA,WAAW;AAKX,SAAA,iBAAqC,CAAA;AAoC5C,UAAM,UAAU,qBAAqB,aAAY,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC;AAE5F,SAAK,SAAS,IAAI,gBAAgB;MACjC,QAAQ,QAAQ;MAChB,SAAS,QAAQ;MACjB,SAAS,QAAQ;MACjB,KAAK,QAAQ;KACb;AACD,SAAK,SAAS,IAAI,MAAM;MACvB,SAAS,KAAK;MACd,UAAU,KAAK,MAAM,KAAK,IAAI;MAC9B,WAAW,IAAI,QAAQ;KACvB;AACD,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,aAAa,QAAQ;AAC1B,SAAK,WAAW,QAAQ;AACxB,SAAK,SAAS,QAAQ;AAGtB,SAAK,UAAU,QAAQ;AACvB,SAAK,OAAO,QAAQ;AACpB,SAAK,eAAe,QAAQ;AAC5B,SAAK,YAAY,QAAQ;AACzB,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AACvB,SAAK,UAAU,QAAQ;AACvB,SAAK,OAAO,GAAG,QAAQ,KAAK,QAAQ,KAAK,IAAI,CAAC;EAC/C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,QAAQ;MACR,SAAS;MACT,SAAS;MACT,WAAW;MACX,cAAc;MACd,QAAQ;MACR,MAAM;MACN,WAAW;MACX,SAAS;MACT,SAAS;KACT;EACF;;;;EAKU,OAAO,MAAa,QAAe,UAAe;AAC3D,aAAS,WAAW,QAAQ,CAAC;AAC7B,aAAS,KAAK,UAAU,MAAM;AAC9B,WAAO,KAAK,UAAU,IAAI;AAE1B,UAAM,YAAY,IAAI,KAAK,OAAO,UAAU,eAAe,IAAI;AAC/D,SAAK,OAAO,MAAM,MAAM,SAAS,SAAS;AAE1C,QAAI,UAAU;AACb,WAAK,KAAK,OAAO,KAAK,UAAU,QAAQ,CAAC;;EAE3C;;;;;;;;EASA,QAAQ,MAAgB,QAAe,UAAe;AACrD,UAAM,QAAQ,MAAM,QAAQ,QAAQ;AACpC,WAAO;EACR;EAEU,SAAS,MAAgB,QAAe,UAAe;AAChE,SAAK,MAAM,IAAI;AACf,SAAK,OAAO,MAAM,QAAQ,QAAQ;EACnC;;;;EAKU,MAAM,MAAW;AAC1B,SAAK,OAAO,KAAK,IAAI;EACtB;;;;EAKQ,QAAQ,MAAa;AAE5B,SAAK,eAAe,QAAQ,CAAC,WAAU;AACtC,aAAO,UAAU;AACjB,aAAO,KAAK,IAAI;IACjB,CAAC;AACD,SAAK,OAAO,IAAI;EACjB;;;;EAKQ,MAAM,MAAa;AAE1B,UAAM,QAAQ,KAAK,OAAO,eAAe,IAAI;AAC7C,UAAM,SAAS,QAAQ,KAAK;AAC5B,SAAK,IAAI,UAAU,MAAM;AAEzB,QAAI,CAAC,KAAK,QAAQ,SAAS,KAAK,OAAO,UAAU;AAChD,WAAK,KAAK,IAAI;AACd;;AAID,UAAM,SAAS,SAAS,KAAK,WAAW,IAAI,KAAK;AAGjD,UAAM,SAAS,IAAI,iBAAiB;MACnC,SAAS,KAAK;MACd,KAAK,KAAK;MACV;MACA,SAAS,KAAK;MACd,MAAM,KAAK;MACX,WAAW,KAAK;MAChB,SAAS,KAAK;;MAEd,cAAc,yBAAyB,KAAK,SAAS,GAAG;KACxD,EAAE,QAAQ,KAAK,MAAM;AAEtB,WAAO,MAAM,MAAM,KAAK,aAAa,KAAK;AAC1C,WAAO,KAAK,OAAO,KAAK,aAAa,KAAK,YAAY;AAGtD,SAAK,eAAe,KAAK,MAAM;AAE/B,WAAO,UAAU,MAAK;AACrB,YAAM,QAAQ,KAAK,eAAe,QAAQ,MAAM;AAChD,UAAI,UAAU,IAAI;AACjB,aAAK,eAAe,OAAO,OAAO,CAAC;;IAErC;EACD;;;;EAKA,IAAI,eAAY;AACf,WAAO,KAAK;EACb;EACA,IAAI,aAAa,MAAI;AACpB,gBAAY,MAAM,IAAK;AACvB,SAAK,gBAAgB;AACrB,SAAK,YAAY,KAAK;EACvB;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK;EACb;EACA,IAAI,UAAU,MAAI;AACjB,QAAI,KAAK,OAAO,QAAQ;AACvB,kBAAY,KAAK,UAAU,IAAI,GAAG,GAAG,KAAK,OAAO,QAAQ;;AAE1D,SAAK,aAAa,KAAK,UAAU,IAAI;EACtC;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,MAAI;AACf,QAAI,KAAK,OAAO,QAAQ;AACvB,kBAAY,KAAK,UAAU,IAAI,GAAG,GAAG,KAAK,OAAO,QAAQ;;AAE1D,SAAK,WAAW,KAAK,UAAU,IAAI;EACpC;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK,OAAO;EACpB;EAEA,IAAI,QAAQ,KAAG;AACd,SAAK,OAAO,UAAU;EACvB;;;;;EAMA,IAAI,YAAS;AACZ,WAAO,KAAK;EACb;EACA,IAAI,UAAU,MAAI;AACjB,SAAK,aAAa,KAAK,UAAU,IAAI;AACrC,SAAK,OAAO,UAAU,eAAe,KAAK,gBAAgB,KAAK,YAAY,KAAK,IAAG,CAAE;EACtF;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,MAAI;AACf,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,gBAAY,cAAc,CAAC;AAC3B,SAAK,WAAW;EACjB;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,OAAO;EACpB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,OAAO,QAAO;AACnB,SAAK,eAAe,QAAQ,CAAC,WAAW,OAAO,QAAO,CAAE;AACxD,WAAO;EACR;;;;AChTK,IAAO,MAAP,cAAmB,eAAoC;EAA7D,cAAA;;AAEU,SAAA,OAAe;AAKhB,SAAA,OAAO,IAAI,WAAW;MAC7B,SAAS,KAAK;MACd,SAAS,SAAM;AACd,YAAI,KAAK,IAAI,GAAG,IAAI,MAAO;AAC1B,iBAAO;eACD;AACN,iBAAO,KAAK,IAAI,GAAG;;MAErB;KACA;AAKD,SAAA,QAAQ,KAAK;AAKb,SAAA,SAAS,KAAK;EAUf;;;;EALC,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;AC1CK,IAAO,cAAP,cAA2B,eAAoC;EAArE,cAAA;;AAEU,SAAA,OAAe;AAKhB,SAAA,QAAQ,IAAI,WAAW;MAC9B,SAAS,KAAK;MACd,SAAS,OAAK,KAAK,IAAI,CAAC,IAAI,IAAI;KAChC;AAKD,SAAA,QAAQ,KAAK;AAKb,SAAA,SAAS,KAAK;EAUf;;;;EALC,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACzBK,IAAO,SAAP,cAAsB,eAAoC;EAAhE,cAAA;;AAEU,SAAA,OAAe;AAKhB,SAAA,YAAsB,IAAI,SAAS;MAC1C,SAAS,KAAK;MACd,OAAO;KACP;AAKD,SAAA,QAAQ,KAAK;AACb,SAAA,SAAS,KAAK;EAWf;;;;;EALC,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;ACbK,IAAO,WAAP,MAAO,kBAAiB,OAAM;EA6BnC,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AA5BxF,SAAA,WAAW;AAEF,SAAA,OAAe;AAKhB,SAAA,OAAa,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC9C,SAAA,QAAc,KAAK;AACnB,SAAA,SAAe,KAAK;AAKrB,SAAA,OAAe,IAAI,OAAO,EAAE,SAAS,KAAK,QAAO,CAAE;AAK3D,SAAA,aAA8B,KAAK;AAWlC,kBAAc,KAAK,iBAAiB,KAAK,MAAM,KAAK,IAAI;EACzD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,OAAO;KACP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;ACtDK,IAAO,kBAAP,MAAO,yBAAwB,eAAsC;EAmB1E,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,iBAAgB,YAAW,GAAI,SAAS,CAAC,CAAC;AAlB3E,SAAA,OAAe;AAoBvB,SAAK,UAAU,KAAK,SAAS,IAAI,WAAW;MAC3C,SAAS,KAAK;MACd,QAAQ;MACR,SAAS,CAAC,QAAO;AAChB,YAAI,OAAO,GAAG;AACb,iBAAO;eACD;AACN,iBAAO;;MAET;KACA;AACD,SAAK,SAAS,KAAK,QAAQ,IAAI,SAAS;MACvC,SAAS,KAAK;MACd,OAAO;KACP;AAGD,SAAK,OAAO,QAAQ,KAAK,OAAO;EACjC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;;;;AC5CK,IAAO,cAAP,MAAO,qBAAoB,OAAgB;EAoChD,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,aAAY,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AAnClF,SAAA,OAAe;AAEf,SAAA,WAAoB;AAkC5B,UAAM,UAAU,qBAAqB,aAAY,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAEpF,SAAK,YAAY,KAAK,QAAQ,IAAI,SAAS;MAC1C,SAAS,KAAK;MACd,OAAO,QAAQ;KACf;AACD,SAAK,OAAO,KAAK,SAAS,IAAI,gBAAgB,EAAE,SAAS,KAAK,QAAO,CAAE;AAEvE,SAAK,aAAa,KAAK,SAAS,KAAK,UAAU;AAC/C,aAAS,MAAM,YAAY;AAG3B,SAAK,UAAU,QAAQ,KAAK,IAAI;EACjC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,OAAO;KACP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,SAAK,UAAU,QAAO;AACtB,SAAK,WAAW,QAAO;AACvB,WAAO;EACR;;;;ACpEK,IAAO,MAAP,MAAO,aAAY,eAA0B;EAiBlD,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC,CAAC;AAhB1E,SAAA,OAAe;AAiBvB,UAAM,UAAU,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAE5E,SAAK,kBAAkB,KAAK,QAAQ,KAAK,SAAS,IAAI,WAAW;MAChE,SAAS,KAAK;MACd,SAAS,KAAK,SAAS,QAAQ,KAAK;MACpC,QAAQ;KACR;AAED,SAAK,YAAY,QAAQ;EAC1B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,eAAe,YAAW,GAAI;MAClD,OAAO;KACP;EACF;;;;;EAMQ,SAAS,UAAgB;AAChC,WAAO,CAAC,QAAe;AACtB,aAAO,KAAK,IAAI,KAAK,IAAI,GAAG,GAAG,QAAQ;IACxC;EACD;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,UAAgB;AACzB,SAAK,YAAY;AACjB,SAAK,gBAAgB,OAAO,KAAK,SAAS,KAAK,SAAS,CAAC;EAC1D;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;;;AChEK,IAAO,WAAP,MAAO,kBAAiB,MAAsB;EAgBnD,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,OAAO,OAAO,UAAU,CAAC,CAAC,CAAC;AAfhG,SAAA,OAAe;AAgBvB,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,OAAO,OAAO,UAAU,CAAC;AAElG,SAAK,QAAQ,KAAK,OAAO,IAAI,IAAI;MAChC,SAAS,KAAK;MACd,OAAO,QAAQ;KACf;AACD,SAAK,KAAK,QAAQ,KAAK,KAAK;EAC7B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,MAAM,YAAW,GAAI;MACzC,UAAU;KACV;EACF;;;;;;EAOA,IAAI,WAAQ;AACX,WAAO,KAAK,KAAK;EAClB;EACA,IAAI,SAAS,KAAG;AACf,SAAK,KAAK,QAAQ;EACnB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;ACzDK,IAAO,eAAP,cAAkE,OAAgB;EAgCvF,cAAA;AAEC,UAAM,qBAAqB,OAAO,YAAW,GAAI,WAAW,CAAC,SAAS,OAAO,CAAC,CAAC;AAhCvE,SAAA,OAAe;AAKf,SAAA,WAAW;AA4BnB,UAAM,UAAU,qBAAqB,OAAO,YAAW,GAAI,WAAW,CAAC,SAAS,OAAO,CAAC;AAExF,SAAK,WAAW,QAAQ;AACxB,SAAK,UAAU,KAAK,QAAQ,UAAU,eAAe,KAAK,QAAQ,KAAK,IAAI,GAAG,IAAI;AAElF,SAAK,kBAAkB,KAAK,aAAa,KAAK,IAAI;AAClD,SAAK,QAAQ,UAAU,GAAG,SAAS,KAAK,eAAe;AACvD,SAAK,QAAQ,UAAU,GAAG,SAAS,KAAK,eAAe;AACvD,SAAK,QAAQ,UAAU,GAAG,QAAQ,KAAK,eAAe;AAGtD,SAAK,gBAAgB,WAAU;AAC/B,SAAK,gBAAgB,KAAK,CAAC;AAG3B,SAAK,kBAAkB,KAAK,SAAS,IAAI,mBAA6B;MACrE,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,OAAO,QAAQ;KACf,EAAE,MAAM,CAAC;AACV,SAAK,eAAe,QAAQ,OAAO,CAAC;EACrC;;;;EAKQ,QAAQ,MAAa;AAC5B,UAAM,MAAM,MAAM,eAAe,KAAK,QAAQ,UAAU,OAAO;AAE/D,QAAI,KAAK,aAAa,KAAK;AAC1B,WAAK,WAAW;AAChB,WAAK,gBAAgB,OAAO,eAAe,KAAK,IAAI;;EAEtD;;;;EAKQ,aAAa,MAAa;AACjC,UAAM,MAAM,MAAM,eAAe,KAAK,QAAQ,UAAU,OAAO;AAC/D,SAAK,WAAW;AAChB,SAAK,gBAAgB,OAAO,oBAAoB,IAAI;AACpD,SAAK,gBAAgB,OAAO,eAAe,KAAK,IAAI;EACrD;EAEA,eAAe,MAAmB;AACjC,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,UAAS;AACzE,WAAO,MAAM,eAAe,YAAY;EACzC;EAEA,eAAe,OAA0B,MAAmB;AAC3D,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,UAAS;AACzE,UAAM,eAAe,OAAO,YAAY;AACxC,WAAO;EACR;EAEA,wBAAwB,OAA0B,MAAmB;AACpE,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,UAAS;AACzE,UAAM,wBAAwB,OAAO,YAAY;AACjD,WAAO;EACR;EAEA,6BAA6B,OAA0B,MAAmB;AACzE,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,UAAS;AACzE,UAAM,6BAA6B,OAAO,YAAY;AACtD,WAAO;EACR;EAEA,gBAAgB,OAAO,WAA0B,cAAoB;AACpE,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,UAAS;AAC9E,UAAM,gBAAgB,OAAO,cAAc,YAAY;AACvD,WAAO;EACR;EAEA,sBAAsB,WAAwB;AAC7C,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,UAAS;AAC9E,UAAM,sBAAsB,YAAY;AACxC,WAAO;EACR;EAEA,oBAAoB,QAA6B,WAA0B,UAAgB,SAAoB;AAC9G,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,UAAS;AAC9E,eAAW,KAAK,UAAU,QAAQ;AAClC,UAAM,oBAAoB,QAAQ,cAAc,UAAU,OAAO;AACjE,WAAO;EACR;EAEA,oBAAoB,MAAmB;AACtC,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,UAAS;AACzE,UAAM,oBAAoB,YAAY;AACtC,WAAO;EACR;EAEA,aAAa,MAAmB;AAC/B,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,UAAS;AACzE,UAAM,aAAa,YAAY;AAC/B,WAAO;EACR;EAEA,kBAAkB,OAA0B,UAAgB,WAAyB;AACpF,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,UAAS;AAC9E,UAAM,kBAAkB,OAAO,UAAU,YAAY;AACrD,WAAO;EACR;EAEA,aAAa,OAA0B,UAAgB,WAAyB;AAC/E,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,UAAS;AAC9E,UAAM,aAAa,OAAO,UAAU,YAAY;AAChD,WAAO;EACR;EAEA,aAAa,OAA0B,UAAgB,WAAyB;AAC/E,UAAM,eAAe,IAAI,mBAAmB,KAAK,SAAS,SAAS,EAAE,UAAS;AAC9E,UAAM,aAAa,OAAO,UAAU,YAAY;AAChD,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,UAAU,MAAM,KAAK,OAAO;AACzC,SAAK,QAAQ,UAAU,IAAI,SAAS,KAAK,eAAe;AACxD,SAAK,QAAQ,UAAU,IAAI,SAAS,KAAK,eAAe;AACxD,SAAK,QAAQ,UAAU,IAAI,QAAQ,KAAK,eAAe;AACvD,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;;;ACvHK,IAAO,WAAP,MAAO,kBAAiB,cAA8B;EAiI3D,cAAA;AAEC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,UAAU,SAAS,WAAW,SAAS,CAAC,CAAC;AAjIhG,SAAA,OAAe;AAoGd,SAAA,OAA8B,IAAI,OAAO;MAClD,SAAS,KAAK;MACd,OAAO;KACP;AAKD,SAAA,SAAqB,KAAK;AAK1B,SAAA,QAA+B;AAiB9B,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,UAAU,SAAS,WAAW,SAAS,CAAC;AAEjH,SAAK,SAAS,QAAQ;AACtB,SAAK,QAAQ,QAAQ;AACrB,SAAK,UAAU,QAAQ;AACvB,SAAK,UAAU,QAAQ;AACvB,SAAK,cAAc,QAAQ;AAC3B,SAAK,eAAe,QAAQ;AAC5B,SAAK,aAAa,QAAQ;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,QAAQ;MACR,aAAa;MACb,OAAO;MACP,YAAY;MACZ,SAAS;MACT,cAAc;MACd,SAAS;KACT;EACF;;;;;EAMA,IAAI,QAAK;AACR,WAAO,KAAK,eAAe,KAAK,IAAG,CAAE;EACtC;;;;;;;EAQQ,UAAU,OAA8B,WAA4B;AAC3E,QAAI,SAAS,KAAK,GAAG;AACpB,aAAO;WACD;AAEN,UAAI;AACJ,WAAK,aAAa,gBAAgB;AACjC,YAAI,eAAe,SAAS,EAAE,SAAS,MAAM,OAAO;AACnD,iBAAO;;;AAIT,aAAO;;EAET;;;;;;;EAQQ,UACP,MACA,WACA,OAAoB;AAGpB,QAAI,SAAS,KAAK,KAAK,QAAQ,IAAI,gBAAgB,KAAK,GAAG;AAC1D,YAAM,WAAW,eAAe,KAAK;AACrC,UAAI,SAAS,QAAQ,GAAG;AACvB,YAAI,SAAS,eAAe;AAC3B,eAAK,IAAI,IAAI,SAAS,SAAS;;aAE1B;AACN,aAAK,IAAI,IAAI;;eAEJ,QAAQ,KAAK,KAAK,SAAS,eAAe;AACpD,WAAK,IAAI,IAAI;WACP;AACN,YAAM,IAAI,MAAM,8BAA8B,KAAK;;EAErD;;;;;;;;;;;;;;;;;;;;;;EAuBA,IAAI,cAAW;AACd,WAAO,KAAK,UAAU,KAAK,cAAc,IAAI;EAC9C;EACA,IAAI,YAAY,OAAK;AACpB,SAAK,UAAU,gBAAgB,MAAM,KAAK;EAC3C;;;;;;;;;;;;;;EAeA,IAAI,eAAY;AACf,WAAO,KAAK,UAAU,KAAK,eAAe,KAAK;EAChD;EACA,IAAI,aAAa,OAAK;AACrB,SAAK,UAAU,iBAAiB,OAAO,KAAK;EAC7C;;;;;;;;;;;;;EAcA,IAAI,aAAU;AACb,WAAO,KAAK;EACb;EACA,IAAI,WAAW,OAAK;AACnB,WAAO,CAAC,UAAU,aAAa,EAAE,KAAK,OAAK,MAAM,KAAK,GAAG,2BAA2B,KAAK,EAAE;AAC3F,SAAK,cAAc;EACpB;;;;;;;;;;;;EAaA,cAAc,MAAa,WAAwB,GAAC;AACnD,SAAK,IAAI,iBAAiB,MAAM,QAAQ;AACxC,WAAO,KAAK,UAAU,IAAI;AAC1B,UAAM,iBAAiB,KAAK,UAAU,KAAK,MAAM;AACjD,QAAI,SAAS;AACb,UAAM,QAAQ,KAAK,UAAU,KAAK,KAAK;AAEvC,UAAM,eAAe,KAAK,eAAe,IAAI;AAC7C,QAAI,eAAe,GAAG;AAErB,YAAM,aAAa,IAAI;AACvB,YAAM,oBAAoB,IAAI;AAE9B,eAAS,oBAAoB;;AAG9B,QAAI,SAAS,KAAK,YAAY;AAC7B,WAAK,KAAK,sBAAsB,IAAI;AAEpC,WAAK,KAAK,eAAe,UAAU,IAAI;eAC7B,KAAK,iBAAiB,UAAU;AAC1C,WAAK,KAAK,aAAa,UAAU,QAAQ,IAAI;eACnC,KAAK,iBAAiB,eAAe;AAC/C,WAAK,KAAK,aAAa,UAAU,QAAQ,IAAI;WACvC;AACN,WAAK,KAAK,oBAAoB,IAAI;AAClC,UAAI,QAAQ,KAAK;AAEjB,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAEtC,YAAI,MAAM,IAAI,CAAC,KAAK,gBAAgB,gBAAgB,MAAM,CAAC,GAAG;AAC7D,kBAAQ,KAAK,aAAa,MAAM,CAAC;AAEjC,gBAAM,CAAC,IAAI;AACX;;;AAGF,WAAK,KAAK,oBAAoB,OAAO,MAAM,QAAQ,QAAQ;;AAG5D,QAAI,SAAS,KAAK,UAAU,GAAG;AAC9B,YAAM,aAAa,WAAW,KAAK;AACnC,YAAM,aAAa,OAAO;AAC1B,WAAK,IAAI,SAAS,UAAU;AAC5B,UAAI,KAAK,gBAAgB,UAAU;AAClC,aAAK,KAAK,wBAAwB,YAAY,QAAQ,UAAU;aAC1D;AACN,aAAK,KAAK,+BAA+B,YAAY,YAAY,KAAK;;;AAGxE,WAAO;EACR;;;;;;;;;;;;;EAcA,eAAe,MAAW;AACzB,SAAK,IAAI,kBAAkB,IAAI;AAC/B,WAAO,KAAK,UAAU,IAAI;AAC1B,UAAM,eAAe,KAAK,eAAe,IAAI;AAC7C,QAAI,eAAe,GAAG;AACrB,YAAM,UAAU,KAAK,UAAU,KAAK,OAAO;AAC3C,UAAI,UAAU,KAAK,YAAY;AAC9B,aAAK,KAAK,eAAe,GAAG,IAAI;iBACtB,KAAK,kBAAkB,UAAU;AAC3C,aAAK,KAAK,aAAa,GAAG,SAAS,IAAI;iBAC7B,KAAK,kBAAkB,eAAe;AAChD,aAAK,KAAK,aAAa,GAAG,SAAS,IAAI;aACjC;AACN,eAAO,QAAQ,KAAK,aAAa,GAAG,iEAAiE;AACrG,aAAK,KAAK,oBAAoB,IAAI;AAClC,aAAK,KAAK,oBAAoB,KAAK,eAAe,MAAM,SAAS,YAAY;;;AAG/E,WAAO;EACR;;;;;;;;;EAUA,eAAe,MAAU;AACxB,WAAO,KAAK,KAAK,eAAe,IAAI;EACrC;;;;;;;;;;;;;EAcA,qBAAqB,UAAgB,MAAa,WAAwB,GAAC;AAC1E,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,cAAc,MAAM,QAAQ;AACjC,SAAK,eAAe,OAAO,KAAK,UAAU,QAAQ,CAAC;AACnD,WAAO;EACR;;;;EAKA,OAAO,OAAY;AAClB,SAAK,KAAK,sBAAsB,KAAK,UAAU,KAAK,CAAC;AACrD,WAAO;EACR;;;;EAKA,QAAQ,aAAwB,eAAe,GAAG,cAAc,GAAC;AAChE,kBAAc,MAAM,aAAa,cAAc,WAAW;AAC1D,WAAO;EACR;;;;;;EAOM,QAAQ,SAAS,MAAI;;AAC1B,YAAM,WAAW,SAAS,KAAK,QAAQ;AACvC,YAAMC,WAAU,IAAI,eAAe,GAAG,UAAU,KAAK,QAAQ,UAAU;AAEvE,YAAM,gBAAgB,KAAK,UAAU,KAAK,MAAM,IAAI,KAAK,UAAU,KAAK,KAAK;AAC7E,YAAM,mBAAmB,gBAAgB,KAAK,UAAU,KAAK,OAAO;AACpE,YAAM,cAAc,mBAAmB;AACvC,YAAM,gBAAgB,mBAAmB;AAEzC,YAAM,QAAQ,IAAI,KAAK,YAAY,OAAO,OAAO,KAAK,IAAG,GAAI;QAC5D,QAAQ,WAAW,KAAK,UAAU,KAAK,MAAM,IAAI;QACjD,OAAO,WAAW,KAAK,UAAU,KAAK,KAAK,IAAI;QAC/C,SAAS,WAAW,KAAK,UAAU,KAAK,OAAO,IAAI;QACnD,SAAAA;OACA,CAAC;AACF,YAAM,KAAK,cAAa;AACxB,YAAM,qBAAqB,YAAY,gBAAgB,eAAe,eAAe,CAAC;AACtF,YAAM,SAAS,MAAMA,SAAQ,OAAM;AACnC,aAAO,OAAO,eAAe,CAAC;IAC/B,CAAC;;EAED,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;AAjbA,WAAA;EADC,UAAU,CAAC;;AAqBZ,WAAA;EADC,UAAU,CAAC;;AAoBZ,WAAA;EADC,MAAM,GAAG,CAAC;;AAsBX,WAAA;EADC,UAAU,CAAC;;AA+Yb,IAAM,kBAAoC,MAAK;AAE9C,QAAM,WAAW;AAEjB,MAAI;AACJ,MAAI;AAGJ,QAAM,cAAwB,CAAA;AAC9B,OAAK,IAAI,GAAG,IAAI,UAAU,KAAK;AAC9B,gBAAY,CAAC,IAAI,KAAK,IAAK,KAAK,WAAW,MAAO,KAAK,KAAK,EAAE;;AAI/D,QAAM,cAAwB,CAAA;AAC9B,QAAM,kBAAkB;AACxB,OAAK,IAAI,GAAG,IAAI,WAAW,GAAG,KAAK;AAClC,QAAK,KAAK,WAAW;AACrB,UAAM,WAAW,KAAK,IAAI,KAAK,KAAK,KAAK,KAAK,kBAAkB,KAAK,KAAK,CAAC,IAAI;AAC/E,gBAAY,CAAC,IAAI,WAAW,KAAK,IAAI;;AAEtC,cAAY,WAAW,CAAC,IAAI;AAG5B,QAAM,cAAwB,CAAA;AAC9B,QAAM,QAAQ;AACd,OAAK,IAAI,GAAG,IAAI,UAAU,KAAK;AAC9B,gBAAY,CAAC,IAAI,KAAK,KAAM,KAAK,WAAW,KAAM,KAAK,IAAI;;AAI5D,QAAM,YAAsB,CAAA;AAC5B,OAAK,IAAI,GAAG,IAAI,UAAU,KAAK;AAC9B,QAAI,KAAK,WAAW;AACpB,cAAU,CAAC,IAAI,OAAO,IAAI,KAAK,IAAI,KAAK,KAAK,CAAC;;AAI/C,QAAM,cAAwB,CAAA;AAC9B,OAAK,IAAI,GAAG,IAAI,UAAU,KAAK;AAC9B,QAAI,KAAK,WAAW;AACpB,UAAM,OAAO,KAAK,IAAI,GAAG,CAAC,IAAI,IAAI;AAClC,UAAM,MAAM,KAAK,IAAI,OAAO,KAAK,KAAK,IAAI,CAAC;AAC3C,gBAAY,CAAC,IAAI,KAAK,IAAI,OAAO,IAAI,EAAE;;AAMxC,WAAS,YAAY,OAAe;AACnC,UAAM,MAAM,IAAI,MAAM,MAAM,MAAM;AAClC,aAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,UAAI,CAAC,IAAI,IAAI,MAAM,CAAC;;AAErB,WAAO;EACR;AAKA,WAAS,aAAa,OAAe;AACpC,WAAO,MAAM,MAAM,CAAC,EAAE,QAAO;EAC9B;AAKA,SAAO;IACN,QAAQ;MACP,IAAI,YAAY,WAAW;MAC3B,KAAK;;IAEN,QAAQ;MACP,IAAI;MACJ,KAAK,aAAa,WAAW;;IAE9B,aAAa;IACb,QAAQ;IACR,QAAQ;MACP,IAAI;MACJ,KAAK,YAAY,WAAW;;IAE7B,MAAM;MACL,IAAI;MACJ,KAAK,YAAY,SAAS;;IAE3B,MAAM;MACL,IAAI;MACJ,KAAK,YAAY,WAAW;;;AAG/B,GAAE;;;AChmBI,IAAgB,aAAhB,MAAgB,oBAAsD,cAAsB;EAkCjG,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,SAAS,CAAC;AAVxD,SAAA,mBAA6B,CAAA;AAK7B,SAAA,UAAU;AAkHV,SAAA,0BAA0B,KAAK;AAO/B,SAAA,2BAA2B,KAAK;AAnHvC,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,SAAS;AAExE,SAAK,UAAU,KAAK,SAAS,IAAI,OAAO;MACvC,SAAS,KAAK;MACd,QAAQ,QAAQ;KAChB;AACD,SAAK,SAAS,KAAK,QAAQ;AAC3B,aAAS,MAAM,QAAQ;EACxB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,QAAQ;KACR;EACF;;;;;;;;;;;;;;;EAgBA,OAAI;AACH,QAAI,KAAK,WAAU,GAAI;AACtB,WAAK,YAAY,iBAAiB,CAAC;AACnC,WAAK,YAAY,kBAAkB,CAAC;;AAErC,WAAO;EACR;;;;EAKU,aAAU;AACnB,QAAI,UAAU;AACd,QAAI,CAAC,KAAK,SAAS;AAClB,WAAK,UAAU;AACf,gBAAU;;AAEX,WAAO;EACR;;;;;;EAOU,YAAY,QAAgB,cAAoB;AACzD,UAAM,iBAAiB,KAAK,eAAe,MAAM,IAAI,KAAK,MAAM;AAChE,SAAK,MAAM,IAAI,IAAI,SAAe;AACjC,YAAM,OAAO,KAAK,YAAY;AAC9B,YAAM,KAAK,KAAK,QAAQ,UAAU,SAAS,CAAC,MAAK;AAChD,aAAK,YAAY,IAAI;AACrB,uBAAe,MAAM,MAAM,IAAI;MAChC,GAAG,IAAI;AACP,WAAK,iBAAiB,KAAK,EAAE;IAC9B;EACD;;;;EAKA,SAAM;AACL,SAAK,iBAAiB,QAAQ,QAAM,KAAK,QAAQ,UAAU,MAAM,EAAE,CAAC;AACpE,SAAK,mBAAmB,CAAA;AACxB,QAAI,KAAK,SAAS;AACjB,WAAK,UAAU;AACf,WAAK,gBAAgB,KAAK;AAC1B,WAAK,iBAAiB,KAAK;;AAE5B,WAAO;EACR;;;;;;;;;;;;;EAcA,qBAAqB,MAAiB,UAAgB,MAAa,UAAsB;AACxF,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,mBAAmB,KAAK,UAAU,QAAQ;AAChD,SAAK,cAAc,MAAM,cAAc,QAAQ;AAC/C,SAAK,eAAe,eAAe,gBAAgB;AACnD,WAAO;EACR;;;;;EAsBA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,OAAM;AACX,SAAK,mBAAmB,CAAA;AACxB,WAAO;EACR;;;;AC/JK,IAAgB,aAAhB,MAAgB,oBAAsD,WAAmB;EAwB9F,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,SAAS,CAAC;AAC/D,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,SAAS;AAExE,SAAK,aAAa,QAAQ;AAC1B,SAAK,YAAY,QAAQ;EAC1B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,QAAQ;MACR,WAAW;MACX,YAAY;KACZ;EACF;;;;;;;;;;;EAYA,cAAc,MAAkC,MAAa,WAAwB,GAAC;AACrF,SAAK,IAAI,iBAAiB,MAAM,MAAM,QAAQ;AAC9C,UAAM,UAAU,KAAK,UAAU,IAAI;AACnC,SAAK,uBAAuB,SAAS,QAAQ;AAC7C,SAAK,QAAQ,MAAM,OAAO;AAC1B,WAAO;EACR;;;;;;;;;;EAWA,eAAe,MAAW;AACzB,SAAK,IAAI,kBAAkB,IAAI;AAC/B,UAAM,UAAU,KAAK,UAAU,IAAI;AACnC,SAAK,wBAAwB,OAAO;AACpC,WAAO;EACR;;;;;;;;;;;;EA+BA,QAAQ,MAAkC,MAAW;AACpD,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,UAAM,oBAAoB,gBAAgB,iBAAiB,KAAK,YAAW,IAAK;AAChF,QAAI,KAAK,aAAa,KAAK,KAAK,eAAe,YAAY,IAAI,MAAM;AACpE,YAAM,WAAW,KAAK,UAAU,KAAK,UAAU;AAC/C,WAAK,UAAU,kBAAkB,mBAAmB,UAAU,YAAY;WACpE;AACN,WAAK,UAAU,eAAe,mBAAmB,YAAY;;AAE9D,WAAO;EACR;;AA5GA,WAAA;EADC,UAAU,CAAC;;;;ACGP,IAAO,oBAAP,MAAO,2BAA0B,SAAQ;EAsB9C,cAAA;AACC,UAAM,qBAAqB,mBAAkB,YAAW,GAAI,WAAW,CAAC,UAAU,SAAS,WAAW,SAAS,CAAC,CAAC;AArBzG,SAAA,OAAe;AAEhB,SAAA,YAAkB,IAAI,KAAK;MAClC,SAAS,KAAK;MACd,MAAM;KACN;AACD,SAAA,SAAe,KAAK;AACpB,SAAA,QAAc,KAAK;AAelB,SAAK,KAAK,QAAQ,KAAK,UAAU,IAAI;AACrC,SAAK,SAAS,KAAK;AACnB,SAAK,QAAQ,KAAK;EACnB;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;ACjCK,IAAO,QAAP,MAAO,eAA2D,WAAmB;EA4B1F,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,SAAS,CAAC;AA3BlD,SAAA,OAAe;AA4BvB,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,SAAS;AAEnE,SAAK,aAAa,IAAI,eAAe,OAAO,OAAO;MAClD,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,QAAQ,MAAM,KAAK,UAAU,IAAI;OAC/B,QAAQ,UAAU,CAAC;AAEtB,SAAK,YAAY,KAAK,WAAW;AACjC,SAAK,SAAS,KAAK,WAAW;AAE9B,SAAK,WAAW,IAAI,kBAAkB,OAAO,OAAO;MACnD,SAAS,KAAK;OACZ,QAAQ,QAAQ,CAAC;AAGpB,SAAK,WAAW,MAAM,KAAK,UAAU,KAAK,MAAM;AAChD,aAAS,MAAM,CAAC,cAAc,aAAa,UAAU,UAAU,CAAC;EACjE;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,UAAU,OAAO,OAChB,eAAe,SAAS,YAAW,GAAI,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAC/E;QACC,QAAQ;QACR,OAAO;QACP,SAAS;QACT,SAAS;OACT;MAEF,YAAY,OAAO,OAClB,eAAe,eAAe,YAAW,GAAI,CAAC,GAAG,OAAO,KAAK,OAAO,YAAW,CAAE,GAAG,aAAa,QAAQ,CAAC,GAC1G;QACC,MAAM;OACN;KAEF;EACF;;;;;;EAOU,uBAAuB,MAAe,UAAgB;AAE/D,SAAK,SAAS,cAAc,MAAM,QAAQ;AAC1C,SAAK,WAAW,MAAM,IAAI;AAE1B,QAAI,KAAK,SAAS,YAAY,GAAG;AAChC,YAAM,iBAAiB,KAAK,UAAU,KAAK,SAAS,MAAM;AAC1D,YAAM,gBAAgB,KAAK,UAAU,KAAK,SAAS,KAAK;AACxD,WAAK,WAAW,KAAK,OAAO,iBAAiB,aAAa;;EAE5D;;;;;EAMU,wBAAwB,MAAa;AAC9C,SAAK,SAAS,eAAe,IAAI;AACjC,SAAK,WAAW,KAAK,OAAO,KAAK,UAAU,KAAK,SAAS,OAAO,CAAC;EAClE;EAEA,eAAe,MAAU;AACxB,WAAO,KAAK,UAAU,IAAI;AAC1B,WAAO,KAAK,SAAS,eAAe,IAAI;EACzC;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAO;AACvB,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;ACpHK,IAAgB,kBAAhB,MAAgB,yBAAgE,WAAmB;EA8DxG,cAAA;AACC,UAAM,qBAAqB,iBAAgB,YAAW,GAAI,SAAS,CAAC;AA7D5D,SAAA,OAAe;AA8DvB,UAAM,UAAU,qBAAqB,iBAAgB,YAAW,GAAI,SAAS;AAE7E,SAAK,WAAW,IAAI,MAAM;MACzB,SAAS,KAAK;MACd,YAAY,QAAQ;MACpB,UAAU,QAAQ;MAClB,WAAW,MAAM,KAAK,UAAU,IAAI;MACpC,QAAQ;KACR;AACD,SAAK,aAAa,IAAI,MAAM;MAC3B,SAAS,KAAK;MACd,YAAY,QAAQ;MACpB,UAAU,QAAQ;MAClB,QAAQ;KACR;AAED,SAAK,aAAa,KAAK,SAAS;AAChC,SAAK,WAAW,KAAK,SAAS;AAC9B,SAAK,aAAa,KAAK,WAAW;AAClC,SAAK,qBAAqB,KAAK,WAAW;AAE1C,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;KACP;AACD,SAAK,SAAS,IAAI,OAAO;MACxB,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AACD,SAAK,cAAc,IAAI,SAAS;MAC/B,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,UAAU;KACV;AACD,SAAK,kBAAkB,IAAI,KAAK;MAC/B,SAAS,KAAK;MACd,MAAM;KACN;AAED,aAAS,MAAM,CAAC,aAAa,eAAe,cAAc,YAAY,cAAc,sBAAsB,QAAQ,CAAC;EACpH;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,aAAa;MACb,YAAY,OAAO,OAClB,eAAe,eAAe,YAAW,GAAI;QAC5C,GAAG,OAAO,KAAK,OAAO,YAAW,CAAE;QACnC;QACA;OACA,GACD;QACC,MAAM;OACN;MAEF,UAAU,OAAO,OAChB,eACC,SAAS,YAAW,GACpB,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAEzC;QACC,QAAQ;QACR,OAAO;QACP,SAAS;QACT,SAAS;OACT;MAEF,YAAY,OAAO,OAClB,eAAe,eAAe,YAAW,GAAI;QAC5C,GAAG,OAAO,KAAK,OAAO,YAAW,CAAE;QACnC;QACA;OACA,GACD;QACC,MAAM;OACN;MAEF,oBAAoB,OAAO,OAC1B,eACC,SAAS,YAAW,GACpB,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAEzC;QACC,QAAQ;QACR,OAAO;QACP,SAAS;QACT,SAAS;OACT;KAEF;EACF;;;;EAKU,uBAAuB,MAAe,UAAgB;AAE/D,SAAK,SAAS,uBAAuB,MAAM,QAAQ;AAEnD,SAAK,WAAW,uBAAuB,MAAM,QAAQ;EACtD;;;;EAKU,wBAAwB,MAAa;AAE9C,SAAK,SAAS,wBAAwB,IAAI;AAE1C,SAAK,WAAW,wBAAwB,IAAI;AAC5C,WAAO;EACR;EAEA,eAAe,MAAU;AACxB,WAAO,KAAK,UAAU,IAAI;AAC1B,WAAO,KAAK,SAAS,eAAe,IAAI;EACzC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,SAAS,QAAO;AACrB,SAAK,WAAW,QAAO;AACvB,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,SAAK,YAAY,QAAO;AACxB,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;;;ACnMK,IAAO,UAAP,MAAO,iBAAgB,gBAA+B;EAU3D,cAAA;AACC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,SAAS,CAAC;AATpD,SAAA,OAAe;AAWvB,SAAK,mBAAmB,IAAI,YAAY;MACvC,SAAS,KAAK;KACd;AAGD,SAAK,UAAU,QAAQ,KAAK,SAAS,SAAS;AAC9C,SAAK,UAAU,MAAM,KAAK,aAAa,KAAK,WAAW,SAAS;AAChE,SAAK,OAAO,IAAI,KAAK,SAAS,QAAQ,KAAK,WAAW,MAAM;AAC5D,SAAK,WAAW,MAAM,KAAK,kBAAkB,KAAK,gBAAgB,IAAI;AACtE,SAAK,SAAS,MAAM,KAAK,iBAAiB,KAAK,MAAM;EACtD;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,iBAAiB,QAAO;AAC7B,WAAO;EACR;;;;AC9BK,IAAO,eAAP,MAAO,sBAAqB,cAAkC;EAwCnE,cAAA;AACC,UAAM,qBAAqB,cAAa,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC,CAAC;AAxChF,SAAA,OAAe;AAyCvB,UAAM,UAAU,qBAAqB,cAAa,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC;AAEjG,SAAK,UAAU,KAAK,QAAQ,mBAAkB;AAC9C,SAAK,QAAQ,KAAK,SAAS,KAAK;AAEhC,SAAK,IAAI,IAAI,MAAM;MAClB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;MACf,OAAO,KAAK,QAAQ;KACpB;AAED,SAAK,YAAY,IAAI,MAAM;MAC1B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;MACf,OAAO,KAAK,QAAQ;KACpB;AAED,SAAK,SAAS,IAAI,MAAM;MACvB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;MACf,OAAO,KAAK,QAAQ;KACpB;AAED,SAAK,OAAO,IAAI,MAAM;MACrB,SAAS,KAAK;MACd,OAAO;MACP,SAAS;MACT,OAAO,QAAQ;MACf,OAAO,KAAK,QAAQ;KACpB;AAED,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,GAAG;MACH,MAAM;MACN,WAAW;MACX,QAAQ;MACR,MAAM;KACN;EACF;;;;;EAMA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAI;AACZ,UAAM,QAA4B;MAAC;MAAW;MAAY;MACzD;MAAY;MAAa;MAAS;MAAW;IAAS;AACvD,WAAO,MAAM,QAAQ,IAAI,MAAM,IAAI,wBAAwB,IAAI,EAAE;AACjE,SAAK,QAAQ,OAAO;EACrB;;;;;;;EAQA,qBAAqB,MAAM,KAAG;AAE7B,UAAM,aAAa,IAAI,aAAa,GAAG;AACvC,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC7B,YAAM,OAAO,KAAK,IAAI,IAAI,KAAK,CAAC;AAChC,YAAM,OAAO,QAAQ,MAAQ,MAAM;AACnC,iBAAW,CAAC,IAAI;;AAEjB,UAAM,YAAY,IAAI,aAAa,GAAG;AACtC,UAAM,cAAc,IAAI,aAAa,GAAG;AAExC,UAAM,cAAc,KAAK,QAAQ,mBAAkB;AACnD,gBAAY,OAAO,KAAK;AACxB,gBAAY,EAAE,QAAQ,KAAK,EAAE;AAC7B,gBAAY,UAAU,QAAQ,KAAK,UAAU;AAC7C,gBAAY,KAAK,QAAQ,KAAK,KAAK;AACnC,gBAAY,qBAAqB,YAAY,WAAW,WAAW;AACnE,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,WAAU;AACvB,SAAK,EAAE,QAAO;AACd,SAAK,UAAU,QAAO;AACtB,SAAK,KAAK,QAAO;AACjB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACjIK,IAAO,SAAP,MAAO,gBAAe,cAA4B;EAyCvD,cAAA;AACC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,SAAS,CAAC,CAAC;AAxCrF,SAAA,OAAe;AAEf,SAAA,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC1C,SAAA,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC5C,SAAA,WAA2B,CAAA;AAqClC,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,aAAa,QAAQ,SAAS,CAAC;AAEtG,SAAK,WAAW,CAAA;AAEhB,SAAK,IAAI,IAAI,OAAO;MACnB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,SAAK,SAAS,IAAI,OAAO;MACxB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,SAAK,OAAO,IAAI,OAAO;MACtB,SAAS,KAAK;MACd,OAAO;MACP,SAAS;MACT,OAAO,QAAQ;KACf;AACD,SAAK,QAAQ,QAAQ;AACrB,SAAK,UAAU,QAAQ;AACvB,aAAS,MAAM,CAAC,UAAU,aAAa,QAAQ,GAAG,CAAC;EACpD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,GAAG;MACH,QAAQ;MACR,WAAW;MACX,MAAM;MACN,SAAS;MACT,MAAM;KACN;EACF;;;;;EAMA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAsB;AAC9B,UAAM,QAA4B;MAAC;MAAW;MAAY;MACzD;MAAY;MAAa;MAAS;MAAW;IAAS;AACvD,WAAO,MAAM,QAAQ,IAAI,MAAM,IAAI,wBAAwB,IAAI,EAAE;AACjE,SAAK,QAAQ;AACb,SAAK,SAAS,QAAQ,YAAU,OAAO,OAAO,IAAI;EACnD;;;;;;EAOA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAO;AAClB,UAAM,aAAa,SAAS,OAAO,IAAI,UAAU,SAAS,SAAS,EAAE;AACrE,UAAM,gBAAgB,CAAC,KAAK,KAAK,KAAK,GAAG;AACzC,QAAI,iBAAiB,cAAc,QAAQ,UAAU;AAErD,WAAO,mBAAmB,IAAI,uBAAuB,cAAc,KAAK,IAAI,CAAC,EAAE;AAC/E,sBAAkB;AAElB,SAAK,WAAW;AAChB,SAAK,MAAM,WAAU;AACrB,SAAK,SAAS,QAAQ,YAAU,OAAO,WAAU,CAAE;AAEnD,SAAK,WAAW,IAAI,MAAM,cAAc;AACxC,aAAS,QAAQ,GAAG,QAAQ,gBAAgB,SAAS;AACpD,YAAM,SAAS,IAAI,aAAa;QAC/B,SAAS,KAAK;OACd;AACD,aAAO,OAAO,KAAK;AACnB,WAAK,UAAU,QAAQ,OAAO,SAAS;AACvC,WAAK,OAAO,QAAQ,OAAO,MAAM;AACjC,WAAK,EAAE,QAAQ,OAAO,CAAC;AACvB,WAAK,KAAK,QAAQ,OAAO,IAAI;AAC7B,WAAK,SAAS,KAAK,IAAI;;AAExB,SAAK,oBAAoB,KAAK;AAC9B,kBAAc,KAAK,OAAO,GAAG,KAAK,mBAAmB,KAAK,MAAM;EACjE;;;;;;;EAQA,qBAAqB,MAAM,KAAG;AAC7B,UAAM,cAAc,IAAI,aAAa;MACpC,WAAW,KAAK,UAAU;MAC1B,MAAM,KAAK,KAAK;MAChB,GAAG,KAAK,EAAE;MACV,MAAM,KAAK;MACX,QAAQ,KAAK,OAAO;KACpB;AAED,UAAM,gBAAgB,IAAI,aAAa,GAAG,EAAE,IAAI,MAAM,CAAC;AACvD,SAAK,SAAS,QAAQ,MAAK;AAC1B,YAAM,WAAW,YAAY,qBAAqB,GAAG;AACrD,eAAS,QAAQ,CAAC,KAAK,MAAM,cAAc,CAAC,KAAK,GAAG;IACrD,CAAC;AACD,gBAAY,QAAO;AACnB,WAAO;EACR;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,SAAS,QAAQ,YAAS;AAC9B,aAAO,QAAO;IACf,CAAC;AACD,aAAS,MAAM,CAAC,UAAU,aAAa,QAAQ,GAAG,CAAC;AACnD,SAAK,UAAU,QAAO;AACtB,SAAK,EAAE,QAAO;AACd,SAAK,OAAO,QAAO;AACnB,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;AC7KK,IAAO,oBAAP,MAAO,2BAA0B,SAAQ;EAgC9C,cAAA;AACC,UAAM,qBAAqB,mBAAkB,YAAW,GAAI,WAAW,CAAC,UAAU,SAAS,WAAW,SAAS,CAAC,CAAC;AA/BzG,SAAA,OAAe;AAgCvB,UAAM,UAAU,qBAAqB,mBAAkB,YAAW,GAAI,WAAW,CAAC,UAAU,SAAS,WAAW,SAAS,CAAC;AAE1H,SAAK,WAAW,QAAQ;AACxB,SAAK,iBAAiB,KAAK,YAAY,QAAQ,aAAa;AAE5D,SAAK,YAAY,KAAK,QAAQ,IAAI,IAAI;MACrC,SAAS,KAAK;MACd,OAAO,QAAQ;KACf;AACD,SAAK,SAAS,KAAK,SAAS,IAAI,MAAM;MACrC,SAAS,KAAK;MACd,KAAK,KAAK;MACV,KAAK,KAAK,iBAAiB,KAAK,IAAI,GAAG,KAAK,QAAQ;KACpD;AACD,SAAK,KAAK,MAAM,KAAK,WAAW,KAAK,MAAM;EAC5C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,SAAS,YAAW,GAAI;MAC5C,eAAe;MACf,UAAU;MACV,SAAS;KACT;EACF;;;;;EAMA,IAAI,gBAAa;AAChB,WAAO,KAAK;EACb;EACA,IAAI,cAAc,KAAG;AACpB,UAAM,OAAO,KAAK,YAAY,GAAG;AACjC,gBAAY,MAAM,CAAC;AACnB,SAAK,iBAAiB;AACtB,SAAK,OAAO,MAAM,KAAK;AAEvB,SAAK,UAAU,KAAK;EACrB;;;;;EAMA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAe;AAC1B,SAAK,WAAW;AAChB,SAAK,OAAO,MAAM,KAAK,iBAAiB,KAAK,IAAI,GAAG,OAAO;EAC5D;;;;EAKA,IAAI,WAAQ;AACX,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,SAAS,UAAQ;AACpB,SAAK,UAAU,QAAQ;EACxB;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;AC9FK,IAAO,YAAP,MAAO,mBAAkB,WAA4B;EAmC1D,cAAA;AACC,UAAM,qBAAqB,WAAU,YAAW,GAAI,SAAS,CAAC;AAlCtD,SAAA,OAAO;AAmCf,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,SAAS;AAEvE,SAAK,aAAa,IAAI,eAAe,OAAO,OAAO,QAAQ,YAAY;MACtE,SAAS,KAAK;MACd,QAAQ,QAAQ;MAChB,QAAQ,MAAM,KAAK,UAAU,IAAI;KACjC,CAAC;AACF,SAAK,YAAY,KAAK,WAAW;AACjC,SAAK,SAAS,KAAK,WAAW;AAC9B,SAAK,SAAS,IAAI,OAAO,OAAO,OAAO,QAAQ,QAAQ,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AACjF,SAAK,iBAAiB,IAAI,kBAAkB,OAAO,OAAO,QAAQ,gBAAgB,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAC5G,SAAK,WAAW,IAAI,kBAAkB,OAAO,OAAO,QAAQ,UAAU,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAGhG,SAAK,WAAW,MAAM,KAAK,QAAQ,KAAK,UAAU,KAAK,MAAM;AAG7D,SAAK,eAAe,QAAQ,KAAK,OAAO,SAAS;AAEjD,aAAS,MAAM,CAAC,cAAc,aAAa,UAAU,UAAU,kBAAkB,UAAU,CAAC;EAC7F;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,UAAU,OAAO,OAChB,eAAe,SAAS,YAAW,GAAI,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAC/E;QACC,QAAQ;QACR,OAAO;QACP,SAAS;QACT,SAAS;OACT;MAEF,QAAQ,OAAO,OACd,eAAe,OAAO,YAAW,GAAI,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAC7E;QACC,GAAG;QACH,SAAS;QACT,MAAM;OACN;MAEF,gBAAgB,OAAO,OACtB,eAAe,kBAAkB,YAAW,GAAI,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GACxF;QACC,QAAQ;QACR,eAAe;QACf,OAAO;QACP,UAAU;QACV,SAAS;QACT,SAAS;QACT,SAAS;OACT;MAEF,YAAY,OAAO,OAClB,eAAe,eAAe,YAAW,GAAI,OAAO,KAAK,OAAO,YAAW,CAAE,CAAC,GAC9E;QACC,MAAM;OACN;KAEF;EACF;;;;;;EAOU,uBAAuB,MAAe,WAAW,GAAC;AAC3D,SAAK,SAAS,cAAc,MAAM,QAAQ;AAC1C,SAAK,eAAe,cAAc,IAAI;AACtC,SAAK,WAAW,MAAM,IAAI;AAC1B,QAAI,KAAK,SAAS,YAAY,GAAG;AAChC,YAAM,iBAAiB,KAAK,UAAU,KAAK,SAAS,MAAM;AAC1D,YAAM,gBAAgB,KAAK,UAAU,KAAK,SAAS,KAAK;AACxD,WAAK,WAAW,KAAK,OAAO,iBAAiB,aAAa;;EAE5D;;;;;EAMU,wBAAwB,MAAa;AAC9C,SAAK,SAAS,eAAe,IAAI;AACjC,SAAK,eAAe,eAAe,IAAI;AACvC,SAAK,WAAW,KAAK,OAAO,KAAK,UAAU,KAAK,SAAS,OAAO,CAAC;EAClE;EAEA,eAAe,MAAU;AACxB,WAAO,KAAK,UAAU,IAAI;AAC1B,WAAO,KAAK,SAAS,eAAe,IAAI;EACzC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAO;AACvB,SAAK,SAAS,QAAO;AACrB,SAAK,eAAe,QAAO;AAC3B,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACpJK,IAAO,WAAP,MAAO,kBAAiB,WAA2B;EAiDxD,cAAA;AACC,UAAM,qBAAqB,UAAS,YAAW,GAAI,SAAS,CAAC;AAhDrD,SAAA,OAAe;AAiDvB,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,SAAS;AAEtE,SAAK,SAAS,IAAI,UAAU,OAAO,OAAO,QAAQ,QAAQ;MACzD,SAAS,KAAK;MACd,WAAW,MAAM,KAAK,UAAU,IAAI;KACpC,CAAC;AACF,SAAK,SAAS,IAAI,UAAU,OAAO,OAAO,QAAQ,QAAQ;MACzD,SAAS,KAAK;KACd,CAAC;AAEF,SAAK,cAAc,IAAI,SAAS;MAC/B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,WAAW,IAAI,IAAI;MACvB,WAAW,QAAQ;MACnB,SAAS,KAAK;MACd,KAAK;MACL,KAAK;KACL;AAED,SAAK,SAAS,MAAK;AACnB,SAAK,cAAc,KAAK,SAAS;AACjC,SAAK,eAAe,IAAI,KAAK;MAC5B,SAAS,KAAK;MACd,OAAO;MACP,MAAM,QAAQ;KACd;AACD,SAAK,gBAAgB,KAAK,aAAa;AAEvC,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO;KACP;AACD,SAAK,SAAS,IAAI,OAAO;MACxB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAGD,SAAK,UAAU,QAAQ,KAAK,OAAO,SAAS;AAC5C,SAAK,UAAU,MAAM,KAAK,aAAa,KAAK,OAAO,SAAS;AAE5D,SAAK,SAAS,QAAQ,KAAK,YAAY;AACvC,SAAK,aAAa,IAAI,KAAK,OAAO,QAAQ,KAAK,OAAO,MAAM;AAE5D,SAAK,OAAO,IAAI,KAAK,OAAO,QAAQ,KAAK,OAAO,MAAM;AAEtD,SAAK,OAAO,QAAQ,KAAK,MAAM;AAC/B,SAAK,OAAO,QAAQ,KAAK,MAAM;AAE/B,aAAS,MAAM,CAAC,UAAU,UAAU,aAAa,iBAAiB,aAAa,CAAC;EACjF;EAEA,eAAe,MAAU;AACxB,WAAO,KAAK,UAAU,IAAI;AAC1B,WAAO,KAAK,OAAO,SAAS,eAAe,IAAI,IAAI,KAAK,OAAO,SAAS,eAAe,IAAI;EAC5F;EAEA,OAAO,cAAW;AACjB,WAAO,UAAU,WAAW,YAAW,GAAI;MAC1C,eAAe;MACf,aAAa;MACb,aAAa;MACb,QAAQ,UACP,eAAe,UAAU,YAAW,GAAI,OAAO,KAAK,WAAW,YAAW,CAAE,CAAC,GAC7E;QACC,gBAAgB;UACf,QAAQ;UACR,OAAO;UACP,SAAS;UACT,SAAS;;QAEV,UAAU;UACT,QAAQ;UACR,OAAO;UACP,SAAS;UACT,SAAS;;OAEV;MACF,QAAQ,UACP,eAAe,UAAU,YAAW,GAAI,OAAO,KAAK,WAAW,YAAW,CAAE,CAAC,GAC7E;QAEC,gBAAgB;UACf,QAAQ;UACR,OAAO;UACP,SAAS;UACT,SAAS;;QAEV,UAAU;UACT,QAAQ;UACR,OAAO;UACP,SAAS;UACT,SAAS;;OAEV;KACF;EACF;;;;EAIU,uBAAuB,MAAe,UAAgB;AAE/D,SAAK,OAAO,uBAAuB,MAAM,QAAQ;AAEjD,SAAK,OAAO,uBAAuB,MAAM,QAAQ;EAClD;;;;EAKU,wBAAwB,MAAa;AAE9C,SAAK,OAAO,wBAAwB,IAAI;AAExC,SAAK,OAAO,wBAAwB,IAAI;AACxC,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,OAAO,QAAO;AACnB,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,SAAK,SAAS,QAAO;AACrB,SAAK,YAAY,QAAO;AACxB,SAAK,aAAa,QAAO;AACzB,SAAK,YAAY,QAAO;AACxB,WAAO;EACR;;;;AC9LK,IAAO,UAAP,MAAO,iBAAgB,gBAA+B;EAW3D,cAAA;AACC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,SAAS,CAAC;AAXpD,SAAA,OAAe;AAYvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,SAAS;AAErE,SAAK,kBAAkB,IAAI,SAAS;MACnC,SAAS,KAAK;MACd,OAAO,QAAQ;KACf;AAGD,SAAK,UAAU,QAAQ,KAAK,SAAS,SAAS;AAC9C,SAAK,UAAU,MAAM,KAAK,aAAa,KAAK,WAAW,SAAS;AAChE,SAAK,UAAU,MAAM,KAAK,iBAAiB,KAAK,eAAe;AAC/D,SAAK,OAAO,IAAI,KAAK,SAAS,QAAQ,KAAK,WAAW,MAAM;AAC5D,SAAK,WAAW,QAAQ,KAAK,gBAAgB,IAAI;AACjD,SAAK,gBAAgB,QAAQ,KAAK,SAAS,SAAS;AACpD,SAAK,SAAS,QAAQ,KAAK,MAAM;EAClC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,gBAAgB,YAAW,GAAI;MACnD,iBAAiB;KACjB;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,gBAAgB,QAAO;AAC5B,WAAO;EACR;;;;ACtCD,IAAM,eAAyB,CAAC,GAAK,OAAO,OAAO,OAAO,MAAO,KAAK;AAShE,IAAO,aAAP,MAAO,oBAAmB,WAA6B;EAqD5D,cAAA;AACC,UAAM,qBAAqB,YAAW,YAAW,GAAI,SAAS,CAAC;AApDvD,SAAA,OAAe;AAehB,SAAA,eAA+B,CAAA;AAK/B,SAAA,mBAA+B,CAAA;AAiCtC,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,SAAS;AAExE,SAAK,SAAS,IAAI,OAAO;MACxB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;KACP;AAED,SAAK,aAAa,IAAI,KAAK;MAC1B,SAAS,KAAK;MACd,MAAM;KACN,EAAE,QAAQ,KAAK,MAAM;AAEtB,SAAK,YAAY,IAAI,OAAO;;MAE3B,GAAG;MACH,SAAS,KAAK;MACd,MAAM;KACN,EAAE,QAAQ,KAAK,UAAU;AAE1B,aAAS,IAAI,GAAG,IAAI,aAAa,QAAQ,KAAK;AAC7C,YAAM,MAAM,IAAI,aAAa;QAC5B,SAAS,KAAK;QACd,aAAa,QAAQ;QACrB,iBAAiB,QAAQ;QACzB,gBAAgB;QAChB,QAAQ,MAAM,IAAI,MAAM,KAAK,UAAU,IAAI,IAAI;QAC/C,MAAM;OACN;AACD,UAAI,QAAQ,KAAK,SAAS;AAC1B,WAAK,aAAa,CAAC,IAAI;AAEvB,YAAM,OAAO,IAAI,SAAS;QACzB,SAAS,KAAK;QACd,OAAO,aAAa,CAAC;OACrB;AACD,WAAK,iBAAiB,CAAC,IAAI;AAC3B,WAAK,UAAU,MAAM,MAAM,IAAI,SAAS;AACxC,WAAK,OAAO,QAAQ,IAAI,MAAM;;AAG/B,SAAK,oBAAoB,IAAI,MAAM;MAClC,SAAS,KAAK;MACd,KAAK;MACL,KAAK,KAAK,YAAY,QAAQ,SAAS;KACvC;AAED,SAAK,WAAW,IAAI,SAAS;MAC5B,QAAQ,QAAQ,SAAS;MACzB,aAAa;MACb,SAAS,KAAK;MACd,OAAO,QAAQ,SAAS;MACxB,SAAS,QAAQ,SAAS;MAC1B,SAAS;KACT;AAED,SAAK,SAAS,MAAM,KAAK,mBAAmB,KAAK,UAAU,SAAS;AACpE,SAAK,SAAS,QAAQ,KAAK,WAAW,IAAI;AAE1C,SAAK,WAAW,QAAQ;AACxB,SAAK,UAAU,QAAQ;EACxB;EAEA,OAAO,cAAW;AACjB,WAAO,UAAU,WAAW,YAAW,GAAI;MAC1C,UAAU,OAAO,OAChB,eAAe,SAAS,YAAW,GAAI,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAC/E;QACC,QAAQ;QACR,OAAO;QACP,SAAS;OACT;MAEF,aAAa;MACb,iBAAiB;MACjB,SAAS;MACT,WAAW;KACX;EACF;;;;;;EAOU,uBAAuB,MAAe,WAAwB,GAAC;AACxE,SAAK,SAAS,cAAc,MAAM,QAAQ;AAC1C,SAAK,aAAa,QAAQ,SAAO,IAAI,MAAM,IAAI,CAAC;AAChD,QAAI,KAAK,SAAS,YAAY,GAAG;AAChC,WAAK,aAAa,QAAQ,SAAM;AAC/B,YAAI,KAAK,OAAO,KAAK,UAAU,KAAK,SAAS,MAAM,IAAI,KAAK,UAAU,KAAK,SAAS,KAAK,CAAC;MAC3F,CAAC;;AAEF,WAAO;EACR;;;;;EAMU,wBAAwB,MAAa;AAC9C,SAAK,SAAS,eAAe,IAAI;AACjC,SAAK,aAAa,QAAQ,SAAO,IAAI,KAAK,OAAO,KAAK,UAAU,KAAK,SAAS,OAAO,CAAC,CAAC;AACvF,WAAO;EACR;EAEA,eAAe,MAAU;AACxB,WAAO,KAAK,UAAU,IAAI;AAC1B,WAAO,KAAK,SAAS,eAAe,IAAI;EACzC;;;;;;;EAQA,IAAI,kBAAe;AAClB,WAAO,KAAK,aAAa,CAAC,EAAE,gBAAgB;EAC7C;EACA,IAAI,gBAAgB,KAAG;AACtB,SAAK,aAAa,QAAQ,SAAQ,IAAI,gBAAgB,QAAQ,GAAI;EACnE;;;;;;;EAQA,IAAI,cAAW;AACd,WAAO,KAAK,aAAa,CAAC,EAAE,YAAY;EACzC;EACA,IAAI,YAAY,KAAG;AAClB,SAAK,aAAa,QAAQ,SAAQ,IAAI,YAAY,QAAQ,GAAI;EAC/D;;;;;;;EAQA,IAAI,YAAS;AACZ,WAAO,KAAK,kBAAkB;EAC/B;EACA,IAAI,UAAU,KAAG;AAChB,SAAK,kBAAkB,MAAM,KAAK,YAAY,GAAG;AACjD,SAAK,UAAU,KAAK;EACrB;;;;;;;EAQA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,KAAG;AACd,SAAK,WAAW;AAChB,SAAK,kBAAkB,MAAM,KAAK,kBAAkB,MAAM,KAAK,IAAI,GAAG,GAAG;EAC1E;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,aAAa,QAAQ,SAAO,IAAI,QAAO,CAAE;AAC9C,SAAK,iBAAiB,QAAQ,cAAY,SAAS,QAAO,CAAE;AAC5D,SAAK,UAAU,QAAO;AACtB,SAAK,OAAO,QAAO;AACnB,SAAK,kBAAkB,QAAO;AAC9B,SAAK,WAAW,QAAO;AACvB,SAAK,SAAS,QAAO;AACrB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;ACpPK,IAAO,gBAAP,MAAO,uBAAsB,MAA2B;EA6B7D,cAAA;AAEC,UAAM,qBAAqB,eAAc,YAAW,GAAI,SAAS,CAAC;AA7B1D,SAAA,OAAe;AAqBf,SAAA,aAAa;AASrB,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,SAAS;AAE3E,SAAK,aAAa,QAAQ;AAC1B,SAAK,UAAU,QAAQ;AACvB,aAAS,MAAM,CAAC,cAAc,UAAU,CAAC;EAC1C;EAEA,OAAO,cAAW;AACjB,WAAO,UAAU,WAAW,YAAW,GAAI,MAAM,YAAW,GAAI;MAC/D,UAAU;QACT,QAAQ;QACR,aAAa;QACb,OAAO;QACP,SAAS;QACT,SAAS;;MAEV,SAAS;MACT,YAAY;QACX,MAAM;;MAEP,YAAY;KACZ;EACF;EAEA,QAAQ,MAAkC,MAAW;AACpD,UAAM,UAAU,KAAK,UAAU,IAAI;AACnC,UAAM,QAAQ,KAAK,YAAY,gBAAgB,iBAAiB,KAAK,YAAW,IAAK,IAAI;AACzF,UAAM,UAAU,QAAQ,KAAK;AAC7B,SAAK,WAAW,UAAU,eAAe,SAAS,OAAO;AACzD,SAAK,WAAW,UAAU,6BAA6B,OAAO,UAAU,KAAK,UAAU,KAAK,UAAU,CAAC;AACvG,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,WAAO;EACR;;AA1DA,WAAA;EADC,MAAM,CAAC;;AASR,WAAA;EADC,UAAU,CAAC;;;;AChBP,IAAO,aAAP,MAAO,oBAAmB,WAA6B;EAe5D,cAAA;AACC,UAAM,qBAAqB,YAAW,YAAW,GAAI,SAAS,CAAC;AAdvD,SAAA,OAAO;AAef,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,SAAS;AACxE,SAAK,QAAQ,IAAI,MAAM,OAAO,OAAO;MACpC,SAAS,KAAK;OACZ,QAAQ,KAAK,CAAC;AAEjB,SAAK,WAAW,IAAI,kBAAkB,OAAO,OAAO;MACnD,SAAS,KAAK;OACZ,QAAQ,QAAQ,CAAC;AAGpB,SAAK,MAAM,MAAM,KAAK,UAAU,KAAK,MAAM;EAC5C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,UAAU,OAAO,OAChB,eAAe,SAAS,YAAW,GAAI,OAAO,KAAK,cAAc,YAAW,CAAE,CAAC,GAC/E;QACC,OAAO;QACP,SAAS;OACT;MAEF,OAAO,OAAO,OACb,eAAe,MAAM,YAAW,GAAI,OAAO,KAAK,OAAO,YAAW,CAAE,CAAC,GACrE;QACC,MAAM;OACN;KAEF;EACF;;;;;;;;EASA,cAAc,MAAa,WAAwB,GAAC;AACnD,WAAO,KAAK,UAAU,IAAI;AAE1B,SAAK,SAAS,cAAc,MAAM,QAAQ;AAE1C,SAAK,MAAM,MAAM,IAAI;AACrB,QAAI,KAAK,SAAS,YAAY,GAAG;AAChC,WAAK,MAAM,KAAK,OAAO,KAAK,UAAU,KAAK,SAAS,MAAM,IAAI,KAAK,UAAU,KAAK,SAAS,KAAK,CAAC;;AAElG,WAAO;EACR;;;;EAKA,eAAe,MAAW;AACzB,WAAO,KAAK,UAAU,IAAI;AAC1B,SAAK,SAAS,eAAe,IAAI;AACjC,SAAK,MAAM,KAAK,OAAO,KAAK,UAAU,KAAK,SAAS,OAAO,CAAC;AAC5D,WAAO;EACR;EAEA,OAAI;AACH,QAAI,KAAK,WAAU,GAAI;AACtB,WAAK,YAAY,iBAAiB,CAAC;AACnC,WAAK,YAAY,kBAAkB,CAAC;;AAErC,WAAO;EACR;EAEA,qBAAqB,UAAgB,MAAa,WAAwB,GAAC;AAC1E,WAAO,KAAK,UAAU,IAAI;AAC1B,eAAW,KAAK,UAAU,QAAQ;AAClC,SAAK,cAAc,MAAM,QAAQ;AACjC,SAAK,eAAe,OAAO,QAAQ;AACnC,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;AC1HD,IAAM,iBAA8B,oBAAI,IAAG;AAKrC,SAAU,aAAa,iBAAuB;AACnD,iBAAe,IAAI,eAAe;AACnC;AAKM,SAAU,kBAAkB,MAAc,WAAiB;AAChE,QAAM;;IAA4B,sBAAsB,IAAI,MAAM,SAAS;;AAC3E,iBAAe,IAAI,SAAS;AAC7B;AAKM,SAAU,wBAAqB;AACpC,SAAO,MAAM,KAAK,cAAc,EAAE,KAAK,IAAI;AAC5C;;;ACnBM,IAAgB,mBAAhB,cAAkF,cAAsB;EAuC7G,YAAY,SAAgB;AAC3B,UAAM,OAAO;AAtCL,SAAA,OAAe;AAoBd,SAAA,iBAAmD,CAAA;AAe7D,SAAA,mBAAwC;AAKvC,UAAM,UAAU,IAAI,gBAAgB,IAAI,KAAK,CAAC,sBAAqB,CAAE,GAAG,EAAE,MAAM,kBAAiB,CAAE,CAAC;AACpG,UAAM,OAAO,KAAK,kBAAiB;AAEnC,SAAK,aAAa,KAAK,QAAQ,WAAU;AACzC,SAAK,cAAc,KAAK,WAAW;AAGnC,SAAK,QAAQ,sBAAsB,SAAS,IAAI,EAAE,KAAK,MAAK;AAE3D,UAAI,CAAC,KAAK,UAAU;AACnB,aAAK,WAAW,KAAK,QAAQ,uBAAuB,MAAM,KAAK,cAAc;AAC7E,aAAK,SAAS,mBAAmB,KAAK,iBAAiB,KAAK,IAAI;AAChE,aAAK,QAAQ,KAAK,QAAQ;;IAE5B,CAAC;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,WAAU;AAC1B,QAAI,KAAK,UAAU;AAClB,WAAK,SAAS,KAAK,YAAY,SAAS;AACxC,WAAK,SAAS,WAAU;;AAEzB,WAAO;EACR;;;;ACvED,IAAM;;EAA6C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgCnD,aAAa,yBAAyB;;;AC/B/B,IAAM;;EAAmC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqEhD,aAAa,eAAe;;;ACtE5B,IAAM;;EAA6B;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CnC,aAAa,SAAS;;;AC5Cf,IAAM,cAAc;AAE3B,IAAM;;EAAqC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgC3C,kBAAkB,aAAa,kBAAkB;;;ACf3C,IAAO,qBAAP,MAAO,4BAA2B,iBAA2C;EAuBlF,cAAA;AACC,UAAM,qBAAqB,oBAAmB,YAAW,GAAI,WAAW,CAAC,aAAa,WAAW,CAAC,CAAC;AAtB3F,SAAA,OAAO;AAuBf,UAAM,UAAU,qBAAqB,oBAAmB,YAAW,GAAI,WAAW,CAAC,aAAa,WAAW,CAAC;AAE5G,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/C,SAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAEhD,SAAK,YAAY,IAAI,MAAc;MAClC,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;MACP,UAAU;MACV,UAAU;MACV,OAAO,KAAK;MACZ,WAAW;KACX;AAED,SAAK,YAAY,IAAI,MAAqB;MACzC,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;MACP,OAAO,KAAK;MACZ,WAAW;KACX;AAED,aAAS,MAAM,CAAC,aAAa,WAAW,CAAC;EAC1C;EAEU,oBAAiB;AAC1B,WAAO;EACR;;;;EAKA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,WAAW;KACX;EACF;EAEA,QAAQ,MAAsB;AAC7B,kBAAc,KAAK,OAAO,MAAM,KAAK,MAAM;AAC3C,UAAM,YAAY,KAAK,WAAW,IAAI,WAAW;AAAgB;AACjE,SAAK,UAAU,SAAS,SAAS;AACjC,UAAM,WAAW,KAAK,WAAW,IAAI,UAAU;AAAgB;AAC/D,SAAK,UAAU,SAAS,QAAQ;EACjC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,OAAO,QAAO;AACnB,SAAK,UAAU,QAAO;AACtB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;ACjFK,IAAO,gBAAP,MAAO,uBAAsB,cAAmC;EA4BrE,cAAA;AAEC,UAAM,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC,CAAC;AA5BjF,SAAA,OAAe;AA6BvB,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,MAAM,CAAC;AAElG,SAAK,aAAa,QAAQ;AAC1B,SAAK,QAAQ,QAAQ;AACrB,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/C,SAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAChD,SAAK,cAAa;EACnB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,MAAM;KACN;EACF;;;;EAKQ,gBAAa;AACpB,UAAM,YAAY,KAAK;AACvB,UAAM,OAAO,KAAK,YAAY,KAAK,UAAU;AAC7C,UAAM,IAAI,KAAK,IAAI,KAAK,KAAK;AAC7B,QAAI,KAAK,UAAU,WAAW;AAC7B,YAAM,KAAK,KAAK,IAAI,KAAK,QAAQ;AACjC,YAAM,KAAK,KAAK;AAChB,WAAK,UAAU,KAAK,QAAQ,gBAAgB,CAAC,IAAI,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC;WACtD;AACN,YAAM,KAAK,KAAK,IAAI,KAAK,QAAQ,cAAc;AAC/C,WAAK,UAAU,KAAK,QAAQ,gBAAgB,CAAC,GAAG,EAAE,GAAG,CAAC,GAAG,EAAE,CAAC;;AAG7D,SAAK,MAAM,MAAM,KAAK,SAAS,KAAK,MAAM;AAC1C,QAAI,WAAW;AAEd,WAAK,QAAQ,WAAW,MAAK;AAC5B,YAAI,CAAC,KAAK,UAAU;AACnB,eAAK,MAAM,WAAW,SAAS;AAC/B,oBAAU,WAAU;;MAEtB,GAAG,KAAK,SAAS;;EAEnB;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK;EACb;EACA,IAAI,UAAU,IAAE;AACf,SAAK,aAAa;AAClB,SAAK,cAAa;EACnB;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,GAAC;AACT,SAAK,QAAQ;AACb,SAAK,cAAa;EACnB;;;;;;;EAQA,qBAAqB,MAAM,KAAG;AAC7B,UAAM,aAAa,IAAI,aAAa,GAAG;AACvC,aAAS,IAAI,GAAG,IAAI,KAAK,KAAK;AAC7B,YAAM,OAAO,KAAK,IAAI,IAAI,KAAK,CAAC;AAChC,YAAM,OAAO,QAAQ,MAAQ,MAAM;AACnC,iBAAW,CAAC,IAAI;;AAEjB,UAAM,YAAY,IAAI,aAAa,GAAG;AACtC,UAAM,cAAc,IAAI,aAAa,GAAG;AACxC,SAAK,QAAQ,qBAAqB,YAAY,WAAW,WAAW;AACpE,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,OAAO,QAAO;AACnB,SAAK,QAAQ,WAAU;AACvB,WAAO;EACR;;;;AC7HK,IAAO,oBAAP,MAAO,2BAA0B,cAAuC;EAkC7E,cAAA;AACC,UAAM,qBAAqB,mBAAkB,YAAW,GAAI,WAAW,CAAC,aAAa,aAAa,WAAW,CAAC,CAAC;AAjCvG,SAAA,OAAO;AAkCf,UAAM,UAAU,qBAAqB,mBAAkB,YAAW,GAAI,WAAW,CAAC,aAAa,aAAa,WAAW,CAAC;AAExH,SAAK,cAAc,KAAK,SAAS,IAAI,mBAAmB;MACvD,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,WAAW,QAAQ;KACnB;AACD,SAAK,YAAY,KAAK,YAAY;AAClC,SAAK,YAAY,KAAK,YAAY;AAElC,SAAK,WAAW,KAAK,QAAQ,IAAI,cAAc;MAC9C,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,MAAM;KACN;AAGD,SAAK,SAAS,QAAQ,KAAK,WAAW;EACvC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,WAAW;MACX,WAAW;KACX;EACF;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK,SAAS;EACtB;EACA,IAAI,UAAU,IAAE;AACf,SAAK,SAAS,YAAY;EAC3B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,YAAY,QAAO;AACxB,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;ACzEK,IAAO,aAAP,MAAO,oBAAmB,WAA6B;EA6B5D,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,SAAS,CAAC;AA7BvD,SAAA,OAAO;AA8Bf,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,SAAS;AAExE,SAAK,SAAS,IAAI,MAAM;MACvB,SAAS,KAAK;MACd,MAAM;KACN;AAED,SAAK,cAAc,QAAQ;AAE3B,SAAK,QAAQ,IAAI,kBAAkB;MAClC,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,WAAW,QAAQ;KACnB;AAED,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AAEvB,SAAK,OAAO,QAAQ,KAAK,KAAK;AAC9B,SAAK,MAAM,QAAQ,KAAK,MAAM;EAC/B;EAEA,OAAO,cAAW;AACjB,WAAO,UAAU,WAAW,YAAW,GAAI;MAC1C,aAAa;MACb,WAAW;MACX,WAAW;MACX,SAAS;KACT;EACF;;;;;;EAOA,IAAI,YAAS;AACZ,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,UAAU,IAAE;AACf,SAAK,MAAM,YAAY;EACxB;EAEA,cAAc,MAAiB,MAAW;AACzC,UAAM,OAAO,KAAK,YAAY,IAAI;AAClC,WAAO,KAAK,UAAU,IAAI;AAC1B,UAAM,cAAc,IAAI;AACxB,SAAK,MAAM,UAAU,eAAe,aAAa,IAAI;AACrD,SAAK,OAAO,MAAM,IAAI;AACtB,SAAK,OAAO,KAAK,OAAO,cAAc,KAAK,WAAW;AACtD,SAAK,MAAM,UAAU,sBAAsB,IAAI;AAC/C,SAAK,MAAM,UAAU,eAAe,KAAK,WAAW,IAAI;AACxD,WAAO;EACR;;;;EAKA,eAAe,MAAW;AACzB,SAAK,MAAM,UAAU,aAAa,GAAG,KAAK,SAAS,IAAI;AACvD,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACrEK,IAAO,YAAP,MAAO,mBAAyD,WAA+B;EA0DpG,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,SAAS,SAAS,CAAC,CAAC;AA1D5E,SAAA,OAAe;AAKhB,SAAA,mBAA4B,CAAA;AAK5B,SAAA,gBAA4E,CAAA;AAK5E,SAAA,UAAmB,CAAA;AAyBnB,SAAA,aAAa;AAKb,SAAA,uBAAuB;AAc9B,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,SAAS,SAAS,CAAC;AAG7F,WAAO,CAAC,SAAS,QAAQ,KAAK,GAAG,kEAAkE;AAEnG,UAAM,WAAW,QAAQ,MAAM,YAAW;AAC1C,SAAK,UAAU,OAAO,OAAO,UAAU,QAAQ,OAAO;AACtD,SAAK,QAAQ,QAAQ;AACrB,SAAK,eAAe,QAAQ;AAG5B,SAAK,cAAc,KAAK,uBAAsB;AAE9C,UAAM,QAAQ,KAAK,QAAQ,QAAQ,KAAK,WAAW;AACnD,SAAK,QAAQ,OAAO,OAAO,CAAC;AAE5B,SAAK,aAAa,KAAK,QAAQ,YAAY,KAAK,gBAAgB,KAAK,IAAI,GAAG,CAAC;EAC9E;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,cAAc;MACd,SAAS,CAAA;MACT,OAAO;KACP;EACF;;;;EAKA,IAAI,eAAY;AACf,WAAO,KAAK,cAAc;EAC3B;;;;;EAMQ,oBAAoB,OAAY;AACvC,SAAK,iBAAiB,KAAK,KAAK;AAEhC,UAAM,mBAAmB,KAAK,cAAc,UAAU,CAAC,MAAM,EAAE,UAAU,KAAK;AAC9E,SAAK,cAAc,OAAO,kBAAkB,CAAC;EAC9C;;;;;;EAOQ,yBAAsB;AAE7B,QAAI,KAAK,iBAAiB,QAAQ;AACjC,aAAO,KAAK,iBAAiB,MAAK;eACxB,KAAK,QAAQ,SAAS,KAAK,cAAc;AAEnD,YAAM,QAAQ,IAAI,KAAK,MAAM,OAAO,OAAO,KAAK,SAAS;QACxD,SAAS,KAAK;QACd,WAAW,KAAK,oBAAoB,KAAK,IAAI;OAC7C,CAAC;AACF,YAAM,QAAQ,KAAK,MAAM;AACzB,WAAK,QAAQ,KAAK,KAAK;AACvB,aAAO;WACD;AACN,WAAK,uCAAuC;;EAE9C;;;;EAKQ,kBAAe;AACtB,SAAK,uBAAuB,KAAK,IAAI,KAAK,uBAAuB,MAAM,KAAK,YAAY;AACxF,QAAI,KAAK,iBAAiB,UAAU,KAAK,QAAQ,SAAS,KAAK,KAAK,KAAK,uBAAuB,CAAC,GAAG;AAEnG,YAAM,aAAa,KAAK,iBAAiB,MAAK;AAC9C,YAAM,QAAQ,KAAK,QAAQ,QAAQ,UAAU;AAC7C,WAAK,QAAQ,OAAO,OAAO,CAAC;AAC5B,UAAI,CAAC,KAAK,QAAQ,WAAW;AAC5B,mBAAW,QAAO;;;EAGrB;;;;EAKQ,eAAe,OAAoB,MAAe,UAAsB;AAC/E,UAAM,QAAQ,UAAO;AACpB,YAAM,WAAW,IAAI,UAAU,KAAK,SAAS,IAAI,EAAE,OAAM;AACzD,YAAM,QAAQ,KAAK,uBAAsB;AACzC,UAAI,OAAO;AACV,cAAM,cAAc,MAAM,MAAM,QAAQ;AACxC,aAAK,cAAc,KAAK;UACvB,MAAM;UAAU;UAAO,UAAU;SACjC;AACD,aAAK,IAAI,iBAAiB,MAAM,IAAI;;IAEtC,CAAC;EACF;;;;EAKQ,gBAAgB,OAAoB,MAAa;AACxD,UAAM,QAAQ,UAAO;AACpB,YAAM,WAAW,IAAI,UAAU,KAAK,SAAS,IAAI,EAAE,OAAM;AACzD,YAAM,QAAQ,KAAK,cAAc,KAAK,CAAC,EAAE,MAAM,SAAQ,MAAO,SAAS,YAAY,CAAC,QAAQ;AAC5F,UAAI,OAAO;AAEV,cAAM,MAAM,eAAe,IAAI;AAE/B,cAAM,WAAW;AACjB,aAAK,IAAI,kBAAkB,MAAM,IAAI;;IAEvC,CAAC;EACF;;;;;EAMQ,eAAe,MAA4B,OAAoB,MAAe,UAAsB;AAC3G,WAAO,CAAC,KAAK,UAAU,4BAA4B;AAEnD,QAAI,QAAQ,KAAK,IAAG,GAAI;AAEvB,UAAI,SAAS,UAAU;AACtB,aAAK,eAAe,OAAO,MAAM,QAAQ;aACnC;AACN,aAAK,gBAAgB,OAAO,IAAI;;WAE3B;AAEN,WAAK,QAAQ,WAAW,MAAK;AAC5B,aAAK,eAAe,MAAM,OAAO,MAAM,QAAQ;MAChD,GAAG,OAAO,KAAK,IAAG,CAAE;;EAEtB;;;;;;;;;;;EAYA,cAAc,OAAgC,MAAa,UAAsB;AAEhF,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1B,cAAQ,CAAC,KAAK;;AAEf,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,eAAe,UAAU,OAAO,cAAc,QAAQ;AAC3D,WAAO;EACR;;;;;;;;;;;;;;EAeA,eAAe,OAAgC,MAAW;AACzD,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1B,cAAQ,CAAC,KAAK;;AAEf,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,eAAe,WAAW,OAAO,YAAY;AAClD,WAAO;EACR;;;;;;;;;;;;EAaA,qBACC,OACA,UACA,MACA,UAAsB;AAEtB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,cAAc,OAAO,cAAc,QAAQ;AAChD,QAAI,QAAQ,QAAQ,GAAG;AACtB,aAAO,QAAQ,KAAK,GAAG,8DAA8D;AACrF,cAAQ;AACR,eAAS,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AACtC,cAAM,IAAI,SAAS,KAAK,IAAI,GAAG,SAAS,SAAS,CAAC,CAAC;AACnD,cAAM,kBAAkB,KAAK,UAAU,CAAC;AACxC,eAAO,kBAAkB,GAAG,qCAAqC;AACjE,aAAK,eAAe,MAAM,CAAC,GAAG,eAAe,eAAe;;WAEvD;AACN,YAAM,kBAAkB,KAAK,UAAU,QAAQ;AAC/C,aAAO,kBAAkB,GAAG,qCAAqC;AACjE,WAAK,eAAe,OAAO,eAAe,eAAe;;AAE1D,WAAO;EACR;EAEA,OAAI;AACH,QAAI,KAAK,WAAU,GAAI;AACtB,WAAK,YAAY,iBAAiB,CAAC;AACnC,WAAK,YAAY,kBAAkB,CAAC;;AAErC,WAAO;EACR;;;;;;;;;;;;;EAcA,IAAI,SAA8C;AAEjD,UAAM,mBAAmB,eAAe,SAAS,CAAC,aAAa,SAAS,CAAC;AAEzE,SAAK,UAAU,UAAU,KAAK,SAAS,gBAAgB;AACvD,SAAK,QAAQ,QAAQ,WAAS,MAAM,IAAI,gBAAgB,CAAC;AACzD,SAAK,YAAY,IAAI,gBAAgB;AACrC,WAAO;EACR;EAEA,MAAG;AACF,WAAO,KAAK,YAAY,IAAG;EAC5B;;;;;EAMA,WAAW,MAAW;AACrB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,cAAc,QAAQ,CAAC,EAAE,MAAK,MAAM;AACxC,YAAM,eAAe,YAAY;IAClC,CAAC;AACD,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,YAAY,QAAO;AACxB,SAAK,QAAQ,QAAQ,OAAK,EAAE,QAAO,CAAE;AACrC,SAAK,gBAAgB,CAAA;AACrB,SAAK,mBAAmB,CAAA;AACxB,SAAK,QAAQ,cAAc,KAAK,UAAU;AAC1C,WAAO;EACR;;;;ACpVK,IAAO,UAAP,MAAO,iBAAgB,WAA0B;EAkDtD,cAAA;AAEC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,QAAQ,UAAU,SAAS,GAAG,MAAM,CAAC;AAlD3F,SAAA,OAAe;AAUhB,SAAA,iBAAoD,oBAAI,IAAG;AAyClE,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,QAAQ,UAAU,SAAS,GAAG,MAAM;AAE5G,UAAM,SAAS,CAAA;AACf,WAAO,KAAK,QAAQ,IAAI,EAAE,QAAQ,CAAC,SAAQ;AAC1C,YAAM,aAAa,SAAS,MAAM,EAAE;AACpC,aAAO,OAAO,IAAI,KACb,SAAS,UAAU,KAAK,SAAS,UAAU,GAAI,4CAA4C,IAAI,EAAE;AACtG,UAAI,OAAO,IAAI,GAAG;AAEjB,cAAM,MAAM,IAAI,eAAe,KAAK,SAAS,IAAI,EAAE,OAAM;AACzD,eAAO,GAAG,IAAI,QAAQ,KAAK,IAAI;iBACrB,SAAS,UAAU,KAAK,SAAS,UAAU,GAAG;AAExD,eAAO,UAAU,IAAI,QAAQ,KAAK,UAAU;;IAE9C,CAAC;AAED,SAAK,WAAW,IAAI,iBAAiB;MACpC,MAAM;MACN,QAAQ,QAAQ;MAChB,SAAS,QAAQ;MACjB,SAAS,QAAQ;KACjB;AACD,SAAK,SAAS,QAAQ;AACtB,SAAK,UAAU,QAAQ;AACvB,SAAK,QAAQ,QAAQ;AAGrB,QAAI,KAAK,SAAS,QAAQ;AAEzB,cAAQ,QAAO,EAAG,KAAK,QAAQ,MAAM;;EAEvC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,WAAW,YAAW,GAAI;MAC9C,QAAQ;MACR,SAAS;MACT,OAAO;MACP,QAAQ;MACR,SAAS;MACT,SAAS;MACT,MAAM,CAAA;KACN;EACF;;;;EAKQ,aAAa,MAAc;AAElC,UAAM,eAAe;AACrB,QAAI,WAAW;AACf,WAAO,WAAW,cAAc;AAE/B,UAAI,KAAK,SAAS,IAAI,OAAO,QAAQ,GAAG;AACvC,eAAO,CAAC;iBACE,KAAK,SAAS,IAAI,OAAO,QAAQ,GAAG;AAC9C,eAAO;;AAER;;AAED,UAAM,IAAI,MAAM,kCAAkC,IAAI,EAAE;EACzD;;;;;;EAOA,cAAc,OAAgC,MAAa,WAAwB,GAAC;AACnF,SAAK,IAAI,iBAAiB,OAAO,MAAM,QAAQ;AAC/C,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1B,cAAQ,CAAC,KAAK;;AAEf,UAAM,QAAQ,UAAO;AACpB,YAAM,YAAY,MAAM,IAAI,eAAe,KAAK,SAAS,IAAI,EAAE,YAAW,CAAE;AAC5E,YAAM,OAAO,KAAK,MAAM,SAAS;AACjC,YAAM,YAAY,YAAY;AAE9B,YAAM,aAAa,KAAK,aAAa,IAAI;AACzC,YAAM,cAAc,OAAO;AAC3B,YAAM,SAAS,KAAK,SAAS,IAAI,WAAW;AAC5C,YAAM,eAAe,yBAAyB,aAAa,SAAS;AAEpE,YAAM,SAAS,IAAI,iBAAiB;QACnC,KAAK;QACL,SAAS,KAAK;QACd,OAAO,KAAK;QACZ,QAAQ,KAAK;QACb,SAAS,KAAK;QACd;OACA,EAAE,QAAQ,KAAK,MAAM;AACtB,aAAO,MAAM,MAAM,GAAG,OAAO,WAAW,cAAc,QAAQ;AAE9D,UAAI,CAAC,QAAQ,KAAK,eAAe,IAAI,IAAI,CAAC,GAAG;AAC5C,aAAK,eAAe,IAAI,MAAM,CAAA,CAAE;;AAEhC,WAAK,eAAe,IAAI,IAAI,EAAyB,KAAK,MAAM;AAGjE,aAAO,UAAU,MAAK;AACrB,YAAI,KAAK,kBAAkB,KAAK,eAAe,IAAI,IAAI,GAAG;AACzD,gBAAM,UAAU,KAAK,eAAe,IAAI,IAAI;AAC5C,gBAAM,QAAQ,QAAQ,QAAQ,MAAM;AACpC,cAAI,UAAU,IAAI;AACjB,oBAAQ,OAAO,OAAO,CAAC;;;MAG1B;IACD,CAAC;AACD,WAAO;EACR;;;;;EAMA,eAAe,OAAgC,MAAW;AACzD,SAAK,IAAI,kBAAkB,OAAO,IAAI;AACtC,QAAI,CAAC,MAAM,QAAQ,KAAK,GAAG;AAC1B,cAAQ,CAAC,KAAK;;AAEf,UAAM,QAAQ,UAAO;AACpB,YAAM,OAAO,IAAI,eAAe,KAAK,SAAS,IAAI,EAAE,OAAM;AAE1D,UAAI,KAAK,eAAe,IAAI,IAAI,KAAM,KAAK,eAAe,IAAI,IAAI,EAAyB,QAAQ;AAClG,cAAM,UAAU,KAAK,eAAe,IAAI,IAAI;AAC5C,eAAO,KAAK,UAAU,IAAI;AAC1B,gBAAQ,QAAQ,YAAS;AACxB,iBAAO,KAAK,IAAI;QACjB,CAAC;AACD,aAAK,eAAe,IAAI,MAAM,CAAA,CAAE;;IAElC,CAAC;AACD,WAAO;EACR;;;;;EAMA,WAAW,MAAW;AACrB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,eAAe,QAAQ,aAAU;AACrC,aAAO,QAAQ,QAAQ;AACtB,cAAM,SAAS,QAAQ,MAAK;AAC5B,eAAO,KAAK,YAAY;;IAE1B,CAAC;AACD,WAAO;EACR;EAEA,OAAI;AACH,QAAI,KAAK,WAAU,GAAI;AACtB,WAAK,YAAY,iBAAiB,CAAC;AACnC,WAAK,YAAY,kBAAkB,CAAC;;AAErC,WAAO;EACR;;;;;;;;EASA,qBACC,OACA,UACA,MACA,WAAwB,GAAC;AAEzB,UAAM,eAAe,KAAK,UAAU,IAAI;AACxC,SAAK,cAAc,OAAO,cAAc,QAAQ;AAChD,QAAI,QAAQ,QAAQ,GAAG;AACtB,aAAO,QAAQ,KAAK,GAAG,+CAA+C;AACrE,YAAsB,QAAQ,CAAC,MAAM,UAAS;AAC9C,cAAM,IAAI,SAAS,KAAK,IAAI,OAAO,SAAS,SAAS,CAAC,CAAC;AACvD,aAAK,eAAe,MAAM,eAAe,KAAK,UAAU,CAAC,CAAC;MAC3D,CAAC;WACK;AACN,WAAK,eAAe,OAAO,eAAe,KAAK,UAAU,QAAQ,CAAC;;AAEnE,WAAO;EACR;;;;;;;EAQA,IAAI,MAAuB,KAA6C,UAAqB;AAC5F,WAAO,OAAO,IAAI,KAAK,SAAS,IAAI,GAAG,iCAAiC,IAAI,EAAE;AAC9E,QAAI,OAAO,IAAI,GAAG;AAEjB,YAAM,MAAM,IAAI,eAAe,KAAK,SAAS,IAAI,EAAE,OAAM;AACzD,WAAK,SAAS,IAAI,KAAK,KAAK,QAAQ;WAC9B;AAEN,WAAK,SAAS,IAAI,MAAM,KAAK,QAAQ;;AAEtC,WAAO;EACR;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,SAAS;EACtB;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,SAAS,QAAO;AACrB,SAAK,eAAe,QAAQ,aAAU;AACrC,cAAQ,QAAQ,YAAU,OAAO,QAAO,CAAE;IAC3C,CAAC;AACD,SAAK,eAAe,MAAK;AACzB,WAAO;EACR;;AAlQA,WAAA;EADC,UAAU,CAAC;;AASZ,WAAA;EADC,UAAU,CAAC;;;;AClCP,IAAO,YAAP,MAAO,mBAAmC,gBAA4C;EAqE3F,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,YAAY,OAAO,CAAC,CAAC;AArE7E,SAAA,OAAe;AA+Bd,SAAA,SAEL,IAAI,cAAc,SAAS;AAWtB,SAAA,eAAsB;AA0B/B,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,YAAY,OAAO,CAAC;AAE9F,SAAK,QAAQ,QAAQ;AACrB,SAAK,WAAW,QAAQ;AACxB,SAAK,QAAQ,QAAQ;AACrB,SAAK,aAAa,KAAK,QAAQ,QAAQ,SAAS;AAChD,SAAK,WAAW,KAAK,QAAQ,QAAQ,OAAO;AAC5C,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,eAAe,QAAQ;AAC5B,SAAK,YAAY,QAAQ;AACzB,SAAK,OAAO,QAAQ;AACpB,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,OAAO,aAAa;AAEzB,SAAK,kBAAiB;EACvB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,gBAAgB,YAAW,GAAI;MACnD,UAAU;MACV,UAAU;MACV,MAAM;MACN,SAAS;MACT,WAAW;MACX,MAAM;MACN,cAAc;MACd,aAAa;MACb,OAAO;KACP;EACF;;;;;;EAOQ,kBAAkB,QAAe,IAAE;AAE1C,SAAK,OAAO,YAAY,OAAO,WAAQ;AACtC,UAAI;AACJ,UAAI,MAAM,UAAU,WAAW;AAC9B,YAAI,MAAM,OAAO,IAAI;AACpB,eAAK,QAAQ,UAAU,MAAM,MAAM,EAAE;;AAEtC,cAAM,YAAY,MAAM,OAAO,KAAK,MAAM,KAAK,cAAc,KAAK,aAAa;AAC/E,YAAI,KAAK,UAAU,QAAQ,SAAS,KAAK,KAAK,KAAK,KAAK,QAAQ,GAAG;AAClE,qBAAW;AACX,cAAI,SAAS,KAAK,KAAK,GAAG;AACzB,uBAAY,KAAK,QAAS,KAAK,iBAAgB;;AAEhD,gBAAM,YAAY,KAAK,OAAO,SAAS,SAAS;AAChD,cAAI,cAAc,MAAM;AACvB,uBAAW,KAAK,IAAI,UAAU,UAAU,OAAO,SAAS;;AAEzD,cAAI,aAAa,UAAU;AAE1B,iBAAK,OAAO,eAAe,WAAW,YAAY,WAAW,GAAG,EAAE,IAAI,GAAE,CAAE;AAC1E,uBAAW,IAAI,WAAW,KAAK,SAAS,QAAQ;;AAEjD,gBAAM,WAAW,IAAI,WAAW,KAAK,SAAS,KAAK,iBAAgB,CAAE;AACrE,gBAAM,KAAK,KAAK,QAAQ,UAAU,eACjC,KAAK,MAAM,KAAK,IAAI,GAAG,UAAU,IAAI,WAAW,KAAK,SAAS,SAAS,GAAG,QAAQ;eAC7E;AACN,gBAAM,KAAK,KAAK,QAAQ,UAAU,SAAS,KAAK,MAAM,KAAK,IAAI,GAAG,IAAI,WAAW,KAAK,SAAS,SAAS,CAAC;;;IAG5G,CAAC;EACF;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO,eAAe,KAAK,QAAQ,UAAU,KAAK;EAC/D;;;;EAKA,IAAI,cAAW;AACd,WAAO,KAAK;EACb;EACA,IAAI,YAAY,QAAM;AACrB,SAAK,eAAe;EACrB;;;;EAKA,IAAI,cAAW;AACd,WAAO,KAAK;EACb;EACA,IAAI,YAAY,MAAI;AACnB,SAAK,eAAe;EACrB;;;;;;;;;EAUA,IAAI,WAAQ;AACX,WAAO,KAAK;EACb;EAEA,IAAI,SAAS,WAAS;AACrB,SAAK,YAAY;EAClB;;;;;EAMA,MAAM,MAAyC;AAC9C,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI,KAAK,OAAO,eAAe,KAAK,MAAM,WAAW;AACpD,WAAK,OAAO,IAAI;QACf,IAAI;QACJ,OAAO;QACP,MAAM;OACN;AACD,WAAK,kBAAkB,KAAK;;AAE7B,WAAO;EACR;;;;;EAMA,KAAK,MAAyC;AAC7C,SAAK,OAAO,IAAI;AAChB,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI,KAAK,OAAO,eAAe,KAAK,MAAM,WAAW;AACpD,WAAK,OAAO,eAAe,WAAW,OAAO,EAAE,IAAI,GAAE,CAAE;AACvD,YAAM,gBAAgB,KAAK,OAAO,UAAU,KAAK;AACjD,UAAI,gBAAgB;AACpB,UAAI,kBAAkB,MAAM;AAC3B,wBAAgB,cAAc;;AAE/B,WAAK,kBAAkB,aAAa;;AAErC,WAAO;EACR;;;;;EAMA,OAAO,MAAyC;AAC/C,WAAO,WAAW,MAAM,SAAS;AACjC,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,SAAK,OAAO,YAAY,OAAO,WAAQ;AACtC,WAAK,QAAQ,UAAU,MAAM,MAAM,EAAE;IACtC,CAAC;AACD,SAAK,OAAO,OAAO,KAAK;AACxB,WAAO;EACR;;;;;;EAOU,MAAM,MAAa;AAC5B,UAAM,QAAQ,KAAK,QAAQ,UAAU,eAAe,IAAI;AACxD,QAAI,CAAC,KAAK,QAAQ,KAAK,OAAO,eAAe,KAAK,MAAM,WAAW;AAClE,UAAI,KAAK,cAAc,KAAK,KAAK,OAAM,IAAK,KAAK,aAAa;AAC7D;;AAED,UAAI,KAAK,UAAU;AAClB,YAAI,YAAY;AAChB,YAAI,CAAC,UAAU,KAAK,QAAQ,GAAG;AAC9B,sBAAY,KAAK,UAAU,KAAK,QAAQ;;AAEzC,iBAAS,KAAK,OAAM,IAAK,IAAI,KAAK;;AAEnC,WAAK,SAAS,MAAM,KAAK,KAAK;;EAEhC;;;;EAKU,mBAAgB;AACzB,WAAO,KAAK,OAAO,KAAK,WAAW,KAAK,cAAc,KAAK,aAAa;EACzE;;;;;;;;;;;EAYA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ;AACb,SAAK,kBAAiB;EACvB;;;;;;;;;EAUA,IAAI,eAAY;AACf,WAAO,KAAK;EACb;EACA,IAAI,aAAa,MAAI;AACpB,SAAK,gBAAgB;AACrB,SAAK,kBAAiB;EACvB;;;;;EAMA,IAAI,UAAO;AACV,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,QAAQ,EAAE,UAAS;EAC7D;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,WAAW,KAAK,QAAQ,OAAO;AACpC,QAAI,KAAK,OAAO;AACf,WAAK,kBAAiB;;EAExB;;;;EAKA,IAAI,YAAS;AACZ,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,UAAU,EAAE,UAAS;EAC/D;EACA,IAAI,UAAU,WAAS;AACtB,SAAK,aAAa,KAAK,QAAQ,SAAS;AACxC,QAAI,KAAK,OAAO;AACf,WAAK,kBAAiB;;EAExB;;;;;;EAOA,IAAI,WAAQ;AACX,QAAI,KAAK,OAAO;AACf,YAAM,QAAQ,KAAK,QAAQ,UAAU;AACrC,YAAM,YAAY,KAAK,OAAO,IAAI,KAAK;AACvC,UAAI,cAAc,QAAQ,UAAU,UAAU,WAAW;AACxD,cAAM,eAAe,KAAK,iBAAgB;AAC1C,cAAM,YAAY,QAAQ,UAAU,QAAQ;AAC5C,eAAO,WAAW;aACZ;AACN,eAAO;;WAEF;AACN,aAAO;;EAET;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAM;AACX,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;AC1WK,IAAO,OAAP,MAAO,cAAwD,gBAAwB;EAoB5F,cAAA;AACC,UAAM,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,YAAY,UAAU,CAAC,CAAC;AAnB3E,SAAA,OAAe;AAoBvB,UAAM,UAAU,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,YAAY,UAAU,CAAC;AAE5F,SAAK,SAAS,IAAI,UAAU;MAC3B,SAAS,KAAK;MACd,UAAU,KAAK,MAAM,KAAK,IAAI;MAC9B,MAAM;MACN,SAAS,QAAQ;MACjB,cAAc,QAAQ;MACtB,aAAa,QAAQ;KACrB;AAED,SAAK,WAAW,QAAQ;AAExB,SAAK,aAAa,QAAQ;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,gBAAgB,YAAW,GAAI;MACnD,UAAU;MACV,UAAU;MACV,cAAc;MACd,YAAY;MACZ,aAAa;MACb,MAAM;MACN,UAAU;KACV;EACF;;;;;EAMA,MAAM,MAAoB;AACzB,SAAK,OAAO,MAAM,IAAI;AACtB,WAAO;EACR;;;;;EAMA,KAAK,MAAoB;AACxB,SAAK,OAAO,KAAK,IAAI;AACrB,WAAO;EACR;;;;;EAMA,OAAO,MAAoB;AAC1B,SAAK,OAAO,OAAO,IAAI;AACvB,WAAO;EACR;;;;;EAMU,MAAM,MAAa;AAC5B,SAAK,SAAS,IAAI;EACnB;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,OAAO;EACpB;;;;EAKA,IAAI,WAAQ;AACX,WAAO,KAAK,OAAO;EACpB;;;;;;;EAQA,IAAI,WAAQ;AACX,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,SAAS,UAAQ;AACpB,SAAK,OAAO,UAAU;EACvB;;;;;EAMA,IAAI,eAAY;AACf,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,aAAa,MAAI;AACpB,SAAK,OAAO,eAAe;EAC5B;;;;;EAMA,IAAI,WAAQ;AACX,WAAO,KAAK,OAAO;EACpB;EACA,IAAI,SAAS,WAAS;AACrB,SAAK,OAAO,WAAW;EACxB;;;;EAKA,IAAI,cAAW;AACd,WAAO,KAAK,OAAO;EACpB;EAEA,IAAI,YAAY,MAAI;AACnB,SAAK,OAAO,cAAc;EAC3B;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,OAAO;EACpB;EAEA,IAAI,KAAK,MAAI;AACZ,SAAK,OAAO,OAAO;EACpB;;;;EAKA,IAAI,aAAU;AACb,QAAI,KAAK,OAAO,SAAS,MAAM;AAC9B,aAAO;WACD;AACN,aAAO,KAAK,OAAO;;EAErB;EACA,IAAI,WAAW,OAAK;AACnB,QAAI,UAAU,UAAU;AACvB,WAAK,OAAO,OAAO;WACb;AACN,WAAK,OAAO,OAAO;;EAErB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACrKK,IAAO,OAAP,MAAO,cAA8B,UAAoB;EAuB9D,cAAA;AAEC,UAAM,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,YAAY,QAAQ,CAAC,CAAC;AAvBzE,SAAA,OAAe;AAKd,SAAA,SAGL,IAAI,cAAc,SAAS;AAKxB,SAAA,UAA0B,oBAAI,IAAG;AAWxC,UAAM,UAAU,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,YAAY,QAAQ,CAAC;AAG1F,SAAK,OAAO,aAAa;AAGzB,YAAQ,OAAO,QAAQ,WAAQ;AAC9B,UAAI,QAAQ,KAAK,GAAG;AACnB,aAAK,IAAI,MAAM,CAAC,GAAG,MAAM,CAAC,CAAC;aACrB;AACN,aAAK,IAAI,KAAK;;IAEhB,CAAC;EACF;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,UAAU,YAAW,GAAI;MAC7C,QAAQ,CAAA;KACR;EACF;;;;;;EAOA,MAAM,MAAsB,QAAa;AACxC,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI,KAAK,OAAO,eAAe,KAAK,MAAM,WAAW;AACpD,eAAS,WAAW,QAAQ,KAAK,QAAQ,KAAK,aAAa,CAAC;AAC5D,UAAI,KAAK,OAAO;AACf,iBAAS,WAAW,QAAQ,KAAK,UAAU;aACrC;AACN,iBAAS,WAAW,QAAQ,CAAC;;AAE9B,YAAM,iBAAiB,KAAK,QAAQ,MAAM;AAC1C,WAAK,OAAO,IAAI;QACf,IAAI;QACJ,QAAQ;QACR,OAAO;QACP,MAAM;OACN;AACD,WAAK,SAAS,WAAQ;AACrB,aAAK,WAAW,OAAO,OAAO,cAAc;MAC7C,CAAC;;AAEF,WAAO;EACR;;;;;;;;EASQ,WAAW,OAAkB,OAAc,QAAa;AAC/D,aAAS;AACT,QAAI,KAAK,OAAO;AACf,UAAI,MAAM,eAAe,KAAK,cAAc,MAAM,cAAc,KAAK,UAAU;AAC9E,YAAI,MAAM,cAAc,QAAQ;AAE/B,mBAAS,KAAK,iBAAgB;;AAE/B,cAAM,MAAM,IAAI,WAAW,KAAK,SAAS,KAAK,CAAC;iBACrC,MAAM,cAAc,KAAK,cAAc,MAAM,eAAe,QAAQ;AAC9E,cAAM,OAAO;AACb,cAAM,MAAM,IAAI,WAAW,KAAK,SAAS,KAAK,CAAC;;eAEtC,MAAM,eAAe,QAAQ;AACvC,YAAM,MAAM,IAAI,WAAW,KAAK,SAAS,KAAK,CAAC;;EAEjD;EAEA,IAAI,cAAW;AACd,WAAO,KAAK;EACb;EACA,IAAI,YAAY,QAAM;AACrB,SAAK,eAAe;AACpB,SAAK,SAAS,WAAQ;AACrB,YAAM,eAAe,KAAK;IAC3B,CAAC;EACF;;;;;EAMA,KAAK,MAAoB;AACxB,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,SAAK,OAAO,OAAO,KAAK;AACxB,SAAK,OAAO,eAAe,WAAW,KAAK;AAC3C,SAAK,SAAS,WAAQ;AACrB,YAAM,KAAK,IAAI;IAChB,CAAC;AACD,WAAO;EACR;;;;;;;;;;;;;;;EAgBA,GAAG,MAAY,OAAW;AACzB,UAAM,cAAc,IAAI,mBAAmB,KAAK,SAAS,IAAI,EAAE,QAAO;AACtE,UAAM,WAAW,IAAI,WAAW,KAAK,SAAS,CAAC,EAAE,UAAS;AAE1D,UAAM,WAAW,KAAK,QAAQ,OAAM;AACpC,QAAI,SAAS,SAAS,KAAI;AAC1B,WAAO,CAAC,OAAO,MAAM;AACpB,YAAM,QAAQ,OAAO;AACrB,UAAI,KAAK,IAAI,cAAc,MAAM,WAAW,IAAI,UAAU;AACzD,YAAI,UAAU,KAAK,GAAG;AACrB,gBAAM,QAAQ;;AAEf,eAAO;;AAER,eAAS,SAAS,KAAI;;AAGvB,QAAI,UAAU,KAAK,GAAG;AACrB,WAAK,IAAI,MAAM,KAAK;AAEpB,aAAO,KAAK,GAAG,IAAI;WACb;AACN,aAAO;;EAET;EAgBA,IAAI,MAAqB,OAAW;AAEnC,QAAI,gBAAgB,UAAU,QAAQ,IAAI,MAAM,MAAM,GAAG;AACxD,cAAQ;AACR,aAAO,MAAM;;AAEd,UAAM,QAAQ,KAAK,QAAQ,IAAI;AAC/B,QAAI;AACJ,QAAI,iBAAiB,WAAW;AAC/B,cAAQ;AACR,YAAM,WAAW,KAAK,MAAM,KAAK,IAAI;WAC/B;AACN,cAAQ,IAAI,UAAU;QACrB,UAAU,KAAK,MAAM,KAAK,IAAI;QAC9B,SAAS,KAAK;QACd;OACA;;AAGF,UAAM,cAAc;AAGpB,UAAM,IAAI;MACT,UAAU,KAAK;MACf,MAAM,KAAK;MACX,SAAS,KAAK;MACd,WAAW,KAAK;MAChB,cAAc,KAAK;MACnB,aAAa,KAAK;KAClB;AAED,SAAK,QAAQ,IAAI,KAAK;AAGtB,SAAK,cAAc,KAAK;AACxB,WAAO;EACR;;;;EAKQ,cAAc,OAAgB;AACrC,SAAK,OAAO,QAAQ,CAAC,eAAc;AAClC,UAAI,WAAW,UAAU,WAAW;AACnC,aAAK,WAAW,OAAO,WAAW,MAAM,WAAW,MAAM;aACnD;AAEN,cAAM,KAAK,IAAI,WAAW,KAAK,SAAS,WAAW,IAAI,CAAC;;IAE1D,CAAC;EACF;EAaA,OAAO,MAAqB,OAAW;AAEtC,QAAI,SAAS,IAAI,KAAK,KAAK,eAAe,MAAM,GAAG;AAClD,cAAQ;AACR,aAAO,MAAM;;AAEd,WAAO,KAAK,QAAQ,IAAI;AACxB,SAAK,QAAQ,QAAQ,WAAQ;AAC5B,UAAI,MAAM,gBAAgB,MAAM;AAC/B,YAAI,QAAQ,KAAK,KAAM,UAAU,KAAK,KAAK,MAAM,UAAU,OAAQ;AAClE,eAAK,QAAQ,OAAO,KAAK;AACzB,gBAAM,QAAO;;;IAGhB,CAAC;AACD,WAAO;EACR;;;;EAKA,QAAK;AACJ,SAAK,SAAS,WAAS,MAAM,QAAO,CAAE;AACtC,SAAK,QAAQ,MAAK;AAClB,WAAO;EACR;;;;;EAMA,OAAO,OAA0C;AAChD,SAAK,SAAS,WAAS,MAAM,OAAO,KAAK,CAAC;AAC1C,SAAK,OAAO,OAAO,KAAK,QAAQ,KAAK,CAAC;AACtC,WAAO;EACR;;;;EAKQ,SAAS,UAAoC;AACpD,QAAI,KAAK,SAAS;AACjB,WAAK,QAAQ,QAAQ,WAAQ;AAC5B,YAAI,iBAAiB,OAAM;AAC1B,gBAAM,SAAS,QAAQ;eACjB;AACN,mBAAS,KAAK;;MAEhB,CAAC;;AAEF,WAAO;EACR;;;;;;EAOQ,QAAQ,MAAc,OAAU;AACvC,SAAK,SAAS,WAAQ;AACrB,YAAM,IAAI,IAAI;IACf,CAAC;EACF;;;;;EAMU,MAAM,MAAe,OAAW;AACzC,QAAI,CAAC,KAAK,MAAM;AACf,WAAK,SAAS,MAAM,KAAK;;EAE3B;;;;;;EAOQ,mBAAmB,OAAgB;AAC1C,QAAI,KAAK,UAAU,MAAM,cAAc,KAAK,cAAc,MAAM,eAAe,KAAK,WAAW;AAC9F,YAAM,OAAO,CAAC;eACJ,MAAM,UAAU,WAAW;AAErC,WAAK,cAAc,KAAK;;EAE1B;EAEA,IAAI,cAAW;AACd,WAAO,KAAK;EACb;EACA,IAAI,YAAY,MAAI;AACnB,SAAK,eAAe;AACpB,SAAK,QAAQ,eAAe,IAAI;EACjC;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK;EACb;EACA,IAAI,SAAS,WAAS;AACrB,SAAK,YAAY;AACjB,SAAK,QAAQ,YAAY,SAAS;EACnC;;;;;;;;;;;;;;;EAgBA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ;AACb,SAAK,SAAS,WAAQ;AACrB,YAAM,YAAY,KAAK;AACvB,YAAM,UAAU,KAAK;AACrB,YAAM,OAAO;AACb,WAAK,mBAAmB,KAAK;IAC9B,CAAC;EACF;;;;;EAMA,IAAI,UAAO;AACV,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,QAAQ,EAAE,UAAS;EAC7D;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,WAAW,KAAK,QAAQ,OAAO;AACpC,QAAI,KAAK,OAAO;AACf,WAAK,SAAS,WAAQ;AACrB,cAAM,UAAU;AAChB,aAAK,mBAAmB,KAAK;MAC9B,CAAC;;EAEH;;;;;EAMA,IAAI,YAAS;AACZ,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,UAAU,EAAE,UAAS;EAC/D;EACA,IAAI,UAAU,WAAS;AACtB,SAAK,aAAa,KAAK,QAAQ,SAAS;AACxC,QAAI,KAAK,OAAO;AACf,WAAK,SAAS,WAAQ;AACrB,cAAM,YAAY,KAAK;AACvB,aAAK,mBAAmB,KAAK;MAC9B,CAAC;;EAEH;;;;EAKA,IAAI,eAAY;AACf,WAAO,KAAK;EACb;EACA,IAAI,aAAa,MAAI;AACpB,SAAK,gBAAgB;AACrB,SAAK,QAAQ,gBAAgB,IAAI;EAClC;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,QAAQ;EACrB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAK;AACV,WAAO;EACR;;;;AC5cD,UAAU,aAAgB,QAAW;AACpC,MAAI,QAAQ;AACZ,SAAO,QAAQ,OAAO,QAAQ;AAC7B,YAAQ,iBAAiB,OAAO,MAAM;AACtC,UAAM,OAAO,KAAK;AAClB;;AAEF;AAKA,UAAU,eAAkB,QAAW;AACtC,MAAI,QAAQ,OAAO,SAAS;AAC5B,SAAO,SAAS,GAAG;AAClB,YAAQ,iBAAiB,OAAO,MAAM;AACtC,UAAM,OAAO,KAAK;AAClB;;AAEF;AAKA,UAAU,YAAe,QAAa,KAAwB;AAC7D,SAAO,MAAM;AACZ,WAAO,IAAI,MAAM;;AAEnB;AAKA,SAAS,iBAAiB,OAAe,QAAa;AACrD,SAAO,MAAM,OAAO,GAAG,OAAO,SAAS,CAAC;AACzC;AAKA,UAAU,qBAAwB,QAAa,aAAoB;AAClE,MAAI,QAAQ,cAAc,IAAI,OAAO,SAAS;AAC9C,SAAO,MAAM;AACZ,YAAQ,iBAAiB,OAAO,MAAM;AACtC,UAAM,OAAO,KAAK;AAClB,QAAI,aAAa;AAChB;AACA,UAAI,SAAS,OAAO,SAAS,GAAG;AAC/B,sBAAc;;WAET;AACN;AACA,UAAI,SAAS,GAAG;AACf,sBAAc;;;;AAIlB;AAKA,UAAU,OAAU,QAAW;AAC9B,MAAI,QAAQ;AACZ,MAAI,YAAY;AAChB,SAAO,QAAQ,OAAO,QAAQ;AAC7B,YAAQ,iBAAiB,OAAO,MAAM;AACtC,UAAM,OAAO,KAAK;AAClB;AACA,aAAU,YAAY,IAAI,IAAI;;AAEhC;AAKA,UAAU,SAAY,QAAW;AAChC,MAAI,QAAQ,OAAO,SAAS;AAC5B,MAAI,YAAY;AAChB,SAAO,SAAS,GAAG;AAClB,YAAQ,iBAAiB,OAAO,MAAM;AACtC,UAAM,OAAO,KAAK;AAClB;AACA,aAAU,YAAY,IAAI,KAAK;;AAEjC;AAKA,UAAU,UAAa,QAAW;AACjC,SAAO,MAAM;AACZ,UAAM,cAAc,KAAK,MAAM,KAAK,OAAM,IAAK,OAAO,MAAM;AAC5D,UAAM,OAAO,WAAW;;AAE1B;AAKA,UAAU,WAAc,QAAW;AAElC,QAAM,OAAiB,CAAA;AACvB,WAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK;AACvC,SAAK,KAAK,CAAC;;AAEZ,SAAO,KAAK,SAAS,GAAG;AAEvB,UAAM,UAAU,KAAK,OAAO,KAAK,MAAM,KAAK,SAAS,KAAK,OAAM,CAAE,GAAG,CAAC;AACtE,UAAM,QAAQ,iBAAiB,QAAQ,CAAC,GAAG,MAAM;AACjD,UAAM,OAAO,KAAK;;AAEpB;AAKA,UAAU,WAAc,QAAW;AAElC,MAAI,QAAQ,KAAK,MAAM,KAAK,OAAM,IAAK,OAAO,MAAM;AACpD,SAAO,MAAM;AACZ,QAAI,UAAU,GAAG;AAChB;eACU,UAAU,OAAO,SAAS,GAAG;AACvC;eACU,KAAK,OAAM,IAAK,KAAK;AAC/B;WACM;AACN;;AAED,UAAM,OAAO,KAAK;;AAEpB;AASM,UAAW,iBAAoB,QAAa,UAAuB,MAAM,QAAQ,GAAC;AAEvF,SAAO,OAAO,SAAS,GAAG,+CAA+C;AACzE,UAAQ,SAAS;IAChB,KAAK;AACJ,aAAO,YAAY,QAAQ,YAAY;IACxC,KAAK;AACJ,aAAO,YAAY,QAAQ,cAAc;IAC1C,KAAK;AACJ,aAAO,qBAAqB,QAAQ,IAAI;IACzC,KAAK;AACJ,aAAO,qBAAqB,QAAQ,KAAK;IAC1C,KAAK;AACJ,aAAO,YAAY,QAAQ,MAAM;IAClC,KAAK;AACJ,aAAO,YAAY,QAAQ,QAAQ;IACpC,KAAK;AACJ,aAAO,UAAU,MAAM;IACxB,KAAK;AACJ,aAAO,YAAY,QAAQ,UAAU;IACtC,KAAK;AACJ,aAAO,WAAW,MAAM;;AAE3B;;;ACzJM,IAAO,UAAP,MAAO,iBAA2B,KAA+B;EAwCtE,cAAA;AAEC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,YAAY,UAAU,SAAS,CAAC,CAAC;AAxCvF,SAAA,OAAe;AAyCvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,YAAY,UAAU,SAAS,CAAC;AAExG,SAAK,WAAW,QAAQ;AACxB,SAAK,UAAU,QAAQ;AACvB,SAAK,WAAW,iBAAiB,QAAQ,QAAQ,QAAQ,OAAO;AAChE,SAAK,QAAQ,QAAQ;EACtB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,KAAK,YAAW,GAAI;MACxC,SAAS;MACT,QAAQ,CAAA;MACR,UAAU;KACV;EACF;;;;EAKU,MAAM,MAAa;AAC5B,UAAM,QAAQ,KAAK,SAAS,KAAI;AAChC,SAAK,SAAS,MAAM;AACpB,SAAK,SAAS,MAAM,KAAK,MAAM;EAChC;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,KAAG;AACb,SAAK,UAAU;AAEf,SAAK,UAAU,KAAK;EACrB;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,QAAQ;AACb,SAAK,WAAW,iBAAiB,KAAK,SAAS,KAAK,KAAK;EAC1D;;;;ACtFK,IAAO,WAAP,MAAO,kBAAkC,UAAoB;EAsClE,cAAA;AAEC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,YAAY,UAAU,aAAa,CAAC,CAAC;AAtC5F,SAAA,OAAe;AAUhB,SAAA,QAAc,IAAI,KAAK;MAC9B,UAAU,KAAK,aAAa,KAAK,IAAI;MACrC,SAAS,KAAK;KACd;AAKO,SAAA,UAA+C,CAAA;AAK/C,SAAA,eAAoD,CAAA;AAgB3D,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,YAAY,UAAU,aAAa,CAAC;AAE7G,SAAK,eAAe,KAAK,QAAQ,QAAQ,WAAW;AAEpD,SAAK,SAAS,QAAQ;AAGtB,SAAK,OAAO,QAAQ;AACpB,SAAK,YAAY,QAAQ;AACzB,SAAK,UAAU,QAAQ;AACvB,SAAK,eAAe,QAAQ;AAC5B,SAAK,cAAc,QAAQ;AAC3B,SAAK,WAAW,QAAQ;AACxB,SAAK,OAAO,QAAQ;AACpB,SAAK,eAAe,QAAQ;EAC7B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,eAAe,UAAU,YAAW,GAAI,CAAC,OAAO,CAAC,GAAG;MACxE,QAAQ,CAAA;MACR,MAAM;MACN,SAAS;MACT,WAAW;MACX,aAAa;KACb;EACF;;;;EAKQ,aAAa,MAAe,OAAU;AAC7C,QAAI,UAAU,MAAM;AACnB,WAAK,SAAS,MAAM,KAAK;;EAE3B;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK;EACb;EACA,IAAI,OAAO,GAAC;AACX,SAAK,MAAK;AACV,SAAK,eAAe;AACpB,SAAK,UAAU,KAAK,gBAAgB,KAAK,YAAY;AACrD,SAAK,eAAc;EACpB;;;;;;EAOA,MAAM,MAAsB,QAAe;AAC1C,SAAK,MAAM,MAAM,MAAM,SAAS,KAAK,WAAW,MAAM,IAAI,MAAM;AAChE,WAAO;EACR;;;;;EAMA,KAAK,MAAoB;AACxB,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;EACR;;;;;;EAOA,IAAI,cAAW;AACd,WAAO,IAAI,WAAW,KAAK,SAAS,KAAK,YAAY,EAAE,UAAS;EACjE;;;;EAKQ,gBAAgB,OAAY;AACnC,WAAO,IAAI,MAAM,OAAO;MACvB,KAAK,CAAC,QAAe,aAA8B;AAElD,eAAO,OAAO,QAAQ;MACvB;MACA,KAAK,CAAC,QAAe,UAAuB,UAAuB;AAClE,YAAI,SAAS,QAAQ,KAAK,SAAS,SAAS,UAAU,EAAE,CAAC,GAAG;AAC3D,cAAI,QAAQ,KAAK,GAAG;AACnB,mBAAO,QAAQ,IAAI,KAAK,gBAAgB,KAAK;iBACvC;AACN,mBAAO,QAAQ,IAAI;;eAEd;AACN,iBAAO,QAAQ,IAAI;;AAEpB,aAAK,eAAc;AAEnB,eAAO;MACR;KACA;EACF;;;;EAKQ,iBAAc;AACrB,SAAK,MAAM,MAAK;AAChB,SAAK,oBAAoB,KAAK,cAAc,KAAK,cAAc,KAAK,WAAW;AAE/E,SAAK,UAAU,KAAK;EACrB;;;;EAKQ,oBAAoB,UAAiB,aAAoB,aAAkB;AAClF,aAAS,QAAQ,CAAC,OAAO,UAAS;AACjC,YAAM,cAAc,QAAS,cAAe;AAC5C,UAAI,QAAQ,KAAK,GAAG;AACnB,aAAK,oBAAoB,OAAO,cAAc,MAAM,QAAQ,WAAW;aACjE;AACN,cAAM,YAAY,IAAI,WAAW,KAAK,SAAS,aAAa,GAAG,EAAE,UAAS;AAC1E,aAAK,MAAM,IAAI,WAAW,KAAK;;IAEjC,CAAC;EACF;;;;;;EAOQ,WAAW,OAAa;AAC/B,WAAO,IAAI,WAAW,KAAK,SAAS,QAAS,KAAK,eAAgB,KAAK,WAAW,EAAE,UAAS;EAC9F;;;;EAKA,QAAK;AACJ,SAAK,MAAM,MAAK;AAChB,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;EAMA,IAAI,OAAI;AACP,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,KAAK,GAAC;AACT,SAAK,MAAM,OAAO;EACnB;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK;EACb;EACA,IAAI,UAAU,OAAK;AAClB,SAAK,aAAa;AAClB,SAAK,MAAM,YAAY,KAAK,WAAW,KAAK;EAC7C;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,OAAK;AAChB,SAAK,WAAW;AAChB,QAAI,UAAU,GAAG;AAChB,WAAK,MAAM,UAAU,KAAK,WAAW,KAAK,aAAa,MAAM;WACvD;AACN,WAAK,MAAM,UAAU,KAAK,WAAW,KAAK;;EAE5C;EAEA,IAAI,cAAW;AACd,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,YAAYC,QAAK;AACpB,SAAK,MAAM,cAAcA;EAC1B;EAEA,IAAI,eAAY;AACf,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,aAAa,MAAI;AACpB,SAAK,MAAM,eAAe;EAC3B;EAEA,IAAI,cAAW;AACd,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,YAAY,MAAI;AACnB,SAAK,MAAM,cAAc;EAC1B;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,MAAM;EACnB;EAEA,IAAI,WAAQ;AACX,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,SAAS,WAAS;AACrB,SAAK,MAAM,WAAW;EACvB;;;;EAKA,IAAI,SAAM;AACT,WAAO,KAAK,MAAM;EACnB;;;;ACpQK,IAAO,YAAP,MAAO,mBAAkB,cAA+B;EA4D7D,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC,CAAC,CAAC;AA3D/E,SAAA,OAAe;AAKhB,SAAA,UAA4B,KAAK,QAAQ,mBAAkB;AAK3D,SAAA,SAA8B,KAAK,QAAQ,sBAAsB,CAAC;AAMlE,SAAA,OAAoB,IAAI,YAAY,EAAE,SAAS,KAAK,QAAO,CAAE;AAK5D,SAAA,IAAU,IAAI,KAAK;MAC3B,SAAS,KAAK;MACd,MAAM;KACN;AAKQ,SAAA,IAAU,IAAI,KAAK;MAC3B,SAAS,KAAK;MACd,MAAM;KACN;AAKQ,SAAA,SAAe,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAchD,SAAA,oBAAoB,CAAC,KAAK,GAAG,KAAK,CAAC;AAS5C,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC;AAEjF,SAAK,OAAO,IAAI,OAAO;MACtB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AACD,aAAS,MAAM,MAAM;AAErB,SAAK,QAAQ,YAAY,CAAC,EAAE,QAAQ,KAAK,OAAO;AAChD,SAAK,QAAQ,QAAQ,KAAK,MAAM;AAIhC,SAAK,QAAQ,eAAe;AAC5B,SAAK,QAAQ,mBAAmB;AAChC,YAAQ,KAAK,QAAQ,KAAK,EAAE,MAAM,CAAC;AACnC,YAAQ,KAAK,QAAQ,KAAK,EAAE,MAAM,CAAC;AAEnC,SAAK,KAAK,MAAM,KAAK,MAAM,KAAK,QAAQ,GAAG;AAE3C,SAAK,EAAE,QAAQ,KAAK,MAAM;AAC1B,SAAK,EAAE,QAAQ,KAAK,MAAM;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;KACN;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,EAAE,QAAO;AACd,SAAK,EAAE,QAAO;AACd,SAAK,OAAO,QAAO;AACnB,SAAK,KAAK,QAAO;AACjB,SAAK,KAAK,QAAO;AACjB,SAAK,QAAQ,WAAU;AACvB,SAAK,OAAO,WAAU;AACtB,WAAO;EACR;;;;AC9HK,IAAgB,SAAhB,cACG,cAAsB;EAoC9B,YAAY,SAAsB;AACjC,UAAM,OAAO;AAnCL,SAAA,OAAe;AAKhB,SAAA,UAAqB,IAAI,UAAU,EAAE,SAAS,KAAK,QAAO,CAAE;AAOpE,SAAA,MAA6B,KAAK,QAAQ;AAKhC,SAAA,aAAmB,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAKrD,SAAA,eAAqB,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAKjE,SAAA,QAAc,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAKhD,SAAA,SAAS,KAAK;AAMb,SAAK,MAAM,IAAI,KAAK,QAAQ,GAAG,KAAK,UAAU;AAC9C,SAAK,aAAa,QAAQ,KAAK,QAAQ,CAAC;AACxC,SAAK,IAAI,eAAe,QAAQ,KAAK,CAAC;AACtC,SAAK,oBAAoB,CAAC,KAAK,cAAc,KAAK,UAAU;AAC5D,aAAS,MAAM,KAAK;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,KAAK;KACL;EACF;;;;EAKU,cAAc,QAAiC;AAExD,SAAK,kBAAkB,KAAK,MAAM;AAClC,SAAK,WAAW,MAAM,QAAQ,KAAK,YAAY;AAC/C,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,WAAW,QAAO;AACvB,SAAK,aAAa,QAAO;AACzB,SAAK,IAAI,QAAO;AAChB,WAAO;EACR;;;;ACrEK,IAAgB,YAAhB,cAAoE,OAAe;EAoBxF,YAAY,SAAyB;AAEpC,UAAM,OAAO;AApBL,SAAA,OAAe;AAsBvB,SAAK,OAAO,IAAI,IAAI;MACnB,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,WAAW,QAAQ;KACnB;AACD,SAAK,QAAQ,KAAK,KAAK;AACvB,SAAK,YAAY,KAAK,KAAK;AAE3B,SAAK,OAAO,QAAQ;AACpB,aAAS,MAAM,CAAC,aAAa,OAAO,CAAC;EACtC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,WAAW;MACX,MAAM;MACN,OAAO;KACP;EACF;;;;EAKA,MAAM,MAAW;AAChB,SAAK,KAAK,MAAM,IAAI;AACpB,WAAO;EACR;;;;EAKA,KAAK,MAAW;AACf,SAAK,KAAK,KAAK,IAAI;AACnB,WAAO;EACR;;;;EAKA,OAAI;AACH,SAAK,KAAK,KAAI;AACd,WAAO;EACR;;;;EAKA,SAAM;AACL,SAAK,KAAK,OAAM;AAChB,WAAO;EACR;;;;;;;;EASA,IAAI,OAAI;AACP,WAAO,KAAK,KAAK;EAClB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,KAAK,OAAO;EAClB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,SAAK,UAAU,QAAO;AACtB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACzFK,IAAO,aAAP,MAAO,oBAAmB,UAA4B;EAqB3D,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,aAAa,iBAAiB,SAAS,CAAC,CAAC;AArBlG,SAAA,OAAe;AAsBvB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,aAAa,iBAAiB,SAAS,CAAC;AAEnH,SAAK,SAAS,IAAI,OAAO,OAAO,OAAO,QAAQ,QAAQ;MACtD,SAAS,KAAK;KACd,CAAC;AAGF,SAAK,cAAc,KAAK,MAAM;AAC9B,SAAK,KAAK,QAAQ,KAAK,OAAO,SAAS;AACvC,SAAK,UAAU,QAAQ;AACvB,SAAK,gBAAgB,QAAQ;EAC9B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,UAAU,YAAW,GAAI;MAC7C,eAAe;MACf,SAAS;MACT,QAAQ;QACP,MAAM;QACN,SAAS;QACT,GAAG;;KAEJ;EACF;;;;EAKA,IAAI,gBAAa;AAChB,WAAO,KAAK,KAAK;EAClB;EACA,IAAI,cAAc,MAAI;AACrB,SAAK,KAAK,MAAM,KAAK,YAAY,IAAI;AAErC,SAAK,UAAU,KAAK;EACrB;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,KAAG;AACd,SAAK,WAAW;AAChB,SAAK,KAAK,MAAM,KAAK,KAAK,MAAM,KAAK,IAAI,GAAG,GAAG;EAChD;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;AC9EK,IAAO,SAAP,MAAO,gBAAe,cAAgC;EA+B3D,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,KAAK,CAAC,CAAC,CAAC;AA9B3E,SAAA,OAAe;AAKhB,SAAA,UAA4B,KAAK,QAAQ,mBAAkB;AAC1D,SAAA,QAA0B,KAAK;AAC/B,SAAA,SAA2B,KAAK;AAwBxC,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,KAAK,CAAC;AAE7E,SAAK,MAAM,IAAI,MAAM;MACpB,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;MACf,UAAU;MACV,UAAU;KACV;AAKD,SAAK,QAAQ,eAAe,QAAQ;AACpC,SAAK,QAAQ,mBAAmB;AAGhC,aAAS,MAAM,KAAK;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,KAAK;MACL,cAAc;KACd;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,WAAU;AACvB,SAAK,IAAI,QAAO;AAChB,WAAO;EACR;;;;ACnEK,IAAO,aAAP,MAAO,oBAAmB,UAA4B;EAc3D,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC,CAAC;AAdtE,SAAA,OAAe;AAevB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC;AAEvF,SAAK,UAAU,IAAI,OAAO;MACzB,SAAS,KAAK;MACd,cAAc,QAAQ;KACtB;AAED,SAAK,cAAc,KAAK,OAAO;AAC/B,SAAK,KAAK,QAAQ,KAAK,QAAQ,GAAG;AAClC,SAAK,KAAK,MAAM;AAChB,SAAK,KAAK,MAAM;EACjB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,UAAU,YAAW,GAAI;MAC7C,cAAc;KACd;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;;;;ACxCK,IAAO,WAAP,MAAO,kBAAiB,cAA8B;EA2B3D,cAAA;AACC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC,CAAC;AA1BpE,SAAA,OAAe;AA2BvB,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC;AAErF,SAAK,OAAO,KAAK,QAAQ,IAAI,IAAI,EAAE,SAAS,KAAK,QAAO,CAAE;AAC1D,SAAK,WAAW,KAAK,SAAS,IAAI,cAAc;MAC/C,SAAS,KAAK;MACd,WAAW,IAAI,KAAK,UAAU,QAAQ,SAAS;MAC/C,MAAM;KACN;AACD,SAAK,KAAK,QAAQ,KAAK,QAAQ;AAC/B,SAAK,aAAa,QAAQ;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;KACX;EACF;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK;EACb;EACA,IAAI,UAAU,WAAS;AACtB,SAAK,aAAa;AAClB,SAAK,SAAS,YAAY,IAAI,KAAK,UAAU,KAAK,SAAS;EAC5D;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,KAAK,QAAO;AACjB,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;AChDK,IAAO,UAAP,MAAO,iBAAgB,OAAsB;EAyDlD,cAAA;AAEC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,iBAAiB,WAAW,aAAa,CAAC,CAAC;AAzDjG,SAAA,OAAe;AA0DvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,iBAAiB,WAAW,aAAa,CAAC;AAElH,SAAK,YAAY,IAAI,SAAS;MAC7B,SAAS,KAAK;MACd,WAAW,QAAQ;KACnB;AACD,SAAK,cAAc,IAAI,SAAS;MAC/B,SAAS,KAAK;MACd,KAAK;MACL,KAAK;MACL,UAAU;KACV;AACD,SAAK,iBAAiB,KAAK,YAAY,QAAQ,aAAa;AAC5D,SAAK,WAAW,QAAQ;AACxB,SAAK,cAAc,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AACrD,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,SAAS;MACT,WAAW;MACX,GAAG,QAAQ;KACX;AACD,SAAK,WAAW,IAAI,OAAO;MAC1B,SAAS,KAAK;MACd,MAAM;KACN;AACD,SAAK,SAAS,KAAK,QAAQ,QAAQ;AACnC,SAAK,OAAO,KAAK,SAAS;AAC1B,SAAK,IAAI,KAAK,UAAU;AAGxB,SAAK,WAAW,MAAM,KAAK,aAAa,KAAK,WAAW,KAAK,WAAW;AACxE,SAAK,YAAY,QAAQ,KAAK,UAAU,SAAS;AACjD,SAAK,YAAY,QAAQ,KAAK,SAAS,SAAS;AAEhD,SAAK,WAAW,MAAM,KAAK,WAAW,KAAK,UAAU,KAAK,YAAY;AAEtE,SAAK,eAAc;AACnB,SAAK,cAAc,QAAQ;AAE3B,aAAS,MAAM,CAAC,QAAQ,GAAG,CAAC;EAC7B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,eAAe;MACf,SAAS;MACT,aAAa;MACb,GAAG;MACH,MAAM;MACN,UAAU;KACV;EACF;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,WAAW;AAChB,SAAK,eAAc;EACpB;;;;EAKA,IAAI,WAAQ;AACX,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,SAAS,UAAQ;AACpB,SAAK,UAAU,YAAY;EAC5B;;;;EAKA,IAAI,gBAAa;AAChB,WAAO,KAAK;EACb;EACA,IAAI,cAAc,UAAQ;AACzB,SAAK,iBAAiB,KAAK,YAAY,QAAQ;AAC/C,SAAK,eAAc;EACpB;;;;EAKA,IAAI,cAAW;AACd,WAAO,SAAS,IAAI,KAAK,YAAY,KAAK,KAAK;EAChD;EACA,IAAI,YAAY,aAAW;AAC1B,SAAK,YAAY,KAAK,QAAQ,IAAI,SAAS,WAAW;EACvD;;;;EAKQ,iBAAc;AACrB,SAAK,YAAY,MAAM,KAAK;AAC5B,SAAK,YAAY,MAAM,KAAK,IAAI,KAAK,iBAAiB,KAAK,IAAI,GAAG,KAAK,QAAQ,GAAG,KAAK,QAAQ,aAAa,CAAC;EAC9G;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,YAAY,QAAO;AACxB,SAAK,UAAU,QAAO;AACtB,SAAK,SAAS,QAAO;AACrB,SAAK,YAAY,QAAO;AACxB,WAAO;EACR;;;;AC3MM,IAAMC,eAAc;AAEpB,IAAM;;EAAoC;;;;;;;;;;;;;;;;;;;;;AAqBjD,kBAAkBA,cAAa,iBAAiB;;;ACD1C,IAAO,aAAP,MAAO,oBAAmB,OAAyB;EAkBxD,cAAA;AACC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC,CAAC;AAjBjE,SAAA,OAAe;AAkBvB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC;AAElF,SAAK,qBAAqB,IAAI,kBAAkB;MAC/C,SAAS,KAAK;MACd,MAAM,QAAQ;KACd;AAED,SAAK,cAAc,KAAK,kBAAkB;AAE1C,SAAK,OAAO,KAAK,mBAAmB;EACrC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,MAAM;KACN;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,mBAAmB,QAAO;AAC/B,WAAO;EACR;;AAUD,IAAM,oBAAN,MAAM,2BAA0B,iBAA0C;EAUzE,cAAA;AACC,UAAM,qBAAqB,mBAAkB,YAAW,GAAI,SAAS,CAAC;AAT9D,SAAA,OAAe;AAUvB,UAAM,UAAU,qBAAqB,mBAAkB,YAAW,GAAI,SAAS;AAE/E,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/C,SAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAEhD,SAAK,OAAO,IAAI,MAAkB;MACjC,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;MACP,UAAU;MACV,UAAU;MACV,OAAO,KAAK;MACZ,WAAW;KACX;EACF;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,iBAAiB,YAAW,GAAI;MACpD,MAAM;KACN;EACF;EAEU,oBAAiB;AAC1B,WAAOC;EACR;EAEA,QAAQ,MAAsB;AAC7B,kBAAc,KAAK,OAAO,MAAM,KAAK,MAAM;AAC3C,UAAM,OAAO,KAAK,WAAW,IAAI,MAAM;AACvC,SAAK,KAAK,SAAS,IAAI;EACxB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,OAAO,QAAO;AACnB,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;ACvGK,IAAO,YAAP,MAAO,mBAAkB,OAAwB;EAmBtD,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AAnBjE,SAAA,OAAe;AAoBvB,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAElF,SAAK,UAAU,IAAI,WAAW;MAC7B,SAAS,KAAK;MACd,QAAQ;KACR;AACD,SAAK,SAAS,QAAQ;AAEtB,SAAK,cAAc,KAAK,OAAO;AAC/B,SAAK,QAAQ,QAAQ;AACrB,SAAK,aAAa,QAAQ;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,OAAO;MACP,YAAY;KACZ;EACF;;;;;;;EAQQ,gBAAgB,GAAW,QAAgB,MAAyB;AAC3E,QAAI,KAAK,IAAI,MAAM,GAAG;AACrB,aAAO,KAAK,IAAI,MAAM;eACZ,WAAW,GAAG;AACxB,WAAK,IAAI,QAAQ,CAAC;eACR,WAAW,GAAG;AACxB,WAAK,IAAI,QAAQ,CAAC;WACZ;AACN,WAAK,IAAI,QAAQ,IAAI,IAAI,KAAK,gBAAgB,GAAG,SAAS,GAAG,IAAI,IAAI,KAAK,gBAAgB,GAAG,SAAS,GAAG,IAAI,CAAC;;AAE/G,WAAO,KAAK,IAAI,MAAM;EACvB;;;;;;;;;;;EAYA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,OAAK;AACd,SAAK,SAAS;AACd,SAAK,QAAQ,OAAQ,OAAI;AACxB,aAAO,KAAK,gBAAgB,GAAG,OAAO,oBAAI,IAAG,CAAE;IAChD,CAAE;EACH;;;;EAKA,IAAI,aAAU;AACb,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,WAAW,cAAY;AAC1B,SAAK,QAAQ,aAAa;EAC3B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;;;;ACxGK,IAAO,QAAP,MAAO,eAAc,cAA2B;EAgBrD,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,UAAU,CAAC,CAAC;AAhBhE,SAAA,OAAe;AAiBvB,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,UAAU,CAAC;AAEjF,SAAK,YAAY,KAAK,QAAQ,KAAK,SAAS,KAAK,QAAQ,sBAAsB,QAAQ,QAAQ;AAC/F,SAAK,oBAAoB,CAAC,KAAK,SAAS;EACzC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,WAAU;AACzB,WAAO;EACR;;;;AC9BK,IAAO,QAAP,MAAO,eAAc,cAA2B;EAwBrD,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,UAAU,CAAC,CAAC;AAvBhE,SAAA,OAAe;AAwBvB,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,UAAU,CAAC;AAEjF,SAAK,UAAU,KAAK,SAAS,KAAK,QAAQ,KAAK,QAAQ,oBAAoB,QAAQ,QAAQ;EAC5F;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,WAAU;AACvB,WAAO;EACR;;;;AC9CK,IAAO,eAAP,cAAiE,cAAsB;EA4B5F,YAAY,SAA4B;AAEvC,UAAM,OAAO;AA5BL,SAAA,OAAe;AA8BvB,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAE/C,SAAK,MAAM,eAAe;AAC1B,SAAK,MAAM,mBAAmB;AAE9B,SAAK,UAAU,KAAK,SAAS,IAAI,UAAU;MAC1C,SAAS,KAAK;MACd,MAAM,QAAQ;KACd;AACD,SAAK,MAAM,KAAK,QAAQ;AACxB,SAAK,SAAS,IAAI,MAAM,EAAE,SAAS,KAAK,SAAS,UAAU,EAAC,CAAE;AAC9D,SAAK,SAAS,IAAI,MAAM,EAAE,SAAS,KAAK,SAAS,UAAU,EAAC,CAAE;AAG9D,SAAK,MAAM,QAAQ,KAAK,MAAM;AAE9B,SAAK,MAAM,QAAQ,KAAK,QAAQ,CAAC;AACjC,SAAK,OAAO,QAAQ,KAAK,QAAQ,CAAC;AAClC,aAAS,MAAM,CAAC,KAAK,CAAC;EACvB;;;;EAKU,qBAAqB,OAAmB;AACjD,SAAK,OAAO,QAAQ,MAAM,CAAC,GAAG,GAAG,CAAC;AAClC,kBAAc,GAAG,KAAK;AACtB,YAAQ,MAAM,MAAM,SAAO,CAAC,GAAG,KAAK,QAAQ,GAAG,CAAC;EACjD;;;;EAKU,sBAAsB,OAAmB;AAClD,SAAK,OAAO,QAAQ,MAAM,CAAC,GAAG,GAAG,CAAC;AAClC,kBAAc,GAAG,KAAK;AACtB,YAAQ,MAAM,MAAM,SAAO,CAAC,GAAG,KAAK,QAAQ,GAAG,CAAC;EACjD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,KAAK;KACL;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,OAAO,QAAO;AACnB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;AClFK,IAAO,uBAAP,cAAiF,aAAqB;EA6B3G,YAAY,SAAoC;AAE/C,UAAM,OAAO;AAEb,SAAK,WAAW,IAAI,OAAO;MAC1B,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AACD,SAAK,aAAa,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AACpD,SAAK,aAAa,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAEpD,SAAK,iBAAiB,IAAI,MAAM,EAAE,SAAS,KAAK,SAAS,UAAU,EAAC,CAAE;AACtE,SAAK,iBAAiB,IAAI,MAAM,EAAE,SAAS,KAAK,SAAS,UAAU,EAAC,CAAE;AAEtE,SAAK,OAAO,QAAQ,KAAK,cAAc;AACvC,SAAK,eAAe,QAAQ,KAAK,MAAM;AAGvC,SAAK,eAAe,QAAQ,KAAK,YAAY,GAAG,CAAC;AACjD,SAAK,WAAW,QAAQ,KAAK,gBAAgB,GAAG,CAAC;AAGjD,SAAK,eAAe,QAAQ,KAAK,YAAY,GAAG,CAAC;AACjD,SAAK,WAAW,QAAQ,KAAK,gBAAgB,GAAG,CAAC;AAGjD,SAAK,SAAS,IAAI,KAAK,WAAW,MAAM,KAAK,WAAW,IAAI;AAC5D,aAAS,MAAM,CAAC,UAAU,CAAC;EAC5B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,aAAa,YAAW,GAAI;MAChD,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,SAAS,QAAO;AACrB,SAAK,WAAW,QAAO;AACvB,SAAK,WAAW,QAAO;AACvB,SAAK,eAAe,QAAO;AAC3B,SAAK,eAAe,QAAO;AAC3B,WAAO;EACR;;;;AC3DK,IAAO,SAAP,MAAO,gBAAe,qBAAmC;EA8C9D,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,aAAa,aAAa,OAAO,CAAC,CAAC;AA9CxF,SAAA,OAAe;AA+CvB,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,aAAa,aAAa,OAAO,CAAC;AAEzG,SAAK,SAAS,QAAQ;AACtB,SAAK,aAAa,QAAQ,YAAY;AACtC,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,KAAK;MACL,KAAK;KACL;AACD,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,KAAK;MACL,KAAK;MACL,OAAO;KACP;AACD,SAAK,cAAc,IAAI,MAAM,EAAE,SAAS,KAAK,QAAO,CAAE;AACtD,SAAK,cAAc,IAAI,MAAM,EAAE,SAAS,KAAK,QAAO,CAAE;AACtD,SAAK,YAAY,KAAK,MAAM;AAC5B,aAAS,MAAM,CAAC,WAAW,CAAC;AAE5B,SAAK,MAAM,UAAU,QAAQ,KAAK,MAAM,SAAS;AAGjD,SAAK,kBAAkB,KAAK,WAAW;AACvC,SAAK,mBAAmB,KAAK,WAAW;AAExC,SAAK,MAAM,QAAQ,KAAK,YAAY,SAAS;AAC7C,SAAK,MAAM,QAAQ,KAAK,YAAY,SAAS;AAE7C,SAAK,QAAQ,KAAK;AAClB,SAAK,OAAO,QAAQ;AACpB,SAAK,SAAS,QAAQ;EACvB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,qBAAqB,YAAW,GAAI;MACxD,WAAW;MACX,WAAW;MACX,OAAO;MACP,MAAM;MACN,QAAQ;MACR,UAAU;MACV,KAAK;KACL;EACF;;;;;EAMA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,OAAK;AACd,SAAK,SAAS;AACd,UAAM,YAAY,KAAK,aAAa;AACpC,SAAK,MAAM,MAAM,KAAK,IAAI,KAAK,aAAa,WAAW,CAAC;AACxD,SAAK,MAAM,MAAM,KAAK,aAAa;AACnC,SAAK,MAAM,MAAM,KAAK,IAAI,KAAK,aAAa,WAAW,CAAC;AACxD,SAAK,MAAM,MAAM,KAAK,aAAa;EACpC;;;;;;EAOA,IAAI,YAAS;AACZ,WAAO,KAAK,aAAa;EAC1B;EACA,IAAI,UAAU,WAAS;AACtB,SAAK,aAAa,YAAY;AAC9B,SAAK,QAAQ,KAAK;EACnB;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,MAAM,OAAO;AAClB,SAAK,MAAM,OAAO;EACnB;;;;;EAMA,IAAI,SAAM;AACT,WAAO,KAAK,MAAM,QAAQ,KAAK,MAAM;EACtC;EACA,IAAI,OAAO,QAAM;AAChB,SAAK,MAAM,QAAQ,KAAM,SAAS;AAClC,SAAK,MAAM,QAAS,SAAS,IAAK;EACnC;;;;EAKA,MAAM,MAAW;AAChB,SAAK,MAAM,MAAM,IAAI;AACrB,SAAK,MAAM,MAAM,IAAI;AACrB,WAAO;EACR;;;;EAKA,KAAK,MAAW;AACf,SAAK,MAAM,KAAK,IAAI;AACpB,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;EACR;;;;EAKA,OAAI;AACH,SAAK,MAAM,KAAI;AACf,SAAK,MAAM,KAAI;AACf,WAAO;EACR;;;;EAKA,SAAM;AACL,SAAK,MAAM,OAAM;AACjB,SAAK,MAAM,OAAM;AACjB,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,MAAM,QAAO;AAClB,SAAK,YAAY,QAAO;AACxB,SAAK,YAAY,QAAO;AACxB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC5MK,IAAO,aAAP,MAAO,oBAAmB,OAAyB;EAmBxD,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,YAAY,CAAC,CAAC;AAnBvE,SAAA,OAAe;AAoBvB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,YAAY,CAAC;AAExF,SAAK,UAAU,IAAI,WAAW;MAC7B,SAAS,KAAK;MACd,QAAQ;KACR;AAED,SAAK,cAAc,QAAQ;AAE3B,SAAK,cAAc,KAAK,OAAO;AAC/B,SAAK,aAAa,QAAQ;AAC1B,SAAK,aAAa,QAAQ;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,YAAY;MACZ,YAAY;KACZ;EACF;;;;EAKA,IAAI,aAAU;AACb,WAAO,KAAK;EACb;EACA,IAAI,WAAW,QAAM;AACpB,SAAK,cAAc;AACnB,UAAM,IAAI,SAAS;AACnB,UAAM,MAAM,KAAK,KAAK;AACtB,SAAK,QAAQ,OAAO,CAAC,MAAK;AACzB,UAAI,KAAK,IAAI,CAAC,IAAI,MAAO;AAExB,eAAO;aACD;AACN,gBAAQ,IAAI,KAAK,IAAI,KAAK,OAAO,KAAK,KAAK,IAAI,KAAK,IAAI,CAAC;;IAE3D,CAAC;EACF;;;;EAKA,IAAI,aAAU;AACb,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,WAAW,cAAY;AAC1B,SAAK,QAAQ,aAAa;EAC3B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,WAAO;EACR;;;;ACxEK,IAAgB,iBAAhB,cAA8E,OAAe;EAclG,YAAY,SAA8B;AAEzC,UAAM,OAAO;AAdL,SAAA,OAAe;AAgBvB,SAAK,gBAAgB,IAAI,KAAK;MAC7B,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,OAAO;KACP;AAED,SAAK,WAAW,KAAK,cAAc;AACnC,aAAS,MAAM,UAAU;AAGzB,SAAK,aAAa,MAAM,KAAK,eAAe,KAAK,UAAU;EAC5D;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,cAAc,QAAO;AAC1B,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;ACxCK,IAAO,gBAAP,MAAO,uBAAsB,eAAoC;EAgBtE,cAAA;AAEC,UAAM,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,UAAU,CAAC,CAAC;AAhBrF,SAAA,OAAe;AAiBvB,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,UAAU,CAAC;AAEtG,SAAK,aAAa,IAAI,MAAM;MAC3B,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,UAAU,QAAQ;KAClB;AACD,SAAK,YAAY,KAAK,WAAW;AAGjC,SAAK,cAAc,KAAK,UAAU;AAClC,aAAS,MAAM,WAAW;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,eAAe,YAAW,GAAI;MAClD,WAAW;MACX,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAO;AACvB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC5DK,IAAO,oBAAP,cAAiC,cAAmC;EA+BzE,YAAY,SAAuC;AAElD,UAAM,OAAO;AA/BL,SAAA,OAAe;AAEf,SAAA,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAoB1C,SAAA,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAK3C,SAAA,WAAW,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAMrD,UAAM,qBAAqB,CAAC,WAAW,iBAAiB,gBAAiB,eAAe;AACxF,UAAM,qBAAqB,CAAC,iBAAiB,gBAAiB,iBAAiB,eAAe;AAE9F,SAAK,SAAS,KAAK,yBAAyB,kBAAkB;AAC9D,SAAK,SAAS,KAAK,yBAAyB,kBAAkB;AAC9D,SAAK,kBAAkB,KAAK,QAAQ,gBAAgB,CAAC,GAAK,CAAG,GAAG,CAAC,GAAK,CAAG,CAAC;AAG1E,kBAAc,KAAK,OAAO,GAAG,KAAK,QAAQ,KAAK,iBAAiB,KAAK,MAAM;AAC3E,kBAAc,KAAK,OAAO,GAAG,KAAK,QAAQ,KAAK,QAAQ;EACxD;;;;EAKQ,yBAAyB,YAAoB;AACpD,UAAM,QAAyB,WAAW,IAAI,WAAQ;AACrD,YAAM,eAAe,CAAC,CAAC,QAAQ,OAAO,GAAG,EAAE,GAAG,CAAC,GAAG,GAAG,EAAE,QAAQ,MAAM,CAAC;AACtE,aAAO,KAAK,QAAQ,gBAAgB,aAAa,CAAC,GAAG,aAAa,CAAC,CAAC;IACrE,CAAC;AAED,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,OAAO,QAAO;AACnB,SAAK,SAAS,QAAO;AACrB,SAAK,OAAO,QAAQ,OAAK,EAAE,WAAU,CAAE;AACvC,SAAK,OAAO,QAAQ,OAAK,EAAE,WAAU,CAAE;AACvC,SAAK,gBAAgB,WAAU;AAC/B,WAAO;EACR;;;;AC9CK,IAAO,mBAAP,MAAO,0BAAyB,OAA+B;EAkDpE,cAAA;AAEC,UAAM,qBAAqB,kBAAiB,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC,CAAC;AAlD5E,SAAA,OAAe;AAmDvB,UAAM,UAAU,qBAAqB,kBAAiB,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC;AAE7F,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;MACf,UAAU,CAAC,KAAK,QAAQ,aAAa;MACrC,UAAU,KAAK,QAAQ,aAAa;KACpC;AAED,SAAK,QAAQ,IAAI,mBAAmB;MACnC,SAAS,KAAK;MACd,MAAM;KACN;AAED,SAAK,UAAU,IAAI,WAAW;MAC7B,SAAS,KAAK;MACd,OAAO;MACP,MAAM;KACN;AAED,SAAK,gBAAgB,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AAC3D,SAAK,kBAAkB,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AAC7D,SAAK,UAAU,IAAI,OAAO,EAAE,SAAS,KAAK,QAAO,CAAE;AACnD,SAAK,OAAO,IAAI,IAAI,EAAE,SAAS,KAAK,QAAO,CAAE;AAE7C,SAAK,gBAAgB,IAAI,kBAAkB,EAAE,SAAS,KAAK,QAAO,CAAE;AACpE,SAAK,WAAW,QAAQ,KAAK,aAAa;AAG1C,SAAK,UAAU,IAAI,KAAK,MAAM,WAAW,KAAK,QAAQ,SAAS;AAE/D,SAAK,cAAc,SAAS,QAAQ,KAAK,eAAe;AACxD,SAAK,QAAQ,QAAQ,KAAK,gBAAgB,MAAM;AAEhD,SAAK,cAAc,QAAQ,KAAK,aAAa;AAC7C,SAAK,MAAM,QAAQ,KAAK,cAAc,MAAM;AAC5C,SAAK,cAAc,QAAQ,KAAK,OAAO;AAEvC,SAAK,gBAAgB,QAAQ,KAAK,IAAI;AACtC,SAAK,QAAQ,QAAQ,KAAK,KAAK,MAAM;AAErC,SAAK,KAAK,QAAQ,KAAK,YAAY;AAGnC,UAAMC,OAAM,KAAK,UAAS;AAC1B,SAAK,MAAM,MAAMA,IAAG;AACpB,SAAK,QAAQ,MAAMA,IAAG;EACvB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,WAAW;KACX;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,KAAK,QAAO;AACjB,SAAK,QAAQ,QAAO;AACpB,SAAK,gBAAgB,QAAO;AAC5B,SAAK,QAAQ,QAAO;AACpB,SAAK,cAAc,QAAO;AAC1B,SAAK,MAAM,QAAO;AAClB,SAAK,cAAc,QAAO;AAC1B,WAAO;EACR;;;;AC1ID,IAAM,oBAAoB,CAAC,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,OAAO,KAAK;AAKzI,IAAM,2BAA2B,CAAC,KAAK,KAAK,KAAK,GAAG;AAc9C,IAAO,WAAP,MAAO,kBAAiB,aAA6B;EA8B1D,cAAA;AAEC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,YAAY,WAAW,CAAC,CAAC;AA9BhF,SAAA,OAAe;AAUhB,SAAA,eAAoC,CAAA;AAKpC,SAAA,mBAAuC,CAAA;AAKvC,SAAA,mBAAuC,CAAA;AAW9C,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,YAAY,WAAW,CAAC;AAEjG,SAAK,WAAW,IAAI,OAAO;MAC1B,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AAGD,SAAK,mBAAmB,yBAAyB,IAAI,UAAO;AAC3D,YAAM,WAAW,KAAK,QAAQ,mBAAkB;AAChD,eAAS,OAAO;AAChB,eAAS,UAAU,QAAQ;AAC3B,aAAO;IACR,CAAC;AAGD,SAAK,mBAAmB,yBAAyB,IAAI,UAAO;AAC3D,YAAM,WAAW,KAAK,QAAQ,mBAAkB;AAChD,eAAS,OAAO;AAChB,eAAS,UAAU,QAAQ;AAC3B,aAAO;IACR,CAAC;AAGD,SAAK,eAAe,kBAAkB,IAAI,CAAC,WAAW,UAAS;AAC9D,YAAM,OAAO,IAAI,kBAAkB;QAClC,SAAS,KAAK;QACd,WAAW,QAAQ;QACnB;OACA;AACD,UAAI,QAAQ,kBAAkB,SAAS,GAAG;AACzC,aAAK,kBAAkB,MAAM,GAAG,KAAK,gBAAgB;aAC/C;AACN,aAAK,mBAAmB,MAAM,GAAG,KAAK,gBAAgB;;AAEvD,WAAK,SAAS,QAAQ,KAAK,SAAS;AACpC,aAAO;IACR,CAAC;AAED,aAAS,MAAM,CAAC,UAAU,CAAC;EAC5B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,aAAa,YAAW,GAAI;MAChD,UAAU;MACV,WAAW;KACX;EACF;;;;EAMA,IAAI,YAAS;AACZ,WAAO,KAAK,aAAa,CAAC,EAAE;EAC7B;EACA,IAAI,UAAU,GAAC;AACd,SAAK,aAAa,QAAQ,OAAK,EAAE,YAAY,CAAC;EAC/C;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,iBAAiB,QAAQ,QAAM,GAAG,WAAU,CAAE;AACnD,SAAK,iBAAiB,QAAQ,QAAM,GAAG,WAAU,CAAE;AACnD,SAAK,aAAa,QAAQ,QAAM,GAAG,QAAO,CAAE;AAC5C,SAAK,SAAS,QAAO;AACrB,WAAO;EACR;;;;ACxHD,IAAM,uBAAuB,CAAC,OAAO,MAAO,OAAO,MAAO,OAAO,MAAO,OAAO,IAAK;AAKpF,IAAM,uBAAuB,CAAC,OAAO,OAAO,OAAO,KAAK;AAKxD,IAAM,qBAAqB,CAAC,KAAK,KAAK,EAAE;AAgBlC,IAAO,WAAP,MAAO,kBAAiB,aAA6B;EA6B1D,cAAA;AAEC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,UAAU,CAAC,CAAC;AA7BnE,SAAA,OAAe;AAehB,SAAA,kBAAsC,CAAA;AAKtC,SAAA,uBAA6C,CAAA;AAUpD,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,UAAU,CAAC;AAEpF,SAAK,WAAW,IAAI,OAAO;MAC1B,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AACD,SAAK,iBAAiB,IAAI,MAAM;MAC/B,SAAS,KAAK;MACd,KAAK;MACL,KAAK;KACL;AAGD,SAAK,kBAAkB,mBAAmB,IAAI,UAAO;AACpD,YAAM,UAAU,KAAK,QAAQ,mBAAkB;AAC/C,cAAQ,OAAO;AACf,cAAQ,UAAU,QAAQ;AAC1B,aAAO;IACR,CAAC;AAGD,SAAK,uBAAuB,qBAAqB,IAAI,CAAC,WAAW,UAAS;AACzE,YAAM,OAAO,IAAI,mBAAmB;QACnC,SAAS,KAAK;QACd;OACA;AACD,WAAK,eAAe,QAAQ,KAAK,SAAS;AAC1C,WAAK,UAAU,QAAQ,qBAAqB,KAAK;AACjD,UAAI,QAAQ,qBAAqB,SAAS,GAAG;AAC5C,aAAK,kBAAkB,GAAG,KAAK,iBAAiB,IAAI;aAC9C;AACN,aAAK,mBAAmB,GAAG,KAAK,iBAAiB,IAAI;;AAEtD,aAAO;IACR,CAAC;AAGD,SAAK,SAAS,QAAQ,KAAK,cAAc;AACzC,aAAS,MAAM,CAAC,UAAU,CAAC;EAC5B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,aAAa,YAAW,GAAI;MAChD,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,gBAAgB,QAAQ,SAAO,IAAI,WAAU,CAAE;AACpD,SAAK,qBAAqB,QAAQ,UAAQ,KAAK,QAAO,CAAE;AACxD,SAAK,SAAS,QAAO;AACrB,SAAK,eAAe,QAAO;AAC3B,WAAO;EACR;;;;AC3GK,IAAO,wBAAP,cAAmF,qBAA6B;EAErH,YAAY,SAAqC;AAEhD,UAAM,OAAO;AAEb,SAAK,WAAW,WAAU;AAC1B,SAAK,WAAW,QAAQ,KAAK,gBAAgB,GAAG,CAAC;AAGjD,SAAK,WAAW,WAAU;AAC1B,SAAK,WAAW,QAAQ,KAAK,gBAAgB,GAAG,CAAC;AAEjD,aAAS,MAAM,CAAC,UAAU,CAAC;EAC5B;;;;ACTK,IAAO,gBAAP,MAAO,uBAAsB,sBAA2C;EA8B7E,cAAA;AAEC,UAAM,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,UAAU,CAAC,CAAC;AA9BrF,SAAA,OAAe;AA+BvB,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,aAAa,UAAU,CAAC;AAEtG,SAAK,aAAa,IAAI,MAAM;MAC3B,SAAS,KAAK;MACd,UAAU,QAAQ;KAClB;AACD,SAAK,cAAc,IAAI,MAAM;MAC5B,SAAS,KAAK;MACd,UAAU,QAAQ;KAClB;AACD,SAAK,iBAAiB,IAAI,MAAM;MAC/B,SAAS,KAAK;MACd,UAAU,QAAQ;KAClB;AACD,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAGD,SAAK,kBAAkB,KAAK,UAAU;AACtC,SAAK,mBAAmB,KAAK,gBAAgB,KAAK,WAAW;AAC7D,SAAK,UAAU,IAAI,KAAK,WAAW,WAAW,KAAK,YAAY,WAAW,KAAK,eAAe,SAAS;AAEvG,SAAK,WAAW,WAAU;AAC1B,SAAK,WAAW,QAAQ,KAAK,WAAW;AACxC,aAAS,MAAM,CAAC,WAAW,CAAC;EAC7B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,sBAAsB,YAAW,GAAI;MACzD,WAAW;MACX,UAAU;KACV;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAO;AACvB,SAAK,YAAY,QAAO;AACxB,SAAK,eAAe,QAAO;AAC3B,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC9EK,IAAO,aAAP,MAAO,oBAAmB,eAAiC;EAiEhE,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AAjElE,SAAA,OAAe;AAkEvB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAEnF,SAAK,aAAa,IAAI,OAAO,EAAE,SAAS,KAAK,QAAO,CAAE;AACtD,SAAK,UAAU,IAAI,MAAM;MACxB,UAAU;MACV,SAAS,KAAK;KACd;AACD,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,KAAK;MACL,KAAK;MACL,MAAM;KACN,EAAE,QAAQ,KAAK,QAAQ,SAAS;AACjC,SAAK,UAAU,IAAI,MAAM;MACxB,UAAU;MACV,SAAS,KAAK;KACd;AACD,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,KAAK;MACL,KAAK;MACL,MAAM;MACN,OAAO;KACP,EAAE,QAAQ,KAAK,QAAQ,SAAS;AACjC,SAAK,aAAa,IAAI,UAAU,EAAE,SAAS,KAAK,QAAO,CAAE;AACzD,SAAK,gBAAgB,IAAI,IAAI;MAC5B,SAAS,KAAK;MACd,KAAK;MACL,KAAK;MACL,MAAM;MACN,OAAO;KACP,EAAE,QAAQ,KAAK,WAAW,IAAI;AAC/B,SAAK,iBAAiB,IAAI,MAAM;MAC/B,WAAW,QAAQ;MACnB,SAAS,KAAK;KACd;AACD,SAAK,YAAY,KAAK,eAAe;AACrC,aAAS,MAAM,WAAW;AAC1B,SAAK,SAAS,QAAQ;AAEtB,SAAK,cAAc,QAAQ;AAG3B,SAAK,QAAQ,QAAQ,KAAK,WAAW,CAAC;AACtC,SAAK,QAAQ,QAAQ,KAAK,WAAW,CAAC;AAEtC,SAAK,WAAW,IAAI,KAAK,MAAM,WAAW,KAAK,MAAM,WAAW,KAAK,cAAc,SAAS;AAE5F,SAAK,WAAW,IAAI,KAAK,SAAS,KAAK,OAAO;AAC9C,SAAK,WAAW,MAAM,KAAK,gBAAgB,KAAK,YAAY;AAE5D,UAAMC,OAAM,KAAK,IAAG;AACpB,SAAK,MAAM,MAAMA,IAAG;AACpB,SAAK,MAAM,MAAMA,IAAG;AACpB,SAAK,cAAc,MAAMA,IAAG;AAE5B,SAAK,aAAa,KAAK;EACxB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,eAAe,YAAW,GAAI;MAClD,OAAO;MACP,YAAY;MACZ,WAAW;MACX,UAAU;KACV;EACF;;;;;;;;;EAUA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,UAAQ;AACjB,SAAK,SAAS;AACd,QAAI,SAAS;AACb,QAAI,WAAW,GAAG;AACjB,WAAK,MAAM,MAAM;AACjB,WAAK,MAAM,MAAM,KAAK;AACtB,WAAK,MAAM,MAAM;AACjB,WAAK,MAAM,MAAM,KAAK;AACtB,eAAS,yBAAyB,WAAW,CAAC,IAAI;WAC5C;AACN,WAAK,MAAM,MAAM,KAAK;AACtB,WAAK,MAAM,MAAM;AACjB,WAAK,MAAM,MAAM,KAAK;AACtB,WAAK,MAAM,MAAM;AACjB,eAAS,yBAAyB,QAAQ,IAAI;;AAE/C,SAAK,WAAW,QAAQ,UAAU,MAAM,KAAK;EAC9C;;;;;;;EAQA,IAAI,aAAU;AACb,WAAO,KAAK;EACb;EACA,IAAI,WAAW,MAAI;AAClB,SAAK,cAAc,KAAK,UAAU,IAAI;AACtC,SAAK,QAAQ,KAAK;EACnB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAO;AACvB,SAAK,QAAQ,QAAO;AACpB,SAAK,QAAQ,QAAO;AACpB,SAAK,MAAM,QAAO;AAClB,SAAK,MAAM,QAAO;AAClB,SAAK,WAAW,QAAO;AACvB,SAAK,cAAc,QAAO;AAC1B,SAAK,eAAe,QAAO;AAC3B,WAAO;EACR;;;;AC1LK,IAAO,SAAP,MAAO,gBAAe,aAA2B;EAmDtD,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,aAAa,WAAW,eAAe,CAAC,CAAC;AAnD9F,SAAA,OAAe;AAoDvB,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,aAAa,WAAW,eAAe,CAAC;AAE/G,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,KAAK;MACL,KAAK;KACL;AACD,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,WAAW,QAAQ;MACnB,KAAK;MACL,KAAK;MACL,OAAO;KACP;AACD,SAAK,iBAAiB,KAAK,YAAY,QAAQ,aAAa;AAC5D,SAAK,WAAW,QAAQ;AACxB,SAAK,IAAI,IAAI,OAAO;MACnB,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AACD,SAAK,YAAY,KAAK,aAAa,QAAQ,QAAQ,KAAK,KAAK;AAC7D,SAAK,YAAY,KAAK,aAAa,QAAQ,QAAQ,KAAK,KAAK;AAE7D,SAAK,YAAY,KAAK,MAAM;AAC5B,SAAK,UAAU,QAAQ,QAAQ;AAG/B,SAAK,kBAAkB,GAAG,KAAK,SAAS;AACxC,SAAK,mBAAmB,GAAG,KAAK,SAAS;AAEzC,SAAK,MAAM,UAAU,QAAQ,KAAK,MAAM,SAAS;AAEjD,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,UAAU,QAAQ;AAEvB,SAAK,MAAM,MAAK;AAChB,SAAK,MAAM,MAAK;AAChB,aAAS,MAAM,CAAC,aAAa,GAAG,CAAC;EAClC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,aAAa,YAAW,GAAI;MAChD,WAAW;MACX,SAAS;MACT,QAAQ;MACR,GAAG;MACH,eAAe;KACf;EACF;EAEQ,aAAa,QAAgB,eAAkB;AACtD,UAAM,UAA8B,CAAA;AAEpC,aAAS,IAAI,GAAG,IAAI,QAAQ,KAAK;AAChC,YAAM,SAAS,KAAK,QAAQ,mBAAkB;AAC9C,aAAO,OAAO;AACd,WAAK,EAAE,QAAQ,OAAO,CAAC;AACvB,oBAAc,QAAQ,OAAO,SAAS;AACtC,cAAQ,KAAK,MAAM;;AAEpB,WAAO;EACR;;;;EAKA,IAAI,UAAO;AACV,WAAO,KAAK;EACb;EACA,IAAI,QAAQ,SAAO;AAClB,SAAK,WAAW;AAChB,UAAM,MAAM,KAAK,iBAAiB,KAAK,IAAI,GAAG,OAAO;AACrD,SAAK,MAAM,MAAM;AACjB,SAAK,MAAM,MAAM;EAClB;;;;EAKA,IAAI,gBAAa;AAChB,WAAO,KAAK;EACb;EACA,IAAI,cAAc,MAAI;AACrB,SAAK,iBAAiB,KAAK,YAAY,IAAI;AAC3C,SAAK,MAAM,MAAM,KAAK;AACtB,SAAK,MAAM,MAAM,KAAK;AACtB,SAAK,UAAU,KAAK;EACrB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,EAAE,QAAO;AACd,SAAK,MAAM,QAAO;AAClB,SAAK,MAAM,QAAO;AAClB,SAAK,UAAU,QAAQ,OAAK,EAAE,WAAU,CAAE;AAC1C,SAAK,UAAU,QAAQ,OAAK,EAAE,WAAU,CAAE;AAC1C,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC7JK,IAAO,SAAP,MAAO,gBAAe,OAAqB;EA+BhD,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AA/B9D,SAAA,OAAe;AAKhB,SAAA,aAA4B,KAAK,QAAQ,gBAAe;AAiBhE,SAAA,QAAuB,QAAQ,QAAO;AAUrC,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AAE/E,SAAK,SAAS,QAAQ;AACtB,SAAK,YAAY,QAAQ;AACzB,SAAK,SAAQ;AAEb,SAAK,cAAc,KAAK,UAAU;EACnC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,OAAO;MACP,UAAU;KACV;EACF;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK;EACb;EACA,IAAI,MAAM,MAAI;AACb,WAAO,KAAK,UAAU,IAAI;AAC1B,gBAAY,MAAM,IAAK;AACvB,SAAK,SAAS;AACd,SAAK,SAAQ;EACd;;;;EAKA,IAAI,WAAQ;AACX,WAAO,KAAK;EACb;EACA,IAAI,SAAS,MAAI;AAChB,WAAO,KAAK,UAAU,IAAI;AAC1B,gBAAY,MAAM,CAAC;AACnB,SAAK,YAAY;AACjB,SAAK,SAAQ;EACd;;;;;EAMM,WAAQ;;AACb,YAAM,gBAAgB,KAAK;AAG3B,YAAMC,WAAU,IAAI,eAAe,GAAG,KAAK,SAAS,KAAK,WAAW,KAAK,QAAQ,UAAU;AAC3F,YAAM,SAAS,IAAI,MAAM,EAAE,SAAAA,SAAO,CAAE;AACpC,YAAM,SAAS,IAAI,MAAM,EAAE,SAAAA,SAAO,CAAE;AACpC,YAAM,QAAQ,IAAI,MAAM,EAAE,SAAAA,SAAO,CAAE;AACnC,aAAO,QAAQ,OAAO,GAAG,CAAC;AAC1B,aAAO,QAAQ,OAAO,GAAG,CAAC;AAC1B,YAAM,WAAW,IAAI,KAAK,EAAE,SAAAA,SAAO,CAAE,EAAE,cAAa;AACpD,YAAM,QAAQ,QAAQ;AACtB,aAAO,MAAM,CAAC;AACd,aAAO,MAAM,CAAC;AAEd,eAAS,KAAK,eAAe,GAAG,CAAC;AACjC,eAAS,KAAK,eAAe,GAAG,KAAK,SAAS;AAE9C,eAAS,KAAK,+BAA+B,GAAG,KAAK,WAAW,KAAK,KAAK;AAG1E,YAAM,gBAAgBA,SAAQ,OAAM;AACpC,WAAK,QAAQ,cAAc,KAAK,IAAI;AAGpC,YAAM;AAEN,WAAK,WAAW,UAAU,MAAM,eAAe,IAAG;AAElD,aAAO;IACR,CAAC;;EAED,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,WAAU;AAC1B,WAAO;EACR;;;;AC7HK,IAAO,eAAP,MAAO,sBAAqB,cAAkC;EAoCnE,cAAA;AACC,UAAM,qBAAqB,cAAa,YAAW,GAAI,SAAS,CAAC;AAnCzD,SAAA,OAAe;AAqCvB,SAAK,SAAS,KAAK,QAAQ,IAAI,MAAM;MACpC,UAAU;MACV,SAAS,KAAK;KACd;AACD,SAAK,UAAU,IAAI,IAAI,EAAE,SAAS,KAAK,QAAO,CAAE;AAChD,SAAK,MAAM,IAAI,SAAS;MACvB,SAAS,KAAK;MACd,OAAO,KAAK;KACZ;AACD,SAAK,gBAAgB,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AAC3D,SAAK,OAAO,IAAI,SAAS;MACxB,SAAS,KAAK;MACd,OAAO,KAAK;KACZ;AAED,SAAK,OAAO,QAAQ,KAAK,SAAS,CAAC;AACnC,SAAK,OAAO,QAAQ,KAAK,QAAQ,QAAQ,CAAC;AAC1C,SAAK,OAAO,QAAQ,KAAK,eAAe,CAAC;AACzC,SAAK,OAAO,QAAQ,KAAK,cAAc,YAAY,CAAC;AACpD,SAAK,QAAQ,QAAQ,KAAK,GAAG;AAC7B,SAAK,cAAc,QAAQ,KAAK,IAAI;EACrC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,IAAI,QAAO;AAChB,SAAK,KAAK,QAAO;AACjB,SAAK,QAAQ,QAAO;AACpB,SAAK,cAAc,QAAO;AAC1B,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACtEK,IAAO,eAAP,MAAO,sBAAqB,cAAkC;EAkDnE,cAAA;AACC,UAAM,qBAAqB,cAAa,YAAW,GAAI,SAAS,CAAC;AAjDzD,SAAA,OAAe;AAkDvB,SAAK,MAAM,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC7C,SAAK,OAAO,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC9C,SAAK,QAAQ,IAAI,IAAI,EAAE,SAAS,KAAK,QAAO,CAAE;AAC9C,SAAK,YAAY,IAAI,SAAS;MAC7B,SAAS,KAAK;MACd,OAAO,KAAK;KACZ;AACD,SAAK,SAAS,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AACpD,SAAK,aAAa,IAAI,SAAS;MAC9B,SAAS,KAAK;MACd,OAAO,KAAK;KACZ;AACD,SAAK,SAAS,KAAK,SAAS,IAAI,MAAM,EAAE,SAAS,KAAK,QAAO,CAAE;AAE/D,SAAK,IAAI,IAAI,KAAK,KAAK;AACvB,SAAK,KAAK,QAAQ,KAAK,MAAM,MAAM;AACnC,SAAK,IAAI,QAAQ,KAAK,MAAM;AAC5B,SAAK,KAAK,QAAQ,KAAK,OAAO,UAAU;AACxC,SAAK,MAAM,QAAQ,KAAK,SAAS;AACjC,SAAK,OAAO,QAAQ,KAAK,UAAU;AACnC,SAAK,UAAU,QAAQ,KAAK,QAAQ,GAAG,CAAC;AACxC,SAAK,WAAW,QAAQ,KAAK,QAAQ,GAAG,CAAC;EAC1C;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,IAAI,QAAO;AAChB,SAAK,KAAK,QAAO;AACjB,SAAK,UAAU,QAAO;AACtB,SAAK,WAAW,QAAO;AACvB,SAAK,MAAM,QAAO;AAClB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACtFK,IAAgB,gBAAhB,cAA4E,OAAe;EAkChG,YAAY,SAA6B;AAExC,UAAM,OAAO;AAlCL,SAAA,OAAe;AAoCvB,SAAK,gBAAgB,IAAI,aAAa,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/D,SAAK,gBAAgB,IAAI,aAAa,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/D,SAAK,WAAW,KAAK,cAAc;AACnC,SAAK,YAAY,KAAK,cAAc;AACpC,SAAK,aAAa,KAAK,cAAc;AACrC,SAAK,cAAc,KAAK,cAAc;AAGtC,SAAK,WAAW,QAAQ,KAAK,aAAa;AAC1C,SAAK,cAAc,QAAQ,KAAK,YAAY;EAC7C;;;;EAKU,oBAAoB,OAAmB;AAChD,SAAK,SAAS,MAAM,GAAG,OAAO,KAAK,UAAU;EAC9C;;;;EAKU,qBAAqB,OAAmB;AACjD,SAAK,UAAU,MAAM,GAAG,OAAO,KAAK,WAAW;EAChD;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,cAAc,QAAO;AAC1B,SAAK,cAAc,QAAO;AAC1B,SAAK,SAAS,QAAO;AACrB,SAAK,UAAU,QAAO;AACtB,SAAK,WAAW,QAAO;AACvB,SAAK,YAAY,QAAO;AACxB,WAAO;EACR;;;;ACnEK,IAAO,gBAAP,MAAO,uBAAsB,cAAmC;EAuCrE,cAAA;AAEC,UAAM,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC,CAAC;AAvCrE,SAAA,OAAe;AAwCvB,UAAM,UAAU,qBAAqB,eAAc,YAAW,GAAI,WAAW,CAAC,OAAO,CAAC;AACtF,SAAK,QAAQ,IAAI,OAAO;MACvB,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AACD,aAAS,MAAM,CAAC,OAAO,CAAC;AACxB,SAAK,oBAAoB,IAAI,SAAS;MACrC,SAAS,KAAK;MACd,OAAO;KACP;AACD,SAAK,qBAAqB,IAAI,SAAS;MACtC,SAAS,KAAK;MACd,OAAO;KACP;AACD,SAAK,WAAW,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AACtD,SAAK,kBAAkB,QAAQ,KAAK,SAAS,MAAM;AACnD,SAAK,iBAAiB,KAAK,QAAQ;AAEnC,SAAK,iBAAiB,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AAC5D,SAAK,eAAe,QAAQ,KAAK,iBAAiB;AAClD,YAAQ,KAAK,QAAQ,YAAY,CAAC,GAAG,KAAK,cAAc;AACxD,SAAK,MAAM,QAAQ,KAAK,eAAe,UAAU;AAEjD,SAAK,YAAY,IAAI,SAAS,EAAE,SAAS,KAAK,QAAO,CAAE;AACvD,SAAK,MAAM,QAAQ,KAAK,kBAAkB;AAC1C,SAAK,mBAAmB,QAAQ,KAAK,UAAU,MAAM;AACrD,SAAK,kBAAkB,KAAK,SAAS;EACtC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,OAAO;KACP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,SAAS,QAAO;AACrB,SAAK,UAAU,QAAO;AACtB,SAAK,kBAAkB,QAAO;AAC9B,SAAK,mBAAmB,QAAO;AAC/B,SAAK,eAAe,QAAO;AAC3B,WAAO;EACR;;;;AClFK,IAAO,UAAP,MAAO,iBAAgB,aAA4B;EA0CxD,cAAA;AAEC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC,CAAC;AA1C5E,SAAA,OAAe;AA2CvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC;AAE7F,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,KAAK;MACL,KAAK;KACL;AACD,SAAK,QAAQ,IAAI,IAAI;MACpB,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,KAAK;MACL,KAAK;KACL;AACD,SAAK,cAAc,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AACrD,SAAK,cAAc,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AACrD,SAAK,YAAY,IAAI,OAAO;MAC3B,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AACD,SAAK,QAAQ,IAAI,OAAO;MACvB,SAAS,KAAK;MACd,OAAO,QAAQ;MACf,OAAO;KACP;AAED,aAAS,MAAM,CAAC,aAAa,OAAO,CAAC;AACrC,SAAK,kBAAkB,KAAK,WAAW;AACvC,SAAK,mBAAmB,KAAK,WAAW;AACxC,SAAK,MAAM,QAAQ,KAAK,YAAY,IAAI;AACxC,SAAK,MAAM,QAAQ,KAAK,YAAY,IAAI;AACxC,SAAK,UAAU,IAAI,KAAK,MAAM,WAAW,KAAK,MAAM,SAAS;AAC7D,SAAK,MAAM,IAAI,KAAK,MAAM,WAAW,KAAK,MAAM,SAAS;AACzD,SAAK,SAAS,QAAQ;EACvB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,aAAa,YAAW,GAAI;MAChD,WAAW;MACX,MAAM;MACN,OAAO;MACP,QAAQ;KACR;EACF;;;;EAKA,MAAM,MAAW;AAChB,SAAK,MAAM,MAAM,IAAI;AACrB,SAAK,MAAM,MAAM,IAAI;AACrB,WAAO;EACR;;;;EAKA,KAAK,MAAW;AACf,SAAK,MAAM,KAAK,IAAI;AACpB,SAAK,MAAM,KAAK,IAAI;AACpB,WAAO;EACR;;;;EAKA,OAAI;AACH,SAAK,MAAM,KAAI;AACf,SAAK,MAAM,KAAI;AACf,SAAK,QAAQ,UAAU,WAAW,KAAK,SAAS;AAChD,WAAO;EACR;;;;EAKA,SAAM;AACL,SAAK,MAAM,OAAM;AACjB,SAAK,MAAM,OAAM;AACjB,SAAK,QAAQ,UAAU,aAAa,KAAK,SAAS;AAClD,WAAO;EACR;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,MAAM,OAAO;AAClB,SAAK,MAAM,OAAO;EACnB;;;;;EAMA,IAAI,SAAM;AACT,WAAO,KAAK,MAAM,QAAQ,KAAK,MAAM;EACtC;EACA,IAAI,OAAO,QAAM;AAChB,SAAK,MAAM,QAAQ,KAAM,SAAS;AAClC,SAAK,MAAM,QAAS,SAAS,IAAK;EACnC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,MAAM,QAAO;AAClB,SAAK,YAAY,QAAO;AACxB,SAAK,YAAY,QAAO;AACxB,SAAK,UAAU,QAAO;AACtB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACxKK,IAAO,UAAP,MAAO,iBAAgB,OAAsB;EA6BlD,cAAA;AAEC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC,CAAC;AA7B5E,SAAA,OAAe;AA8BvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC;AAE7F,SAAK,aAAa,IAAI,MAAM;MAC3B,SAAS,KAAK;MACd,WAAW;MACX,UAAU,QAAQ;KAClB;AACD,SAAK,OAAO,IAAI,IAAI;MACnB,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,KAAK;MACL,KAAK,QAAQ;MACb,WAAW,QAAQ;MACnB,OAAO;;KACP,EAAE,MAAK,EAAG,QAAQ,KAAK,WAAW,SAAS;AAC5C,SAAK,YAAY,KAAK,KAAK;AAC3B,SAAK,QAAQ,KAAK,KAAK;AAEvB,SAAK,MAAM,QAAQ,QAAQ;AAC3B,aAAS,MAAM,CAAC,aAAa,OAAO,CAAC;AACrC,SAAK,WAAW,MAAM,KAAK,YAAY,KAAK,YAAY;EACzD;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,OAAO,YAAW,GAAI;MAC1C,UAAU;MACV,WAAW;MACX,OAAO;MACP,MAAM;KACN;EACF;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,KAAK;EAClB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,KAAK,OAAO;EAClB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAO;AACvB,SAAK,KAAK,QAAO;AACjB,SAAK,UAAU,QAAO;AACtB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACjFK,IAAO,WAAP,MAAO,kBAAiB,cAA8B;EAsC3D,cAAA;AACC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,QAAQ,MAAM,CAAC,CAAC;AArCvE,SAAA,OAAe;AAQhB,SAAA,aAA6B,CAAA;AAoB7B,SAAA,WAA2B,CAAA;AAUlC,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,QAAQ,MAAM,CAAC;AAExF,SAAK,QAAQ,KAAK,SAAS,KAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC1E,SAAK,SAAS,IAAI,MAAM;MACvB,SAAS,KAAK;MACd,UAAU,QAAQ;KAClB;AACD,SAAK,MAAM,QAAQ,KAAK,MAAM;AAE9B,gBAAY,QAAQ,UAAU,CAAC;AAG/B,aAAS,UAAU,GAAG,UAAU,QAAQ,UAAU,WAAW;AAC5D,WAAK,WAAW,OAAO,IAAI,KAAK,QAAQ,eAAc;AACtD,WAAK,OAAO,QAAQ,KAAK,WAAW,OAAO,GAAG,SAAS,CAAC;;AAIzD,SAAK,OAAO,QAAQ;AACpB,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,WAAW;MACX,MAAM;MACN,UAAU;KACV;EACF;;;;;;;EAQA,WAAQ;AACP,SAAK,WAAW,QAAQ,CAAC,UAAU,UAAS;AAC3C,YAAM,SAAS,KAAK,SAAS,KAAK;AAClC,UAAI,KAAK,UAAU,OAAO;AACzB,iBAAS,sBAAsB,MAAM;iBAC3B,KAAK,UAAU,YAAY;AACrC,iBAAS,uBAAuB,MAAM;;IAExC,CAAC;AACD,QAAI,KAAK,aAAa,GAAG;AACxB,aAAO,KAAK,SAAS,CAAC;WAChB;AACN,aAAO,KAAK;;EAEd;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,WAAW,CAAC,EAAE;EAC3B;EACA,IAAI,KAAK,MAAgB;AACxB,SAAK,WAAW,QAAQ,CAAC,UAAU,UAAS;AAC3C,eAAS,UAAU,OAAO;AAC1B,WAAK,SAAS,KAAK,IAAI,IAAI,aAAa,IAAI;IAC7C,CAAC;EACF;;;;;EAMA,IAAI,WAAQ;AACX,WAAO,KAAK,WAAW;EACxB;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK;EACb;EACA,IAAI,KAAK,MAAkB;AAC1B,WAAO,SAAS,cAAc,SAAS,OAAO,2BAA2B,IAAI,EAAE;AAC/E,SAAK,QAAQ;EACd;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK,WAAW,CAAC,EAAE;EAC3B;EACA,IAAI,UAAU,KAAgB;AAC7B,SAAK,WAAW,QAAQ,OAAK,EAAE,wBAAwB,GAAG;EAC3D;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,WAAW,QAAQ,OAAK,EAAE,WAAU,CAAE;AAC3C,SAAK,OAAO,QAAO;AACnB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;AC5JK,IAAO,YAAP,MAAO,mBAAoD,cAAsB;EAoBtF,cAAA;AACC,UAAM,qBAAqB,WAAU,YAAW,GAAI,SAAS,CAAC;AAnBtD,SAAA,OAAe;AAqBvB,SAAK,QAAQ,KAAK,SAAS,KAAK,YAAY,IAAI,SAAS;MACxD,SAAS,KAAK;MACd,MAAM;MACN,MAAM;KACN;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AChBK,IAAO,QAAP,MAAO,eAAc,UAAuB;EA0BjD,cAAA;AACC,UAAM,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC,CAAC;AAzBjE,SAAA,OAAe;AAiBhB,SAAA,OAAO;AASd,UAAM,UAAU,qBAAqB,OAAM,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC;AAElF,SAAK,QAAQ,KAAK,SAAS,KAAK,YAAY,IAAI,SAAS;MACxD,SAAS,KAAK;MACd,MAAM;MACN,MAAM;MACN,UAAU,QAAQ;KAClB;AAED,SAAK,YAAY,QAAQ,WACzB,KAAK,cAAc,QAAQ;EAC5B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,UAAU,YAAW,GAAI;MAC7C,WAAW;MACX,aAAa;MACb,UAAU;KACV;EACF;;;;;EAMA,WAAQ;AACP,SAAK,2CAA2C;AAChD,WAAO,KAAK,SAAQ;EACrB;;;;;;;;EASA,WAAQ;AACP,UAAM,UAAU,KAAK,UAAU,SAAQ;AACvC,UAAM,gBAAgB,KAAK,aAAa,IAAI,CAAC,OAAuB,IAAI;AACxE,UAAM,OAAO,cAAc,IAAI,YAAS;AACvC,YAAM,eAAe,OAAO,OAAO,CAAC,OAAO,YAAY,QAAQ,UAAU,SAAS,CAAC;AACnF,YAAM,MAAM,KAAK,KAAK,eAAe,OAAO,MAAM;AAGlD,WAAK,OAAO,KAAK,IAAI,KAAK,KAAK,OAAO,KAAK,SAAS;AACpD,aAAO,KAAK,cAAc,KAAK,OAAO,SAAS,KAAK,IAAI;IACzD,CAAC;AACD,QAAI,KAAK,aAAa,GAAG;AACxB,aAAO,KAAK,CAAC;WACP;AACN,aAAO;;EAET;;;;EAKA,IAAI,WAAQ;AACX,WAAO,KAAK,UAAU;EACvB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;ACxGK,IAAO,MAAP,MAAO,aAAY,UAAqB;EAgB7C,cAAA;AACC,UAAM,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC,CAAC;AAf1D,SAAA,OAAe;AAgBvB,UAAM,UAAU,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC;AAE3E,SAAK,cAAc,QAAQ;AAC3B,SAAK,UAAU,OAAO;AACtB,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,aAAa;MACb,MAAM;MACN,WAAW;KACX;EACF;;;;;EAMA,WAAQ;AACP,UAAM,SAAS,KAAK,UAAU,SAAQ;AACtC,WAAO,OAAO,IAAI,OAAK,KAAK,cAAc,SAAS,CAAC,IAAI,CAAC;EAC1D;;;;;;EAOA,IAAI,OAAI;AACP,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,UAAU,OAAO;EACvB;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,UAAU,KAAG;AAChB,SAAK,UAAU,YAAY;EAC5B;;;;;;;EAQA,oBAAoB,OAAa;AAChC,WAAO,KAAK,SAAS,QAAQ,KAAK,MAAM,0DAA0D,KAAK,IAAI,EAAE;AAC7G,WAAO,QAAQ,KAAK,QAAQ,cAAc,KAAK,OAAO;EACvD;;;;ACxEK,IAAO,UAAP,MAAO,iBAAgB,UAAyB;EAKrD,cAAA;AACC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,SAAS,CAAC;AAJpD,SAAA,OAAe;AAMvB,SAAK,UAAU,OAAO;AACtB,SAAK,UAAU,OAAO;EACvB;;;;EAKA,WAAQ;AACP,UAAM,QAAQ,KAAK,UAAU,SAAQ;AACrC,WAAO,MAAM,CAAC;EACf;;;;ACrBK,IAAO,WAAP,MAAO,kBAAiB,UAA0B;EASvD,cAAA;AACC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC,CAAC;AAR/D,SAAA,OAAe;AASvB,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC;AAEhF,SAAK,UAAU,OAAO;AACtB,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,UAAU,YAAW,GAAI;MAC7C,MAAM;KACN;EACF;;;;;EAMA,WAAQ;AACP,WAAO,KAAK,UAAU,SAAQ;EAC/B;;;;;EAMA,IAAI,OAAI;AACP,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,UAAU,OAAO;EACvB;;;;AClCK,IAAO,OAAP,MAAO,cAAa,cAA0B;EAYnD,cAAA;AAEC,UAAM,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC,CAAC;AAZ3D,SAAA,OAAe;AAavB,UAAM,UAAU,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,MAAM,CAAC;AAE5E,SAAK,QAAQ,KAAK,SAAS,IAAI,KAAK;MACnC,SAAS,KAAK;KACd;AAED,QAAI,CAAC,MAAK,UAAU,IAAI,KAAK,OAAO,GAAG;AACtC,YAAK,UAAU,IAAI,KAAK,SAAS,oBAAI,IAAG,CAAE;;AAE1C,UAAK,UAAU,IAAI,KAAK,OAAO,EAAgB,IAAI,IAAI;AAGxD,SAAK,OAAO,QAAQ;EACrB;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;KACN;EACF;;;;;;EAiBA,IAAI,OAAI;AACP,WAAO,KAAK,UAAS;EACtB;EACA,IAAI,KAAK,MAAI;AACZ,QAAI,MAAM;AACT,WAAK,SAAQ;WACP;AACN,WAAK,YAAW;;AAEhB,UAAK,UAAU,IAAI,KAAK,OAAO,EAAgB,QAAQ,cAAY,SAAS,YAAW,CAAE;EAC3F;;;;EAKA,IAAI,QAAK;AACR,WAAO,KAAK,MAAM,KAAK,UAAU;EAClC;;;;EAKQ,WAAQ;AACf,QAAI,CAAC,MAAK,QAAQ,IAAI,KAAK,OAAO,GAAG;AACpC,YAAK,QAAQ,IAAI,KAAK,SAAS,oBAAI,IAAG,CAAE;;AAExC,UAAK,QAAQ,IAAI,KAAK,OAAO,EAAgB,IAAI,IAAI;EACvD;;;;EAKQ,cAAW;AAClB,QAAI,MAAK,QAAQ,IAAI,KAAK,OAAO,GAAG;AAClC,YAAK,QAAQ,IAAI,KAAK,OAAO,EAAgB,OAAO,IAAI;;EAE3D;;;;EAKQ,YAAS;AAChB,WAAO,MAAK,QAAQ,IAAI,KAAK,OAAO,KAAM,MAAK,QAAQ,IAAI,KAAK,OAAO,EAAgB,IAAI,IAAI;EAChG;;;;EAKQ,WAAQ;AAEf,WAAO,CAAC,MAAK,QAAQ,IAAI,KAAK,OAAO;IAEnC,MAAK,QAAQ,IAAI,KAAK,OAAO,KAAM,MAAK,QAAQ,IAAI,KAAK,OAAO,EAAgB,SAAS;EAC5F;;;;EAKQ,cAAW;AAClB,QAAI,KAAK,UAAS,GAAI;AACrB,WAAK,MAAM,KAAK,QAAQ;eACd,KAAK,SAAQ,GAAI;AAE3B,WAAK,MAAM,KAAK,QAAQ;WAClB;AACN,WAAK,MAAM,KAAK,QAAQ;;EAE1B;EAEA,UAAO;AACN,UAAM,QAAO;AACZ,UAAK,UAAU,IAAI,KAAK,OAAO,EAAgB,OAAO,IAAI;AAC3D,SAAK,YAAW;AAChB,WAAO;EACR;;AAtFe,KAAA,YAAyC,oBAAI,IAAG;AAKhD,KAAA,UAAuC,oBAAI,IAAG;;;AC1CxD,IAAO,SAAP,MAAO,gBAAe,cAA4B;EAmCvD,cAAA;AAEC,UAAM,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC,CAAC;AAnCtE,SAAA,OAAe;AAoCvB,UAAM,UAAU,qBAAqB,QAAO,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC;AAEvF,SAAK,UAAU,KAAK,QAAQ,IAAI,OAAO;MACtC,SAAS,KAAK;MACd,KAAK,QAAQ;MACb,cAAc,QAAQ;KACtB;AACD,SAAK,MAAM,KAAK,QAAQ;AACxB,SAAK,UAAU,KAAK,SAAS,IAAI,OAAO;MACvC,SAAS,KAAK;MACd,QAAQ,QAAQ;KAChB;AACD,SAAK,SAAS,KAAK,QAAQ;AAG3B,SAAK,QAAQ,QAAQ,KAAK,OAAO;AACjC,SAAK,OAAO,QAAQ;AAEpB,aAAS,MAAM,CAAC,OAAO,QAAQ,CAAC;EACjC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,KAAK;MACL,QAAQ;MACR,cAAc;KACd;EACF;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ,OAAO;EACrB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,IAAI,QAAO;AAChB,SAAK,QAAQ,QAAO;AACpB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;ACnFK,IAAO,UAAP,MAAO,iBAAgB,cAA6B;EAmCzD,cAAA;AACC,UAAM,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,UAAU,KAAK,CAAC,CAAC;AAlCvE,SAAA,OAAe;AAmCvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,UAAU,KAAK,CAAC;AAExF,SAAK,QAAQ,KAAK,QAAQ,IAAI,KAAK;MAClC,MAAM,QAAQ;MACd,SAAS,KAAK;KACd;AACD,SAAK,UAAU,KAAK,SAAS,IAAI,OAAO;MACvC,SAAS,KAAK;MACd,KAAK,QAAQ;MACb,QAAQ,QAAQ;MAChB,MAAM,QAAQ;MACd,cAAc,QAAQ;KACtB;AACD,SAAK,MAAM,KAAK,QAAQ;AACxB,SAAK,SAAS,KAAK,QAAQ;AAE3B,SAAK,MAAM,QAAQ,KAAK,OAAO;AAC/B,aAAS,MAAM,CAAC,OAAO,QAAQ,CAAC;EACjC;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,KAAK;MACL,QAAQ;MACR,MAAM;MACN,MAAM;MACN,cAAc;KACd;EACF;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,MAAM;EACnB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,MAAM,OAAO;EACnB;;;;;EAMA,IAAI,QAAK;AACR,WAAO,KAAK,MAAM,SAAS,KAAK;EACjC;;;;EAKA,IAAI,OAAI;AACP,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,KAAK,MAAI;AACZ,SAAK,QAAQ,OAAO;EACrB;;;;;;EAYQ,QAAQ,MAAY;AAC3B,QAAI,CAAC,SAAQ,MAAM,IAAI,IAAI,GAAG;AAC7B,eAAQ,MAAM,IAAI,MAAM,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;;AAE5D,WAAO,SAAQ,MAAM,IAAI,IAAI;EAC9B;;;;;;;;;;;EAYA,KAAK,MAAc,SAAmB,GAAC;AACtC,UAAM,MAAM,KAAK,QAAQ,IAAI;AAC7B,UAAM,WAAW,IAAI,KAAK;MACzB,SAAS,KAAK;MACd,OAAO;MACP,MAAM;KACN;AACD,SAAK,QAAQ,QAAQ;AACrB,aAAS,QAAQ,GAAG;AACpB,WAAO;EACR;;;;;EAMA,QAAQ,MAAY;AACnB,UAAM,MAAM,KAAK,QAAQ,IAAI;AAC7B,QAAI,QAAQ,IAAI;AAChB,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,IAAI,QAAO;AAChB,SAAK,OAAO,QAAO;AACnB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;AArDe,QAAA,QAA2B,oBAAI,IAAG;;;AC9G5C,IAAO,OAAP,MAAO,cAAa,cAA0B;EAoBnD,cAAA;AAEC,UAAM,qBAAqB,MAAK,YAAW,GAAI,SAAS,CAAC;AApBjD,SAAA,OAAe;AAsBvB,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAE/C,SAAK,SAAS,KAAK,SAAS,IAAI,MAAM;MACrC,UAAU;MACV,SAAS,KAAK;KACd;AAED,SAAK,MAAM,QAAQ,KAAK,QAAQ,GAAG,CAAC;AACpC,SAAK,MAAM,QAAQ,KAAK,QAAQ,GAAG,CAAC;EACrC;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,OAAO,QAAO;AACnB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACrBK,IAAO,iBAAP,MAAO,wBAAuB,cAAoC;EAyEvE,cAAA;AACC,UAAM,qBAAqB,gBAAe,YAAW,GAAI,WAAW,CAAC,gBAAgB,eAAe,CAAC,CAAC;AAxE9F,SAAA,OAAe;AAKf,SAAA,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAK1C,SAAA,SAAS;AAKT,SAAA,MAAM,IAAI,OAAO;MACzB,SAAS,KAAK;MACd,WAAW;MACX,MAAM;KACN;AAKO,SAAA,gBAAgB,IAAI,OAAO;MAClC,SAAS,KAAK;MACd,WAAW;MACX,MAAM;KACN;AAKQ,SAAA,MAAM,IAAI,OAAO;MACzB,SAAS,KAAK;MACd,WAAW;MACX,MAAM;KACN;AAKQ,SAAA,OAAO,IAAI,OAAO;MAC1B,SAAS,KAAK;MACd,WAAW;MACX,MAAM;KACN;AAYS,SAAA,oBAAoB,CAAC,KAAK,KAAK,KAAK,KAAK,KAAK,IAAI;AAe3D,UAAM,UAAU,qBAAqB,gBAAe,YAAW,GAAI,WAAW,CAAC,gBAAgB,eAAe,CAAC;AAE/G,SAAK,eAAe,IAAI,OAAO;MAC9B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,gBAAgB,IAAI,OAAO;MAC/B,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,IAAI,IAAI,OAAO;MACnB,SAAS,KAAK;MACd,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,MAAM,IAAI,KAAK,KAAK,KAAK,IAAI;AAClC,SAAK,MAAM,MAAM,KAAK,eAAe,KAAK,GAAG;AAE7C,SAAK,aAAa,IAAI,KAAK,IAAI,WAAW,KAAK,cAAc,SAAS;AACtE,SAAK,cAAc,IAAI,KAAK,IAAI,WAAW,KAAK,KAAK,SAAS;AAE9D,SAAK,EAAE,QAAQ,KAAK,IAAI,CAAC;AACzB,SAAK,EAAE,QAAQ,KAAK,cAAc,CAAC;AACnC,SAAK,EAAE,QAAQ,KAAK,IAAI,CAAC;AACzB,SAAK,EAAE,QAAQ,KAAK,KAAK,CAAC;AAE1B,aAAS,MAAM,CAAC,QAAQ,OAAO,OAAO,iBAAiB,cAAc,CAAC;EACvE;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,GAAG;MACH,eAAe;MACf,cAAc;KACd;EACF;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,aAAS,MAAM,CAAC,QAAQ,OAAO,OAAO,iBAAiB,cAAc,CAAC;AACtE,SAAK,IAAI,QAAO;AAChB,SAAK,cAAc,QAAO;AAC1B,SAAK,IAAI,QAAO;AAChB,SAAK,KAAK,QAAO;AACjB,SAAK,aAAa,QAAO;AACzB,SAAK,cAAc,QAAO;AAC1B,SAAK,EAAE,QAAO;AACd,WAAO;EACR;;;;AC7IK,IAAO,WAAP,cAAwB,cAA8B;EAA5D,cAAA;;AAEU,SAAA,OAAe;AAQf,SAAA,YAAmB,IAAI,MAAM;MACrC,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,YAAmB,IAAI,MAAM;MACrC,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,YAAmB,IAAI,MAAM;MACrC,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,WAAkB,IAAI,MAAM;MACpC,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,WAAkB,IAAI,MAAM;MACpC,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,WAAkB,IAAI,MAAM;MACpC,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,MAAa,IAAI,MAAM;MAC/B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,MAAa,IAAI,MAAM;MAC/B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;AAEQ,SAAA,MAAa,IAAI,MAAM;MAC/B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ,WAAW,SAAS;KACxC;EA6BF;EA3BC,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,WAAW;MACX,WAAW;MACX,UAAU;MACV,UAAU;MACV,UAAU;MACV,KAAK;MACL,KAAK;MACL,KAAK;KACL;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,UAAU,QAAO;AACtB,SAAK,UAAU,QAAO;AACtB,SAAK,SAAS,QAAO;AACrB,SAAK,SAAS,QAAO;AACrB,SAAK,SAAS,QAAO;AACrB,SAAK,IAAI,QAAO;AAChB,SAAK,IAAI,QAAO;AAChB,SAAK,IAAI,QAAO;AAChB,WAAO;EACR;;AAOD,cAAc,CAAAC,aAAU;AACvB,EAAAA,SAAQ,WAAW,IAAI,SAAS,EAAE,SAAAA,SAAO,CAAE;AAC5C,CAAC;AAED,eAAe,CAAAA,aAAU;AACxB,EAAAA,SAAQ,SAAS,QAAO;AACzB,CAAC;;;ACzFK,IAAO,WAAP,MAAO,kBAAiB,cAA8B;EA0B3D,cAAA;AAEC,UAAM,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,aAAa,aAAa,WAAW,CAAC,CAAC;AA1B9F,SAAA,OAAe;AA2BvB,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,WAAW,CAAC,aAAa,aAAa,WAAW,CAAC;AAE/G,SAAK,UAAU,KAAK,QAAQ,KAAK,SAAS,KAAK,QAAQ,aAAY;AAEnE,SAAK,eAAe,QAAQ;AAC5B,SAAK,cAAc,QAAQ;AAC3B,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,gBAAgB,QAAQ;AAC7B,SAAK,iBAAiB,QAAQ;AAC9B,SAAK,iBAAiB,QAAQ;AAC9B,SAAK,cAAc,QAAQ;AAC3B,SAAK,gBAAgB,QAAQ;AAE7B,SAAK,YAAY,IAAI,MAAM;MAC1B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;KACf;AACD,SAAK,YAAY,IAAI,MAAM;MAC1B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;KACf;AACD,SAAK,YAAY,IAAI,MAAM;MAC1B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;KACf;AACD,SAAK,eAAe,IAAI,MAAM;MAC7B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;KACf;AACD,SAAK,eAAe,IAAI,MAAM;MAC7B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;KACf;AACD,SAAK,eAAe,IAAI,MAAM;MAC7B,SAAS,KAAK;MACd,OAAO,KAAK,QAAQ;MACpB,OAAO,QAAQ;KACf;EACF;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,gBAAgB;MAChB,gBAAgB;MAChB,eAAe;MACf,eAAe;MACf,aAAa;MACb,cAAc;MACd,cAAc;MACd,cAAc;MACd,cAAc;MACd,WAAW;MACX,WAAW;MACX,WAAW;MACX,aAAa;MACb,eAAe;KACf;EACF;;;;EAKA,YAAY,GAAW,GAAW,GAAS;AAC1C,SAAK,UAAU,QAAQ;AACvB,SAAK,UAAU,QAAQ;AACvB,SAAK,UAAU,QAAQ;AACvB,WAAO;EACR;;;;EAKA,eAAe,GAAW,GAAW,GAAS;AAC7C,SAAK,aAAa,QAAQ;AAC1B,SAAK,aAAa,QAAQ;AAC1B,SAAK,aAAa,QAAQ;AAC1B,WAAO;EACR;;;;EAKA,IAAI,eAAY;AACf,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,aAAa,KAAG;AACnB,SAAK,QAAQ,eAAe;EAC7B;;;;EAKA,IAAI,cAAW;AACd,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,YAAY,KAAG;AAClB,SAAK,QAAQ,cAAc;EAC5B;;;;EAKA,IAAI,gBAAa;AAChB,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,cAAc,KAAG;AACpB,SAAK,QAAQ,gBAAgB;EAC9B;;;;EAKA,IAAI,gBAAa;AAChB,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,cAAc,KAAG;AACpB,SAAK,QAAQ,gBAAgB;EAC9B;;;;EAKA,IAAI,iBAAc;AACjB,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,eAAe,KAAG;AACrB,SAAK,QAAQ,iBAAiB;EAC/B;;;;;EAMA,IAAI,iBAAc;AACjB,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,eAAe,KAAG;AACrB,SAAK,QAAQ,iBAAiB;EAC/B;;;;EAKA,IAAI,gBAAa;AAChB,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,cAAc,KAAG;AACpB,SAAK,QAAQ,gBAAgB;EAC9B;;;;;EAMA,IAAI,cAAW;AACd,WAAO,KAAK,QAAQ;EACrB;EACA,IAAI,YAAY,KAAG;AAClB,SAAK,QAAQ,cAAc;EAC5B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,WAAU;AACvB,SAAK,aAAa,QAAO;AACzB,SAAK,aAAa,QAAO;AACzB,SAAK,aAAa,QAAO;AACzB,SAAK,UAAU,QAAO;AACtB,SAAK,UAAU,QAAO;AACtB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AClMK,IAAO,WAAP,MAAO,kBAAiB,cAA8B;EAkB3D,cAAA;AAEC,UAAM,qBAAqB,UAAS,YAAW,GAAI,SAAS,CAAC;AAlBrD,SAAA,OAAO;AAmBf,UAAM,UAAU,qBAAqB,UAAS,YAAW,GAAI,SAAS;AAEtE,SAAK,QAAQ,IAAI,KAAK;MACrB,SAAS,KAAK;KACd;AAED,WAAO,UAAS,WAAW,qCAAqC;AAEhE,SAAK,UAAU,KAAK,QAAQ,6BAA4B;AACxD,SAAK,MAAM,QAAQ,KAAK,OAAO;AAC/B,SAAK,YAAY,IAAI,cAAc,KAAK,QAAQ,QAAQ;MACvD,UAAU,QAAQ;KAClB;EACF;EAEA,OAAO,cAAW;AACjB,WAAO,cAAc,YAAW;EACjC;;;;;EAMA,IAAI,WAAQ;AACX,WAAO,KAAK,UAAU;EACvB;;;;;EAMA,WAAW,YAAS;AACnB,WAAO,cAAc,QAAQ,QAAQ,IAAI,WAAW,eAAe;EACpE;;;;EAKA,IAAI,QAAK;AACR,QAAI,KAAK,UAAU,UAAU,YAAY;AACxC,aAAO;eACG,KAAK,UAAU,UAAU,UAAU;AAC7C,aAAO;WACD;AACN,aAAO;;EAET;;;;;EAMM,QAAK;;AACV,aAAO,KAAK,UAAU,WAAW,6BAA6B;AAC9D,YAAM,eAAe,IAAI,QAAQ,UAAO;AACvC,cAAM,cAAc,MAAK;AACxB,eAAK,UAAU,oBAAoB,SAAS,aAAa,KAAK;AAE9D,eAAI;QACL;AAEA,aAAK,UAAU,iBAAiB,SAAS,aAAa,KAAK;MAC5D,CAAC;AAED,WAAK,UAAU,MAAK;AACpB,aAAO,MAAM;IACd,CAAC;;;;;;EAMK,OAAI;;AACT,aAAO,KAAK,UAAU,WAAW,yBAAyB;AAC1D,YAAM,cAA6B,IAAI,QAAQ,UAAO;AACrD,cAAM,aAAa,CAAC,MAAgB;AACnC,eAAK,UAAU,oBAAoB,iBAAiB,YAAY,KAAK;AAErE,eAAK,EAAE,IAAI;QACZ;AAEA,aAAK,UAAU,iBAAiB,iBAAiB,YAAY,KAAK;MACnE,CAAC;AACD,WAAK,UAAU,KAAI;AACnB,aAAO,MAAM;IACd,CAAC;;;;;EAKD,QAAK;AACJ,WAAO,KAAK,UAAU,WAAW,0BAA0B;AAC3D,SAAK,UAAU,MAAK;AACpB,WAAO;EACR;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,QAAQ,WAAU;AACvB,WAAO;EACR;;;;ACxIK,IAAO,aAAP,MAAO,oBAAmB,cAAgC;EAqD/D,cAAA;AAEC,UAAM,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC,CAAC;AArD/E,SAAA,OAAe;AAKhB,SAAA,cAAsC,KAAK,QAAQ,yBAAwB;AAC1E,SAAA,QAAQ,KAAK;AACb,SAAA,SAAS,KAAK;AA+CtB,UAAM,UAAU,qBAAqB,YAAW,YAAW,GAAI,WAAW,CAAC,aAAa,OAAO,CAAC;AAEhG,SAAK,YAAY,IAAI,MAAM;MAC1B,UAAU,KAAK,YAAY,UAAU;MACrC,UAAU,KAAK,YAAY,UAAU;MACrC,SAAS,KAAK;MACd,SAAS;MACT,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,SAAS,IAAI,MAAM;MACvB,UAAU,KAAK,YAAY,OAAO;MAClC,UAAU,KAAK,YAAY,OAAO;MAClC,SAAS,KAAK;MACd,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,UAAU,IAAI,MAAM;MACxB,UAAU,KAAK,YAAY,QAAQ;MACnC,UAAU,KAAK,YAAY,QAAQ;MACnC,SAAS,KAAK;MACd,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,OAAO,IAAI,MAAM;MACrB,UAAU,KAAK,YAAY,KAAK;MAChC,UAAU,KAAK,YAAY,KAAK;MAChC,SAAS,KAAK;MACd,SAAS;MACT,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAED,SAAK,QAAQ,IAAI,MAAM;MACtB,UAAU,KAAK,YAAY,MAAM;MACjC,UAAU,KAAK,YAAY,MAAM;MACjC,SAAS,KAAK;MACd,SAAS;MACT,OAAO,KAAK,YAAY;MACxB,OAAO;MACP,OAAO,QAAQ;KACf;AAGD,aAAS,MAAM,CAAC,QAAQ,WAAW,UAAU,SAAS,WAAW,CAAC;EACnE;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,QAAQ;MACR,MAAM;MACN,OAAO;MACP,SAAS;MACT,WAAW;KACX;EACF;;;;;EAMA,IAAI,YAAS;AACZ,WAAO,KAAK,YAAY;EACzB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,YAAY,WAAU;AAC3B,SAAK,OAAO,QAAO;AACnB,SAAK,QAAQ,QAAO;AACpB,SAAK,UAAU,QAAO;AACtB,SAAK,MAAM,QAAO;AAClB,SAAK,KAAK,QAAO;AACjB,WAAO;EACR;;;;ACxIK,IAAO,OAAP,MAAO,cAAa,cAA0B;EA4BnD,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,aAAa,WAAW,CAAC,CAAC,CAAC;AA3B5F,SAAA,OAAe;AA4BvB,UAAM,UAAU,qBAAqB,MAAK,YAAW,GAAI,WAAW,CAAC,aAAa,WAAW,CAAC;AAE9F,SAAK,YAAY,IAAI,SAAS;MAC7B,SAAS,KAAK;MACd,WAAW,QAAQ;KACnB;AACD,SAAK,MAAM,IAAI,YAAY;MAC1B,SAAS,KAAK;MACd,OAAO,SAAS,QAAQ,SAAS;KACjC;AACD,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/C,SAAK,QAAQ,KAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAG7D,SAAK,MAAM,QAAQ,KAAK,KAAK;AAE7B,SAAK,MAAM,MAAM,KAAK,WAAW,KAAK,KAAK,KAAK,MAAM,IAAI;EAC3D;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,WAAW;KACX;EACF;;;;EAKA,IAAI,YAAS;AACZ,WAAO,SAAS,KAAK,IAAI,KAAK;EAC/B;EACA,IAAI,UAAU,QAAM;AACnB,SAAK,IAAI,QAAQ,SAAS,MAAM;EACjC;;;;EAKA,IAAI,YAAS;AACZ,WAAO,KAAK,UAAU;EACvB;EACA,IAAI,UAAU,eAAa;AAC1B,SAAK,UAAU,YAAY;EAC5B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,MAAM,QAAO;AAClB,SAAK,UAAU,QAAO;AACtB,SAAK,IAAI,QAAO;AAChB,SAAK,MAAM,QAAO;AAClB,WAAO;EACR;;;;ACtFK,IAAO,UAAP,MAAO,iBAAgB,cAA6B;EAmBzD,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC,CAAC,CAAC;AAlBlF,SAAA,OAAe;AAmBvB,UAAM,UAAU,qBAAqB,SAAQ,YAAW,GAAI,WAAW,CAAC,WAAW,CAAC;AAEpF,SAAK,cAAc,KAAK,QAAQ,KAAK,SAAS,IAAI,WAAW;MAC5D,SAAS,KAAK;MACd,OAAO;MACP,QAAQ;MACR,SAAS;MACT,WAAW,QAAQ;KACnB;AAED,SAAK,YAAY,KAAK,YAAY;AAClC,aAAS,MAAM,WAAW;EAC3B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;KACX;EACF;;;;;EAMA,IAAI,YAAS;AACZ,WAAO,KAAK,YAAY;EACzB;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,YAAY,QAAO;AACxB,SAAK,UAAU,QAAO;AACtB,WAAO;EACR;;;;AC3DK,IAAO,oBAAP,MAAO,2BAA0B,cAAuC;EA4B7E,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,mBAAkB,YAAW,GAAI,SAAS,CAAC,CAAC;AA3B7E,SAAA,OAAe;AA4BvB,UAAM,UAAU,qBAAqB,mBAAkB,YAAW,GAAI,SAAS;AAE/E,SAAK,gBAAgB,KAAK,QAAQ,IAAI,aAAa,EAAE,SAAS,KAAK,QAAO,CAAE;AAC5E,SAAK,gBAAgB,KAAK,SAAS,IAAI,aAAa,EAAE,SAAS,KAAK,QAAO,CAAE;AAC7E,SAAK,MAAM,IAAI,WAAW,OAAO,OAAO,QAAQ,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAC/E,SAAK,OAAO,IAAI,WAAW,OAAO,OAAO,QAAQ,MAAM,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAEjF,SAAK,cAAc,IAAI,MAAM,KAAK,KAAK,KAAK,cAAc,GAAG;AAC7D,SAAK,cAAc,KAAK,MAAM,KAAK,MAAM,KAAK,cAAc,IAAI;AAChE,aAAS,MAAM,CAAC,OAAO,MAAM,CAAC;EAC/B;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,KAAK;QACJ,OAAO;QACP,WAAW;QACX,SAAS;QACT,QAAQ;QACR,MAAM;;MAEP,MAAM;QACL,OAAO;QACP,WAAW;QACX,SAAS;QACT,QAAQ;QACR,MAAM;;KAEP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,IAAI,QAAO;AAChB,SAAK,KAAK,QAAO;AACjB,SAAK,cAAc,QAAO;AAC1B,SAAK,cAAc,QAAO;AAC1B,WAAO;EACR;;;;ACvDK,IAAO,sBAAP,MAAO,6BAA4B,cAAyC;EAsCjF,cAAA;AACC,UAAM,OAAO,OAAO,qBAAqB,qBAAoB,YAAW,GAAI,SAAS,CAAC,CAAC;AArC/E,SAAA,OAAe;AAsCvB,UAAM,UAAU,qBAAqB,qBAAoB,YAAW,GAAI,SAAS;AAEjF,SAAK,YAAY,KAAK,QAAQ,IAAI,eAAe;MAChD,SAAS,KAAK;MACd,cAAc,QAAQ;MACtB,eAAe,QAAQ;KACvB;AACD,SAAK,eAAe,KAAK,UAAU;AACnC,SAAK,gBAAgB,KAAK,UAAU;AACpC,SAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAChD,SAAK,MAAM,IAAI,WAAW,OAAO,OAAO,QAAQ,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAC/E,SAAK,MAAM,IAAI,WAAW,OAAO,OAAO,QAAQ,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAC/E,SAAK,OAAO,IAAI,WAAW,OAAO,OAAO,QAAQ,MAAM,EAAE,SAAS,KAAK,QAAO,CAAE,CAAC;AAGjF,SAAK,UAAU,IAAI,MAAM,KAAK,KAAK,KAAK,MAAM;AAC9C,SAAK,UAAU,IAAI,MAAM,KAAK,KAAK,KAAK,MAAM;AAC9C,SAAK,UAAU,KAAK,MAAM,KAAK,MAAM,KAAK,MAAM;AAEhD,aAAS,MAAM,CAAC,QAAQ,OAAO,OAAO,iBAAiB,cAAc,CAAC;EACvE;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,cAAc;MACd,eAAe;MACf,KAAK;QACJ,OAAO;QACP,WAAW;QACX,SAAS;QACT,QAAQ;QACR,MAAM;;MAEP,KAAK;QACJ,OAAO;QACP,WAAW;QACX,SAAS;QACT,QAAQ;QACR,MAAM;;MAEP,MAAM;QACL,OAAO;QACP,WAAW;QACX,SAAS;QACT,QAAQ;QACR,MAAM;;KAEP;EACF;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,UAAU,QAAO;AACtB,SAAK,IAAI,QAAO;AAChB,SAAK,IAAI,QAAO;AAChB,SAAK,KAAK,QAAO;AACjB,SAAK,OAAO,QAAO;AACnB,WAAO;EACR;;;;AC3GK,IAAO,MAAP,MAAO,aAAY,cAAyB;EAoEjD,cAAA;AACC,UAAM,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,OAAO,OAAO,MAAM,CAAC,CAAC;AAnExE,SAAA,OAAe;AAUf,SAAA,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAoD1C,SAAA,oBAAqC,CAAA;AAM9C,UAAM,UAAU,qBAAqB,KAAI,YAAW,GAAI,WAAW,CAAC,OAAO,OAAO,MAAM,CAAC;AAEzF,SAAK,QAAQ,KAAK,kBAAkB,IAAI,eAAe;MACtD,SAAS,KAAK;MACd,eAAe,QAAQ;MACvB,cAAc,QAAQ;KACtB;AAED,SAAK,WAAW,IAAI,KAAK;MACxB,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,OAAO;KACP;AAED,SAAK,WAAW,IAAI,KAAK;MACxB,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,OAAO;KACP;AAED,SAAK,YAAY,IAAI,KAAK;MACzB,SAAS,KAAK;MACd,MAAM,QAAQ;MACd,OAAO;KACP;AAED,SAAK,MAAM,KAAK,SAAS;AACzB,SAAK,MAAM,KAAK,SAAS;AACzB,SAAK,OAAO,KAAK,UAAU;AAC3B,SAAK,IAAI,KAAK,gBAAgB;AAC9B,SAAK,eAAe,KAAK,gBAAgB;AACzC,SAAK,gBAAgB,KAAK,gBAAgB;AAG1C,SAAK,gBAAgB,IAAI,MAAM,KAAK,UAAU,KAAK,MAAM;AACzD,SAAK,gBAAgB,IAAI,MAAM,KAAK,UAAU,KAAK,MAAM;AACzD,SAAK,gBAAgB,KAAK,MAAM,KAAK,WAAW,KAAK,MAAM;AAE3D,aAAS,MAAM,CAAC,OAAO,OAAO,QAAQ,gBAAgB,eAAe,CAAC;AACtE,SAAK,oBAAoB,CAAC,KAAK,eAAe;EAC/C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,MAAM;MACN,eAAe;MACf,KAAK;MACL,cAAc;MACd,KAAK;KACL;EACF;;;;EAKA,UAAO;AACN,UAAM,QAAO;AACb,aAAS,MAAM,CAAC,OAAO,OAAO,QAAQ,gBAAgB,eAAe,CAAC;AACtE,SAAK,gBAAgB,QAAO;AAC5B,SAAK,aAAa,QAAO;AACzB,SAAK,cAAc,QAAO;AAC1B,SAAK,SAAS,QAAO;AACrB,SAAK,SAAS,QAAO;AACrB,SAAK,UAAU,QAAO;AACtB,SAAK,IAAI,QAAO;AAChB,SAAK,IAAI,QAAO;AAChB,SAAK,KAAK,QAAO;AACjB,SAAK,EAAE,QAAO;AACd,WAAO;EACR;;;;ACzIK,IAAO,YAAP,MAAO,mBAAkB,cAA+B;EAuB7D,cAAA;AAEC,UAAM,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC,CAAC;AAvBzE,SAAA,OAAe;AAKhB,SAAA,aAA4B,KAAK,QAAQ,gBAAe;AAmB/D,UAAM,UAAU,qBAAqB,WAAU,YAAW,GAAI,WAAW,CAAC,OAAO,QAAQ,CAAC;AAE1F,SAAK,UAAU,IAAI,gBAAgB,QAAQ,KAAK,YAAS;AACxD,WAAK,SAAS;AACd,cAAQ,OAAM;IACf,CAAC;AAED,SAAK,QAAQ,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAC/C,SAAK,SAAS,IAAI,KAAK,EAAE,SAAS,KAAK,QAAO,CAAE;AAGhD,QAAI,KAAK,QAAQ,QAAQ;AACxB,WAAK,SAAS,KAAK;;AAIpB,SAAK,YAAY,QAAQ;AAGzB,SAAK,MAAM,MAAM,KAAK,YAAY,KAAK,MAAM;EAC9C;EAEA,OAAO,cAAW;AACjB,WAAO,OAAO,OAAO,cAAc,YAAW,GAAI;MACjD,WAAW;MACX,QAAQ;KACR;EACF;;;;;;;EAQM,KAAK,KAAW;;AACrB,WAAK,SAAS,MAAM,KAAK,QAAQ,KAAK,GAAG;IAC1C,CAAC;;;;;EAKD,IAAI,SAAM;AACT,QAAI,KAAK,QAAQ,QAAQ;AACxB,aAAO,KAAK;WACN;AACN,aAAO;;EAET;EACA,IAAI,OAAO,QAAM;AAChB,QAAI,QAAQ;AACX,WAAK,QAAQ,IAAI,MAAM;;AAGxB,QAAI,KAAK,WAAW,QAAQ;AAE3B,WAAK,MAAM,WAAU;AACrB,WAAK,WAAW,WAAU;AAE1B,WAAK,aAAa,KAAK,QAAQ,gBAAe;AAC9C,WAAK,MAAM,MAAM,KAAK,YAAY,KAAK,MAAM;;AAE9C,UAAM,OAAO,KAAK,QAAQ,IAAG;AAC7B,SAAK,WAAW,SAAS,OAAO,OAAO;EACxC;;;;;;EAOA,IAAI,YAAS;AACZ,WAAO,KAAK,WAAW;EACxB;EACA,IAAI,UAAU,MAAI;AACjB,SAAK,WAAW,YAAY;EAC7B;EAEA,UAAO;AACN,UAAM,QAAO;AACb,SAAK,QAAQ,QAAO;AACpB,SAAK,WAAW,WAAU;AAC1B,WAAO;EACR;;;;ACtHK,SAAU,MAAG;AAClB,SAAO,WAAU,EAAG,IAAG;AACxB;AAOM,SAAU,YAAS;AACxB,SAAO,WAAU,EAAG,UAAS;AAC9B;AAOO,IAAMC,aAAY,WAAU,EAAG;AAOhC,SAAU,eAAY;AAC3B,SAAO,WAAU,EAAG;AACrB;AAOO,IAAMC,eAAc,WAAU,EAAG;AAKjC,IAAM,SAAS,WAAU,EAAG;AAO7B,SAAU,iBAAc;AAC7B,SAAO,WAAU,EAAG;AACrB;AAMO,IAAMC,YAAW,WAAU,EAAG;AAM/B,SAAU,cAAW;AAC1B,SAAO,WAAU,EAAG;AACrB;AAOO,IAAMC,QAAO,WAAU,EAAG;AAQ3B,SAAU,UAAO;AACtB,SAAO,WAAU,EAAG;AACrB;AAMO,IAAM,UAAU,WAAU;AAO3B,SAAU,SAAM;AACrB,SAAO,gBAAgB,OAAM;AAC9B;AAKO,IAAM,SAAiC;AACvC,IAAM,UAAmC;AACzC,IAAM,eAAwC;",
  "names": ["insertElementInSet", "cacheTestResult", "createNotSupportedError", "exposeCurrentFrameAndCurrentTime", "getNativeContext", "getOrCreateBackupOfflineAudioContext", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "window", "context", "addActiveInputConnectionToAudioNode", "addPassiveInputConnectionToAudioNode", "connectNativeAudioNodeToNativeAudioNode", "deleteActiveInputConnectionToAudioNode", "disconnectNativeAudioNodeFromNativeAudioNode", "getAudioNodeConnections", "getAudioNodeTailTime", "getEventListenersOfAudioNode", "getNativeAudioNode", "insertElementInSet", "isActiveAudioNode", "isPartOfACycle", "isPassiveAudioNode", "insertElementInSet", "createNativeGainNode", "disconnect", "getUnrenderedAudioWorkletNodes", "createAnalyserNodeRenderer", "createIndexSizeError", "createNativeAnalyserNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "createNativeAnalyserNode", "getNativeAudioNode", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioBufferStore", "cacheTestResult", "createNotSupportedError", "nativeAudioBufferConstructor", "nativeOfflineAudioContextConstructor", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "AudioBuffer", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioBufferSourceNodeRenderer", "createAudioParam", "createInvalidStateError", "createNativeAudioBufferSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "context", "connectAudioParam", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "start", "context", "baseAudioContextConstructor", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "mediaElementAudioSourceNodeConstructor", "mediaStreamAudioDestinationNodeConstructor", "mediaStreamAudioSourceNodeConstructor", "mediaStreamTrackAudioSourceNodeConstructor", "nativeAudioContextConstructor", "audioNodeConstructor", "createAudioDestinationNodeRenderer", "createIndexSizeError", "createInvalidStateError", "getNativeContext", "isNativeOfflineAudioContext", "renderInputsOfAudioNode", "context", "renderInputsOfAudioNode", "createAudioParam", "createNativeChannelMergerNode", "createNativeConstantSourceNode", "createNativeScriptProcessorNode", "createNotSupportedError", "getFirstSample", "isNativeOfflineAudioContext", "overwriteAccessors", "context", "nativeAudioWorkletNodeConstructor", "connect", "disconnect", "cacheTestResult", "createIndexSizeError", "createInvalidAccessError", "createNotSupportedError", "eventTargetConstructor", "getNativeContext", "isNativeAudioContext", "isNativeAudioNode", "isNativeAudioParam", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "context", "audioParamAudioNodeStore", "createAudioParamRenderer", "createCancelAndHoldAutomationEvent", "createCancelScheduledValuesAutomationEvent", "createExponentialRampToValueAutomationEvent", "createLinearRampToValueAutomationEvent", "createSetTargetAutomationEvent", "createSetValueAutomationEvent", "createSetValueCurveAutomationEvent", "nativeAudioContextConstructor", "setValueAtTimeUntilPossible", "DEFAULT_OPTIONS", "addUnrenderedAudioWorkletNode", "audioNodeConstructor", "createAudioParam", "createAudioWorkletNodeRenderer", "createNativeAudioWorkletNode", "getAudioNodeConnections", "getBackupOfflineAudioContext", "getNativeContext", "isNativeOfflineAudioContext", "nativeAudioWorkletNodeConstructor", "sanitizeAudioWorkletNodeOptions", "setActiveAudioWorkletNodeInputs", "testAudioWorkletNodeOptionsClonability", "wrapEventListener", "context", "exposeCurrentFrameAndCurrentTime", "connectAudioParam", "connectMultipleOutputs", "createNativeAudioBufferSourceNode", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "deleteUnrenderedAudioWorkletNode", "disconnectMultipleOutputs", "getNativeAudioNode", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "addAudioWorkletModule", "analyserNodeConstructor", "audioBufferConstructor", "audioBufferSourceNodeConstructor", "biquadFilterNodeConstructor", "channelMergerNodeConstructor", "channelSplitterNodeConstructor", "constantSourceNodeConstructor", "convolverNodeConstructor", "decodeAudioData", "delayNodeConstructor", "dynamicsCompressorNodeConstructor", "gainNodeConstructor", "iIRFilterNodeConstructor", "minimalBaseAudioContextConstructor", "oscillatorNodeConstructor", "pannerNodeConstructor", "periodicWaveConstructor", "stereoPannerNodeConstructor", "waveShaperNodeConstructor", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createBiquadFilterNodeRenderer", "createInvalidAccessError", "createNativeBiquadFilterNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "connectAudioParam", "createNativeBiquadFilterNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createChannelMergerNodeRenderer", "createNativeChannelMergerNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "createNativeChannelMergerNode", "getNativeAudioNode", "renderInputsOfAudioNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createChannelSplitterNodeRenderer", "createNativeChannelSplitterNode", "getNativeContext", "isNativeOfflineAudioContext", "sanitizeChannelSplitterOptions", "context", "createNativeChannelSplitterNode", "getNativeAudioNode", "renderInputsOfAudioNode", "renderInputsOfAudioParam", "createIndexSizeError", "createNativeAudioBufferSourceNode", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createConstantSourceNodeRendererFactory", "createNativeConstantSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "context", "connectAudioParam", "createNativeConstantSourceNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "start", "DEFAULT_OPTIONS", "audioNodeConstructor", "createConvolverNodeRenderer", "createNativeConvolverNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "createNativeConvolverNode", "getNativeAudioNode", "renderInputsOfAudioNode", "createNotSupportedError", "nativeOfflineAudioContextConstructor", "audioBufferStore", "cacheTestResult", "createDataCloneError", "createEncodingError", "getNativeContext", "isNativeContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "testPromiseSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "connectNativeAudioNodeToNativeAudioNode", "getAudioNodeConnections", "getNativeAudioNode", "getNativeAudioParam", "getNativeContext", "isActiveAudioNode", "isNativeOfflineAudioContext", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createDelayNodeRenderer", "createNativeDelayNode", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "connectAudioParam", "createNativeDelayNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "pickElementFromSet", "getUnrenderedAudioWorkletNodes", "audioParamAudioNodeStore", "getAudioNodeConnections", "getValueForKey", "createIndexSizeError", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createDynamicsCompressorNodeRenderer", "createNativeDynamicsCompressorNode", "createNotSupportedError", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "connectAudioParam", "createNativeDynamicsCompressorNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "window", "wrapEventListener", "window", "createAbortError", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createGainNodeRenderer", "createNativeGainNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "connectAudioParam", "createNativeGainNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "activeAudioWorkletNodeInputsStore", "getValueForKey", "getAudioNodeConnections", "audioNodeTailTimeStore", "getAudioParamConnections", "backupOfflineAudioContextStore", "context", "backupOfflineAudioContextStore", "nativeOfflineAudioContextConstructor", "unrenderedAudioWorkletNodeStore", "DEFAULT_OPTIONS", "audioNodeConstructor", "createNativeIIRFilterNode", "createIIRFilterNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "createNativeAudioBufferSourceNode", "getNativeAudioNode", "nativeOfflineAudioContextConstructor", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "disconnectNativeAudioNodeFromNativeAudioNode", "getAudioNodeConnections", "getNativeAudioNode", "getNativeAudioParam", "isActiveAudioNode", "isNativeAudioContext", "isNativeAudioNode", "isNativeAudioParam", "isNativeOfflineAudioContext", "nativeAudioContextConstructor", "window", "window", "isNativeAudioContext", "isNativeOfflineAudioContext", "nativeOfflineAudioContextConstructor", "window", "cacheTestResult", "testTransferablesSupport", "audioNodeConstructor", "createNativeMediaElementAudioSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "DEFAULT_OPTIONS", "audioNodeConstructor", "createNativeMediaStreamAudioDestinationNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "audioNodeConstructor", "createNativeMediaStreamAudioSourceNode", "getNativeContext", "isNativeOfflineAudioContext", "context", "audioNodeConstructor", "createNativeMediaStreamTrackAudioSourceNode", "getNativeContext", "context", "createInvalidStateError", "createNotSupportedError", "createUnknownError", "minimalBaseAudioContextConstructor", "nativeAudioContextConstructor", "audioDestinationNodeConstructor", "createAudioListener", "eventTargetConstructor", "isNativeOfflineAudioContext", "unrenderedAudioWorkletNodeStore", "wrapEventListener", "DEFAULT_OPTIONS", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "minimalBaseAudioContextConstructor", "startRendering", "insertElementInSet", "isNativeAudioNode", "connect", "disconnect", "cacheTestResult", "createIndexSizeError", "window", "start", "start", "addSilentConnection", "cacheTestResult", "testAudioBufferSourceNodeStartMethodConsecutiveCallsSupport", "testAudioBufferSourceNodeStartMethodOffsetClampingSupport", "testAudioBufferSourceNodeStopMethodNullifiedBufferSupport", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "window", "createNativeGainNode", "overwriteAccessors", "window", "createInvalidStateError", "createNativeAudioWorkletNodeFaker", "createNativeGainNode", "createNotSupportedError", "monitorConnections", "nativeAudioWorkletNodeConstructor", "connectMultipleOutputs", "createIndexSizeError", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNotSupportedError", "disconnectMultipleOutputs", "exposeCurrentFrameAndCurrentTime", "getActiveAudioWorkletNodeInputs", "monitorConnections", "nativeAudioContextConstructor", "wrapChannelMergerNode", "addSilentConnection", "cacheTestResult", "createNativeConstantSourceNodeFaker", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "addSilentConnection", "createNativeAudioBufferSourceNode", "createNativeGainNode", "monitorConnections", "createNotSupportedError", "overwriteAccessors", "createNotSupportedError", "createNativeIIRFilterNodeFaker", "createInvalidAccessError", "createInvalidStateError", "createNativeScriptProcessorNode", "createNotSupportedError", "createInvalidStateError", "isNativeOfflineAudioContext", "window", "addSilentConnection", "cacheTestResult", "testAudioScheduledSourceNodeStartMethodNegativeParametersSupport", "testAudioScheduledSourceNodeStopMethodConsecutiveCallsSupport", "testAudioScheduledSourceNodeStopMethodNegativeParametersSupport", "wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls", "createNativePannerNodeFaker", "connectNativeAudioNodeToNativeAudioNode", "createInvalidStateError", "createNativeChannelMergerNode", "createNativeGainNode", "createNativeScriptProcessorNode", "createNativeWaveShaperNode", "createNotSupportedError", "disconnectNativeAudioNodeFromNativeAudioNode", "getFirstSample", "monitorConnections", "createIndexSizeError", "createNotSupportedError", "createNativeChannelMergerNode", "createNativeChannelSplitterNode", "createNativeGainNode", "createNativeWaveShaperNode", "createNotSupportedError", "monitorConnections", "nativeStereoPannerNodeFakerFactory", "createConnectedNativeAudioBufferSourceNode", "createInvalidStateError", "createNativeWaveShaperNodeFaker", "isDCCurve", "monitorConnections", "nativeAudioContextConstructor", "overwriteAccessors", "createConnectedNativeAudioBufferSourceNode", "createInvalidStateError", "createNativeGainNode", "isDCCurve", "monitorConnections", "DEFAULT_OPTIONS", "baseAudioContextConstructor", "cacheTestResult", "createInvalidStateError", "createNativeOfflineAudioContext", "startRendering", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createNativeOscillatorNode", "createOscillatorNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "wrapEventListener", "context", "connectAudioParam", "createNativeOscillatorNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "start", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createNativePannerNode", "createPannerNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "connectAudioParam", "createNativeChannelMergerNode", "createNativeConstantSourceNode", "createNativeGainNode", "createNativePannerNode", "getNativeAudioNode", "nativeOfflineAudioContextConstructor", "renderAutomation", "renderInputsOfAudioNode", "renderNativeOfflineAudioContext", "DEFAULT_OPTIONS", "createNativePeriodicWave", "getNativeContext", "sanitizePeriodicWaveOptions", "context", "renderInputsOfAudioParam", "getAudioNodeConnections", "getAudioNodeRenderer", "isPartOfACycle", "getAudioNodeRenderer", "getAudioParamConnections", "isPartOfACycle", "cacheTestResult", "createNativeGainNode", "createNativeScriptProcessorNode", "activeAudioWorkletNodeInputsStore", "audioNodeTailTimeStore", "audioBufferStore", "cacheTestResult", "getAudioNodeRenderer", "getUnrenderedAudioWorkletNodes", "renderNativeOfflineAudioContext", "testAudioBufferCopyChannelMethodsOutOfBoundsSupport", "wrapAudioBufferCopyChannelMethods", "wrapAudioBufferCopyChannelMethodsOutOfBounds", "DEFAULT_OPTIONS", "audioNodeConstructor", "createAudioParam", "createNativeStereoPannerNode", "createStereoPannerNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "context", "connectAudioParam", "createNativeStereoPannerNode", "getNativeAudioNode", "renderAutomation", "renderInputsOfAudioNode", "nativeAudioBufferConstructor", "nativeOfflineAudioContextConstructor", "nativeAudioContextConstructor", "nativeOfflineAudioContextConstructor", "nativeAudioContextConstructor", "nativeOfflineAudioContextConstructor", "isSupported", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "nativeAudioWorkletNodeConstructor", "nativeOfflineAudioContextConstructor", "nativeOfflineAudioContextConstructor", "nativeOfflineAudioContextConstructor", "nativeOfflineAudioContextConstructor", "nativeOfflineAudioContextConstructor", "window", "nativeAudioContextConstructor", "createNativeGainNode", "nativeOfflineAudioContextConstructor", "nativeOfflineAudioContextConstructor", "DEFAULT_OPTIONS", "audioNodeConstructor", "createInvalidStateError", "createNativeWaveShaperNode", "createWaveShaperNodeRenderer", "getNativeContext", "isNativeOfflineAudioContext", "setAudioNodeTailTime", "context", "createNativeWaveShaperNode", "getNativeAudioNode", "renderInputsOfAudioNode", "convertNumberToUnsignedLong", "createIndexSizeError", "convertNumberToUnsignedLong", "copyFromChannel", "copyToChannel", "overwriteAccessors", "createInvalidStateError", "monitorConnections", "start", "disconnect", "window", "isNativeAudioNode", "window", "isNativeAudioNode", "window", "isNativeAudioNode", "window", "context", "context", "isAudioNode", "isAudioNode", "context", "now", "context", "start", "context", "context", "log", "now", "isAudioNode", "now", "context", "now", "context", "context", "now", "context", "now", "context", "start", "now", "now", "context", "start", "workletName", "workletName", "now", "now", "context", "context", "Transport", "Destination", "Listener", "Draw"]
}
